;# $Id: phx_root.mac,v 1.105 1997/10/16 22:02:16 shepperd Exp $
;#
;#		Copyright 1991,1992,1993,1994,1995,1996,1997 Atari Games.
;#	Unauthorized reproduction, adaptation, distribution, performance or 
;#	display of this computer program or the associated audiovisual work
;#	is strictly prohibited.
;#
;#	This file contains some of the following:
;#
;#	Exception code.
;#	Start-up code in roughly the order it gets executed.
;#	Subroutines for startup code.
;#	Subroutines needed by C code, that need to be in assembly
;#
;#	Similarly, .globls are "close to" the code that uses them
;#
;#	April 4, 1996	Dave Shepperd, modified os_rootr4k for Phoenix
;#
OUTPUT_LANG 	  == 4		; LANG_ASR3k

	.include config.mac

.macro MKOPT name value
.if not_defined,name
name == value
name = value
.endc
.endm

MKOPT LOOP_ON_ERROR	 1		; 1=normal, 0=don't loop on error
MKOPT STOP_ON_EXCEPTION  0		; 0=normal, 1=stop on any exception
MKOPT STOP_ON_NONINTR	 0		; 0=normal, 1=stop on any non-interrupt exception
MKOPT JUMP_TO_CACHE	 1		; 1=normal, 0=don't jump to cache on exception
MKOPT DO_STACK_CHECKING  0		; 0=normal, 1=add extra stack underflow checks
MKOPT DO_STACK_ALIGNCHK  1		; 1=normal, 0=don't check for stack alignment at exception
MKOPT SQUAWK_ON_EXCEPT	 0		; 0=normal, 1=blast reason for exception in normal_except
MKOPT VIDEO_BOARD	 0		; 0=normal, 1=video board present in system
MKOPT REPORT_WDOG_RESETS 1		; 1=normal, 0=don't pm dump on watchdog resets
MKOPT ICELESS_STUB	 0		; 0=normal, 1=ICELESS code
MKOPT ICELESS_AST	 0		; 0=normal, 1=Have shims decode Iceless interrupts
MKOPT BOOT_ROM_CODE	 0		; 0=normal, 1=BOOT RAMROM code
MKOPT BOOT_COPY_SELF	 0		; 0=normal, 1=Copy this program to DRAM
MKOPT BOOT_FROM_XBUS	 0		; 0=normal, 1=BOOT RAMROM from xbus slot
MKOPT BOOT_FROM_DISK	 0		; 0=normal, 1=BOOT from DISK
MKOPT BOOT_COMPRESSED	 0		; 0=normal, 1=BOOT from compressed EPROM
MKOPT TIME_EXCEPTIONS	 0		; 0=normal, 1=time exceptions
MKOPT TEST_EXCEPTIONS	 0		; 0=normal, 1=touch external memory at exception entry/exit
MKOPT FLUSH_CACHE_EXCEPT 0		; 1=normal, 0=don't flush cache at exception entry/exit
MKOPT DELAY_LED_DISPLAY  1		; 1=normal, 0=skip LED display delay (for timing purposes)
MKOPT DELAY_LED_TIME	 65535*3	; number of usecs to linger on LED display
MKOPT TEST_MEM64	 0		; 0=none, 1=once, >1 = forever
MKOPT TEST_MEM32	 0		; 0=none, 1=once, >1 = forever
MKOPT TESTMEM32_PART1	0x00080000	; First part memory test is 512K
MKOPT TEST_BRAM		 1		; 1=normal, 0=don't include BRAM test code
MKOPT TEST_WALKING1	 0		; 0=normal, 1=perform walking 1's test in RAM test
MKOPT TEST_REFRESH	 0		; 0=normal, 1=perform refresh delay test
MKOPT ANN_TEST_SERIAL	 0		; 0=none, 1=not supported at this time
MKOPT STOP_ON_ERROR	 0		; 0=none, 1=stop on any memory error
MKOPT IRQ_CHEAP_EXCEPTION 0		; 0=normal, 1=allow IRQ's to be cheap exceptions
MKOPT FPCSR_INIT	 (C1_FCSR_FS|C1_FCSR_EN_V|C1_FCSR_EN_Z|C1_FCSR_EN_O) ; initial FP CSR
MKOPT DRAM_BANKS	 4		; default to 4 banks unless told otherwise
MKOPT DRAM_BANK_SIZE	 0x08000000	; default to 8MB banks unless told otherwise
MKOPT PM_DATA_BEGIN	DRAM_BASEnc+0x400 ; location of PM area
MKOPT PM_DATA_END	DRAM_BASEnc+0x7FF ; last location of PM area
MKOPT NO_WDOG		0		; 0=normal, 1=don't kick WODG, ever
MKOPT EPROM_ST		0		; 0=normal, 1=Eprom flavor of SelfTest
MKOPT INCLUDE_XINU	0		; 0=normal, 1=include Xinu support
MKOPT INCLUDE_SYSCALL	0		; 0=normal, 1=include SYSCALL support code
MKOPT NON_PIPELINED_MODE 0		; 0=normal, 1=enable non-pipelined (R4k) mode
MKOPT SA_DIAGS		0		; 0=normal, 1=standalone diags
MKOPT FAKE_MEM32_ERR	0		; 0=normal, 1=fake a test_mem32 error
MKOPT FAKE_MEM32_ERR_O	0		; 0=normal, 1=fake a test_mem32 error at odd addr
MKOPT FAKE_MEM32_BITS	0x0FFFF
MKOPT FAKE_MEM64_ERR	0		; 0=normal, 1=fake a test_mem64 error
MKOPT FAKE_MEM64_BITS	0xFFFF0000
MKOPT ANNOUNCE_BOOT_ACTIONS 0		; 0=normal, 1=announce boot actions

MKOPT CPU_SPEED_VARIABLE 0		; CPU clock speed is not set dynamically
.if false, CPU_SPEED_VARIABLE
MKOPT CPU_SPEED		100000000	; CPU clock speed in HZ
.endc
MKOPT REG_SIZE		REGISTER_SIZE

MKOPT ICELESS_LVL	0
MKOPT ICELESS_MANY	0
MKOPT INCLUDE_FEXCP	0
.if true, BOOT_COMPRESSED		; Compressed EPROM code always dies on exceptions
STOP_ON_EXCEPTION == 1
STOP_ON_EXCEPTION = 1
.endc

.if defined, IO_UART_CTL_INTERNAL_ENA
MKOPT BR9600		IO_UART_CTL_9600_BAUD
 .if true, CPU_SPEED_VARIABLE
MKOPT PUTC_BLINK_TIME 	(150000000/8)	;Pick a speed, anything will do
 .iff
MKOPT PUTC_BLINK_TIME 	(CPU_SPEED/8)
 .endc
MKOPT PUTC_UART_ENAB (IO_UART_CTL_INTERNAL_ENA|IO_UART_CTL_IGNORE_CTS_IN|BR9600)
.endc

MKOPT USE_MIPS4		0		; Assume not to use MIPS4 instructions
MKOPT USE_MIPS3		1		; Assume to use MIPS3 instructions

.if true, USE_MIPS4
	.set mips4
.iff
 .if true, USE_MIPS3
	.set mips3
 .endc
.endc

.if true, PM_DATA_END-PM_DATA_BEGIN < PM_RxK_SIZE
 .error ; PM_DATA_BEGIN and PM_DATA_END need adjusting
.endc

MKOPT NO_FRBIT		1		; assume no FR bit in the status reg

LCL_INIT_SR == SR_CU0|SR_CU1|SR_CU2|SR_CU3|SR_DE|SR_KX
LCL_INIT_SR =  SR_CU0|SR_CU1|SR_CU2|SR_CU3|SR_DE|SR_KX
.if true, BOOT_ROM_CODE != 0
LCL_INIT_SR == LCL_INIT_SR | SR_BEV
LCL_INIT_SR =  LCL_INIT_SR | SR_BEV
.endc
.if true, NO_FRBIT == 0
LCL_INIT_SR == LCL_INIT_SR | SR_FR
LCL_INIT_SR =  LCL_INIT_SR | SR_FR
.endc

MKOPT INIT_SR	LCL_INIT_SR		;initial value to which to set SR
MKOPT INIT_CFG	CFG_C_NONCOHERENT|CFG_IB|CFG_DB	;initial value to set processor config

.macro WALKER_LED which
 .if defined, LED_OUT
	.set at
	.set noreorder
	li	s0,  0
10:	xor	v0, s0, 7
	sw	v0, LED_OUT			;# Turn on LED
	li	a0, 100000
	bal	prc_wait_n_usecs
	nop
  .if not_blank,which
	srl	s0, 1
  .iff
	sll	s0, 1
  .endc
	and	v0, s0, 127
	bne	v0, r0, 10b
	nop
	nop
  .if not_blank,which
	li	s0, 8
  .iff
	li	s0, 1
  .endc
	b	10b
	nop
 .endc
.endm

	.macro	ALIGN3
	.align 3
	.endm

; The following macro does a "load relative address" of sorts.
; Since this code is normally linked to run at 0x80000000 and
; during the boot sequence is actually running at 0xBFC00000,
; doing normal 'la's won't quite do the trick until all of DRAM
; has been loaded. This macro will essentially do a 'la' where
; the address is either 0x80xxxxxx or 0xBFCxxxxx depending on
; what the run address is. It assumes the fp register contains
; the upper bits of the running address, but any register can
; be used by setting the 'offset' parameter at invocation time.
; It needs a temp and assumes to use r1 ($1).

	.macro lra dest, source, working=$1, offset=fp
	la dest, source
	.iif identical,<working>,<$1>,.set noat
	la working, startup
	subu dest, working
	.iif identical,<working>,<$1>,.set at
	addu dest, offset
	.endm

	.globl UNLK_EP
UNLK_EP = BRAM_UNLK
SCRATCH_RAM =	BRAM_UNLK 

	.globl	cpu_params

.if true, BOOT_ROM_CODE == 0
	.bss
cpu_params:
	.space	CPU_FRAME_SIZE
	.globl	beg_static
beg_static:
set_ipl_vec:
	.space 4
ramv_tbl:
	DEC_CONST RAMV_TBL_SIZ	S_SIZ_RAM_VECTOR_STR
	.space RAMV_TBL_SIZ
ramv_tbl_end:
	.globl	savintp
	.globl	restintp
savintp:
	.space	4
restintp:
	.space	4

.if true, TIME_EXCEPTIONS
	.globl _guts_inest
	.globl _guts_astlvl
	.globl exception_time
exception_time:
	.space	8
.endc
	.align 3

	.globl	interrupt_stack_limit
	.globl	interrupt_stack
	.globl	ISR_SIZE

ISR_SIZE = 1024*3
interrupt_stack_limit:

	.space	ISR_SIZE	;# give ourselves n of interrupt stack
interrupt_stack:

.endc				;BOOT_ROM_CODE == 0

	.text

;#***************************************************************
;#  This is the start of the code.				*
;#***************************************************************

	.globl	boot_entry
	.globl	except
	.globl	text_size

	.set	noat
	.set	noreorder

.if true, (BOOT_ROM_CODE == 0) && (BOOT_COMPRESSED == 0)
	.rdata
.endc
	
FRAME startup
	.set at
romv_tbl:
.if true, BOOT_ROM_CODE || BOOT_COPY_SELF || (HOST_BOARD == PHOENIX_AD) || (HOST_BOARD == FLAGSTAFF) || (HOST_BOARD == SEATTLE)
 .if true, BOOT_ROM_CODE || BOOT_COMPRESSED
	b	boot_entry	;# reset vector (0xBFC00000, 0xB4000000 or 0x80000000 ) *
 .iff
	.word	0x10003FFF	;# Damn assembler won't do this automatically
 .endc
.iff
	j	boot_entry	;# reset vector (0xBFC00000 or 0x80000000) *
.endc
	nop
	.word	0xFEEDFACE
	.word	ramrom_size
	.align	4		;# skip up to 0xBFC00010

;++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;  WARNING WARNING WARNING WARNING WARNING WARNING WARNING WARNING WARNING 
;
; The following table is constructed according the the definition of the structure
; ROM_VECTOR_STR in idt.mac. If you change anything here be sure to update the struct
; definition in idt.mac. Also, if you change anything here without rebuilding
; _all_ flavors of GUTS _and_ STUB, you will certainly break them such that they will
; not likely work together if at all.
;

stub_setup:
	.space 4*4		;# stub will init these when or if it is loaded
.if true, BOOT_ROM_CODE > 0
	.space 4*4
.iff
	.globl	romv_tbl
	.globl	ramv_tbl
	.globl	ramv_tbl_end
	.word	ramv_tbl	;# Pointer to RAM based array of pointers to functions
	.word	INIT_SP		;# last address in SRAM to use, value to init stack
				;# to external init routines (ICELESS stub for example)
	.word	begin		;# pointer to the OS entry address
	.word	except		;# pointer to game's exception handler
.endc
	.word	0		;# stub exception reason goes here
;
; End of ROM_VECTOR_STR structure
;------------------------------------------------------------------------------
;
	.space  3*4+2		;# shove this copyright message right up against vec1
	.ascii	"Copyright (c) 1996,1997 Atari Games Inc., All Rights Reserved"

	.align	7		;# advance pc to 80000080 *
	.globl	vec1; .globl vec2; .globl vec3
	.globl	vec4; .globl vec5; .globl vec6; .globl vec7
vec1:	j	Eexcept
	or	k0, r0, 1	;# (x) tlb refill
j_except:
	j	except
	or	k0, r0, 1	;# (x) tlb refill

	.align	7		;# advance pc to 0x80000100 *

vec2:	j	Eexcept
	or	k0, r0, 2	;# Cache error

	.align	7		;# advance pc 0x80000180 *
vec3:	j	Eexcept
	or	k0, r0, 3	;# All other exceptions

	.align	7		;# advance pc 0x80000200 *
vec4:	j	Eexcept
	or	k0, r0, 4	;# tlb refill

	.align	7		;# advance pc 0x80000280 *
vec5:	j	Eexcept
	or	k0, r0, 5	;# xtlb refill

	.align	7		;# advance pc 0x80000300 *
vec6:	j	Eexcept
	or	k0, r0, 6	;# Cache error

	.align	7		;# advance pc 0x80000380 *
	.globl	stub_running
stub_running = . - 4		;# grab a "vector" so the game can use it
vec7:	j	Eexcept
	or	k0, r0, 7	;# All other exceptions

	.set	at
	.set	reorder
ENDFRAME startup

.if true, BOOT_ROM_CODE == 0

 .if true, (BOOT_FROM_DISK == 0) && (EPROM_ST == 0)
	.align	10		;# advance PC to 0xX0000400
	.globl	pm_start
	.globl	powerUp
	.globl	pm_end
	.globl	pm_data
pm_start:
POWERUP =	0xC0EDBABE
powerUp:
	.space	4
pm_data:
	DEC_CONST	PM_SIZE PM_RxK_SIZE
	.space	PM_SIZE
pm_end:
	.space 4
 .endc
 .if true, (BOOT_COMPRESSED == 0)
	.align 15		;# advance pc to 0xX0010000 *
	.space 1
	.align 15
 .iff
	.align 11		;# advance pc to 0xX0000800 *
 .endc
	.globl	bss_start
	.globl	bss_end
	.globl	INIT_SP
	.globl	BootUp
	.globl	ROMCTS_INIT
	.globl	begin
.endc

	.text

	.align 3		;# make sure it is aligned on an 8 byte boundary
FRAME boot_entry
	.set	noreorder
	.set	at
begin:
;#***************************************************************
;#  Smack the SR to a known state				*
;#***************************************************************

	li	v1, INIT_SR
	mtc0	v1, C0_SR	;# set SR to known state *
	nop			;# wait for FP enable bit to take effect

.if true, !SA_DIAGS && (BOOT_ROM_CODE || BOOT_FROM_DISK || BOOT_COMPRESSED)
	mtc1	ra, $f0		;# save return address in f0
	mtc1	sp, $f2		;# save SP in f2
.endc
.if true, SA_DIAGS && (TEST_MEM32 | TEST_MEM64)
	bal	5f		;# find out where we are
	nop
	ALIGN3
5:	srl	ra, 24		;# get upper bits
	and	ra, 0xFF	;# isolate them
	xor	ra, 0xBF	;# check against 0xBFC00000
	bne	ra, r0, 6f	;# not EPROM, just continue
	nop
	mtc0	r0, C0_LLADDR	;# else 0 the LLADDR register
	ALIGN3
6:
sa_diag_entry:
.endc

;#***************************************************************
;#  Jump to noncached memory in case we were started		*
;*  by the stub. Then figure out where we are executing.	*
;#***************************************************************

;# WARNING DANGER WARNING DANGER WARNING DANGER WARNING
;# DO NOT ADD, DELETE OR CHANGE THE ORDER OF THE INSTRUCTIONS IN
;# THE FOLLOWING SEQUENCE
	ALIGN3
	bal	15f
	nop
15:	lui	v0, 0x2000
	or	ra, v0		;# get addr of '15:' non-cached
	addu	ra, 6*4		;# compute address of 20f
	j	ra
	nop
	nop

20:	li	v1, 0xFFFF
;# END OF SEQUENCE
	nor	v1, r0, v1
	and	fp, ra, v1

;#***************************************************************
;#  Init the rest of the important CPU registers		*
;#***************************************************************

	mtc0	r0, C0_COUNT	;# zero the system clock counter
	mtc0	r0, C0_CAUSE	;# clear software interrupts *
	li	v1, INIT_CFG	;# initialise the processor stats.
	mtc0	v1, C0_CONFIG	;# set cache algorithm for 0x80000000-0x9FFFFFFF
	li	v1, FPCSR_INIT	;# set the initial FP CSR
	ctc1	v1, C1_FCSR	;# init the FCSR

/* the memory system may need up to 256us to start up... */
	ALIGN3
	bal	prc_wait_n_usecs
	or	a0, r0, 128	;# wait about 256 microseconds
	
	srl	v0, fp, 24	;# isolate the upper 8 bits of our PC
	li	v1, 0xA0
	beq	v1, v0, skip_copy	;# running from DRAM, already copied and init'd
	nop	
.if true, SA_DIAGS && (TEST_MEM32|TEST_MEM64)
	mfc0	v1, C0_LLADDR
	nop
	bne	v1, r0, skip_galileo	;# looping on DRAM tests, don't reinit the galileo
	nop
.endc

;#***************************************************************
;#  Init the Galileo chip					*
;#***************************************************************

	ALIGN3
init_galileo:
	la v0, GALILEO_BOOT_BASE	;# point to Galileo chip
	la v1, (GALILEO_BASE&0x1FFFFFFF)>>21
	sw v1, GALILEO_Internal-GALILEO_BASE(v0)	;# The Galileo is now at 0x0C000000-0x0C0FFFFF
	sync
	ALIGN3
	bal	prc_wait_n_usecs
	or	a0, r0, 20		;# wait about 20 microseconds

	la v0, GALILEO_BASE		;# point to the new address
.if true, NON_PIPELINED_MODE
	lw v1, GALILEO_CPUINTFC-GALILEO_BASE(v0)
	or v1, 1<<GALILEO_CPUINTFC_WriteMod_b
	sw v1, GALILEO_CPUINTFC-GALILEO_BASE(v0)
.endc
	sw r0, GALILEO_RAS10_LOW-GALILEO_BASE(v0)	;# Bank 1-0 live at 0x00000000-0x03FFFFFF

.if true, (HOST_BOARD == PHOENIX)
	li v1, 0x1f			;# Bank 1-0 live at 0x00000000-0x03FFFFFF on Phoenix
.iff
	li v1, 0x3			;# Bank 1-0 live at 0x00000000-0x00FFFFFF on Phoenix-AD and Flagstaff
.endc
	sw v1, GALILEO_RAS10_HIGH-GALILEO_BASE(v0)

.if true, (HOST_BOARD == PHOENIX)
	sw r0, GALILEO_RAS0_LOW-GALILEO_BASE(v0)	;# RAS 0 lives at 0x00000000-0x01FFFFFF
	li v1, 0x0b
	sw v1, GALILEO_RAS0_HIGH-GALILEO_BASE(v0)
	li v1, 0x10
	sw v1, GALILEO_RAS1_LOW-GALILEO_BASE(v0)	;# RAS 1 lives at 0x02000000-0x03FFFFFF
	li v1, 0x3f
	sw v1, GALILEO_RAS1_HIGH-GALILEO_BASE(v0)
.endc
.if true, (HOST_BOARD == PHOENIX_AD)
;
; Fix these for 8MB RAMS
;
	sw r0, GALILEO_RAS0_LOW-GALILEO_BASE(v0)	;# RAS 0 lives at 0x00000000-0x001FFFFF
	li v1, 0x01
	sw v1, GALILEO_RAS0_HIGH-GALILEO_BASE(v0)
	li v1, 0x02
	sw v1, GALILEO_RAS1_LOW-GALILEO_BASE(v0)	;# RAS 1 lives at 0x00200000-0x003FFFFF
	li v1, 0x03
	sw v1, GALILEO_RAS1_HIGH-GALILEO_BASE(v0)
.endc
.if true, (HOST_BOARD == FLAGSTAFF) || (HOST_BOARD == SEATTLE)
	sw r0, GALILEO_RAS0_LOW-GALILEO_BASE(v0)	;# RAS 0 lives at 0x00000000-0x007FFFFF
	li v1, 0x07
	sw v1, GALILEO_RAS0_HIGH-GALILEO_BASE(v0)
	li v1, 0x08
	sw v1, GALILEO_RAS1_LOW-GALILEO_BASE(v0)	;# RAS 1 lives at 0x00800000-0x00AFFFFF
	li v1, 0x0a
	sw v1, GALILEO_RAS1_HIGH-GALILEO_BASE(v0)
.endc
	li v1, 0x20
	sw v1, GALILEO_RAS32_LOW-GALILEO_BASE(v0)	 ;# Bank 3-2 live at 0x04000000-0x07FFFFFF
	li v1, 0x3f
	sw v1, GALILEO_RAS32_HIGH-GALILEO_BASE(v0)
	li v1, 0x40
	sw v1, GALILEO_RAS2_LOW-GALILEO_BASE(v0)	;# RAS 2 lives at 0x04000000-0x05FFFFFF
	li v1, 0x5f
	sw v1, GALILEO_RAS2_HIGH-GALILEO_BASE(v0)
	li v1, 0x60
	sw v1, GALILEO_RAS3_LOW-GALILEO_BASE(v0)	;# RAS 3 lives at 0x06000000-0x07FFFFFF
	li v1, 0x7f
	sw v1, GALILEO_RAS3_HIGH-GALILEO_BASE(v0)

	li v1, 0x50
	sw v1, GALILEO_PCIIO_LOW-GALILEO_BASE(v0)	 ;# PCI I/O lives at 0x0A000000-0x0BFFFFFF
	li v1, 0x5f
	sw v1, GALILEO_PCIIO_HIGH-GALILEO_BASE(v0)
	li v1, 0x40
	sw v1, GALILEO_PCIMEM_LOW-GALILEO_BASE(v0)	 ;# PCI Memory lives at 0x08000000-0x09FFFFFF
	li v1, 0x4f
	sw v1, GALILEO_PCIMEM_HIGH-GALILEO_BASE(v0)

.if true, (HOST_BOARD == PHOENIX)
	li v1, 0x80
	sw v1, GALILEO_CS20_LOW-GALILEO_BASE(v0)	;# CS2-0 live at 0x10000000-0x14FFFFFF
	li v1, 0x3f
	sw v1, GALILEO_CS20_HIGH-GALILEO_BASE(v0)
	li v1, 0xc0
	sw v1, GALILEO_CS3BOOT_LOW-GALILEO_BASE(v0)	;# CS3 & Boot live at 0x18000000-1FFFFFFF
	li v1, 0x7f
	sw v1, GALILEO_CS3BOOT_HIGH-GALILEO_BASE(v0)
.endc

.if true, (HOST_BOARD == PHOENIX_AD) || (HOST_BOARD == FLAGSTAFF) || (HOST_BOARD == SEATTLE)
	li v1, 0x80
	sw v1, GALILEO_CS20_LOW-GALILEO_BASE(v0)	;# CS2-0 live at 0x10000000-0x15FFFFFF
	li v1, 0x2f
	sw v1, GALILEO_CS20_HIGH-GALILEO_BASE(v0)
	li v1, 0xB0
	sw v1, GALILEO_CS3BOOT_LOW-GALILEO_BASE(v0)	;# CS3 & Boot live at 0x16000000-1FFFFFFF
	li v1, 0x7f
	sw v1, GALILEO_CS3BOOT_HIGH-GALILEO_BASE(v0)
.endc

	sw r0, GALILEO_CS0_LOW-GALILEO_BASE(v0)	;# CS 0 lives at 0x10000000-0x11FFFFFF
	li v1, 0x1f
	sw v1, GALILEO_CS0_HIGH-GALILEO_BASE(v0)
	li v1, 0x20
	sw v1, GALILEO_CS1_LOW-GALILEO_BASE(v0)	;# CS 1 lives at 0x12000000-0x13FFFFFF
	li v1, 0x3f
	sw v1, GALILEO_CS1_HIGH-GALILEO_BASE(v0)
	li v1, 0x40
	sw v1, GALILEO_CS2_LOW-GALILEO_BASE(v0)	;# CS 2 lives at 0x14000000-0x15FFFFFF
	li v1, 0x5f
	sw v1, GALILEO_CS2_HIGH-GALILEO_BASE(v0)
.if true, (HOST_BOARD == PHOENIX)
	li v1, 0x80
	sw v1, GALILEO_CS3_LOW-GALILEO_BASE(v0)	;# CS 3 lives at 0x16000000-0x1fbFFFFFF
	li v1, 0xfb
	sw v1, GALILEO_CS3_HIGH-GALILEO_BASE(v0)
.endc
.if true, (HOST_BOARD == PHOENIX_AD) || (HOST_BOARD == FLAGSTAFF) || (HOST_BOARD == SEATTLE)
	li v1, 0x60
	sw v1, GALILEO_CS3_LOW-GALILEO_BASE(v0)	;# CS 3 lives at 0x16000000-0x17FFFFFF
	li v1, 0x7f
	sw v1, GALILEO_CS3_HIGH-GALILEO_BASE(v0)
.endc

.macro CFG exp
D_CFG == D_CFG | (exp)
D_CFG = D_CFG | (exp)
.endm

; The Galileo Rev A chip says in the release notes that all 'timing'
; specific config parameters must be greater than or equal to 3. Accordingly,
; they have all been minimised to 3.

D_CFG = 0
D_CFG == 0
.if true, 0 || (HOST_BOARD == PHOENIX)
CFG	(3<<GALILEO_DEV_CFG_TurnOff_b)|(4<<GALILEO_DEV_CFG_AccToFirst_b)
CFG	(3<<GALILEO_DEV_CFG_AccToNext_b)|(3<<GALILEO_DEV_CFG_ADStoWr_b)
CFG	(3<<GALILEO_DEV_CFG_WrActive_b)|(3<<GALILEO_DEV_CFG_WrHigh_b)
CFG	(2<<GALILEO_DEV_CFG_DevWidth_b)|(0<<GALILEO_DEV_CFG_DevLoc_b)
CFG	(0<<GALILEO_DEV_CFG_LatchFunct_b)
.iff
CFG	(4<<GALILEO_DEV_CFG_TurnOff_b)|(8<<GALILEO_DEV_CFG_AccToFirst_b)
CFG	(8<<GALILEO_DEV_CFG_AccToNext_b)|(3<<GALILEO_DEV_CFG_ADStoWr_b)
CFG	(6<<GALILEO_DEV_CFG_WrActive_b)|(4<<GALILEO_DEV_CFG_WrHigh_b)
CFG	(2<<GALILEO_DEV_CFG_DevWidth_b)|(0<<GALILEO_DEV_CFG_DevLoc_b)
CFG	(0<<GALILEO_DEV_CFG_LatchFunct_b)
.endc
	li v1, D_CFG
	sw v1, GALILEO_DEV0_CFG-GALILEO_BASE(v0)
.if true, 0 || (HOST_BOARD == PHOENIX_AD) || (HOST_BOARD == FLAGSTAFF) || (HOST_BOARD == SEATTLE)
D_CFG = 0
D_CFG == 0
CFG	(7<<GALILEO_DEV_CFG_TurnOff_b)|(15<<GALILEO_DEV_CFG_AccToFirst_b)
CFG	(15<<GALILEO_DEV_CFG_AccToNext_b)|(7<<GALILEO_DEV_CFG_ADStoWr_b)
CFG	(7<<GALILEO_DEV_CFG_WrActive_b)|(7<<GALILEO_DEV_CFG_WrHigh_b)
CFG	(2<<GALILEO_DEV_CFG_DevWidth_b)|(0<<GALILEO_DEV_CFG_DevLoc_b)
CFG	(0<<GALILEO_DEV_CFG_LatchFunct_b)
	li v1, D_CFG
.endc
	sw v1, GALILEO_DEV2_CFG-GALILEO_BASE(v0)
D_CFG = 0
D_CFG == 0
.if true, 0 || (HOST_BOARD == PHOENIX)
CFG	(3<<GALILEO_DEV_CFG_TurnOff_b)|(4<<GALILEO_DEV_CFG_AccToFirst_b)
CFG	(3<<GALILEO_DEV_CFG_AccToNext_b)|(3<<GALILEO_DEV_CFG_ADStoWr_b)
CFG	(3<<GALILEO_DEV_CFG_WrActive_b)|(3<<GALILEO_DEV_CFG_WrHigh_b)
CFG	(2<<GALILEO_DEV_CFG_DevWidth_b)|(1<<GALILEO_DEV_CFG_DevLoc_b)
CFG	(0<<GALILEO_DEV_CFG_LatchFunct_b)
.iff
CFG	(4<<GALILEO_DEV_CFG_TurnOff_b)|(8<<GALILEO_DEV_CFG_AccToFirst_b)
CFG	(8<<GALILEO_DEV_CFG_AccToNext_b)|(3<<GALILEO_DEV_CFG_ADStoWr_b)
CFG	(6<<GALILEO_DEV_CFG_WrActive_b)|(4<<GALILEO_DEV_CFG_WrHigh_b)
CFG	(2<<GALILEO_DEV_CFG_DevWidth_b)|(0<<GALILEO_DEV_CFG_DevLoc_b)
CFG	(0<<GALILEO_DEV_CFG_LatchFunct_b)
.endc
	li v1, D_CFG
	sw v1, GALILEO_DEV1_CFG-GALILEO_BASE(v0)
	sw v1, GALILEO_DEV3_CFG-GALILEO_BASE(v0)

.if true, 0 && ( (HOST_BOARD == PHOENIX_AD) || (HOST_BOARD == FLAGSTAFF) ) || (HOST_BOARD == SEATTLE)
D_CFG = 0
D_CFG == 0
CFG	(4<<GALILEO_DEV_CFG_TurnOff_b)|(8<<GALILEO_DEV_CFG_AccToFirst_b)
CFG	(8<<GALILEO_DEV_CFG_AccToNext_b)|(3<<GALILEO_DEV_CFG_ADStoWr_b)
CFG	(6<<GALILEO_DEV_CFG_WrActive_b)|(4<<GALILEO_DEV_CFG_WrHigh_b)
CFG	(2<<GALILEO_DEV_CFG_DevWidth_b)|(0<<GALILEO_DEV_CFG_DevLoc_b)
CFG	(0<<GALILEO_DEV_CFG_LatchFunct_b)
	li v1, D_CFG
	sw v1, GALILEO_BOOT_CFG-GALILEO_BASE(v0)
.endc

.macro CFG exp
.endm

.if defined, LED_OUT
	li v1, (1<<B_LED_RED)|(1<<B_LED_GRN)|(1<<B_LED_YEL)
	sw v1, LED_OUT			;# Start with all LED's off
.endc

.if true, (HOST_BOARD == FLAGSTAFF) || (HOST_BOARD == SEATTLE)
	li v1, (781<<GALILEO_DRAM_CFG_RefIntCnt_b)
.iff
	li v1, (768<<GALILEO_DRAM_CFG_RefIntCnt_b)
.endc
	sw v1, GALILEO_DRAM_CFG-GALILEO_BASE(v0)
	move t1, r0
	la t0, GALILEO_DRAM0_CFG
	la a0, DRAM_BASEnc+0x00000000
	ALIGN3
	bal init_dram			;# init bank 0
	nop 
	or t1, v0			;# save status

.if true, DRAM_BANKS > 1
 .if true, (HOST_BOARD == PHOENIX_AD) 
	la a0, DRAM_BASEnc+0x00200000
 .endc
 .if true, (HOST_BOARD == FLAGSTAFF) || (HOST_BOARD == SEATTLE)
	la a0, DRAM_BASEnc+0x00800000
 .endc
 .if true, (HOST_BOARD == PHOENIX) 
	la a0, DRAM_BASEnc+0x01000000
 .endc

	la t0, GALILEO_DRAM1_CFG
	ALIGN3
	bal init_dram			;# init bank 1
	nop
	sll v0, 2
	or t1, v0
.endc

.if true, DRAM_BANKS > 2
	la t0, GALILEO_DRAM2_CFG
	la a0, DRAM_BASEnc+0x04000000
	ALIGN3
	bal init_dram			;# init bank 2
	nop
	sll v0, 4
	or t1, v0
.endc

.if true, DRAM_BANKS > 3
	la t0, GALILEO_DRAM3_CFG
	la a0, DRAM_BASEnc+0x06000000
	ALIGN3
	bal init_dram			;# init bank 3
	nop
	sll v0, 6
	or k1, t1, v0
.endc

.if true, (HOST_BOARD == PHOENIX_AD) || (HOST_BOARD == FLAGSTAFF) || (HOST_BOARD == SEATTLE)
	li a0, 100000			;# wait 0.1 seconds
	ALIGN3
	bal prc_wait_n_usecs
	nop
	li a0, 1<<B_LED_GRN		;# blink the green LED once
	ALIGN3
	bal prc_blink_led
	move a1, r0			;# use default blink time
.endc

/* Reset the NSS board */
.if true, HOST_BOARD == PHOENIX
	la	t0, MISC_CONFIG		;# Address of the NSS reset port
	li	t1, MISC_CONFIG_NSS_RESET ;# NSS Reset bit
	sw	t1, 0(t0)		;# Drive NSS reset
.endc
.if defined, RESET_CTL
	la	t0, RESET_CTL		;# Address of the reset port
	sw	r0, 0(t0)		;# reset everything
.endc
	ALIGN3
	bal	prc_wait_n_usecs
	or	a0, r0, 1000		;# wait about 1 millisecond

.if true, (HOST_BOARD == PHOENIX)
	sw	zero, 0(t0)		# Release NSS reset
.endc

.if true, (HOST_BOARD == PHOENIX_AD) || (HOST_BOARD == SEATTLE)
	li	t1, (1<<B_RESET_EXP)|(1<<B_RESET_WIDGET)|(1<<B_RESET_NSS) # Un-reset a few things
	sw	t1, (t0)
.endc

.if true, (HOST_BOARD == FLAGSTAFF)
	li	t1, (1<<B_RESET_EXP)|(1<<B_RESET_WIDGET)|(1<<B_RESET_ENET) # Un-reset a few things
	sw	t1, (t0)
.endc
	ALIGN3
skip_galileo:

.if true, (BOOT_FROM_DISK == 0) && (NO_WDOG == 0)
	sw	r0, WATCHDOG
.endc

.if true, TEST_MEM32
;#***************************************************************
;#  Test memory
;#***************************************************************

 .if true, SA_DIAGS == 0
	lw	v0, GP_STS
	and	v0, 1<<B_GPSTS_DBG
	beq	v0, r0, no_memtest
	nop
 .iff
  .if true, ANNOUNCE_BOOT_ACTIONS || SA_DIAGS
	mfc0	v0, C0_LLADDR
	nop
	bne	v0, r0, 5f			;# already unlocked
	nop
	ALIGN3
	bal	UnLock
	nop
	li	a0, 1000000
	ALIGN3
	bal	prc_wait_n_usecs
	nop
	lra	a0, boot_version
	ALIGN3
	bal	prc_puts
	nop

	ALIGN3
5:	lw	v0, GP_STS
	and	v0, 1<<B_GPSTS_DBG
	bne	v0, r0, 8f
	nop
	lw	v0, IO_DIPSW
	and	v0, IO_DIPSW4			;# isolate dip switch 5
	bne	v0, r0, no_memtest		;# switch 5 off, continue with program
	nop

	ALIGN3
8:
	lra	a0, sa_header_1
	ALIGN3
	bal	prc_puts
	nop
	li	a0, 0x32
	li	a1, 2
	ALIGN3
	bal	prc_putv
	nop
	lra	a0, sa_header_1_mode
	ALIGN3
	bal	prc_puts
	nop
  .endc
 .endc

 .if defined, LED_OUT
	lw	a0, LED_OUT
	and	a0, ~(1<<B_LED_YEL)	;# turn on YEL LED
	sw	a0, LED_OUT
 .endc
	la	a0, DRAM_BASEnc		;# point to destination
 .if true, SA_DIAGS == 0
	li	a1, PM_DATA_BEGIN-1	;# Up to but not including PM area
	move	a2, r0			;# Not used
	ALIGN3
	bal	test_mem32		;# check memory in 32 bit mode
	nop
	bne	v0, r0, test_error	;# report errors
	nop
	la	a0, PM_DATA_END+1	;# point to destination
 .endc
	li	a1, DRAM_BASEnc+TESTMEM32_PART1-1 ;# first half test size
	move	a2, r0			;# Not used
	ALIGN3
	bal	test_mem32		;# check memory in 32 bit mode
	nop
	bne	v0, r0, test_error	;# report errors
	nop
 .if true, SA_DIAGS && TEST_MEM64
	lra	a0, sa_header_1
	ALIGN3
	bal	prc_puts
	nop
	li	a0, 0x64
	li	a1, 2
	ALIGN3
	bal	prc_putv
	nop
	lra	a0, sa_header_1_mode
	ALIGN3
	bal	prc_puts
	nop
	la	a0, DRAM_BASEnc		;# point to destination
	li	a1, DRAM_BASEnc+TESTMEM32_PART1-1 ;# first half test size
	move	a2, r0			;# Not used
	ALIGN3
	bal	test_mem64		;# check memory in 64 bit mode
	nop
	bne	v0, r0, test_error64	;# report errors
	nop
 .endc
	ALIGN3
no_memtest:
.endc
.if defined, LED_OUT
	li v1, (1<<B_LED_RED)|(1<<B_LED_GRN)|(1<<B_LED_YEL)
	sw v1, LED_OUT			;# Start with all LED's off
	move a1, r0			;# use default blink time
	ALIGN3
	bal prc_blink_led
	li a0, 1<<B_LED_GRN		;# blink the green LED once
.endc

;#***************************************************************
;#  Init the CACHE's						*
;#***************************************************************

	la	v0, init_cache		;# get pointer to cache init routine
	and	v0, 0x0000FFFF		;# isolate the init_cache's addr low bits
	or	v0, fp			;# make a new address
	ALIGN3
	jal	v0			;# init the caches
	nop

.if true, BOOT_COPY_SELF == 0
;#***************************************************************
;#  Put a copy loop into DRAM					*
;#***************************************************************

	la	v0, copy_loop_start	;# point to our loop addr
	and	v0, 0x0000FFFF
	or	v0, fp
	la	v1, copy_loop_end
	and	v1, 0x0000FFFF
	or	v1, fp
	la	a0, DRAM_BASEnc		;# destination

	ALIGN3
6:	lw	a1, (v0)		;# src
	addu	v0, 4
	sw	a1, (a0)		;# dst
	bgtu	v1, v0, 6b
	addu	a0, 4

.if true, BOOT_FROM_XBUS
	sw	r0, XBUS_BASE		;# select XBUS bank 0 
.endc

	ALIGN3
	bal	prc_wait_n_usecs
	or	a0, r0, 20		;# wait about 20 microseconds for WB to flush

	la	a3, copy_loop_end
	la	v0, copy_loop_start
	subu	a3, v0			;# compute size of copy loop

	la	v0, DRAM_BASE		;# point to cached mem
	ALIGN3
	jal	v0			;# goto it
	nop

	la	a3, copy_loop_end
	la	v0, copy_loop_start
	subu	a3, v0			;# compute size of copy loop
	la	v0, RAMROM_BASE		;# src address
	addu	v1, v0, a3		;# end address
	la	a0, DRAM_BASEnc		;# dst address
.if true, BOOT_FROM_XBUS
	sw	r0, XBUS_BASE		;# select bank 0 again
.endc

	ALIGN3
7:	lw	a1, (v0)
	addu	v0, 4
	sw	a1, (a0)
	bgtu	v1, v0, 7b
	addu	a0, 4

	la	v0, DRAM_BASE
	cache	Hit_Invalidate_I,   0(v0) ;# clobber the first cache line
	cache	Hit_Invalidate_I,  32(v0) ;# clobber the second cache line
	cache	Hit_Invalidate_I,  64(v0) ;# clobber the third cache line
	cache	Hit_Invalidate_I,  96(v0) ;# clobber the fourth cache line
	cache	Hit_Invalidate_I, 128(v0) ;# clobber the fifth cache line
	cache	Hit_Invalidate_I, 160(v0) ;# clobber the sixth cache line
	ALIGN3
	bal	prc_wait_n_usecs
	or	a0, r0, 20		;# wait about 20 microseconds

	la	v0, DRAM_BASEnc		;# now jump to user's program non-cached
	j	v0
	nop

	ALIGN3
copy_loop_start:

	la	v0, RAMROM_BASE		;# point to ramrom
	li	v1, 0xFEEDFACE

	lw	a0, ROMV_SENTINEL(v0)
10:	bne	a0, v1, 10b		;# wait for a feedface to show up
	lw	a0, ROMV_SENTINEL(v0)

	lw	v1, ROMV_TSIZE(v0)	;# get size
	li	a0, 8192*1024		;# more than 8MB?
	bleu	v1, a0, 20f		;# yep,
	nop
	move	v1, a0			;# max it out to 8MB
20:	la	a0, DRAM_BASEnc		;# point to destination
	li	t0, PM_DATA_BEGIN	;# don't copy anything into PM area
	li	t1, PM_DATA_END
	addu	v1, a0			;# compute end address (destination addr + size)
	addu	a0, a3			;# skip over the copy loop
	addu	v0, a3			;# compute new source address
	bltu	v1, a0, 40f		;# already done
;	nop				;# Don't need this nop actually
.if true, BOOT_FROM_XBUS
	li	a2, 4*1024*1024-4	;# 4 MB boundary
	sw	r0, XBUS_BASE		;# always start on bank 0
.endc
30:
.if true, BOOT_FROM_XBUS
	and	a3, a0, a2		;# are we on a bank boundary
	bne	a3, r0, 35f		;# nope, continue
	srl	a3, a0, 22		;# get the upper 3 bits of address
	and	a3, 7
	sw	a3, XBUS_BASE		;# select a new bank
	la	v0, RAMROM_BASE		;# reset the source pointer
35:
.endc
	bgtu	a0, t1, 38f		;# ok to continue
	lw	a1, (v0)
	bltu	a0, t0, 38f		;# ok to continue
	nop
	b	39f
	nop
38:	sw	a1, (a0)
39:	addu	a0, 4
	bgtu	v1, a0, 30b
	addu	v0, 4
40:	j	ra
	nop
	ALIGN3
copy_loop_end:
.iff
	la	v0, DRAM_BASEnc		;# destination
	la	v1, 0xBFC00000		;# source is EPROM
	la	a0, PM_DATA_BEGIN-DRAM_BASEnc	;# stop copying at PM BEGIN
	addu	a0, v1
	ALIGN3
10:	lw	a1, (v1)		;# get source
	sw	a1, (v0)		;# write it
	addu	v1, 4
	bgtu	a0, v1, 10b	
	addu	v0, 4

	addu	v0, (PM_DATA_END-PM_DATA_BEGIN+3)&-4
	addu	v1, (PM_DATA_END-PM_DATA_BEGIN+3)&-4
	la	a1, text_start
	la	a0, text_end		;# end of source
	subu	a0, a1			;# compute size in bytes
	addu	a0, 0xBFC00000		;# compute limit in EPROM space
	ALIGN3
20:	lw	a1, (v1)		;# get source
	sw	a1, (v0)		;# write it
	addu	v1, 4
	bgtu	a0, v1, 20b	
	addu	v0, 4

	ALIGN3
	bal	prc_wait_n_usecs
	or	a0, r0, 20		;#3 wait about 20 microseconds

	la	v0, DRAM_BASEnc
	j	v0			;# goto ourself in DRAM
	nop
.endc
	
	ALIGN3
skip_copy:

.if defined, IO_MAIN_CTL
	sw	r0, IO_MAIN_CTL		;# be sure to disable all IOASIC interrupts
.endc
.if defined, LED_OUT
	li v0, (1<<B_LED_RED)|(1<<B_LED_YEL)|(1<<B_LED_GRN)
	sw v0, LED_OUT			;# Turn off all the LED's
.endc

.if true, 0
;#***************************************************************
;#  Handy loop to see if we get this far 			*
;#***************************************************************

	WALKER_LED
.endc

.if true, BOOT_ROM_CODE
	la	v0, RAMROM_BASE+0x00E00000
	ALIGN3
10:	b	10b
	lw	r0, (v0)
.endc

.if true, BOOT_ROM_CODE == 0
;#***************************************************************
;#  Init the TLB 						*
;#***************************************************************

	ALIGN3
	bal	init_tlb	;# init the tlb
	nop

;#***************************************************************
;#  Init the CACHE's						*
;#***************************************************************

	la	v0, init_cache	;# get pointer to cache init routine
	li	v1, 0x20000000	;# get a constant
	or	v0, v1		;# make sure address is in non-cached memory
	ALIGN3
	jal	v0		;# init the caches
	nop

;#***************************************************************
;#  Set all the exception vectors				*
;#***************************************************************

	la	v0, j_except
	la	k0, DRAM_BASEnc
	or	v0, 0x20000000	;# make address non-cached
	lw	v1, 0x004(v0)	;# get instruction in delay slot
	sw	v1, 0x004(k0)	;# fill delay slot
	lw	v1, 0x000(v0)	;# get jump instruction
	sw	v1, 0x000(k0)	;# location 0
	sw	v1, 0x080(k0)	;# all other vectors get the same
	sw	v1, 0x100(k0)
	sw	v1, 0x180(k0)
	sw	v1, 0x200(k0)
	sw	v1, 0x280(k0)
	sw	v1, 0x300(k0)
	sw	v1, 0x380(k0)

;#***************************************************************
;#  Now do relative jump to cached execution area 		*
;#***************************************************************
	bal	10f		;# get current PC
	nop
	ALIGN3
10:	srl	v0, ra, 24	;# isolate upper byte
	and	v0, 0xFF
	li	v1, 0xA0
	bne	v0, v1, 25f	;# if not running in DRAM, skip it
	nop
	la	v0, 20f		;# assume this is a cached address
	jr	v0		;# jump to cached memory
	nop
	ALIGN3
20:	and	fp, v0, 0xFF000000	;# reset the fp register too
	li	v0, INIT_SR&~SR_BEV	;# clear the BEV bit
	mtc0	v0, C0_SR
	ALIGN3
25:

.if true, TEST_MEM32 
;#***************************************************************
;#  Finish testing memory
;#***************************************************************

 .if true, SA_DIAGS == 0
	lw	v0, GP_STS
	and	v0, 1<<B_GPSTS_DBG
	beq	v0, r0, no_memtest_part2
	nop
 .iff
  .if true, ANNOUNCE_BOOT_ACTIONS || SA_DIAGS
	la	v0, prc_puts
	lw	v1, (v0)
	or	v0, 0xBFC00000
	lw	a0, (v0)
	beq	a0, v1, 5f		;# DRAM matches EPROM, don't need to unlock
	nop
	mfc0	v0, C0_LLADDR
	nop
	bne	v0, r0, 5f		;# second and subsequent times, no need to unlock
	nop
	bal	UnLock
	nop
	li	a0, 1000000
	bal	prc_wait_n_usecs
	nop
	la	a0, boot_version
	bal	prc_puts
	nop

5:	lw	v0, GP_STS
	and	v0, 1<<B_GPSTS_DBG
	bne	v0, r0, 8f
	nop
	lw	v0, IO_DIPSW
	and	v0, IO_DIPSW4			;# isolate dip switch 5
	bne	v0, r0, no_memtest_part2	;# switch 5 off, continue with program
	nop

8:	la	a0, sa_header_2
	bal	prc_puts
	nop
	li	a0, 0x32
	li	a1, 2
	bal	prc_putv
	nop
	la	a0, sa_header_1_mode
	bal	prc_puts
	nop
  .endc
 .endc

 .if defined, LED_OUT
	li	a0, ~(1<<B_LED_YEL)	;# turn on YEL LED
	sw	a0, LED_OUT
 .endc
	li	a0, DRAM_BASEnc+TESTMEM32_PART1 ;# start where first 1/2 left off
 .if true, (HOST_BOARD == PHOENIX_AD)
	li	a1, DRAM_BASEnc+0x00400000-1 ;# DRAM end (3.5 megabyte)
 .iff
	li	a1, DRAM_BASEnc+0x00800000-1 ;# DRAM end (7.5 megabyte)
 .endc
	move	a2, r0			;#Not used
	bal	test_mem32		;# check memory in 32 bit mode
	nop
	bne	v0, r0, test_error	;# report errors
	nop
 .if true, SA_DIAGS && TEST_MEM64
	la	a0, sa_header_2
	bal	prc_puts
	nop
	li	a0, 0x64
	li	a1, 2
	bal	prc_putv
	nop
	la	a0, sa_header_1_mode
	bal	prc_puts
	nop
	li	a0, DRAM_BASEnc+TESTMEM32_PART1 ;# start where first 1/2 left off
	li	a1, DRAM_BASEnc+0x00800000-1 ;# DRAM end (7.5 megabyte)
	move	a2, r0			;# Not used
	bal	test_mem64		;# check memory in 64 bit mode
	nop
	bne	v0, r0, test_error64	;# report errors
	nop
 .endc
no_memtest_part2:
.endc

.if defined, LED_OUT
	li v1, (1<<B_LED_RED)|(1<<B_LED_GRN)|(1<<B_LED_YEL)
	sw v1, LED_OUT			;# Start with all LED's off
	move a1, r0			;# use default blink time
	bal prc_blink_led
	li a0, 1<<B_LED_GRN		;# blink the green LED once
.endc

.if true, SA_DIAGS && (TEST_MEM32|TEST_MEM64)
	lw	v0, IO_DIPSW
	and	v0, IO_DIPSW4		;# isolate dip switch 5
	bne	v0, r0, clear_bss	;# continue with program
	la	a0, sa_loop_msg		;# display loop count message
	bal	prc_puts
	nop
	mfc0	a0, C0_LLADDR
	addu	a0, 1			;# increment it
	mtc0	a0, C0_LLADDR		;# save it
	bal	prc_putv		;# display count
	li	a1, 5			;# loop count

	lra	a0, sa_diag_entry, offset=0xbfc00000
	lw	v0, (a0)
	lw	v1, sa_diag_entry
	bne	v0, v1, sa_diag_entry	;# running from RAMROM, can't go back to EPROM
	nop

	j	a0			;# else, continue by jumping back to eprom
	nop
.endc

;#***************************
;#  First clear our BSS     *
;#***************************

clear_bss:
	la	sp, DRAM_BASEnc
	lw	sp, ROMV_STACK(sp)	;# get the value to which to init the stack
	addu	sp, -4*REG_SIZE		;# leave 4 doubles on the stack
	and	sp, -8			;# align it on a double word boundary
40:	la	v0, bss_start		;# prepare to clear all bss
	la	v1, bss_end

	sw	r0, (v0)
41:	addu	v0, 4
	bgt	v1, v0, 41b
	sw	r0, (v0)

.if true, (BOOT_FROM_DISK == 0) && (BOOT_COMPRESSED == 0) && (EPROM_ST == 0) && (SA_DIAGS == 0)
	la	s0, pm_data
	lw	a0, pm_msg(s0)		;# get pointer to message
	beq	a0, r0, 5f		/* 0 is a legit value for this */
	nop
	li	v0, 8
	srl	v1, a0, 28		;# get upper nibble of address
	beq	v1, v0, 5f		;# anywhere in region 8 is ok
	nop
	jal	tlbprobe		;# check it
	or	a1, r0, 4		;# 4 bytes
	bge	v0, r0, 5f		;# ok
	nop
	sw	r0, pm_msg(s0)		;# else make it 0
5:	lw	a0, pm_stack(s0)	;# get pointer to stack
	beq	v0, r0, 10f		/* 0 is a legit value for this */
	nop
	li	v0, 8
	srl	v1, a0, 28		;# get upper nibble of address
	beq	v1, v0, 10f		;# anywhere in region 8 is ok
	nop
	jal	tlbprobe		;# check it
	or	a1, r0, 4		;# 4 bytes
	bge	v0, r0, 10f		;# it is a legit value
	nop
	sw	r0, pm_stack(s0)	/* 0 the stack params */
	sw	r0, pm_stklower(s0)
	b	15f
	sw	r0, pm_stkupper(s0)

10:	lw	a0, pm_stklower(s0)	;# get stack lower limit
	lw	a1, pm_stkupper(s0)	;# get stack upper limit
	li	v0, 8
	srl	v1, a0, 28		;# get upper nibble of address
	beq	v1, v0, 15f		;# anywhere in region 8 is ok
	nop
	jal	tlbprobe		;# check it
	subu	a1, a0			;# compute stack size in bytes
	bge	v0, r0, 15f		;# ok
	nop
	sw	r0, pm_stklower(s0)
	sw	r0, pm_stkupper(s0)
15:	lw	a0, pm_sr(s0)		;# check the SR register
	and	a0, (1<<27)|(3<<23)|(1<<21)|(1<<19)|0x78
	bne	a0, r0, pm_nfg		;# bad, reset all of it
	lw	a0, pm_cause(s0)	;# check cause too
	and	a0, 0x4FFF0083
	bne	a0, r0, pm_nfg		;# bad, reset all of it
	nop
	lw	a0, pm_cntr(s0)		;# get the current counter
	li	a1, -42			;# is it special?
	blt	a0, a1, pm_nfg		;# not legal, whack it
	nop
	beq	a0, a1, pm_ok		;# this is a prc_reboot
	nop
	bne	a0, r0, pm_ok		;# not zero means something to somebody
	nop
	beq	v0, r0, pm_ok
	nop
.if true, 0				;The WDOG bit doesn't work yet
.if defined, GP_STS
	lw	a0, GP_STS		;# get status
	and	a0, 1<<B_GPSTS_WDOG	;# isolate the WDOG bit
	beq	a0, r0, pm_nfg		;# not a WDOG timeout
.endc
.endc
	mfc0	a0, C0_ERRPC		;# assume a watchdog reset
	mfc1	a2, $f0			;# get saved ra
	mfc1	a3, $f2			;# get saved sp
	li	a1, -41			;# get a -41
	sw	a1, pm_cntr(s0)		;# so the "WATCHDOG RESET" message will appear 
	sw	a2, pm_regs+31*4(s0)	;# stuff old ra into regs
	sw	a3, pm_regs+29*4(s0)	;# stuff old sp into regs
	b	pm_ok
	sw	a0, pm_pc(s0)		;# record the PC at WD reset
	
pm_nfg:
	move	s1, s0
	li	a0, PM_SIZE
20:	sw	r0, (s1)
	addu	a0, -4
	bgt	a0, r0, 20b
	addu	s1, 4
pm_ok:
.endc
50:
;#****************************************************************
;#  Leave some stuff in a handy spot for the program if it cares *
;#****************************************************************

	jal	config_cache		;# get cache sizes for the program to use
	nop				;# returns with icache size in t2, dcache size in t3
					;# icache linesize in t4, dcache linesize in t5
					;# t6 and t7 are 0
	la	v0, cpu_params
	mfc0	t1, C0_PRID
	li	t6, 4600
	sw	t6, cpu_type(v0)
	sw	t2, cpu_icache(v0)
	sw	t3, cpu_dcache(v0)
	sw	t1, cpu_prid(v0)
	sw	t4, cpu_icache_ls(v0)
	sw	t5, cpu_dcache_ls(v0)

	jal	flush_cache
	nop

;#***************************************************************
;#  Clear all FP and most GP registers 				*
;#***************************************************************

.macro .zeror	reg
	dmtc1	r0, $f'reg'
.endm .zeror

...2 == 0
.if true, NO_FRBIT
.rept	16
    .zeror	\...2
    ...2 == ...2 + 2
.endr
.iff
.rept	32
    .zeror	\...2
    ...2 == ...2 + 1
.endr
.endc
.macro .zeror	reg
	move	$'reg', r0
.endm .zeror
...2 == 4
.rept	29-4				;stop at sp
    .zeror	\...2
    ...2 == ...2 + 1
.endr

	dmtc0	r0, C0_CTXT
	mtc0	r0, C0_PAGEMASK		;# see that all registers start out 0
	mtc0	r0, C0_LLADDR
	dmtc0	r0, C0_XCTXT

.if true, 0
;#***************************************************************
;#  Handy loop to see if we get this far 			*
;#***************************************************************

	WALKER_LED

.iff

	la	v0, BootUp
	j	v0
	move	ra, r0		;# No return address so gdb doesn't get confused
.endc
.endc				; BOOT_ROM_CODE == 0	
	.set at
	.set reorder
ENDFRAME boot_entry

;/* -*-asm-*- */
;
;/* code to unlock the IO ASIC
; *	
; *  this code is from Chris Krubel's ioasic.c c-code compiled
; *  down to assembly code and modified to run with no RAM required.
; */

/*
 * These arrays contain values and addresses to write the
 * values to in order to unlock the I/O ASIC.
 */

IOASIC_OFFSET_SHIFT = 2		;# IOASIC lives in a 32 bit address space

PIC1:	
.int	0x002b, 0x0093, 0x00a7, 0x004e, 0x0000, 0x000e, -1

PIC2:	
.int 0x6f43, 0x7970, 0x6972, 0x6867, 0x2074, 0x4328, 0x2029, 0x3931
.int 0x3539, 0x4d20, 0x6469, 0x6177, 0x2079, 0x614d, 0x756e, 0x6166
.int 0x7463, 0x7275, 0x6e69, 0x2067, 0x6f43, 0x706d, 0x6e61, 0x2079
.int 0x2d2d, 0x5020, 0x6f72, 0x7270, 0x6569, 0x6174, 0x7972, 0x2d20
.int 0x202d, 0x7375, 0x2065, 0x7570, 0x7372, 0x6175, 0x746e, 0x7420
.int 0x206f, 0x694d, 0x7764, 0x7961, 0x4d20, 0x6e61, 0x6675, 0x6361
.int 0x7574, 0x6972, 0x676e, 0x4320, 0x6d6f, 0x6170, 0x796e, 0x6920
.int 0x736e, 0x7274, 0x6375, 0x6974, 0x6e6f, 0x2073, 0x2d2d, 0x6620
.int 0x726f, 0x6920, 0x746e, 0x7265, 0x616e, 0x206c, 0x7375, 0x2e65
.int 0x2020, 0x2020, 0x2020, 0x2020, 0x2020, 0x2020, 0x2020, 0x2020
.int 0x2020, 0x2020, 0x2020, 0x2020, 0x2020, 0x2020, 0x2020, 0x2020
.int 0x2020, 0x2020, 0x2020, 0x2020, 0x2020, 0x2020, 0x2020, 0x2020
.int 0

PIC3:	
.int 0x4343, 0x6f6f, 0x7070, 0x7979, 0x7272, 0x6969, 0x6767, 0x6868
.int 0x7474, 0x2020, 0x2828, 0x4343, 0x2929, 0x2020, 0x3131, 0x3939
.int 0x3939, 0x3535, 0x2020, 0x4d4d, 0x6969, 0x6464, 0x7777, 0x6161
.int 0x7979, 0x2020, 0x4d4d, 0x6161, 0x6e6e, 0x7575, 0x6666, 0x6161
.int 0x6363, 0x7474, 0x7575, 0x7272, 0x6969, 0x6e6e, 0x6767, 0x2020
.int 0x4343, 0x6f6f, 0x6d6d, 0x7070, 0x6161, 0x6e6e, 0x7979, 0x2020
.int 0x2d2d, 0x2d2d, 0x2020, 0x5050, 0x7272, 0x6f6f, 0x7070, 0x7272
.int 0x6969, 0x6565, 0x7474, 0x6161, 0x7272, 0x7979, 0x2020, 0x2d2d
.int 0x2d2d, 0x2020, 0x7575, 0x7373, 0x6565, 0x2020, 0x7070, 0x7575
.int 0x7272, 0x7373, 0x7575, 0x6161, 0x6e6e, 0x7474, 0x2020, 0x7474
.int 0x6f6f, 0x2020, 0x4d4d, 0x6969, 0x6464, 0x7777, 0x6161, 0x7979
.int 0x2020, 0x4d4d, 0x6161, 0x6e6e, 0x7575, 0x6666, 0x6161, 0x6363
.int 0x7474, 0x7575, 0x7272, 0x6969, 0x6e6e, 0x6767, 0x2020, 0x4343
.int 0x6f6f, 0x6d6d, 0x7070, 0x6161, 0x6e6e, 0x7979, 0x2020, 0x6969
.int 0x6e6e, 0x7373, 0x7474, 0x7272, 0x7575, 0x6363, 0x7474, 0x6969
.int 0x6f6f, 0x6e6e, 0x7373, 0x2020, 0x2d2d, 0x2d2d, 0x2020, 0x6666
.int 0x6f6f, 0x7272, 0x2020, 0x6969, 0x6e6e, 0x7474, 0x6565, 0x7272
.int 0x6e6e, 0x6161, 0x6c6c, 0x2020, 0x7575, 0x7373, 0x6565, 0x2e2e
.int 0x2020, 0x2020, 0x2020, 0x2020, 0x2020, 0x2020, 0x2020, 0x2020
.int 0x2020, 0x2020, 0x2020, 0x2020, 0x2020, 0x2020, 0x2020, 0x2020
.int 0x2020, 0x2020, 0x2020, 0x2020, 0x2020, 0x2020, 0x2020, 0x2020
.int 0x2020, 0x2020, 0x2020, 0x2020, 0x2020, 0x2020, 0x2020, 0x2020
.int 0x2020, 0x2020, 0x2020, 0x2020, 0x2020, 0x2020, 0x2020, 0x2020
.int 0x2020, 0x2020, 0x2020, 0x2020, 0x2020, 0x2020, 0x2020, 0x2020
.int 0

PIC4:	
.int 0x0054, 0x0029, 0x00e2, -1

/* ---------------------------------------------------------------------*/
/* PICWrite
	write a value to the PIC - a0 = data, a1 = address
	return value in v0
	uses a0, a1, t0, t1, t2, v0, v1 
*/
	ALIGN3
FRAME PICWrite,global=0
	la	t0, IOASIC_BASE	# t0 = ioasic base addr
	li	t1, 0		# t1 = loop count
	ALIGN3
L2:	
	sltiu 	v1, t1, 100	# test loop counter
	bnez 	v1, L5		# if loop counter not 0 do the loop
	b	L3		# return failure loop timed out
	ALIGN3
L5:	
 	lw 	v1, 0(t0)	# read data
      	/*  if((wData & 0xe000) != 0x2000) */
	li	t2, 0x0000e000
	and 	t2, v1, t2	# mask top 3 bits
	li 	v1, 0x00002000	
	beq 	t2, v1, LM8	# are top three bits 001?
				# yes - do the write
				# no  - try again
	b L4
	ALIGN3
LM8:	
	sw 	a0, 0(a1)	# write the data
	li 	v0, 1		# return code = 1 
	j	ra

	ALIGN3
L4:	
	addiu 	t1, t1, 1	# increment loop counter
	b 	L2		# jump back to loop head

	ALIGN3
L3:	
	li 	v0, 0		# return code = 0
	j	ra
ENDFRAME PICWrite

/* --------------------------------------------------------------------- */
/* PICReady - return a 1 if the pic reads ready */
/* uses t0, t1, and v0 */

	ALIGN3
FRAME PICReady,global=0
	la 	t0, IOASIC_BASE
	lw	t1, 0(t0)
	andi 	v0, t1, 0x0001
	j	ra
ENDFRAME PICReady

/* --------------------------------------------------------------------- */
/* UnLock - unlock the IOASIC - return a one if sucessful */
/*	uses a0-a3, t0-t5						 */

	ALIGN3
FRAME UnLock
	move	a3, ra			# save the return address
	move	t5, fp			# save FP
	li	fp, 0x003FFFFF
	nor	fp, r0, fp
	and	fp, ra			;# isolate upper address bits

	la	t0, RESET_CTL		# read the reset register
	lw	t1, 0(t0)
	li 	v1, ~(1<<B_RESET_IOASIC) # make a mask
	and 	t1, v1
	sh	t1, 0(t0)		# store it

	li	a0, 1000
	ALIGN3
	bal	prc_wait_n_usecs	# wait about 1 millisecond

	ori	t1, (1<<B_RESET_IOASIC) # set the bit in the reset register
	sw 	t1, 0(t0)		# save it

	ALIGN3
					# delay to allow PIC to initialize
piccheck:				# try 2000 times to see if pic is ok
	li	t3, 2000		# t3 = limit

	ALIGN3
L13:	
	li	a0, 1000
	ALIGN3
	bal	prc_wait_n_usecs	# wait about 1 millisecond
	ALIGN3
	bal	PICReady		# see if he's awake
	bgtz	v0, L18			# true - exit loop
					# false - try again
	addiu	t3, t3, -1		# decrement loop counter
	bgtz	t3, L13			# as long as there's a loop count, continue

	li	v0, 1			# bail out, PIC must be dead
	j	a3

	/* pic loop number one */
	ALIGN3
L18:	

	la	a1, IOASIC_BASE + (3 << IOASIC_OFFSET_SHIFT)
	li	t3, 0		# t3 is index

	ALIGN3
L19:	
	addiu	v0, t3, 0	# copy index to v0
	addiu	t3, t3, 1	# increment index
	sll	v1, v0, 0x2	# multiply v0 by 4 (word addresses)
	lra	v0, PIC1
	addu	v1, v1, v0	# add in offset

	lw	a0, 0(v1)	# fetch the data
	li	v1, -1

	beq	a0, v1, L20	# is data minus one?
				# true	- go to next sequence
				# false - write the data to pic

	ALIGN3
L22:	
	bal	PICWrite	# write data to pic
	bgtz	v0, L19		# return == 1? 
				# true	- go on to next data item
				# false - bail out

	li	v0, 1		# exit with return code of 1
	b	LM69

	/* pic loop number two */
	ALIGN3
L20:	
	la	a1, IOASIC_BASE + (2 << IOASIC_OFFSET_SHIFT)
	lra	t4, PIC2
	/*  for(i = 0; i < 16384; i++) */
	li	t3, 0		# t3 is loop counter
	ALIGN3
L24:	
	move 	v0, t3
	slti	v1, v0, 16384
	beqz	v1, L25
	/* if(!(iValue = *iData++)) */
	ALIGN3
LM45:	
	move	v0, t4		# grab t4 data pointer into v0
	addiu	t4, v0, 4	# increment t4
	lw	a0, 0(v0)	# use old t4 value in v0 to grab data
	bnez	a0, L28		# if data != 0 write it

	lra	t4, PIC3	;# otherwise load new pointer
	move	v0, t4		# copy new pointer to v0
	addiu	t4, v0, 4	# increment t4
	lw 	a0, 0(v0)	# grab first data in new array

	ALIGN3
L28:	
	bal	PICWrite	# write to pic
	bnez	v0, L26		# check return value
				# pos. continue, if neg. bail
	li	v0, 2		# load up a failure return code
	b	LM69		# bail out
	ALIGN3
L26:	
	addiu	t3, t3, 1	# increment loop counter
	b	L24

	/* third ioasic loop */
	ALIGN3
L25:	
	la	a1, IOASIC_BASE + (0 << IOASIC_OFFSET_SHIFT)
	li	t3, 0		# t3 is index into PIC4 array

	ALIGN3
L30:	
	move	v0, t3		# grab t3
	addiu	t3, t3, 1	# increment and store back
	sll	v1, v0, 0x2	# v1 = old t3 times four
	lra	v0, PIC4	;# load v0 with base of array
	addu 	v1, v1, v0	# compute offset
	lw	a0, 0(v1)	# fetch it
	li	v1, -1		# load constant
	beq	a0, v1, L31	# is data -1 true: done with loop 3
				# false: keep going

	ALIGN3
L33:	
	bal	PICWrite	# write the data to the PIC
	bgtz	v0, L32		# check return 1: keep going
				# zero: error
	ALIGN3
LM58:	
	li	v0, 3		# load up error code
	b	LM69		# bail out

	ALIGN3
L32:	
	b	L30		# loop around the loop

	/* delay to wait for PIC ready */
	ALIGN3
L31:	
	li	t0, 0		# t0 is loop counter
	li	t1, 400000	# t1 is loop end value
	la	t2, IOASIC_BASE	# t2 is ioasic base address

	ALIGN3
L35:	
	beq	t1, t0, L36	# is t1 less than t0
				# true - timed out exit wait loop
				# false - try again

	ALIGN3
L38:	
	lw	v0, IO_MAIN_CTL-IOASIC_BASE(t2)	# read MAIN_CONTROL
	beqz	v0, L40		# is it zero true - exit wait loop

	ALIGN3
L39:	
	addiu	t0, t0, 1	# update loop counter
	b	L35		# keep going

	ALIGN3
L36:	
	li	v0, 1		# wait loop timed out
	b	LM69

	ALIGN3
L40:
	lui	v0, 0x0000
	ori	v0, 0x4000
	sh	v0, IO_MAIN_CTL-IOASIC_BASE(t2)	# write a zero to MAIN_CONTROL
				# this should turn off the LED
	move	v0, zero

	ALIGN3
LM69:				# exit this routine good or bad
	move	fp, t5		# restore fp
	j	a3		# return

ENDFRAME UnLock

.if defined, LED_OUT
/************************************************
 * prc_blink_led - blink the specified LED's once
 * At entry:
 *	a0 = bitmap of LED's to blink
 *	a1 = blink time (0=default)
 * At exit:
 *	returns nothing
 *	a0, a1, a2, a3, v0, v1, hi and lo trashed
 */
	ALIGN3
FRAME prc_blink_led
	bne	a1, r0, 10f
	li	a1, 100000		;# default to 0.1 seconds
	ALIGN3
10:	move	a3, ra			;# save return address
	move	a2, a0			;# remember input bits
	lw	v0, LED_OUT		;# get current LED bits
	xor	v0, a2			;# turn on LED
	sw	v0, LED_OUT
	move	a0, a1			;# set wait time
	ALIGN3
	bal	prc_wait_n_usecs
	lw	v0, LED_OUT		;# turn off the specified LED's
	xor	v0, a2			;# get inverse of input
	sw	v0, LED_OUT
	move	a0, a1			;# set wait time
	ALIGN3
	bal	prc_wait_n_usecs
	j	a3
ENDFRAME prc_blink_led
.endc

/********************************************************************
 * prc_wait_n_usecs - wait at least specified number of microseconds
 * At entry:
 *	a0 = minimum number of microseconds to wait
 * At exit:
 *	nothing.
 *	a0, v0, v1, hi and lo trashed
 */
	ALIGN3
FRAME prc_wait_n_usecs
	mfc0	v0, C0_COUNT		;# starting count
.if true, CPU_SPEED_VARIABLE
 .if true, HOST_BOARD == FLAGSTAFF
	li	v1, 100			;# always assume 200MHZ on Flagstaff
 .iff
  .if true, HOST_BOARD == SEATTLE
	li	v1, 75			;# always assume 150MHZ on Seattle
  .iff
	li	v1, 50			;# else assume a 100MHZ
  .endc
 .endc
.iff
	li	v1, CPU_SPEED/2000000	;# get multiplier
.endc
5:	multu	v1, a0			;# convert microseconds to CPU ticks
	mflo	a0			;# get ticks
	ALIGN3
10:	mfc0	v1, C0_COUNT
	subu	v1, v0			;# get difference between old and new
	bltu	v1, a0, 10b		;# if haven't timed out yet, keep looking
	j	ra
ENDFRAME prc_wait_n_usecs

.if true, BOOT_ROM_CODE == 0 && (BOOT_COMPRESSED == 0)
/************************************************
 * prc_enable_cp1 - enable co-processor 1
 * At entry:
 *	no requirements
 * At exit:
 *	v0 = contents of current SR
 */
FRAME prc_enable_cp1
	.set reorder
	.set at
	mfc0	v0, C0_SR
	li	v1, SR_CU1
	or	v1, v0
	mtc0	v1, C0_SR
	j	ra
ENDFRAME prc_enable_cp1

/************************************************
 * prc_set_fpcsr - set the FPU's CSR
 * At entry:
 *	a0 = value to insert in the CSR
 * At exit:
 *	v0 = old contents of CSR
 */
FRAME prc_set_fpcsr
	.set reorder
	.set at
	cfc1	v0, $31
	ctc1	a0, $31
	j	ra
ENDFRAME prc_set_fpcsr

/************************************************
 * prc_get_fpcsr - get the FPU's csr
 * At entry:
 *	no requirements
 * At exit:
 *	v0 = current contents of CSR
 */
FRAME prc_get_fpcsr
	.set reorder
	.set at
	cfc1	v0, $31
	j	ra
ENDFRAME prc_get_fpcsr

/************************************************
 * prc_get_cause - get the current processor CAUSE
 * At entry:
 *	no requirements
 * At exit:
 *	v0 = contents of current CAUSE
 */
FRAME prc_get_cause
	.set reorder
	.set at
	mfc0	v0, C0_CAUSE
	j	ra
ENDFRAME prc_get_cause

/************************************************
 * prc_set_cause - set the current processor CAUSE
 * At entry:
 *	a0 new value 
 * At exit:
 *	v0 = old contents of CAUSE
 */
FRAME prc_set_cause
	.set reorder
	.set at
	mfc0	v0, C0_CAUSE
	mtc0	a0, C0_CAUSE
	j	ra
ENDFRAME prc_set_cause

/************************************************
 * prc_get_ipl - get the current processor IPL
 * At entry:
 *	no requirements
 * At exit:
 *	v0 = contents of current SR
 */
FRAME prc_get_ipl
	.set reorder
	.set at
	mfc0	v0, C0_SR
	j	ra
ENDFRAME prc_get_ipl

/************************************************
 * prc_isie - IS Interrupt Enabled?
 * At entry:
 *	no requirements
 * At exit:
 *	v0 = 1 if interrupts enabled, else 0
 *	v1, t0 and t1 trashed.
 */
FRAME prc_isie
	mfc0	v1, C0_SR	;# get the SR register
	move	v0, r0		;# Assume no interrupts
	and	t0, v1, 7	;# isolate lower three bits
	li	t1, SR_IE	;# get SR_IE pattern
	bne	t0, t1, 10f	;# interrupts are off
	and	t0, v1, 0xFF00	;# maybe they are on
	beq	t0, r0, 10f	;# interrupts are off
	addu	v0, 1		;# interrupts are on
10:	j	ra
ENDFRAME prc_isie

/************************************************
 * prc_set_sr - set the processor status register
 * At entry:
 *	a0 = new value
 * At exit:
 *	v0 = old contents of SR
 *	t0-t4 trashed
 * stores only the low order 16 SR bits 
 */
FRAME prc_set_sr
	mfc0	v0, C0_SR
	mtc0	a0, C0_SR
.if true, TEST_EXCEPTIONS
	la	t1, XBUSMON_BASE
	sw	a0, (t1)
.endc
	j	ra
ENDFRAME prc_set_sr

; prc_adj_msclock - get amount to adjust usclock
; At entry:
;	Interrupts must be disabled
; At exit:
;	v0 = number of increments to apply to millisecond clock
;
FRAME prc_adj_msclock
	.set noreorder
	li	v0, 1			;# assume to increment once
	mfc0	t0, C0_COMPARE		;# get current COMPARE value
5:	mfc0	v1, C0_COUNT		;# get current COUNT value
	mtc0	t0, C0_COMPARE		;# ack the timer interrupt
	addu	v1, 3			;# compensate for our loop
	subu	t1, v1, t0		;# subtract compare from count
	bltu	t1, t0, 10f		;# if (new)count < compare, we're done
	mtc0	t1, C0_COUNT		;# write a new value
	b	5b			;# count >= compare, do it again
	addu	v0, 1			;# but up the increment

10:	j	ra
	nop
	.set reorder
ENDFRAME prc_adj_msclock

.if true, 0
; prc_timer_rate - get/set timer interrupt interval
; At entry:
;	a0 = if not 0, 1/2 number of CPU ticks with which to interrupt
; At exit:
;	v0 = old rate
;
FRAME prc_timer_rate
	beq	a0, r0, 10f		;# just return old value
	mtc0	r0, C0_COUNT		;# restart the timer
	mfc0	v0, C0_COMPARE		;# get current COMPARE value
	mtc0	a0, C0_COMPARE		;# set an new COMPARE value (acks any interrupts too)
	j	ra

10:	mfc0	v0, C0_COMPARE
	j	ra
ENDFRAME prc_timer_rate
.endc

; prc_get_count - get CPU counter register
; At entry:
;	no requirements
; At exit:
;	v0 = CPU count register
;
FRAME prc_get_count
	mfc0	v0, C0_COUNT
	j	ra
ENDFRAME prc_get_count

; prc_get_compare - get CPU compare register
; At entry:
;	no requirements
; At exit:
;	v0 = CPU compare register
;
FRAME prc_get_compare
	mfc0	v0, C0_COMPARE
	j	ra
ENDFRAME prc_get_compare

; prc_set_count - set CPU counter register
; At entry:
;	a0 = value to install in count register
; At exit:
;	v0 = previous CPU count register
;
FRAME prc_set_count
	mfc0	v0, C0_COUNT
	mtc0	a0, C0_COUNT
	j	ra
ENDFRAME prc_set_count

; prc_set_compare - set CPU compare register
; At entry:
;	a0 = value to install into compare register
; At exit:
;	v0 = previous CPU compare register
;
FRAME prc_set_compare
	mfc0	v0, C0_COMPARE
	mtc0	a0, C0_COMPARE
	j	ra
ENDFRAME prc_set_compare
.endc					; BOOT_ROM_CODE == 0 && (BOOT_COMPRESSED == 0)

.if true, BOOT_ROM_CODE == 0
/************************************************
 * prc_set_ipl - set the processor IPL
 * At entry:
 *	a0 = new ipl
 *	(only low order 16 bits are significant)
 * At exit:
 *	v0 = old contents of SR
 *	t0-t4 trashed
 * stores only the low order 16 SR bits 
 */
FRAME prc_set_ipl
	.set noreorder

	la	v0, set_ipl_vec		;# Address of bendable vector...
	lw	v0, (v0)		;# ... for upper layers (Nucleus)
	beq	v0, r0, 10f		;# Branch if not loaded
	nop
	jr	v0			;# Jump to upper layer routine
	nop
10:

	mfc0	v0, C0_SR		;# get current SR
	li	t0, 0xFFFF&~(SR_KX|SR_SX|SR_UX|SR_KSMASK) ;# get a mask of allowable bits to change
	nor	t1, r0, t0		;# get the 1's compliment of the mask
	and	t2, a0, t0		;# the user can only change these bits
	and	t1, v0			;# clear out the old bits
	or	t2, t1			;# drop in the new bits
.if true, TEST_EXCEPTIONS
	la	t1, XBUSMON_BASE
	sw	t2, (t1)
.endc
	j	ra			;# return with old im in v0
	mtc0	t2, C0_SR		;# set the new mask
	.set reorder
ENDFRAME prc_set_ipl
.endc

;# Eexcept - all exceptions while excecuting from EPROM enter at this point
;# At entry:
;#	an exception has occured. No state has been saved
;# At exit:
;#	does not exit. Any exception while executing in EPROM is fatal.
;#
FRAME Eexcept, global=0
	.set	noreorder
	move	s0, ra			;# save return address
	move	s1, r0			;# start with a known LED value
	ALIGN3
10:	mfc0	k1, C0_CAUSE
	la	v0, GALILEO_CS0
	sw	k0, (v0)		;# write which exception vector
	mfc0	k0, C0_SR
	sw	k1, 4(v0)		;# write Cause
	mfc0	k1, C0_EPC
	sw	k0, 8(v0)		;# write SR
	mfc0	k0, C0_ERRPC
	sw	k1, 12(v0)		;# write EPC
	mfc0	k1, C0_BADVADDR
	sw	k0, 16(v0)		;# write ERRPC
	sw	k1, 20(v0)		;# write BADVADDR
	sw	ra, 24(v0)		;# write return address
.if defined, LED_OUT
	xor	s1, (1<<B_LED_RED)|(1<<B_LED_YEL)|(1<<B_LED_GRN)
	li	a1, 75000		;# blink them very fast
	ALIGN3
	bal	prc_blink_led
	move	a0, s1
.endc
	b	10b
	nop	
	.set reorder
ENDFRAME Eexcept

;# except - all exceptions enter at this point
;# At entry:
;#	an exception has occured. No state has been saved
;# At exit:
;#	exception is dispatched and handled (or not)
;#
FRAME except, global=1
	.set	noreorder

.if true, STOP_ON_EXCEPTION
	b	Eexcept			;# all exceptions die
	nop
.iff
 .if true, 0 && ( (HOST_BOARD == PHOENIX_AD) || (HOST_BOARD == FLAGSTAFF) || (HOST_BOARD == SEATTLE) )
	mfc0	k0, C0_CAUSE
	nop
	and	k0, 0x7F
	beq	k0, r0, 20f
	nop

	li	s0, ~(1<<B_LED_RED)
	move	t4, ra
10:	mfc0	t0, C0_SR
	mfc0	t1, C0_CAUSE
	mfc0	t2, C0_EPC
	mfc0	t3, C0_BADVADDR
	la	k0, LED_OUT+0x400
	sw	t0, (k0)
	sw	t1, 0x8(k0)
	sw	t2, 0x10(k0)
	sw	t3, 0x18(k0)
	sw	t4, 0x20(k0)
	sw	s0, LED_OUT

	la	a0, 11f
	and	a0, 0x000FFFFF
	or	a0, RAMROM_BASE
	jr	a0
	nop
	
11:	la	a0, RAMROM_BASE+8
	la	a1, text_end
	la	a2, text_start
	subu	a1, a2
	addu	a1, -8
	la	a2, DRAM_BASEnc+8

12:	lw	t5, (a0)
	lw	t6, (a2)
	xor	t7, t5, t6
	bne	t7, r0, 15f
	nop
	addu	a0, 4
	addu	a2, 4
	addu	a1, -4
	bgt	a1, r0, 12b
	nop
	
	bal	prc_wait_n_usecs
	li	a0, 50000
	b	10b
	xor	s0, 1<<B_LED_RED

15:	sw	a0, 0x100(k0)
	sw	t5, 0x108(k0)
	sw	a2, 0x110(k0)
	sw	t6, 0x118(k0)
	sw	t7, 0x120(k0)
	xor	s0, 1<<B_LED_YEL
	sw	s0, LED_OUT
	bal	prc_wait_n_usecs
	li	a0, 50000
	b	15b
	nop	
20:
 .endc
	
	.set 	noat
 .if true, BOOT_ROM_CODE == 0

	la	k0, 10f
	j	k0
	nop
10:
  .if true, TEST_EXCEPTIONS
	mfc0	k0, C0_SR
	la	k1, XBUSMON_BASE
	sw	k0, (k1)
  .endc
  .if true, TIME_EXCEPTIONS
	la	k1, _guts_astlvl
	la	k0, _guts_inest
	lw	k0, (k0)
	lw	k1, (k1)
	bne	k0, r0, 1f
	addu	k1, 1
	bne	k1, r0, 1f
	mfc0	k1, C0_COUNT
	la	k0, exception_time
	sw	k1, 4(k0)
1:
  .endc
  .if true, (ICELESS_LVL || ICELESS_MANY)
	la	k0, DRAM_BASEnc
	lw	k1, ROMV_STUB_EH(k0)	;# is there a stub loaded?
	mfc0	k0, C0_CAUSE
	beq	k1, r0, normal_exception	;# no, we do all exception processing
	and	k0, 0x7C		;# mask off cause

   .if true, INCLUDE_FEXCP
	xor	k0, 0x3C		;# check for FPE
	beq	k0, r0, normal_exception ;# we do our own FPE exception processing
	xor	k0, 0x3C
   .endc

   .if true, INCLUDE_SYSCALL
	xor	k0, 0x20		;# check for SYSCALL
	beq	k0, r0, normal_exception
	xor	k0, 0x20
   .endc

	beq	k0, r0, 10f		;# it's an IRQ
	mfc0	k0, C0_CAUSE		;# get the cause again

	j	k1			;# goto stub's exception handler
	nop

10:
   .if true, 0 || (!ICELESS_AST)		; moved ICELESS interrupt detection to phx_shims.c
	mfc0	k1, C0_SR
	and	k0, 0x8000		;# ICELESS always comes in on interrupt 7
	and	k0, k1			;# ICELESS interrupt enabled?
	beq	k0, r0, normal_exception ;# not iceless, we do the processing
	nop
	la	k0, INTCTL_IE		;# maybe iceless, check the interrupt control PLD
	lw	k0, (k0)		;# get interrupt enable bits
	la	k1, INTCTL_CAUSE
	lw	k1, (k1)		;# get interrupt cause bits
	and	k0, k1
    .if true, ICELESS_MANY
 	and	k0, ICELESS_MANY	;# for now, _any_ expansion slot give ICELESS interrupt
    .iff
 	and	k0, 1<<(ICELESS_LVL-1)	;# check for iceless interrupt among them
    .endc
	beq	k0, r0, normal_exception ;# not ICELESS
	lui	k0, (DRAM_BASEnc>>16)&0xFFFF
	lw	k1, ROMV_STUB_EH(k0)
	j	k1			;# let the stub deal with it
	nop

   .iff
	b	normal_exception
	nop
   .endc
  .iff
	b	normal_exception
	nop
  .endc
 .iff
	mfc0	t0, C0_SR
	mfc0	t1, C0_CAUSE
	mfc0	t2, C0_EPC
	mfc0	t3, C0_BADVADDR
	la	k0, BRAM_UNLK
	sw	t0, (k0)
	sw	t1, 8(k0)
	sw	t2, 16(k0)
	sw	t3, 24(k0)

	ALIGN3
10:	b	10b
	nop
 .endc
.endc				; STOP_ON_EXCEPTION
	.set at
	.set reorder
ENDFRAME except

.if true, (BOOT_ROM_CODE == 0) && (STOP_ON_EXCEPTION == 0) 
erl_msg:
	.asciz "Exception with ERL bit set"
stack_underflow_msg:
	.asciz	"Stack Underflow"
	.align 2

.macro .lreg op, prefix, reg, base, offset, index
	op 	$'prefix''reg', (base+'offset')*REG_SIZE(index)
.endm .lreg

;# normal_exception - used for all exceptions other than some IRQ's
;#
;# At entry:
;#	no state has been saved.
;# At exit:
;#	depends on what the exception_handler does, but normally an exception
;#	is fatal and results in a 'software reset'. All state is preserved
;#	and control is passed to the C function exception_handler with the
;#	pointer to the saved state in a0. The function exception_handler
;#	can either return with a pointer to the saved state in v0 or call or
;#	jmp to return_to_user which will restore the state and return to
;# 	the exception instruction.
;#
FRAME normal_exception
	.set 	noat
	.set	noreorder

 .if true, STOP_ON_NONINTR || SQUAWK_ON_EXCEPT > 0
	mfc0	k1, C0_CAUSE
	nop
	and	k1, 0x00FF
	beq	k1, r0, 2f
	mfc0	k1, C0_CAUSE

	la	k0, SCRATCH_RAM
	sw	k1, 0x100(k0)
	mfc0	k1, C0_EPC
	sw	k1, 0x108(k0)
	mfc0	k1, C0_ERRPC
	sw	k1, 0x110(k0)
	mfc0	k1, C0_BADVADDR
	sw	k1, 0x118(k0)
	mfc0	k1, C0_SR
	sw	k1, 0x120(k0)
	la	k0, GALILEO_PCI_CFG
	lw	r0, (k0)
2:
 .endc
 .if true, FLUSH_CACHE_EXCEPT
	addiu	k0, sp, -1*NUM_REGS*REG_SIZE	;# make room for all possible registers
	li	k1, NUM_REGS*REG_SIZE/32
	cache	Create_Dirty_Exc_D, (k0)	;# mark cache line dirty
3:	addu	k0, 32				;# up to next cache line
	addu	k1, -1				;# count it
	bgtz	k1, 3b				;# do all cache lines
	cache	Create_Dirty_Exc_D, (k0)
 .endc

	addiu	k0, sp, -1*NUM_REGS*REG_SIZE	;# get new sp again
	mfc0	k1, C0_CAUSE
	sd	sp, SP_REGNUM*REG_SIZE(k0)	;# save unmodified sp
	move	sp, k0				;# move stack
	sd	k1, CAUSE_REGNUM*REG_SIZE(sp)
	mfc0	k0, C0_SR
	dmfc0	k1, C0_EPC
	sd	k0, PS_REGNUM*REG_SIZE(sp)
	sd	k1, EPC_REGNUM*REG_SIZE(sp)
	sd	k1, PC_REGNUM*REG_SIZE(sp)
	sd	r0, (ZERO_REGNUM+0)*REG_SIZE(sp)
	sd	r1, (ZERO_REGNUM+1)*REG_SIZE(sp)
	.set at
	nor	k1, r0, 0x07
	and	k1, k0			;# clear the lower 3 bits in the SR
	and	k0, SR_ERL		;# did we get an ERL?
	beq	k0, r0, 10f		;# nope, all is well in the world
	mtc0	k1, C0_SR		;# allow nested exceptions but not interrupts

	la	a0, erl_msg
	b	prc_panic		;# An error exception is sudden death
	nop

10:
;;; NOTE: the save of gp _has_ to happen. It appears here in the branch delay slot
;;; You can remove the one below once this code is turned back on.
;	la	k1, bss_end			;# point to end of our ram
;	addu	k1, 2048			;# plus some cushion
;	bgtu	sp, k1, 12f			;# room on the stack
;	sd	gp, (ZERO_REGNUM+28)*REG_SIZE(sp)

;	la	a0, stack_underflow_msg
;	b	prc_panic			;# signal death
;	nop

12:	sd	gp, (ZERO_REGNUM+28)*REG_SIZE(sp)	;# Comment this out later
	sd	s8, (ZERO_REGNUM+30)*REG_SIZE(sp)
	sd	ra, (ZERO_REGNUM+31)*REG_SIZE(sp)

	mfhi	k0
	mflo	k1
	sd	k0, HI_REGNUM*REG_SIZE(sp)
	sd	k1, LO_REGNUM*REG_SIZE(sp)

 .if true, IRQ_CHEAP_EXCEPTION
	mfc0	k0, C0_CAUSE
	nop
	and	k0, 0x7C
	beq	k0, r0, cheap_exception
.endc
	dmfc0	k0, C0_BADVADDR		;# get the error address
	dmfc0	k1, C0_ERRPC
	sd	k0, BADVADDR_REGNUM*REG_SIZE(sp)
	sd	k1, ERRPC_REGNUM*REG_SIZE(sp)
...1 == 2
.rept	26-2				;# 2 through 25
.lreg	sd, <>, \...1, ZERO_REGNUM, \...1, sp
...1 == ...1 + 1
.endr
 .if true, ...1 != 26
  .error ;Not enough registers saved
 .endc

 .if true, ICELESS_STUB > 0
        cfc1	t0, C1_FIR		;# get the FIR
 .endc
	mfc0	k0, C0_SR	
	cfc1	t1, C1_FCSR
	and	k0, SR_FR
	beq	k0, r0, 12f		;# save only 16 regs
...1 == 0
	.lreg	sdc1, f, \...1, FP0_REGNUM, \...1, sp

...1 == 1
.rept	30
.lreg	sdc1, f, \...1, FP0_REGNUM, \...1, sp
...1 == ...1 + 1
.endr
	b	13f			;# next
	.lreg	sdc1, f, \...1, FP0_REGNUM, \...1, sp

12:
...1 == 2
	.lreg	sdc1, f, \...1, FP0_REGNUM, \...1, sp
.rept	14
	...1 == ...1 + 2
	.lreg	sdc1, f, \...1, FP0_REGNUM, \...1, sp
.endr

13:
 .if true, ICELESS_STUB > 0
	sd	t0, FCRIR_REGNUM*REG_SIZE(sp)
 .endc
	sd	t1, FCRCS_REGNUM*REG_SIZE(sp)

15:
 .if true, INCLUDE_XINU
	move	a0, sp			;# point to register frame
	li	t0, -4*REG_SIZE
	addu	sp, t0			;# leave 4 empty slots on the stack
	and	sp, t0
	la	k0, savintp		;# Xinu support 4/5/97 -- dms
	lw	k0, (k0)		;# bendable vector for Xinu
	beq	k0, r0, 20f		;# branch if no Xinu
	nop
	jalr	k0
	nop
20:
 .iff
	la	k0, savintp		;# Nucleus support 11/27/95 -- fom
	lw	k0, (k0)		;# bendable vector for Nucleus
	beq	k0, r0, 20f		;# branch if no Nucleus
	nop
	jalr	k0			;# this better be TCT_Interrupt_Context_Save
20:
	move	a0, sp			;# point to register frame
	li	t0, -4*REG_SIZE
	addu	sp, t0			;# leave 4 empty slots on the stack
	and	sp, t0
 .endc
	la	v0, exception_handler	;# point to exception handler in (perhaps) cache memory
	jal	v0			;# goto C exception handler
	nop

	la	v1, restintp		;# Nucleus support 11/27/95 -- fom
	lw	v1, (v1)		;# bendable vector for Nucleus
	beq	v1, r0, 30f		;# branch if no Nucleus
	nop
	jalr	v1			;# this better be TCT_Interrupt_Context_Restore
	nop
30:

	b	returnToUser
	move	a0, v0			;# returns with pointer to register frame
	
	.set	reorder
ENDFRAME normal_exception

 .if true, IRQ_CHEAP_EXCEPTION
FRAME cheap_exception, global=0
	.set noat
	.set noreorder
	li	k0, 1
	sd	k0, ZERO_REGNUM*REG_SIZE(sp)	;# cheap frame
...1 == 1
.rept	15				;# 1 through 15
.lreg	sd, <>, \...1, ZERO_REGNUM, \...1, sp
...1 == ...1 + 1
.endr
	.set	at
  .if true, ...1 != 16
   .error ;Not enough registers saved
  .endc
...1 == 24
.rept	2				;# 24 and 25 (t8, t9)
.lreg	sd, <>, \...1, ZERO_REGNUM, \...1, sp
...1 == ...1 + 1
.endr
	mfc0	k0, C0_SR
	lui	k1, 0xF000
	nor	k1, r0, k1
	and	k0, k1
	mtc0	k0, C0_SR

	la	k0, savintp		;# Nucleus support 11/27/95 -- fom
	lw	k0, (k0)		;# bendable vector for Nucleus
	beq	k0, r0, 20f		;# branch if no Nucleus
	nop
	jalr	k0			;# this better be TCT_Interrupt_Context_Save
20:
	move	a0, sp			;# point to register frame
	li	t0, -4*REG_SIZE
	addu	sp, t0			;# leave 4 empty slots on the stack
	and	sp, t0

	la	v0, exception_handler	;# point to exception handler in (perhaps) cache memory
	jal	v0			;# goto C exception handler
	nop

	la	v1, restintp		;# Nucleus support 11/27/95 -- fom
	lw	v1, (v1)		;# bendable vector for Nucleus
	beq	v1, r0, 30f		;# branch if no Nucleus
	nop
	jalr	v1			;# this better be TCT_Interrupt_Context_Restore
	nop
30:
	b	return_cheap
	move	a0, v0			;# returns with pointer to register frame
	.set at
	.set reorder
ENDFRAME cheap_exception

FRAME return_cheap, global=0
	.set noreorder
	.set noat
	ld	v0, HI_REGNUM*REG_SIZE(a0)
	ld	v1, LO_REGNUM*REG_SIZE(a0)
	mthi	v0
	ld	v0, CAUSE_REGNUM*REG_SIZE(a0)
	mtlo	v1
	ld	v1, EPC_REGNUM*REG_SIZE(a0)
	mtc0	v0, C0_CAUSE
	dmtc0 	v1, C0_EPC
	move	k0, a0
...1 == 1
.rept 15		;registers 1-15
.lreg	ld, <>, \...1, ZERO_REGNUM, \...1, k0
...1 == ...1 + 1
.endr
...1 == 24
.rept 2			;registers 24-25
.lreg	ld, <>, \...1, ZERO_REGNUM, \...1, k0
...1 == ...1 + 1
.endr
  .if true, TIME_EXCEPTIONS
;;;	la	ra, _guts_inest
;;;	lw	ra, (ra)
;;;	bne	ra, r0, 1f
;;;	la	ra, exception_time
;;;	mfc0	sp, C0_COUNT
;;;	lw	s8, (ra)
;;;	addu	sp, s8
;;;	lw	s8, 4(ra)
;;;	subu	sp, s8
;;;	sw	sp, (ra)
;;;1:
  .endc
...1 == 29
.rept 3			;registers 29-31
.lreg	ld, <>, \...1, ZERO_REGNUM, \...1, k0
...1 == ...1 + 1
.endr
  .if true, FLUSH_CACHE_EXCEPT
	addiu	k0, sp, -1*NUM_REGS*REG_SIZE	;# point back to top of old stack
	li	k1, NUM_REGS*REG_SIZE/32-1	;# clear out n-1 cache lines
	cache	Hit_Invalidate_D, (k0)		;# mark cache line invalid w/o writing it
3:	addu	k0, 32				;# up to next cache line
	addu	k1, -1
	bgtz	k1, 3b				;# do all cache lines
	cache	Hit_Invalidate_D, (k0)		;# mark cache line invalid w/o writing it
  .endc
	eret
	nop
.set reorder
.set at
ENDFRAME return_cheap

FRAME save_fp_regs
.set noreorder
	mfc0	v0, C0_SR
	or 	v1, v0, 0xF0000000 		;# enable the FPU
	mtc0	v1, C0_SR
	and	v1, SR_FR
	beq	v1, r0, 10f
...1 == 0
.lreg	sdc1, f, \...1, FP0_REGNUM, \...1, a0

.rept	30
.lreg	sdc1, f, \...1, FP0_REGNUM, \...1, a0
...1 == ...1 + 1
.endr
	b	20f
.lreg	sdc1, f, \...1, FP0_REGNUM, \...1, a0

10:
...1 == 2
.rept	15
.lreg	sdc1, f, \...1, FP0_REGNUM, \...1, a0
...1 == ...1 + 2
.endr
20:
	cfc1	v0, C1_FCSR
	j	ra
	sd	v0, FCRCS_REGNUM*REG_SIZE(a0)
.set reorder
ENDFRAME save_fp_regs
 .endc			; CHEAP_EXCEPTION

;# Return to user:
;# At entry:
;#	a0 = pointer to register frame to restore
;#
FRAME returnToUser
.if true, IRQ_CHEAP_EXCEPTION
	ld	v0, ZERO_REGNUM*REG_SIZE(a0)
	bne	v0, r0, return_cheap
.endc
.set noreorder
.set at
	ld	t0, PS_REGNUM*REG_SIZE(a0)	;# get the saved SR 
        ld	t1, FCRCS_REGNUM*REG_SIZE(a0)
	or	t0, SR_EXL			;# make sure there's an EXL bit set
        mtc0	t0, C0_SR			;# SR = t1 
	ctc1	t1, C1_FCSR			;# set the FCSR
	and	t0, SR_FR
	beq	t0, r0, 5f

...1 == 0
.lreg	ldc1, f, \...1, FP0_REGNUM, \...1, a0

.rept	30
...1 == ...1 + 1
.lreg	ldc1, f, \...1, FP0_REGNUM, \...1, a0
.endr
	b	10f
...1 == ...1 + 1
.lreg	ldc1, f, \...1, FP0_REGNUM, \...1, a0

...1 == 2
5:
.rept	15
.lreg	ldc1, f, \...1, FP0_REGNUM, \...1, a0
...1 == ...1 + 2
.endr

10:
	ld	v0, HI_REGNUM*REG_SIZE(a0)
	ld	v1, LO_REGNUM*REG_SIZE(a0)
	mthi	v0
	ld	v0, CAUSE_REGNUM*REG_SIZE(a0)
	mtlo	v1
	ld	v1, EPC_REGNUM*REG_SIZE(a0)
	mtc0	v0, C0_CAUSE
;	ld	v0, ERRPC_REGNUM*REG_SIZE(a0)
	dmtc0 	v1, C0_EPC
;	dmtc0 	v0, C0_ERRPC

.set	noat

	move	k0, a0
...1 == 1
.rept 25		;registers 1-25
.lreg	ld, <>, \...1, ZERO_REGNUM, \...1, k0
...1 == ...1 + 1
.endr
 .if true, TIME_EXCEPTIONS
	la	sp, _guts_astlvl
	la	ra, _guts_inest
	lw	ra, (ra)
	lw	sp, (sp)
	bne	ra, r0, 1f
	addu	sp, 1
	bne	sp, r0, 1f
	mfc0	sp, C0_COUNT
	la	ra, exception_time
	lw	s8, (ra)
	addu	sp, s8
	lw	s8, 4(ra)
	subu	sp, s8
	sw	sp, (ra)
1:
 .endc
...1 == 28
.rept 4			;registers 28-31
.lreg	ld, <>, \...1, ZERO_REGNUM, \...1, k0
...1 == ...1 + 1
.endr
 .if true, FLUSH_CACHE_EXCEPT
	addiu	k0, sp, -1*NUM_REGS*REG_SIZE	;# point back to top of old stack
	li	k1, NUM_REGS*REG_SIZE/32-1	;# clear out n-1 cache lines
	cache	Hit_Invalidate_D, (k0)		;# mark cache line invalid w/o writing it
3:	addu	k0, 32				;# up to next cache line
	addu	k1, -1
	bgtz	k1, 3b				;# do all cache lines
	cache	Hit_Invalidate_D, (k0)		;# mark cache line invalid w/o writing it
 .endc
 .if true, TEST_EXCEPTIONS
	mfc0	k0, C0_SR
	la	k1, XBUSMON_BASE
	and	k0, 0xFFFD
	sw	k0, (k1)
.endc
	eret
	nop
.set reorder
.set at
ENDFRAME returnToUser

.if true, INCLUDE_SYSCALL
FRAME prc_syscall
	syscall
	nop
	j	ra
ENDFRAME prc_syscall
.endc

FRAME wait_forever
	jal	flush_cache		;# make sure all data is written
	lw	v0, stub_setup		;# is the stub loaded?
	bne	v0, r0, 20f		;# stub is loaded, so simply pretend to reset
.if defined, LED_OUT
	li	s0, (1<<B_LED_RED)|(1<<B_LED_GRN)|(1<<B_LED_YEL)
10:	sw	s0, LED_OUT
	li	a0, 50000
	bal	prc_wait_n_usecs
	sw	r0, LED_OUT
	li	a0, 50000
	bal	prc_wait_n_usecs
	b	10b
.iff
10:	b	10b
.endc

20:	bal	prc_reset_hardware
	b	begin
ENDFRAME wait_forever

FRAME prc_panic
	mfc0	a3, C0_SR
	nor	a2, r0, SR_IE		;# get an interrupt disable mask 
	and	a2, a3			;# disable interrupts
	mtc0	a2, C0_SR
.if true, (BOOT_FROM_DISK == 0) && (EPROM_ST == 0)
	.set noat
	la	k1, pm_data
	sw	a3, pm_sr(k1)		;# failing SR
	sw	ra, pm_pc(k1)		;# failing address
	mfc0	k0, C0_CAUSE
	sw	k0, pm_cause(k1)	;# cause reg
	sw	sp, pm_stack(k1)	;# failing stack pointer
        sw      sp, pm_stkrelative(k1)  ;# relative sp is the same
        la      k0, INIT_SP             ;# stack limits
        sw      k0, pm_stkupper(k1)
        la      k0, bss_end
        sw      k0, pm_stklower(k1)
	sw	a0, pm_msg(k1)		;# user's message
	lw	k0, pm_cntr(k1)
	addu	k0, 1
	sw	k0, pm_cntr(k1)
	addu	k0, k1, pm_regs

...1 == 0				;# Save all the registers
.rept	32
.lreg	sw, <>, \...1, ZERO_REGNUM, \...1, k0
...1 == ...1 + 1
.endr
	.set at
lcl_pm_tsiz = PM_TEXT_SIZE-1
 .if defined,AN_VIS_COL
  .if true, AN_VIS_COL < PM_TEXT_SIZE
lcl_pm_tsiz = AN_VIS_COL-1
  .endc
 .endc
	addu	a2, k1, pm_text
	sw	a2, pm_msg(k1)
	move	a3, a0			;# save address
	srl	v1, a0, 28		;# get upper nibble of address
	and	v1, 0xF
	li	v0, 8
	beq	v0, v1, 5f		;# anywhere in region 8 is ok
	jal	tlbprobe		;# check user's address (blows a0, a1, t0, t1, v0, v1)
	bltz	v0, 15f			;# address nfg	
5:	li	a1, lcl_pm_tsiz-1	;# copy up to n bytes to test area

10:	lbu	k0, (a3)
	sb	k0, (a2)
	addu	a1, -1
	addu	a3, 1
	addu	a2, 1
	beq	k0, r0, 20f		;# found end of message
	bgt	a1, r0, 10b		;# room for more

15:	sb	r0, (a2)		;# terminate message with a null
.endc	
20:	b	wait_forever
ENDFRAME  prc_panic
.endc					;# BOOT_ROM_CODE == 0 || STOP_ON_EXCEPTION == 0

.if true, (BOOT_ROM_CODE == 0)
	.text

	HEX_CONST TLB_PG_4K	(0x0001000)	;/*   4k */
	HEX_CONST TLB_PG_16K	(0x0004000)	;/*  16K */
	HEX_CONST TLB_PG_64K	(0x0010000)	;/*  64k */
	HEX_CONST TLB_PG_256K	(0x0040000)	;/* 256k */
	HEX_CONST TLB_PG_1M	(0x0100000)	;/*  1MB */
	HEX_CONST TLB_PG_4M	(0x0400000)	;/*  4MB */
	HEX_CONST TLB_PG_16M	(0x1000000)	;/* 16MB */

TLB_COUNT == 0
;
; TLB initializer table macro. It has 10 arguments which are described as:
;	pagesize	one of the TLB_PG_xx values listed above
;	virtual_addr	starting virtual address to assign to region pair
;	even_phys_addr	starting physical address for even TLB entry
;	even_cache_alg	even TLB entry cache algorithm (only a 0-3 on 4600)
;	even_dirty	even TLB entry dirty bit (1=region writeable)
;	even_valid	even TLB entry valid bit
;	odd_phys_addr	starting physical address for odd TLB entry
;			   (if this field is left blank, it will be automatically computed
;			    by adding the pagesize to the even_phys_addr
;			    parameter)
;	odd_cache_alg	odd TLB entry cache algorithm
;	odd_dirty	odd TLB dirty bit
;	odd_valid	odd TLB valid bit
;
.macro I_TLB pagesize, vaddr, paddr_0, c_0, d_0, v_0, paddr_1, c_1, d_1, v_1
   .word ((pagesize-1)<<1)&TLBPGMASK_MASK
.if true, ((vaddr) & (((pagesize<<1)-1)) & -8192) != 0
   .error ;virtual addr vaddr not a multiple of 2*'pagesize'
.endc
   .word (vaddr)&TLBHI_VPN2MASK
   .word ((paddr_0 >> (12-TLBLO_PFNSHIFT)) & TLBLO_PFNMASK) | (c_0<<3) | (d_0<<2) | (v_0<<1) | 1
.if blank,paddr_1
tmp = (paddr_0)+(pagesize)
.iff
tmp = paddr_1
.endc
   .word ((tmp >> (12-TLBLO_PFNSHIFT)) & TLBLO_PFNMASK) | (c_1<<3) | (d_1<<2) | (v_1<<1) | 1
   TLB_COUNT == TLB_COUNT + 1
.endm

  .align 2

tlb_table:
; Cache algorithm's on the 4600 can be one of:
;	0 (cached, noncoherent, write through, no write allocate (store miss skips cache))
;	1 (cached, noncoherent, write through, write allocate (store miss loads cache))
;	2 (uncached)
;	3 (cached, noncoherent, write back)
;DCALG = 2		;# for now, make DRAM (main memory) Uncached
DCALG = 3		;# for now, make DRAM (main memory) cached
;CALG = 2		;# for now, make everything else Uncached too
CALG = 0		;# for now, make everything else cached too
; Note that the virtual address must be an even multiple of pagesize*2
   HEX_CONST I_TLB_COUNT TLB_COUNT

.if true, TLB_COUNT >= 48
      .error ;pppphhhhhhppppt: TLB table too big
.endc

FRAME init_tlb global=0
	move	s0, ra			;# save return address

	li	v0, 0x20000000
	la	s1, map_tlb4000
	or	s1, v0			;# make address non-cached
	li	s2, I_TLB_COUNT
	la	s3, tlb_table
	or	s3, v0			;# make address non-cached
	move	s4, zero
	la	s5, resettlb
	or	s5, v0			;# make address non-cached
	beq	s2, r0, 15f		;# if table empty, just clear all of it

	ALIGN3
10:	lw	a0,  0(s3)		;# get pagemask
	lw	a1,  4(s3)		;# get HI
	lw	a2,  8(s3)		;# get even pte
	lw	a3, 12(s3)		;# get odd pte
	or	a0, s4			;# or in the index
	ALIGN3
	jal	s1			;# set the tlb
	addiu	s3, 4*4			;# advance pointer
	addiu	s4, 1			;# bump index
	blt	s4, s2, 10b		;# continue until all entries loaded

	ALIGN3
15:	li	s6, N_TLB_ENTRIES
	ALIGN3
20:	move	a0, s4	
	ALIGN3
	jal	s5			;# reset the rest of the entries
	addiu	s4, 1		
	blt	s4, s6, 20b

	j	s0			;# return
ENDFRAME init_tlb

.endc					; BOOT_ROM_CODE == 0

	ALIGN3
FRAME init_dram, global=0
	.set noreorder
.if true, HOST_BOARD == PHOENIX
	move v0, r0
	li v1, (1<<GALILEO_DRAMBK_CFG_Refresh_b)|(1<<GALILEO_DRAMBK_CFG_BankWidth_b)
	sw v1, (t0)
	sync 
	li a1, 0x55555555
	sw a1, (a0)
	li a3, 0xAAAAAAAA
	sw a3, 4(a0)
	sw r0, 8(a0)
	sw r0, 12(a0)
	sync 
	lw a2, (a0)
	bne a1, a2, 10f
	nop 
	lw a2, 4(a0)
	beq a3,a2, 20f
	nop 
	ALIGN3
10:	li v0, 1
	li v1, (1<<GALILEO_DRAMBK_CFG_Refresh_b)
	sw v1, (t0)
	sync 
	sw a1, (a0)
	li v1, 0xC0EDBABE
	sw v1, 4(a0)
	lw a2, (a0)
	beq a1, a2, 20f
	nop 
	li v0, 2
	li v1, (1<<GALILEO_DRAMBK_CFG_Refresh_b)|(1<<GALILEO_DRAMBK_CFG_BankLoc_b)
	sw v1, (t0)
	sync
	sw a1, (a0)
	li v1, 0xC0EDBABE
	sw v1, (a0)
	lw a2, (a0)
	beq a1, a2, 20f
	nop 
	li v0, 3

.iff
 .if true, (HOST_BOARD == FLAGSTAFF) || (HOST_BOARD == SEATTLE)
	li v1, (1<<GALILEO_DRAMBK_CFG_Refresh_b)|(1<<GALILEO_DRAMBK_CFG_BankWidth_b)
 .iff
	li v1, (0<<GALILEO_DRAMBK_CFG_Refresh_b)|(1<<GALILEO_DRAMBK_CFG_BankWidth_b)
 .endc
	sw v1, (t0)
;	lw r0, (a0)
	li v0, 3
.endc
	ALIGN3
20:	jr ra
	nop 
	.set reorder
ENDFRAME init_dram

.if true, (TEST_MEM32 || TEST_MEM64 || TEST_BRAM)
.define TMP1		$8	;t0
.define TMP2		$9	;t1
.define TSTNUM		$10	;t2
.define RASAVE		$11	;t3

.define STARTA		$12	;t4
.define ENDA		$13	;t5

.define TBBASE		$12	;t4
.define TBSIZE		$13	;t5

;.define WDOG_REG	$14	;t6
.define TMP0		$15	;t7
.define EXPECTED	$16	;s0
.define ADDRESS		$17	;s1
.define	ACTUAL		$18	;s2
.define WALKBIT		$19	;s3
.define BUNLK		$20	;s4
.define TICKS_USEC	$21	;s5

.define TSTSEN_TMP3	$19	;s3
.define TSTSEN_CNT	$20	;s4
.macro KICK_WDOG 
;	sw	r0, (WDOG_REG)		;# writing this register kicks the dog
.endm
.endc

.if true, (TEST_MEM64 > 0)

.macro FLUSH_WB addr=(ADDRESS)
.endm

;# Quick and dirty RAM test.
;# At entry:
;#	a0 = starting address
;#	a1 = ending address
;#	a2 = .ne. if required to do read after write
;#	fp = 64 bit control register shadow
;# At exit:
;#	v0 = 0 if success
;#	v0 = 1 if failure and ...
;#	ACTUAL = "is" data
;#	EXPECTED = "s/b" data
;#	ADDRESS = failing address
;#	TSTNUM = subtest number
;#	trashes a0-a3, v0-v1, t0-t7, s0-s4

	ALIGN3
FRAME	test_mem64, global=0
	.set noreorder

	move	RASAVE, ra	;# remember where we came from
	move	STARTA, a0	;# save the starting address
	move	ENDA, a1	;# save the ending address
	nor	TMP0, r0, 7	;# get a -8
	and	STARTA, TMP0	;# make both addresses double aligned
	and	ENDA, TMP0
;	la	WDOG_REG, WATCHDOG
	KICK_WDOG

	li	TSTNUM, 0		;# TEST 0 - walk a single bit through location 0
	li	EXPECTED, 1		;# first walk a single bit
	move	ADDRESS, STARTA
	ALIGN3
10:	sd	EXPECTED, (ADDRESS)	;# write the long
	ld	ACTUAL, (ADDRESS)	;# read it back
	bne	ACTUAL, EXPECTED, 200f	;# branch if there's an error
	nop
	dsll	EXPECTED, 1		;# shift test bit
	bne	EXPECTED, r0, 10b	;# keep testing
	nop

	li	TSTNUM, 1		;# TEST 1 - fill memory with all one's
	nor	EXPECTED, r0, r0	;# get a -1
	move	ADDRESS, STARTA
	sd	EXPECTED, (ADDRESS)	;# fill all of RAM with 1's
	ALIGN3
20:
	FLUSH_WB 			;# this is required if writing to RamRom area
	add	ADDRESS, 8
	blt	ADDRESS, ENDA, 20b
	sd	EXPECTED, (ADDRESS)	;# fill all of RAM with 1's
	FLUSH_WB 

	KICK_WDOG
	move	ADDRESS, STARTA		;# then read it all back to see if it worked
	ld	ACTUAL, (ADDRESS)
	ALIGN3
30:	bne	ACTUAL, EXPECTED, 200f	;# fail
	nop
	add	ADDRESS, 8
	blt	ADDRESS, ENDA, 30b
	ld	ACTUAL, (ADDRESS)
	bne	ACTUAL, EXPECTED, 200f
	nop
		
.if true, 1
	KICK_WDOG
	li	TSTNUM, 2		;# TEST 2 - write 1's compliment of address into location
	move	ADDRESS, STARTA
	ALIGN3
40:	move	EXPECTED, ADDRESS
	addu	EXPECTED, 4
	dsll32	EXPECTED, 0
	or	EXPECTED, ADDRESS
	nor	EXPECTED, r0
	sd	EXPECTED, (ADDRESS)	;# put address into location
	FLUSH_WB
	add	ADDRESS, 8
	bleu	ADDRESS, ENDA, 40b
	nop
	
	KICK_WDOG
	move	ADDRESS, STARTA
	ALIGN3
50:	ld	ACTUAL, (ADDRESS)	;# then read it all back to see if it worked
	move	EXPECTED, ADDRESS
	addu	EXPECTED, 4
	dsll32	EXPECTED, 0
	or	EXPECTED, ADDRESS
	nor	EXPECTED, r0
	bne	ACTUAL, EXPECTED, 200f	;# fail
	nop
	add	ADDRESS, 8
	bleu	ADDRESS, ENDA, 50b
	nop
.endc

	KICK_WDOG
	li	TSTNUM, 3		;# TEST 3 - write address into location
	move	ADDRESS, STARTA
	ALIGN3
40:	move	EXPECTED, ADDRESS
	addu	EXPECTED, 4
	dsll32	EXPECTED, 0
	or	EXPECTED, ADDRESS
	sd	EXPECTED, (ADDRESS)	;# put address into location
	FLUSH_WB
	add	ADDRESS, 8
	bleu	ADDRESS, ENDA, 40b
	nop
	
	KICK_WDOG
	move	ADDRESS, STARTA
	ALIGN3
50:	ld	ACTUAL, (ADDRESS)	;# then read it all back to see if it worked
	move	EXPECTED, ADDRESS
	addu	EXPECTED, 4
	dsll32	EXPECTED, 0
	or	EXPECTED, ADDRESS
	bne	ACTUAL, EXPECTED, 200f	;# fail
	nop
	add	ADDRESS, 8
	bleu	ADDRESS, ENDA, 50b
	nop

  .if true, TEST_REFRESH > 0
	li	TSTNUM, 4		;# TEST 4 - verify refresh is occuring
	li	a0, 1000000		;# wait 1 second
	ALIGN3
	bal	prc_wait_n_usecs	;# sleep for awhile to see if refresh works
	nop

	KICK_WDOG
	move	ADDRESS, STARTA
	ld	ACTUAL, (ADDRESS)	;# then read it all back to see if it worked
	ALIGN3
50:	move	EXPECTED, ADDRESS
.if true, FAKE_MEM64_ERR == 0
	bne	ACTUAL, EXPECTED, 200f	;# fail
.iff
	beq	ACTUAL, EXPECTED, 200f	;# fake a fail
.endc
	nop
	add	ADDRESS, 8
	blt	ADDRESS, ENDA, 50b
	ld	ACTUAL, (ADDRESS)
	move	EXPECTED, ADDRESS
	bne	ACTUAL, EXPECTED, 200f
	nop
  .endc

  .if true, TEST_WALKING1 > 0
	li	TSTNUM, 5		;# TEST 5 - walk a single bit through memory
	move	ADDRESS, STARTA
	li	WALKBIT, 1		;# walk a single bit through each location of memory
	ALIGN3
55:	ld	EXPECTED, (ADDRESS)	;# Get existing data
	xor	EXPECTED, WALKBIT		;# flip a bit
	sd	EXPECTED, (ADDRESS)	;# write it back
	FLUSH_WB
	nor	TMP0, EXPECTED		;# get the 1's compliment of what was written
	ld	TMP1, 8(ADDRESS)	;# get next location
	xor	TMP1, TMP0		;# flip a bunch of bits
	sd	TMP1, 8(ADDRESS)	;# write them back
	FLUSH_WB 8(ADDRESS)
	ld	ACTUAL, (ADDRESS)	;# get the data
	bne	EXPECTED, ACTUAL, 200f	;# doesn't match what was written, it fails
	nop
	xor	EXPECTED, WALKBIT	;# put bit back
	sd	EXPECTED, (ADDRESS)	;# restore location to normal
	FLUSH_WB
	xor	TMP1, TMP0
	dsll	WALKBIT, 1		;# shift bit left
	sd	TMP1, 8(ADDRESS)	;# restore the next location
	FLUSH_WB 8(ADDRESS)
	bne	WALKBIT, r0, 55b	;# keep testing
	nop

	add	ADDRESS, 8		;# increment the address
	blt	ADDRESS, ENDA, 55b	;# keep testing
	li	WALKBIT, 1		;# get a new bit

	KICK_WDOG
	li	TSTNUM, 6		;# TEST 6 - verify addresses still in memory
	move	ADDRESS, STARTA
	ALIGN3
58:	ld	ACTUAL, (ADDRESS)	;# then read it all back to make sure the addresses are still there
	move	EXPECTED, ADDRESS
	addu	EXPECTED, 4
	dsll32	EXPECTED, 0
	or	EXPECTED, ADDRESS
	bne	ACTUAL, EXPECTED, 200f ;# fail
	nop
	add	ADDRESS, 8
	bleu	ADDRESS, ENDA, 58b
	nop
  .endc

	KICK_WDOG
	li	TSTNUM, 7		;# TEST 7 - fill all of memory with 0's
	move	ADDRESS, STARTA
	move	EXPECTED, r0
	sd	EXPECTED, (ADDRESS)	;# fill ram with 0's
	ALIGN3
60:
	FLUSH_WB
	add	ADDRESS, 8
	blt	ADDRESS, ENDA, 60b
	sd	EXPECTED, (ADDRESS)

	FLUSH_WB
	move	ADDRESS, STARTA		;# then read it all back to see if it worked
	move	EXPECTED, r0
	ld	ACTUAL, (ADDRESS)
	ALIGN3
70:	nop
	bne	EXPECTED, ACTUAL, 200f	;# fail
	nop
	add	ADDRESS, 8
	blt	ADDRESS, ENDA, 70b
	ld	ACTUAL, (ADDRESS)
	nop
	bne	EXPECTED, ACTUAL, 200f	;# fail
	nop
		
	jr	RASAVE
	move	v0, r0			;# signal no errors

	ALIGN3
200:
  .if true, 0 && ANN_TEST_SERIAL
	la	v0, mem_test_msgs
	sll	TSTNUM, 2
	addu	v0, TSTNUM
	lw	TSTNUM, (v0)
  .endc
	jr	RASAVE
	addu	v0, r0, 1
	
.set reorder
ENDFRAME test_mem64

.macro FLUSH_WB
   .error ;Redefine FLUSH_WB after test_mem64
.endm

.endc

.if true, SA_DIAGS && (TEST_MEM32|TEST_MEM64)
	ALIGN3
FRAME show_suspect64,global=0
	move	s5, ra		;# save return address
	lra	a0, sa_suspect
	ALIGN3
	bal	prc_puts
	nor	BUNLK, r0, r0		;# get a mask of all one's
	dsll32	BUNLK, 0		;# shift it left 32 bits
	xor	WALKBIT, ACTUAL, EXPECTED ;# get error bits
	and	v0, WALKBIT, BUNLK	;# isolate upper bits
	beq	v0, r0, 50f		;# no errors in odd half

	lra	a0, sa_odd_addr
	ALIGN3
	bal	prc_puts		;# report error on odd addr buffers
	dsrl32	WALKBIT, 0		;# get upper 32 error bits
	and	v1, WALKBIT, 0xFFFF	;# see if there's errors in data lsb
	beq	v1, r0, 10f		;# no 
	lra	a0, sa_odd_data_l	;# report odd data lsb
	ALIGN3
	bal	prc_puts
	ALIGN3
10:	srl	WALKBIT, 16		;# get odd data msb error bits
	and	v1, WALKBIT, 0xFFFF
	beq	v1, r0, 50f		;# no msb
	lra	a0, sa_odd_data_u
	ALIGN3
	bal	prc_puts		;# report odd data msb
	ALIGN3
50:	xor	WALKBIT, ACTUAL, EXPECTED ;# get error bits again
	dsrl32	BUNLK, 0		;# get low 32 bit mask
	and	WALKBIT, BUNLK		;# isolat lower bits
	beq	WALKBIT, r0, 100f	;# no even errors
	lra	a0, sa_even_addr	;# report even address buffers
	ALIGN3
	bal	prc_puts
	and	v0, WALKBIT, 0xFFFF
	beq	v0, r0, 60f
	lra	a0, sa_even_data_l
	ALIGN3
	bal	prc_puts		;# report even addr lsb errors
	ALIGN3
60:	srl	WALKBIT, 16
	and	v0, WALKBIT, 0xFFFF
	beq	v0, r0, 100f
	lra	a0, sa_even_data_u
	ALIGN3
	bal	prc_puts		;# report even addr msb errors
	ALIGN3
100:		
	j	s5			;# return
ENDFRAME show_suspect64

	ALIGN3
FRAME show_suspect,global=0
	dsll32	ACTUAL, 0		;# shove the data up 32 bits
	dsll32	EXPECTED, 0
	and	v0, ADDRESS, 4
	bne	v0, r0, show_suspect64	;# if addr odd, continue in 64 bit mode
	dsrl32	ACTUAL, 0		;# make sure upper bits are 0
	dsrl32	EXPECTED, 0
	b	show_suspect64		;# and continue in 64 bit mode
ENDFRAME show_suspect
.endc

.if true, TEST_MEM64 && SA_DIAGS
	ALIGN3
FRAME test_error64, global=0
	move	BUNLK, TSTNUM		;# save test number for later	
 .if true, FAKE_MEM64_ERR
	nor	ACTUAL, r0, FAKE_MEM64_BITS
	xor	ACTUAL, EXPECTED
 .endc
 .if true, (ANNOUNCE_BOOT_ACTIONS == 0) && (SA_DIAGS == 0)
	ALIGN3
 	bal	UnLock			;# unlock the IOASIC
	li	a0, 1000000
	ALIGN3
	bal	prc_wait_n_usecs	;# wait a while for it to take effect
 .endc
	lra	a0, sa_error_0		;# point to our error message (relative)
	ALIGN3
	bal	prc_puts		;# print it
	lra	v0, mem_test_msgs	;# point to our next error message (relative)
	sll	v1, BUNLK, 2		;# get test number
	addu	v0, v1			;# add to array pointer
	lw	v0, (v0)		;# get message pointer (absolute)
	la	v1, startup		;# make it relative
	subu	v0, v1
	addu	a0, v0, fp
	ALIGN3
	bal	prc_puts		;# display test description message
	lra	a0, sa_error_1
	ALIGN3
	bal	prc_puts		;# display error address description
	move	a0, ADDRESS		;# get failing address
	li	a1, 6			;# six nibbles worth of physical address
	ALIGN3
	bal	prc_putv		;# display hex constant
	lra	a0, sa_expect
	ALIGN3
	bal	prc_puts		;# display expected description
	move	a0, EXPECTED
	li	a1, 16			;# 16 nibbles worth of data
	ALIGN3
	bal	prc_putv
	lra	a0, sa_got
	ALIGN3
	bal	prc_puts		;# display actual description
	move	a0, ACTUAL
	li	a1, 16
	ALIGN3
	bal	prc_putv		;# display actual data
	lra	a0, sa_errbits
	ALIGN3
	bal	prc_puts		;# display errbits description
	xor	a0, ACTUAL, EXPECTED
	li	a1, 16
	ALIGN3
	bal	prc_putv		;# display error bits data
	ALIGN3
	bal	show_suspect64		;# display the suspect chips
	lra	a0, sa_scope
	ALIGN3
	bal	prc_puts		;# display the scope loop message

	ALIGN3
10:	sd	EXPECTED, (ADDRESS)
	ld	r0, (ADDRESS)
	b	10b
	nop
ENDFRAME test_error64
.endc

.if true, TEST_MEM64 | TEST_MEM32
	ALIGN3
FRAME test_error, global=0
 .if true, SA_DIAGS == 0
test_error64:
 .endc
 .if true, SA_DIAGS
	move	BUNLK, TSTNUM		;# save test number for later	
  .if true, FAKE_MEM32_ERR
   .if true, FAKE_MEM32_ERR_O
	or	ADDRESS, 4
   .endc
	nor	ACTUAL, r0, FAKE_MEM32_BITS
	xor	ACTUAL, EXPECTED
  .endc
  .if true, (ANNOUNCE_BOOT_ACTIONS == 0) && (SA_DIAGS == 0)
	ALIGN3
 	bal	UnLock			;# unlock the IOASIC
	li	a0, 1000000
	ALIGN3
	bal	prc_wait_n_usecs	;# wait a while for it to take effect
  .endc
	lra	a0, sa_error_0		;# point to our error message (relative)
	ALIGN3
	bal	prc_puts		;# print it
	lra	v0, mem_test_msgs	;# point to our next error message (relative)
	sll	v1, BUNLK, 2		;# get test number
	addu	v0, v1			;# add to array pointer
	lw	v0, (v0)		;# get message pointer (absolute)
	la	v1, startup		;# make it relative
	subu	v0, v1
	addu	a0, v0, fp
	ALIGN3
	bal	prc_puts		;# display test description message
	lra	a0, sa_error_1
	ALIGN3
	bal	prc_puts		;# display error address description
	move	a0, ADDRESS		;# get failing address
	li	a1, 6			;# six nibbles worth of physical address
	ALIGN3
	bal	prc_putv		;# display hex constant
	lra	a0, sa_expect
	ALIGN3
	bal	prc_puts		;# display expected description
	move	a0, EXPECTED
	li	a1, 8			;# 8 nibbles worth of data
	ALIGN3
	bal	prc_putv
	lra	a0, sa_got
	ALIGN3
	bal	prc_puts		;# display actual description
	move	a0, ACTUAL
	li	a1, 8
	ALIGN3
	bal	prc_putv		;# display actual data
	lra	a0, sa_errbits
	ALIGN3
	bal	prc_puts		;# display errbits description
	xor	a0, ACTUAL, EXPECTED
	li	a1, 8
	ALIGN3
	bal	prc_putv		;# display error bits data
	ALIGN3
	bal	show_suspect		;# display the suspect chips
	lra	a0, sa_scope
	ALIGN3
	bal	prc_puts		;# display the scope loop message

	ALIGN3
10:	sw	EXPECTED, (ADDRESS)
	lw	r0, (ADDRESS)
	b	10b
	nop
 .iff
;	BLAST_ERRORS
	KICK_WDOG

  .if defined, RAMROM_BASE
	la	v0, RAMROM_BASE+0x001FFFF0
	sw	TSTNUM, 0(v0)
	sw	ADDRESS, 4(v0)
	sw	EXPECTED, 8(v0)
	sw	ACTUAL, 12(v0)
  .endc
  .if defined, B_LED_RED
	li	TMP1, 1<<B_LED_RED
  .endc
	ALIGN3
120:
  .if true, (STOP_ON_ERROR)
	la	v0, GALILEO_CS0		;# Point to expansion connector
	sw	TSTNUM, 0(v0)
	sw	ADDRESS, 4(v0)
	sw	EXPECTED, 8(v0)
	sw	ACTUAL, 12(v0)
  .endc

  .if true, (STOP_ON_ERROR == 0)

	la	t0, begin
	or	t0, 0x20000000
	j	t0
	nop
  .iff
   .if defined, LED_OUT
	lw	TMP0, LED_OUT
	xor	TMP0, TMP1
	sw	TMP0, LED_OUT
   .endc
	li	TMP0, 100000
	ALIGN3
130:	sw	EXPECTED, (ADDRESS)
	lw	r0, (ADDRESS)
	addu	TMP0, -1
	bne	TMP0, r0, 130b
	nop
	b	120b
	nop
  .endc			;STOP_ON_ERROR
 .endc			;SA_DIAGS
ENDFRAME test_error
.endc			;TEST_MEM64 | TEST_MEM32

.if true, (TEST_MEM32 > 0)

.macro FLUSH_WB addr=(ADDRESS)
.endm

;# Quick and dirty RAM test.
;# At entry:
;#	a0 = starting address
;#	a1 = ending address
;#	a2 = .ne. if required to do read after write
;#	fp = control register shadow
;# At exit:
;#	v0 = 0 if no errors
;#	v0 = 1 if errors and ...
;#	ACTUAL = "is" data
;#	EXPECTED = "s/b" data
;#	ADDRESS = failing address
;#	TSTNUM = subtest number 
;#	trashes a0-a3, v0-v1, t0-t5, s0-s4

	ALIGN3
FRAME	test_mem32, global=0
.set noreorder

	move	RASAVE, ra	;# remember where we came from
	move	STARTA, a0	;# save the starting address
	move	ENDA, a1	;# save the ending address
	nor	TMP0, r0, 3	;# get a -4
	and	STARTA, TMP0	;# make both addresses word aligned
	and	ENDA, TMP0
;	la	WDOG_REG, WATCHDOG
	KICK_WDOG

	li	TSTNUM, 0		;# TEST 0 - walk a single bit through location 0
	li	EXPECTED, 1		;# first walk a single bit
	move	ADDRESS, STARTA
	ALIGN3
10:	sw	EXPECTED, (ADDRESS)	;# write the word
	lw	ACTUAL, (ADDRESS)	;# read it back
	bne	ACTUAL, EXPECTED, 200f	;# branch if there's an error
	nop
	sll	EXPECTED, 1		;# shift test bit
	bne	EXPECTED, r0, 10b	;# keep testing
	nop

	li	EXPECTED, 1		;# then through location 4 (64 bit bus)
	move	ADDRESS, STARTA
	addu	ADDRESS, 4
	ALIGN3
15:	sw	EXPECTED, (ADDRESS)	;# write the word
	lw	ACTUAL, (ADDRESS)	;# read it back
	bne	ACTUAL, EXPECTED, 200f	;# branch if there's an error
	nop
	sll	EXPECTED, 1		;# shift test bit
	bne	EXPECTED, r0, 15b	;# keep testing
	nop

	li	TSTNUM, 1		;# TEST 1 - fill memory with all one's
	nor	EXPECTED, r0, r0	;# get a -1
	move	ADDRESS, STARTA
	sw	EXPECTED, (ADDRESS)	;# fill all of RAM with 1's
	ALIGN3
20:
	FLUSH_WB
	add	ADDRESS, 4
	blt	ADDRESS, ENDA, 20b
	sw	EXPECTED, (ADDRESS)	;# fill all of RAM with 1's

	FLUSH_WB
	KICK_WDOG

	move	ADDRESS, STARTA		;# then read it all back to see if it worked
	lw	ACTUAL, (ADDRESS)
	ALIGN3
30:	bne	ACTUAL, EXPECTED, 200f	;# fail
	nop
	add	ADDRESS, 4
	blt	ADDRESS, ENDA, 30b
	lw	ACTUAL, (ADDRESS)
	bne	ACTUAL, EXPECTED, 200f
	nop
		
	KICK_WDOG
	li	TSTNUM, 2		;# TEST 2 - write 1's compliment of address into location
	move	ADDRESS, STARTA
	nor	v0, r0, ADDRESS
	ALIGN3
40:	sw	v0, (ADDRESS)		;# put 1's compliment of address into location
	FLUSH_WB
	add	ADDRESS, 4
	bleu	ADDRESS, ENDA, 40b
	nor	v0, r0, ADDRESS
	
	KICK_WDOG
	move	ADDRESS, STARTA
	ALIGN3
50:	lw	ACTUAL, (ADDRESS)	;# then read it all back to see if it worked
	nor	EXPECTED, r0, ADDRESS
	bne	ACTUAL, EXPECTED, 200f	;# fail
	nop
	add	ADDRESS, 4
	bleu	ADDRESS, ENDA, 50b
	nop

	KICK_WDOG
	li	TSTNUM, 3		;# TEST 3 - write address into location
	move	ADDRESS, STARTA
	sw	ADDRESS, (ADDRESS)	;# put address into location
	ALIGN3
40:
	FLUSH_WB
	add	ADDRESS, 4
	blt	ADDRESS, ENDA, 40b
	sw	ADDRESS, (ADDRESS)
	FLUSH_WB
	
	KICK_WDOG
	move	ADDRESS, STARTA
	lw	ACTUAL, (ADDRESS)	;# then read it all back to see if it worked
	ALIGN3
50:	move	EXPECTED, ADDRESS
.if true, FAKE_MEM32_ERR == 0
	bne	ACTUAL, EXPECTED, 200f	;# fail
.iff
	beq	ACTUAL, EXPECTED, 200f	;# fake a fail
.endc
	nop
	add	ADDRESS, 4
	blt	ADDRESS, ENDA, 50b
	lw	ACTUAL, (ADDRESS)
	move	EXPECTED, ADDRESS
	bne	ACTUAL, EXPECTED, 200f
	nop

  .if true, TEST_REFRESH > 0
	li	TSTNUM, 4		;# TEST 4 - verify refresh is occuring
	li	a0, 1000000		;# wait 1 second
	ALIGN3
	bal	prc_wait_n_usecs	;# sleep for awhile to see if refresh works
	nop
	KICK_WDOG
	move	ADDRESS, STARTA
	lw	ACTUAL, (ADDRESS)	;# then read it all back to see if it worked
	ALIGN3
50:	move	EXPECTED, ADDRESS
	bne	ACTUAL, EXPECTED, 200f	;# fail
	nop
	add	ADDRESS, 4
	blt	ADDRESS, ENDA, 50b
	lw	ACTUAL, (ADDRESS)
	move	EXPECTED, ADDRESS
	bne	ACTUAL, EXPECTED, 200f
	nop

  .endc

  .if true, TEST_WALKING1 > 0
	KICK_WDOG
	li	TSTNUM, 5		;# TEST 5 - walk a single bit through memory
	move	ADDRESS, STARTA
	li	WALKBIT, 1		;# walk a single bit through each location of memory
	ALIGN3
55:	lw	EXPECTED, (ADDRESS)	;# Get existing data
	xor	EXPECTED, WALKBIT	;# flip a bit
	sw	EXPECTED, (ADDRESS)	;# write it back
	FLUSH_WB
	nor	TMP0, EXPECTED		;# get the 1's compliment of what was written
	lw	TMP1, 4(ADDRESS)	;# get next location
	xor	TMP1, TMP0		;# flip a bunch of bits
	sw	TMP1, 4(ADDRESS)	;# write them back
	FLUSH_WB 4(ADDRESS)
	lw	ACTUAL, (ADDRESS)		;# get the data
	bne	EXPECTED, ACTUAL, 200f	;# doesn't match what was written, it fails
	nop
	xor	EXPECTED, WALKBIT	;# put bit back
	sw	EXPECTED, (ADDRESS)	;# restore location to normal
	FLUSH_WB
	xor	TMP1, TMP0
	sll	WALKBIT, 1		;# shift bit left
	sw	TMP1, 4(ADDRESS)	;# restore the next location
	FLUSH_WB 4(ADDRESS)
	bne	WALKBIT, r0, 55b		;# keep testing
	nop

	add	ADDRESS, 4		;# increment the address
	blt	ADDRESS, ENDA, 55b	;# keep testing
	li	WALKBIT, 1		;# get a new bit

	KICK_WDOG
	li	TSTNUM, 6		;# TEST 6 - verify addresses still in memory
	move	ADDRESS, STARTA
	lw	ACTUAL, (ADDRESS)	;# then read it all back to make sure the addresses are still there
	ALIGN3
58:	move	EXPECTED, ADDRESS
	bne	ACTUAL, EXPECTED, 200f ;# fail
	nop
	add	ADDRESS, 4
	blt	ADDRESS, ENDA, 58b
	lw	ACTUAL, (ADDRESS)
	move	EXPECTED, ADDRESS
	bne	ACTUAL, EXPECTED, 200f
	nop
  .endc

	KICK_WDOG
	li	TSTNUM, 7		;# TEST 7 - fill all of memory with 0's
	move	ADDRESS, STARTA
	move	EXPECTED, r0
	sw	EXPECTED, (ADDRESS)	;# fill ram with 0's
	ALIGN3
60:
	FLUSH_WB
	add	ADDRESS, 4
	blt	ADDRESS, ENDA, 60b
	sw	EXPECTED, (ADDRESS)

	KICK_WDOG
	move	ADDRESS, STARTA		;# then read it all back to see if it worked
	move	EXPECTED, r0
	lw	ACTUAL, (ADDRESS)
	ALIGN3
70:	nop
	bne	EXPECTED, ACTUAL, 200f	;# fail
	nop
	add	ADDRESS, 4
	blt	ADDRESS, ENDA, 70b
	lw	ACTUAL, (ADDRESS)
	nop
	bne	EXPECTED, ACTUAL, 200f	;# fail
	nop
		
	jr	RASAVE
	move	v0, r0

	ALIGN3
200:
  .if true, 0 && ANN_TEST_SERIAL
	la	v0, mem_test_msgs
	sll	TSTNUM, 2
	addu	v0, TSTNUM
	lw	TSTNUM, (v0)
  .endc
	jr	RASAVE
	addu	v0, r0, 1

.set reorder
ENDFRAME test_mem32
.endc		; TEST_MEM32 

.if true, TEST_BRAM
.macro FLUSH_WB addr=(ADDRESS)
.endm
.macro UNLOCK
	sw	r0, (BUNLK)
.endm

;# Quick and dirty BRAM test.
;# At entry:
;#	no requirements
;#	fp = control register shadow
;# At exit:
;#	v0 = 0 if no errors
;#	v0 = 1 if errors and ...
;#	ACTUAL = "is" data
;#	EXPECTED = "s/b" data
;#	ADDRESS = failing address
;#	TSTNUM = subtest number 
;#	trashes a0-a3, v0-v1, t0-t7, s0-s4

FRAME	test_bram, global=0
	.set noreorder
	move	RASAVE, ra
	la	STARTA, BRAM_BASE
	la	ENDA, BRAM_BASE+BRAM_SIZE-4
	la	BUNLK, BRAM_UNLK
;	la	WDOG_REG, WATCHDOG
	KICK_WDOG

	li	TSTNUM, 0		;# TEST 0 - walk a single bit through location 0
	li	EXPECTED, 1		;# first walk a single bit
	move	ADDRESS, STARTA
10:
	UNLOCK
	sw	EXPECTED, (ADDRESS)	;# write the byte
	lbu	ACTUAL, (ADDRESS)	;# read it back
	bne	ACTUAL, EXPECTED, 200f	;# branch if there's an error
	nop
	sll	EXPECTED, 1		;# shift test bit
	and	EXPECTED, 0xFF		;# there's only 8 bits
	bne	EXPECTED, r0, 10b	;# keep testing
	nop

	KICK_WDOG
	li	TSTNUM, 1		;# TEST 1 - fill memory with all 1's
	li	EXPECTED, 0xFF		;# get a byte of all one's
	move	ADDRESS, STARTA
	UNLOCK
20:	sw	EXPECTED, (ADDRESS)	;# fill all of RAM with 1's
	FLUSH_WB
	add	ADDRESS, 4
	blt	ADDRESS, ENDA, 20b
	UNLOCK
	sw	EXPECTED, (ADDRESS)	;# store the last one
	FLUSH_WB
	
	KICK_WDOG
	move	ADDRESS, STARTA		;# then read it all back to see if it worked
	lbu	ACTUAL, (ADDRESS)
30:	bne	ACTUAL, EXPECTED, 200f	;# fail
	add	ADDRESS, 4
	blt	ADDRESS, ENDA, 30b
	lbu	ACTUAL, (ADDRESS)
	bne	ACTUAL, EXPECTED, 200f
	nop
		
	KICK_WDOG
	li	TSTNUM, 2		;# TEST 2 - put address into location
	move	ADDRESS, STARTA
	li	EXPECTED, 0
	UNLOCK
40:	sw	EXPECTED, (ADDRESS)	;# put (sort of) address into location
	FLUSH_WB
	addu	EXPECTED, 1
	addu	ADDRESS, 4
	blt	ADDRESS, ENDA, 40b
	UNLOCK
	sw	EXPECTED, (ADDRESS)	;# store last addr
	FLUSH_WB
	
	KICK_WDOG 
	lbu	ACTUAL, (ADDRESS)	;# then read it all back to see if it worked
50:	and	EXPECTED, 0xFF
	bne	ACTUAL, EXPECTED, 200f	;# fail
	nop
	addu	ADDRESS, -4
	addu	EXPECTED, -1
	bgt	ADDRESS, STARTA, 50b
	lbu	ACTUAL, (ADDRESS)
	bne	ACTUAL, EXPECTED, 200f
	nop
		
	KICK_WDOG 
	li	TSTNUM, 4		;# TEST 4 - walk a 1 through all of memory
	move	ADDRESS, STARTA
	li	WALKBIT, 1		;# walk a single bit through each location of memory
55:	lbu	EXPECTED, (ADDRESS)	;# Get existing data
	xor	EXPECTED, WALKBIT		;# flip a bit
	UNLOCK
	sw	EXPECTED, (ADDRESS)	;# write it back
	FLUSH_WB
	xor	TMP0, EXPECTED, 0xFF	;# get the 1's compliment of what was written
	lbu	TMP1, 4(ADDRESS)	;# get next location
	xor	TMP1, TMP0		;# flip a bunch of bits
	UNLOCK
	sw	TMP1, 4(ADDRESS)	;# write them back
	FLUSH_WB 4(ADDRESS)
	lbu	ACTUAL, (ADDRESS)		;# get the data
	bne	EXPECTED, ACTUAL, 200f	;# doesn't match what was written, it fails
	nop
	xor	EXPECTED, WALKBIT	;# put bit back
	UNLOCK
	sw	EXPECTED, (ADDRESS)	;# restore location to normal
	FLUSH_WB
	xor	TMP1, TMP0
	dsll	WALKBIT, 1		;# shift bit left
	UNLOCK
	sw	TMP1, 4(ADDRESS)	;# restore the next location
	and	WALKBIT, 0xFF
	bne	WALKBIT, r0, 55b		;# keep testing
	FLUSH_WB 4(ADDRESS)
	nop

	addu	ADDRESS, 4		;# increment the address
	blt	ADDRESS, ENDA, 55b	;# keep testing
	li	WALKBIT, 1		;# get a new bit

	KICK_WDOG
	li	TSTNUM, 5		;# TEST 5 - verify addresses still in memory
	li	EXPECTED, 0
	move	ADDRESS, STARTA
	lbu	ACTUAL, (ADDRESS)	;# then read it all back to make sure the addresses are still there
58:	and	EXPECTED, 0xFF
	bne	ACTUAL, EXPECTED, 200f ;# fail
	nop
	addu	EXPECTED, 1
	addu	ADDRESS, 4
	blt	ADDRESS, ENDA, 58b
	lbu	ACTUAL, (ADDRESS)
	and	EXPECTED, 0xFF
	bne	ACTUAL, EXPECTED, 200f
	nop

	KICK_WDOG
	li	TSTNUM, 6		;# TEST 6 - fill all of RAM with 0's
	move	ADDRESS, STARTA
	move	EXPECTED, r0
	UNLOCK
60:
	sw	EXPECTED, (ADDRESS)	;# fill ram with 0's
	FLUSH_WB
	addu	ADDRESS, 4
	blt	ADDRESS, ENDA, 60b
	UNLOCK
	sw	EXPECTED, (ADDRESS)
	FLUSH_WB

	move	ADDRESS, STARTA		;# then read it all back to see if it worked
	move	EXPECTED, r0
	lbu	ACTUAL, (ADDRESS)
70:	nop
	bne	EXPECTED, ACTUAL, 200f	;# fail
	nop
	addu	ADDRESS, 4
	blt	ADDRESS, ENDA, 70b
	lbu	ACTUAL, (ADDRESS)
	nop
	bne	EXPECTED, ACTUAL, 200f	;# fail
	nop
		
	jr	RASAVE
	move	v0, r0

200:
  .if true, 0 && ANN_TEST_SERIAL
	la	v0, mem_test_msgs
	sll	TSTNUM, 2
	addu	v0, TSTNUM
	lw	TSTNUM, (v0)
  .endc
	jr	RASAVE
	addu	v0, r0, 1

	.set reorder
ENDFRAME test_bram
.endc

.if true, ((TEST_MEM32 || TEST_MEM64 || TEST_BRAM) && (BOOT_COMPRESSED == 0)) || SA_DIAGS
	DEC_CONST	SAVE_s0		(0*REG_SIZE)
	DEC_CONST	SAVE_s1		(1*REG_SIZE)
	DEC_CONST	SAVE_s2		(2*REG_SIZE)
	DEC_CONST	SAVE_s3		(3*REG_SIZE)
	DEC_CONST	SAVE_s4		(4*REG_SIZE)
	DEC_CONST	SAVE_s5		(5*REG_SIZE)
	DEC_CONST	SAVE_a0		(6*REG_SIZE)
	DEC_CONST	SAVE_ra		(7*REG_SIZE)
	DEC_CONST	SAVE_size	(8*REG_SIZE)

.macro ASM_PROLOG
	addu	sp, -SAVE_size
	sw	s0, SAVE_s0(sp)
	sw	s1, SAVE_s1(sp)
	sw	s2, SAVE_s2(sp)
	sw	s3, SAVE_s3(sp)
	sw	s4, SAVE_s4(sp)
	sw	s5, SAVE_s5(sp)
	sw	ra, SAVE_ra(sp)
	sw	a0, SAVE_a0(sp)
.endm
.macro ASM_EPILOG size=6
	lw	s0, SAVE_s0(sp)
	lw	s1, SAVE_s1(sp)
	lw	s2, SAVE_s2(sp)
	lw	s3, SAVE_s3(sp)
	lw	s4, SAVE_s4(sp)
	lw	s5, SAVE_s5(sp)
	lw	ra, SAVE_ra(sp)
	lw	a0, SAVE_a0(sp)
	addu	sp, SAVE_size
	j	ra
.endm
.macro ASM_RET_VAL arg
	beq	v0, r0, 10f		;# No errors, nothing to send back
	lw	v1, SAVE_a0(sp)
	beq	v1, r0, 10f
 .if nb, arg
	dsrl32	TMP0, ACTUAL, 0
	sw	TMP0, actual_msb(v1)
 .iff
	sw	r0, actual_msb(v1)
 .endc
	sw	ACTUAL, actual_lsb(v1)
 .if nb, arg
	dsrl32	TMP0, EXPECTED, 0
	sw	TMP0, expected_msb(v1)
 .iff
	sw	r0, expected_msb(v1)
 .endc
	sw	EXPECTED, expected_lsb(v1)
	sw	ADDRESS, bad_address(v1)
	sw	TSTNUM, subtest(v1)
10:
.endm

 .if true, TEST_MEM32
FRAME zag_test_mem32
	ASM_PROLOG
	move	a0, a1
	move	a1, a2
	move	a2, a3
	bal	test_mem32
	ASM_RET_VAL
	ASM_EPILOG
ENDFRAME zag_test_mem32
 .endc
 .if true, TEST_MEM64
FRAME zag_test_mem64
	ASM_PROLOG
	move	a0, a1
	move	a1, a2
	move	a2, a3
	bal	test_mem64
	ASM_RET_VAL 64bit
	ASM_EPILOG
ENDFRAME zag_test_mem64
 .endc
 .if true, TEST_BRAM
FRAME zag_test_bram
	ASM_PROLOG
	bal	test_bram
	ASM_RET_VAL
	ASM_EPILOG
ENDFRAME zag_test_bram
 .endc
 .undefine TMP1
 .undefine TMP2
 .undefine TSTNUM
 .undefine RASAVE

 .undefine STARTA
 .undefine ENDA
 
 .undefine TBBASE
 .undefine TBSIZE

;.undefine WDOG_REG
 .undefine TMP0
 .undefine EXPECTED
 .undefine ADDRESS
 .undefine ACTUAL
 .undefine WALKBIT
 .undefine BUNLK
 .undefine TICKS_USEC
 
 .undefine TSTSEN_TMP3
 .undefine TSTSEN_CNT

	.align 3
;*********************************************************************
;# Flush 'n' bytes of data cache 
;# At entry:
;#	a0 = buff
;#	a1 = count in bytes
;# At exit:
;#	trashes a0-a3, v0-v1
FRAME prc_flush_pdcache
	.set noreorder
	mfc0	a3, C0_CONFIG
	li	a2, 16				;# assume cache line size is 16
	and	a3, CFG_DB
	beq	a3, r0, 10f
	nop

	li	a2, 32				;# cache line is 32 bytes
10:	cache	Hit_Writeback_Inv_D, (a0)	;# invalidate cache line
	subu	a1, a2				;# decrement count
	bgt	a1, r0, 10b
	addu	a0, a2				;# increment address

	j	ra
	nop
	.set reorder
ENDFRAME prc_flush_pdcache

;*********************************************************************
;# Invalidate 'n' bytes of data cache 
;# At entry:
;#	a0 = buff
;#	a1 = count in bytes
;# At exit:
;#	trashes a0-a3, v0-v1
FRAME prc_inv_pdcache
	.set noreorder
	mfc0	a3, C0_CONFIG
	li	a2, 16				;# assume cache line size is 16
	and	a3, CFG_DB
	beq	a3, r0, 10f
	nop

	li	a2, 32				;# cache line is 32 bytes
10:	cache	Hit_Invalidate_D, (a0)		;# mark cache line invalid w/o writing it
	subu	a1, a2				;# decrement count
	bgt	a1, r0, 10b
	addu	a0, a2				;# increment address

	j	ra
	nop
	.set reorder
ENDFRAME prc_inv_pdcache

walk_a_bit:
	.asciz "Walking one bit through address 0"
fill_with_ones:
	.asciz "Fill all of memory with 1's"
address_to_location:
	.asciz "Write each location's address"
oc_address_to_location:
	.asciz "Write 1's compliment of address to each location"
refresh_verify:
	.asciz "Verify refresh"
walk_1_bit:
	.asciz "Walk a 1 throughout memory"
verify_address:
	.asciz "Verify location's address is in each location"
fill_with_0:
	.asciz "Fill all of memory with 0's"
	.align 2
	.globl mem_test_msgs
mem_test_msgs:
	.word walk_a_bit, fill_with_ones, oc_address_to_location, address_to_location
	.word refresh_verify, walk_1_bit, verify_address, fill_with_0
 .if true, SA_DIAGS && (TEST_MEM32|TEST_MEM64)
sa_header_1:
	.asciz "\r\nTesting DRAM physical addresses (512KB) 0x000000-0x07FFFF, "
sa_header_1_mode:
	.asciz " bit mode ..."
sa_header_2:
	.asciz "\r\nTesting DRAM physical addresses (7.5MB) 0x080000-0x7FFFFF, "
sa_error_0:
	.asciz "\r\nError while performing: \""
sa_error_1:
	.asciz "\"\r\nAt physical address: 0x"
sa_expect:
	.asciz "\r\nExpected to read: 0x"
sa_got:
	.asciz "\r\n   Actually read: 0x"
sa_errbits:
	.asciz "\r\n   Bits in error: 0x"
sa_scope:
	.asciz "\r\nLooping on writes+reads at failing address.\r\nPress reset to continue..."
sa_loop_msg:
	.asciz "\r\nSuccessful tests completed: 0x"
sa_suspect:
	.asciz "\r\nSuspect chips: U86 "
sa_even_addr:
	.asciz "U34 U35 U56 U57 "
sa_odd_addr:
	.asciz "U36 U37 U58 U59 "
sa_even_data_u:
	.asciz "U44 "
sa_even_data_l:
	.asciz "U43 "
sa_odd_data_u:
	.asciz "U45 "
sa_odd_data_l:
	.asciz "U46 "
 .endc			; SA_DIAGS && (TEST_MEM32|TEST_MEM64)
.endc			; if ((TEST_MEM32 || TEST_MEM64 || TEST_BRAM) && (BOOT_COMPRESSED == 0)) || SA_DIAGS

.if true, BOOT_COMPRESSED == 0
;*********************************************************************
;* ++++++++++ WARNING DANGER WARNING DANGER WARNING DANGER +++++++++++
;*
;* This needs to be moved if and when we use a read only text section.
;*
.if true, (BOOT_FROM_DISK == 0) && (EPROM_ST == 0)
	.align 2
	.globl go_to_self_test
go_to_self_test:
	.word 0
.endc
;*
;* +++++ END OF "THIS NEEDS TO BE MOVED" AREA ++++++++++++++++++++++++
;*********************************************************************
.endc

	.align 3
.if true, BOOT_ROM_CODE == 0
 .if true, BOOT_FROM_DISK || BOOT_COMPRESSED
FRAME copy_and_go_size
	la	v0, candg_end
	la	v1, copy_and_go
	subu	v0, v1
	j	ra
ENDFRAME copy_and_go_size

;*********************************************************************
;* ++++++++++ WARNING DANGER WARNING DANGER WARNING DANGER +++++++++++
;*
;* Do not add any additional functions (FRAME/ENDFRAME) nor add any
;* calls (b, bal or jal) to functions between here and the label
;* "candg_end". This special code is used by GUTS and the HD boot code
;* and must remain position independent.
;*
;# Copy data from src to dst, then jump to addr at dst
;# At entry:
;#	a0 = dst
;#	a1 = src
;#	a2 = count in bytes
;# At exit:
;#	Does not exit. jumps to non-cached dst address
;#	All hardware has been reset.
;#	trashes a0-a3, v0-v1

FRAME copy_and_go
	la	v0, 0x20000000
	or	a0, v0
	move	ra, a0
	li	v1, PM_DATA_BEGIN ;# Don't copy anything into PM area
	li	a3, PM_DATA_END
10:	bgtu	a0, a3, 20f
	bltu	a0, v1, 20f
	b	30f

20:	lw	v0, (a1)
	sw	v0, (a0)
30:	addu	a0, 4
	addu	a1, 4
	addu	a2, -4
	bgtu	a2, r0, 10b
;#	b	prc_reset_hardware	;# !!! Fall through to prc_reset_hardware !!!
ENDFRAME copy_and_go
 .endc

;****
;**** Don't even think about putting anything here!!!!!
;****

FRAME prc_reset_hardware
 .if true, (HOST_BOARD == PHOENIX_AD) || (HOST_BOARD == FLAGSTAFF) || (HOST_BOARD == SEATTLE)
	sw	r0, RESET_CTL
  .if true, (HOST_BOARD == PHOENIX_AD) || (HOST_BOARD == SEATTLE)
	sw	r0, NSS_CTL
  .endc
	sw	r0, INTCTL_NMI
	sw	r0, INTCTL_IE
	sw	r0, INTCTL_MAPA
	sw	r0, INTCTL_STS
	sw	r0, INTCTL_VSY_ACK
	sw	r0, ARB_CTL
	li	v0, ~(1<<B_LED_RED)
	sw	v0, LED_OUT
 .iff
	sw	r0, NSS_FIFO_RST
	li	v0, MISC_CONFIG_NSS_RESET
	sw	v0, MISC_CONFIG
	sw	r0, IO_RESET
	sw	r0, PCI_RESET
 .endc
	j	ra
ENDFRAME prc_reset_hardware
candg_end:
;*
;* +++++ END OF "DO NOT CHANGE" AREA +++++++++++++++++++++++++++++++++
;*********************************************************************
.endc				; BOOT_ROM_CODE == 0

.if defined, IO_UART_CTL_INTERNAL_ENA
;# Local support function to blink yellow LED while waiting for
;# UART xmit ready.
;# At entry:
;#	no requirements
;# At exit:
;#	returns when XMT_EMPTY flag is set in IO_MAIN_STS register.
;#	Blinks Yellow LED while waiting.
;#	trashes t0-t2
	ALIGN3
FRAME putc_blink_yel,global=0
.if defined, LED_OUT
	mfc0	t2, C0_COUNT
.endc
	ALIGN3
10:	lw	t0, IO_MAIN_STS
	and	t0, IO_MAIN_UART_XMT_EMPTY
	bne	t0, r0, 20f
.if defined, LED_OUT
	mfc0	t1, C0_COUNT
	subu	t1, t2
	subu	t1, PUTC_BLINK_TIME
	blt	t1, r0, 10b			;# not time to blink
	lw	t1, LED_OUT
	xor	t1, 1<<B_LED_YEL		;# flip LED
	sw	t1, LED_OUT
	mfc0	t2, C0_COUNT			;# reset timer
	b	10b
.endc
	ALIGN3
20:
.if defined, LED_OUT
	lw	t1, LED_OUT
	or	t1, 1<<B_LED_YEL
	sw	t1, LED_OUT
.endc
	j	ra
ENDFRAME putc_blink_yel

;# prc_putc - writes a character out IOASIC UART port.
;# At entry:
;#	a0 - character to output
;# At exit:
;#	Waits for entire character to be sent. Blinks Yellow
;#	LED until character has been sent
;#	trashes a0, v0, v1, t0-t5
	ALIGN3
FRAME prc_putc
	move	t5, ra			;# save return address
	move	t3, a0			;# save character to send
.if defined, LED_OUT
	la	t0, LED_OUT
	lw	t1, (t0)
	and	t1, ~(1<<B_LED_YEL)		;# Turn on YEL led 
	sw	t1, (t0)
.endc
	la	t0, IO_MAIN_CTL
	lw	t4, (t0)			;# Get current contents of IO_CONTROL
	sw	r0, (t0)			;# disable all IOASIC interrupts
	li	t2, PUTC_UART_ENAB		;# get UART init constant
.if defined, IO_DIPSW
	lw	t0, IO_DIPSW
	and	t0, IO_DIPSW2			;# If there's a DIPSW, check for CTS enable
	bne	t0, r0, 10f
	and	t2, ~IO_UART_CTL_IGNORE_CTS_IN ;# Ignore CTS
	ALIGN3
10:
.endc
	la	t0, IO_UART_CTL
	lhu	t1, (t0)			;# get UART status
	beq	t2, t1, 20f			;# If already init'd, skip it
	sw	t2, (t0)			;# else set UART
	li	a0, 100000
	ALIGN3
	bal	prc_wait_n_usecs		;# Give it time to settle
	lhu	t1, (t0)			;# Check to see that it set
	beq	t2, t1, 20f
	ALIGN3
15:	li	a0, (1<<B_LED_RED)|(1<<B_LED_YEL) ;# It didn't, so blink LED's and get stuck
	ALIGN3
	bal	prc_blink_led
	b	15b

	ALIGN3
20:	bal	putc_blink_yel			;# Wait for XMIT ready, blink YEL led
	sh	t3, IO_UART_TX			;# send character
	ALIGN3
	bal	putc_blink_yel			;# Wait for XMIT ready, blink YEL led

.if defined, LED_OUT
	lw	t0, LED_OUT			;# Turn off the yellow led
	or	t0, 1<<B_LED_YEL
	sw	t0, LED_OUT
.endc
	sw	t4, IO_MAIN_CTL			;# restore the IO_CONTROL reg
	j	t5				;# return

ENDFRAME prc_putc

 .if true, SA_DIAGS && (TEST_MEM32|TEST_MEM64)
;# prc_puts - writes a null terminated string out IOASIC UART port.
;# At entry:
;#	a0 - pointer to string to output
;# At exit:
;#	Returns number of characters sent
;#	Waits for entire string to be sent. Blinks Yellow
;#	LED while each character is sent.
;#	trashes a0-a3, t0-t6
	ALIGN3
FRAME prc_puts
	move	t6, a0				;# save string pointer
	move	a3, a0				;# save string pointer
	move	a2, ra				;# save return address
	ALIGN3
10:	lbu	a0, (a3)			;# get character
	beq	a0, r0, 20f			;# done
	ALIGN3
	bal	prc_putc			;# send character
	addu	a3, 1				;# next
	b	10b

	ALIGN3
20:	subu	v0, a3, t6			;# compute character sent count
	j	a2				;# done
ENDFRAME prc_puts

;# prc_putv - ASCII'fies the value in A0 and emits it as HEX out the serial port
;# At entry:
;#	a0 - word to output
;#	a1 - number of nibbles to emit
;# At exit:
;#	Waits for entire string to be sent. Blinks Yellow
;#	LED while each character is sent.
;#	trashes a0-a3, t0-t6
	ALIGN3
FRAME prc_putv
	move	a3, a0				;# save value
	move	a2, ra				;# save return address
	sll	t6, a1, 2			;# multiply nibble count by 4
	ALIGN3
10:	addu	t6, -4				;# decrement one nibble
	blt	t6, r0, 30f			;# nothing to do
	dsrlv	a0, a3, t6			;# get nibble from 64 bit word
	and	a0, 0xF				;# isolate the nibble
	addu	a0, 0x30			;# ASCII'fy it
	li	t0, 0x3A
	blt	a0, t0, 20f			;# it's 0-9
	addu	a0, 7				;# adjust it to a 'A-F'
	ALIGN3
20:	bal	prc_putc			;# send character
	b	10b

	ALIGN3
30:	j	a2				;# done
ENDFRAME prc_putv
 .endc			;SA_DIAGS && (TEST_MEM32|TEST_MEM64)
.endc
