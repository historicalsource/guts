dispatch.c                               Atari Games Corp. macpp v9.12   "Oct 16 1997 13:26:41"


    1  00000005 OUTPUT_LANG == 5 
    1           ; $Id: def_pp.mac,v 1.7 1997/07/01 20:54:19 shepperd Exp $
    2           ;	.ESCAPE	MACRO_OPEN	'['
    3           ;	.ESCAPE	MACRO_CLOSE	']'
    4           ;	This file contains macro definitions intended to make it easier to
    5           ; have a common definitions file and generate appropriate .i and .h files that
    6           ; allow (inter alia) passing structures between C and assembly. For structures
    7           ; They define offsets corresponding to those produce by the C compiler.
    8  00000000 ...SSP==0			; Beginning software "stack pointer" is zero
    9  00000000 ...SAP==0			; Beginning structure allocation pointer is 0
   10  00000000 ...SAL==0			; Beginning strictest alignment is 0 (byte)
   11  00000000 ...SSN==0			; Beginning structure sequence number
   12           ;
   13           ; The following defaults match GNU CC (or GreenHill -x132) on a 68000
   14  00000001 	.iif	ndf,MAX_ALIGN,MAX_ALIGN == 1
   15  00000000 	.iif	ndf,MIN_ALIGN,MIN_ALIGN == 0
   16  00000004 	.iif	ndf,PTR_SIZ,PTR_SIZ == 4
   17  00000000 LANG_ASM	== 0		; Microtek
   18  00000001 LANG_MAC	== 1		; MACxx
   19  00000002 LANG_C		== 2		; C
   20  00000003 LANG_TXT	== 3		; Plain text
   21  00000004 LANG_ASRxk	== 4		; GNU AS for the R3k or R4k
   22  00000005 LANG_NONE	== 5		; No output (just keep the MACPP variables)
   23    (0)    	.if	ndf,OUTPUT_LANG
   24     X     OUTPUT_LANG	== LANG_C
   25    (0)    	.endc
   26           ;
   27           ; One more try at stand-alone comments
   28           .MACRO .REM. code body
   29            .if true, (OUTPUT_LANG != LANG_C) && (OUTPUT_LANG != LANG_NONE)
   30           'code'body
   31            .endc
   32           .endm
   33           ;
   34           ; The following two macros are "helpers", which set a (possibly numbered)
   35           ; symbol to a value. .SET_SYM. sets a non-numbered symbol while
   36           ; .SET_NSYM. sets a numbered one. When the elided-parameter bug in macxx
   37           ; is fixed, we can merge the two.
   38           ; The majority of calls to .SET_NSYM. are used to create a "stack" by
   39           ; defining a set of symbols with names of the form ...SSP<stack level>.
   40           ;
   41           .MACRO	.SET_SYM. dname sloc sname 
   42           	.if	b,sname
   43           dname == sloc
   44           	.iff
   45           dname == sname'sloc
   46           	.endc
   47           	.ENDM
   48           ;
   49           .MACRO	.SET_NSYM. dname dloc sloc sname 
   50           	.if	b,sname
   51           dname'dloc == sloc
   52           	.iff
   53           dname'dloc == sname'sloc
   54           	.endc
   55           	.ENDM
   56           ; This one is like .SET_NSYM., but uses .define instead, for string substitution.
dispatch.c                               Atari Games Corp. macpp v9.12   "Oct 16 1997 13:26:41"


   57           ; It is needed to save the names of enclosing structs for use in emitting qualified
   58           ; structure tag offsets, e.g foo.bar.head, where head in an element of a struct
   59           ; named bar which is in turn a part of a struct named foo
   60           .MACRO	.DEF_NSYM. dname dloc sname 
   61           	.define dname'dloc sname
   62           	.ENDM
   63           ;
   64           ; The following is to "export" a symbol as having a value. These are the
   65           ; only part that makes it into macpp's output for structure offsets in assembly.
   66           ;
   67           .MACRO	.EXPORT. name val type number comment
   68               .if true, OUTPUT_LANG == LANG_C
   69           	.if	eq,number-1
   70           	    .if	b,comment
   71           type name;
   72           	    .iff
   73           type name;	/* comment */
   74           	    .endc
   75           	.iff
   76           	    .if	b,comment
   77           type name[number];
   78           	    .iff
   79           type name[number];	/* comment */
   80           	    .endc
   81           	.endc
   82               .iff	; else must be assembly
   83           	.if true, OUTPUT_LANG != LANG_NONE
   84           	    ...more == 0
   85           	    .iif	nb,type,...more==1
   86           	    .iif	nb,number,...more==1
   87           	    .if	b,comment
   88           	    .iff
   89           		...more==1
   90           	    .endc
   91           	    .if	true, OUTPUT_LANG == LANG_MAC
   92           		.if	eq,...more
   93           name	=	val
   94           		.iff
   95           name	=	val	; number type comment
   96           		.endc
   97           	    .iff
   98           		.if	eq,...more
   99           name	EQU	val
  100           		.iff
  101           		    .if true, OUTPUT_LANG == LANG_ASRxk
  102           name	=	val	;# number type comment
  103           		    .iff
  104           name	EQU	val	; number type comment
  105           		    .endc
  106           		.endc
  107           	    .endc	; MAC versus ASM
  108           	.endc	; OUTPUT_LANG != LANG_NONE
  109               .endc	; C versus assembly
  110           .endm
  111           ;
  112           ; These export qualified names
  113           .MACRO	.EXQ1. qual name val type number comment
dispatch.c                               Atari Games Corp. macpp v9.12   "Oct 16 1997 13:26:41"


  114           .if true, OUTPUT_LANG != LANG_NONE
  115           ...more == 0
  116               .iif	nb,type,...more==1
  117               .iif	nb,number,...more==1
  118               .iif	nb,comment,...more==1
  119               .if	true, OUTPUT_LANG == LANG_MAC
  120           	.if	eq,...more
  121           qual'.'name	=	val
  122           	.iff
  123           qual'.'name	=	val	; number type comment
  124           	.endc
  125               .iff
  126           	.if	eq,...more
  127           qual'.'name	EQU	val
  128           	.iff
  129           	    .if true, OUTPUT_LANG == LANG_ASRxk
  130           qual'.'name	=	val	;# number type comment
  131           	    .iff
  132           qual'.'name	EQU	val	; number type comment
  133           	    .endc
  134           	.endc
  135               .endc
  136           .endc
  137           .endm
  138           ;
  139    (0)    .if true, OUTPUT_LANG == LANG_MAC
  140           ;
  141     X     	.MACRO	.EXQ2. qual1 qual2 name val
  142     X     qual1'.'qual2'.'name = val
  143     X     	.endm
  144           
  145     X     	.MACRO	.EXQ3. qual1 qual2 qual3 name val
  146     X     qual1'.'qual2'.'qual3'.'name = val
  147     X     	.endm
  148           ;
  149    (0)    .iff
  150           ;
  151           	.MACRO	.EXQ2. qual1 qual2 name val
  152           qual1'.'qual2'.'name EQU val
  153           	.endm
  154           
  155           	.MACRO	.EXQ3. qual1 qual2 qual3 name val
  156           qual1'.'qual2'.'qual3'.'name EQU val
  157           	.endm
  158           ;
  159    (0)    .endc
  160           ;
  161           ;
  162           ; The macro STR_START is intended to start a structure definition.
  163           ; It stacks the current value of the allocation pointer and alignment
  164           ; and resets them to 0
  165           .MACRO	STR_START str_name
  166           .if true, OUTPUT_LANG != LANG_NONE
  167               .if	eq,OUTPUT_LANG-LANG_C
  168           	.SET_NSYM. STR_STK,\...SSP,\...SSN 
  169           	.SET_SYM. SSN'str_name,\...SSN
  170           	.SET_SYM. ...SSN,\...SSN+1
dispatch.c                               Atari Games Corp. macpp v9.12   "Oct 16 1997 13:26:41"


  171           	...SSP == ...SSP+1
  172           struct str_name {
  173               .iff	; else must be assembly
  174           	.if	ndf,QUAL_NAMES
  175           	    .if true, OUTPUT_LANG == LANG_ASRxk
  176           		.REM. <;#* > < offsets in struct str_name'>
  177           	    .iff
  178           		.REM. * < offsets in struct str_name'>
  179           	    .endc
  180           	.endc
  181           	.SET_NSYM. STR_STK,\...SSP,\...SAP 
  182           	.SET_NSYM. STR_STK,\...SSP+1,\...SAL 
  183           	.SET_NSYM. STR_STK,\...SSP+2,\...SSN 
  184           	...SAP == 0
  185           	...SAL == 0
  186           	.DEF_NSYM. STRN_NAME,\...SSP,str_name
  187           	.SET_SYM. SSN'str_name,\...SSN
  188           	.SET_SYM. ...SSN,\...SSN+1
  189           	...SSP == ...SSP+3
  190               .endc	; C versus assembly
  191           .endc
  192           .endm
  193           ;
  194           ;
  195           ; The macro .PAD. sets <label> to <oldval> rounded up to the next value
  196           ; which is 0 modulo 2**<align>. Actually, <align> is massaged a bit first.
  197           ; the value used is max(MIN_ALIGN,min(align,MAX_ALIGN)). For the 68000
  198           ; 68000, MAX_ALIGN should be 1. For the 68020 or 80386, MAX_ALIGN can be 0,
  199           ; but things will run faster with it >=2. For ASAP, it should be 2. There
  200           ; is no benefit in enforcing a larger MAX_ALIGN than the bus-width of the
  201           ; processor, but you can if you need to be compatible with some compiler.
  202           ; Similarly, MIN_ALIGN should always be 0, unless you must be compatible
  203           ; with a compiler that over-zealously pads (e.g. GreenHills without -x132).
  204           ; As a "side-effect", the variable ...SAL is updated to contain the largest
  205           ; alignment needed so far.
  206           .MACRO	.PAD.	label oldval align
  207           	.if	lt,align-MIN_ALIGN
  208           ...alp	==	MIN_ALIGN
  209           	.iff
  210           	.if	gt,align-MAX_ALIGN
  211           ...alp	==	MAX_ALIGN
  212           	.iff
  213           ...alp	==	align
  214           	.endc
  215           	.endc
  216           	.if	gt,...alp-...SAL
  217           ...SAL	==	...alp
  218           	.endc
  219           ...alm	==	(1<<...alp)-1
  220           label	==	(oldval+...alm)&^C...alm
  221           	.endm
  222           ;
  223           ; The macro .ALIGN. is intended to align the storage allocation pointer
  224           ; ('.' in MACXX) to the boundary given
  225           ;
  226           	.macro	.ALIGN. ...pwr
  227           	.if true, OUTPUT_LANG != LANG_NONE
dispatch.c                               Atari Games Corp. macpp v9.12   "Oct 16 1997 13:26:41"


  228           	    .if	ne,...pwr
  229           	    .align	...pwr
  230           	    .endc
  231           	.endc
  232           	.endm
  233           ;
  234           ; The macro .RESERVE. is intended to reserve an area of storage. It is a
  235           ; macro primarily to allow passing its parameter by value
  236           ;
  237           .MACRO	.RESERVE. qty comment
  238           	.if true, OUTPUT_LANG != LANG_NONE
  239           	DS.B	qty	; comment
  240           	.endc
  241           	.endm
  242           ;
  243           ; The macro STR_END is intended to end a structure definition. If the optional
  244           ; parameter QTY is omitted, it is assumed to be one. The previous value of the
  245           ; allocation pointer is popped, then incremented by the size of the just-ended
  246           ; structure (plus padding) times QTY.
  247           .MACRO	STR_END NAME QTY
  248           	.if true, OUTPUT_LANG != LANG_NONE
  249           	.if	eq,OUTPUT_LANG-LANG_C
  250           	.IF	B,QTY
  251           };
  252           	.IFF
  253           }<0x'QTY>;
  254           	.ENDC
  255           ...SSP	== ...SSP-1
  256           	.SET_SYM. ...tmp,\...SSP,STR_STK
  257           	.iif	ne,...tmp-(SSN'NAME),.error	;structure nesting error
  258           ; End of C version
  259           	.iff	; else must be assembly
  260           S_ALN_'NAME == ...SAL
  261           	.iif	df,EXPORT_ALN,.EXPORT. S_ALN_'NAME,\...SAL
  262           	.PAD.	...tmp \...SAP \...SAL
  263           	.IF	B,QTY
  264           S_SIZ_'NAME	==	...tmp
  265           	.iif	df,EXPORT_SIZ,.EXPORT. S_SIZ_'NAME,\...tmp
  266           	.IFF
  267           S_SIZ_'NAME	== ...tmp*<'QTY'>
  268           	.iif	df,EXPORT_SIZ,.EXPORT. S_SIZ_'NAME,\...tmp*<'QTY'>
  269           	.ENDC
  270           ...SSP	== ...SSP-3
  271           ; pop sequence number and test for match
  272           	.SET_SYM. ...tmp,\...SSP+2,STR_STK
  273           	.iif	ne,...tmp-(SSN'NAME),.error	;structure nesting error
  274           ; pop previous alignment and force max of (prev,new) if not at top level
  275           	.SET_SYM. ...tmp,\...SSP+1,STR_STK
  276           	.if	ne,...SSP
  277           	.iif	gt,...tmp-...SAL,...SAL	==	...tmp
  278           	.endc
  279           ; pop previous allocation ptr and add size contribution of just-closed struct
  280           	.SET_SYM. ...tmp,\...SSP,STR_STK
  281           ...SAP	== S_SIZ_'NAME+...tmp
  282           	.endc	; C versus assembly
  283           	.endc	; != LANG_NONE
  284           	.ENDM
dispatch.c                               Atari Games Corp. macpp v9.12   "Oct 16 1997 13:26:41"


  285           ;
  286  00000010 .UNS_FLAG.	==	0x10
  287  00000020 .VOL_FLAG.	==	0x20
  288  00000040 .CNST_FLAG.	==	0x40
  289  00000080 .PTR_FLAG.	==	0x80
  290  00000100 .SGN_FLAG	==	0x100
  291           	.macro	.SET_TYPE. ...var ...type
  292           ...flags	==	0
  293           	.irp	...token,<'...type'>
  294           	.if	idn,...token,unsigned
  295           ...flags	==	...flags | .UNS_FLAG.
  296           	.rexit
  297           	.endc
  298           	.if	idn,...token,const
  299           ...flags	==	...flags | .CNST_FLAG.
  300           	.rexit
  301           	.endc
  302           	.if	idn,...token,volatile
  303           ...flags	==	...flags | .VOL_FLAG.
  304           	.rexit
  305           	.endc
  306           	.if	idn,...token,signed
  307           ...flags	==	...flags | .SGN_FLAG.
  308           	.rexit
  309           	.endc
  310           	.if	idn,...token,char
  311           ...flags	==	(...flags & 0xFFFFFFF8 ) | 1
  312           	.rexit
  313           	.endc
  314           	.if	idn,...token,short
  315           ...flags	==	(...flags & 0xFFFFFFF8 ) | 2
  316           	.rexit
  317           	.endc
  318           	.if	idn,...token,long
  319           ...flags	==	(...flags & 0xFFFFFFF8 ) | 4
  320           	.rexit
  321           	.endc
  322           	.if	idn,...token,int
  323           	.iif	ne,...flags & 7,.rexit	; Already spec'd "long" or "short"
  324           ...flags	==	(...flags & 0xFFFFFFF8 ) | 4
  325           	.rexit
  326           	.endc
  327           ; Getting here means none of the usual keywords. Could be a "*" or a typedef
  328           	.irpc	...char,<'...token'>
  329           	.if	idn,...char,*
  330           ...flags	==	...flags | .PTR_FLAG.
  331           	.endc
  332           	.endr
  333           	.iif	ne,...flags & .PTR_FLAG., .rexit
  334           ; Not a pointer either
  335           	.if	df,...token'_size
  336           ...flags	==	(...flags & 0xFFFFFFF8 ) | ...token'_size
  337           	.iff
  338           	.if	dif,...token,void
  339           	.error	; Cannot determine basic size of ...type
  340           	.endc
  341           	.endc
dispatch.c                               Atari Games Corp. macpp v9.12   "Oct 16 1997 13:26:41"


  342           	.endr
  343           ...var	==	...flags
  344           	.endm
  345           ;
  346           ;
  347    (0)    .if true, OUTPUT_LANG == LANG_C
  348           ; C version
  349     X         .macro	STR_ELT name,type,number,comment
  350     X     	.if true, number == 1
  351     X     	    .if	b,comment
  352     X     type name;
  353     X     	    .iff
  354     X     type name;	/* comment */
  355     X     	    .endc
  356     X     	.iff
  357     X     	    .if	b,comment
  358     X     type name[number];
  359     X     	    .iff
  360     X     type name[number];	/* comment */
  361     X     	    .endc
  362     X     	.endc
  363     X         .endm
  364    (0)    .iff
  365           ; Assembly version
  366               .macro	.STR_ELT. name, type, elt_pwr, n_elts, comment
  367           	.if true, OUTPUT_LANG != LANG_NONE
  368           	    .PAD.	...tmp ...SAP elt_pwr
  369               ...serad	== 10
  370           	    .radix	10.
  371           	    .if	ndf,QUAL_NAMES
  372           		.EXPORT. name,\...tmp,<'type'>,n_elts,<'comment'>
  373           	    .iff
  374           		.EXQ1. STRN_NAME0,name,\...tmp,<'type'>,n_elts,<'comment'>
  375           		.if	gt,...SSP-3
  376           		    .SET_SYM. ...cum1,\...SSP-3,STR_STK
  377           		    .EXQ2. STRN_NAME0 STRN_NAME3 name \...tmp+...cum1
  378           		.endc
  379           		.if	gt,...SSP-6
  380           		    .SET_SYM. ...cum2,\...SSP-6,STR_STK
  381           		    .EXQ3. STRN_NAME0 STRN_NAME3 STRN_NAME6 name \...tmp+cum1+cum2
  382           		.endc
  383           	    .endc
  384           	    .radix	...serad
  385               ...SAP	==	...tmp+((1<<elt_pwr)*n_elts)
  386           	.endc
  387               .endm
  388               .macro	STR_ELT name, type, n_elts, comment
  389           	.if true, OUTPUT_LANG != LANG_NONE
  390           	    .SET_TYPE. ...var_type <'type'>
  391               elt_pwr	== -1
  392           	    .if	ne,...var_type & .PTR_FLAG.
  393               elt_pwr == 2						; All ptrs 4 bytes
  394           	    .iff
  395           ; Not a pointer, get base type
  396           		.iif true, (...var_type & 7) >= 4, elt_pwr == 2	; long and int
  397           		.iif true, (...var_type & 7) == 2, elt_pwr == 1	; short
  398           		.iif true, (...var_type & 7) == 1, elt_pwr == 0	; char
dispatch.c                               Atari Games Corp. macpp v9.12   "Oct 16 1997 13:26:41"


  399           	    .endc
  400           	    .if true, elt_pwr < 0
  401           		.error	; Unknown alignment for type
  402           		.mexit
  403           	    .endc
  404           	    .STR_ELT. name,<'type'>,elt_pwr,n_elts,<'comment'>
  405           	.endc
  406               .endm
  407    (0)    .endc	; C versus assembly STR_ELT
  408           ;
  409           ;
  410    (0)    .if	eq,OUTPUT_LANG-LANG_C
  411           ; C version
  412     X         .macro	STR_REF name,sname,number,comment
  413     X     ...num	== 1
  414     X     	.iif	nb,number,...num==number
  415     X     	.if	eq,...num-1
  416     X     	    .if	b,comment
  417     X     struct sname name;
  418     X     	    .iff
  419     X     struct sname name;	/* comment */
  420     X     	    .endc
  421     X     	.iff
  422     X     	    .if	b,comment
  423     X     struct sname name[number];
  424     X     	    .iff
  425     X     struct sname name[number];	/* comment */
  426     X     	    .endc
  427     X     	.endc
  428     X     	.endm
  429    (0)    .iff
  430           ; else must be assembly
  431               .macro	STR_REF name,sname,n_elts,comment
  432           	.if true, OUTPUT_LANG != LANG_NONE
  433           	    .if	ndf,S_ALN_'sname
  434           		.error ;reference to undefined struct
  435           	    .iff
  436           		.PAD.	...tmp ...SAP \S_ALN_'sname
  437           		.SET_SYM. ...siz,\S_SIZ_'sname
  438           		.if	ndf,QUAL_NAMES
  439           		    .EXPORT. name,\...tmp,<struct sname>,n_elts,<'comment'>
  440           		.iff
  441           		    .EXQ1. STRN_NAME0 name \...tmp,<struct sname>,n_elts,<'comment'>
  442           		    .if	gt,...SSP-3
  443           			.SET_SYM. ...cum1,\...SSP-3,STR_STK
  444           			.EXQ2. STRN_NAME0 STRN_NAME3 name \...tmp+...cum1
  445           		    .endc
  446           		    .if	gt,...SSP-6
  447           			.SET_SYM. ...cum2,\...SSP-6,STR_STK
  448           			.EXQ3. STRN_NAME0 STRN_NAME3 STRN_NAME6 name \...tmp+cum1+cum2
  449           		    .endc
  450           		.endc
  451           		...SAP	==	...tmp+(...siz*n_elts)
  452           	    .endc
  453           	.endc
  454               .endm
  455    (0)    .endc
dispatch.c                               Atari Games Corp. macpp v9.12   "Oct 16 1997 13:26:41"


  456           ;
  457    (0)    .if	eq,OUTPUT_LANG-LANG_C
  458     X         .macro	STR_PTR name,sname,number,comment
  459     X     ...num	== 1
  460     X     	.iif	nb,number,...num==number
  461     X     	.if	eq,...num-1
  462     X     	    .if	b,comment
  463     X     struct sname *'name;
  464     X     	    .iff
  465     X     struct sname *'name;	/* comment */
  466     X     	    .endc
  467     X     	.iff
  468     X     	    .if	b,comment
  469     X     struct sname *'name[number];
  470     X     	    .iff
  471     X     struct sname *'name[number];	/* comment */
  472     X     	    .endc
  473     X     	.endc
  474     X         .endm
  475    (0)    .iff
  476           ; Assembly version
  477               .macro	STR_PTR name,sname,number,comment
  478           	.if true, OUTPUT_LANG != LANG_NONE
  479           	    .STR_ELT. name,<struct sname' *>,2,number,<'comment'>
  480           	.endc
  481               .endm
  482    (0)    .endc
  483           ;
  484    (0)    .if	eq,OUTPUT_LANG-LANG_C
  485     X         .macro	STR_FPTR name,ret_type,number,comment
  486     X     ...num	== 1
  487     X     	.iif	nb,number,...num==number
  488     X     	.if	eq,...num-1
  489     X     	    .if	b,comment
  490     X     ret_type (*'name)();
  491     X     	    .iff
  492     X     ret_type (*'name)();	/* comment */
  493     X     	    .endc
  494     X     	.iff
  495     X     	    .if	b,comment
  496     X     ret_type name'[number]();	/* comment */
  497     X     	    .iff
  498     X     ret_type name'[number]();	/* comment */
  499     X     	    .endc
  500     X     	.endc
  501     X         .endm
  502    (0)    .iff
  503           ; Assembly version
  504               .macro	STR_FPTR name,ret_type,number,comment
  505           	.STR_ELT. name,<'ret_type ()>,2,number,<'comment'>
  506               .endm
  507    (0)    .endc
  508           ;
  509           ; This is used to actually declare a struct (reserve storage)
  510    (0)    .if	eq,OUTPUT_LANG-LANG_C
  511     X         .macro	STR_DECL name sname qty comment
  512     X     	STR_REF name sname qty <'comment'>
dispatch.c                               Atari Games Corp. macpp v9.12   "Oct 16 1997 13:26:41"


  513     X         .endm
  514    (0)    .iff
  515           ; Assembly version
  516               .macro	STR_DECL name sname qty=1 comment
  517           	.if	ndf,S_ALN_'sname
  518           	    .ERROR ;undefined structure type sname
  519           	.iff
  520           	    .ALIGN.	\S_ALN_'sname
  521           name:
  522           	    .RESERVE.	\qty*S_SIZ_'sname <'qty struct sname comment'>
  523           	.endc
  524               .endm
  525    (0)    .endc
  526           ;
  527           ; This is used to output an appropriate 'extern' declaration
  528    (0)    .if	eq,OUTPUT_LANG-LANG_C
  529     X         .macro	STR_IMPORT name sname qty comment
  530     X     extern
  531     X     	STR_REF name sname qty <'comment'>
  532     X         .endm
  533     X         .macro	IMPORT name type comment
  534     X     extern type name; /* comment */
  535     X         .endm
  536    (0)    .iff
  537               .macro	STR_IMPORT name sname qty=1 comment
  538           	.if true, OUTPUT_LANG != LANG_NONE
  539           	    .if	ndf,S_ALN_'sname
  540           		.ERROR ;undefined structure type sname
  541           	    .iff
  542           	xref	name	; qty struct sname comment
  543           	    .endc
  544           	.endc
  545               .endm
  546               .macro	IMPORT name type comment
  547           	.if true, OUTPUT_LANG != LANG_NONE
  548           	xref	name ; type comment
  549           	.endc
  550               .endm
  551    (0)    .endc
  552           .macro	RTN_IMPORT name type params comment
  553           	.if true, OUTPUT_LANG != LANG_NONE
  554           	    .if	eq,OUTPUT_LANG-LANG_C
  555           extern type name(); /* (params) comment */
  556           	    .iff
  557           	xref name ; type (params) comment
  558           	    .endc
  559           	.endc
  560           .endm
  561           ;
  562           ; This is the "inner" macro to output a constant in decimal form for various languages.
  563           ; It assumes that it will be called with the default radix = 10. for both the input
  564           ; (val) and its output.
  565           .MACRO	__DC__ name val comment
  566           .if true, OUTPUT_LANG != LANG_NONE
  567               .if	b,comment
  568           	.if	eq,OUTPUT_LANG-LANG_C
  569           #define name (val)
dispatch.c                               Atari Games Corp. macpp v9.12   "Oct 16 1997 13:26:41"


  570           	.iff
  571           	    .if	eq,OUTPUT_LANG-LANG_ASM
  572           name	EQU	val
  573           	    .iff
  574           name	=	val
  575           	    .endc	; Which assembly
  576           	.endc	; C or assembly
  577               .iff	; Non-blank comment
  578           	.if	true, OUTPUT_LANG == LANG_C
  579           #define name (val)	/*'comment'*/
  580           	.iff
  581           	    .if	true, OUTPUT_LANG == LANG_ASM
  582           name	EQU	val	; comment
  583           	    .iff
  584           name	=	val	;# comment
  585           	    .endc	; Which assembly
  586           	.endc	; C or assembly
  587               .endc	; non-blank Comment
  588           .endc
  589           .endm
  590           ;
  591           ;
  592           ; This is the "inner" macro to output a constant in hexadecimal form for various
  593           ; languages. It assumes that it will be called with the default radix = 16. for both
  594           ; the input (val) and its output.
  595           .MACRO	__HC__ name val comment
  596           .if true, OUTPUT_LANG != LANG_NONE
  597               .if	b,comment
  598           	.if true, OUTPUT_LANG == LANG_C
  599           #define name (0x'val')
  600           	.iff
  601           	    .if	true, OUTPUT_LANG == LANG_ASM
  602           name	EQU	$'val
  603           	    .iff
  604           name	=	0x'val
  605           	    .endc	; Which assembly
  606           	.endc	; C or assembly
  607               .iff	; Non-blank comment
  608           	.if true, OUTPUT_LANG == LANG_C
  609           #define name (0x'val')	/*'comment'*/
  610           	.iff
  611           	    .if	true, OUTPUT_LANG == LANG_ASM
  612           name	EQU	$'val	; comment
  613           	    .iff
  614           name	=	0x'val	;# comment
  615           	    .endc	; Which assembly
  616           	.endc	; C or assembly
  617               .endc	; non-blank Comment
  618           .endc
  619           .endm
  620           ;
  621           ;
  622           ; This is the "inner" macro to output an address in hexadecimal form for various
  623           ; languages. It assumes that it will be called with the default radix = 16. for both
  624           ; the input (val) and its output.
  625           .MACRO	__AC__ name type val comment
  626           .if true, OUTPUT_LANG != LANG_NONE
dispatch.c                               Atari Games Corp. macpp v9.12   "Oct 16 1997 13:26:41"


  627               .if	true, OUTPUT_LANG == LANG_C
  628           	.if	b,comment
  629           #define name (('type'*)(0x'val))
  630           	.iff
  631           #define name (('type'*)(0x'val))	/*'comment'*/
  632           	.endc	; non-blank Comment
  633               .iff
  634           	.if true, OUTPUT_LANG == LANG_ASM
  635           name	EQU	$'val	; ('type') comment
  636           	.iff
  637           name	=	0x'val	;# ('type') comment
  638           	.endc	; Which assembly
  639               .endc	; C or Assembly
  640           .endc
  641           .endm
  642           ;
  643           ; This is the "inner" macro to output an address in hexadecimal form for various
  644           ; languages. It assumes that it will be called with the default radix = 16. for both
  645           ; the input (val) and its output.
  646           ; It differs from __AC__ by including a "dereference", Which makes a difference in C
  647           .MACRO	__VR__ name type val comment
  648           .if true, OUTPUT_LANG != LANG_NONE
  649               .if	true, OUTPUT_LANG == LANG_C
  650           	.if b,comment
  651           #define name (*('type'*)(0x'val))
  652           	.iff
  653           #define name (*('type'*)(0x'val))	/*'comment'*/
  654           	.endc	; non-blank Comment
  655               .iff
  656           	.if true, OUTPUT_LANG == LANG_ASM
  657           name	EQU	$'val	; ('type') comment
  658           	.iff
  659           name	=	0x'val	;# ('type') comment
  660           	.endc	; Which assembly
  661               .endc	; C or Assembly
  662           .endc
  663           .endm
  664           ;
  665           ;
  666           .MACRO	DEC_CONST name val comment
  667           name	==	val
  668           .if true, OUTPUT_LANG != LANG_NONE
  669           ...rad	== 10
  670           	.radix	10.
  671           	__DC__ name \('name') <'comment'>
  672           	.radix	...rad
  673           .endc
  674           	.endm
  675           ;
  676           .MACRO	HEX_CONST name val comment
  677           name	==	val
  678           .if true, OUTPUT_LANG != LANG_NONE
  679           ...rad	== 10
  680           	.radix	16.
  681           	__HC__ name \('name') <'comment'>
  682           	.radix	...rad
  683           .endc
dispatch.c                               Atari Games Corp. macpp v9.12   "Oct 16 1997 13:26:41"


  684           	.endm
  685           ;
  686           .MACRO	REG_CONST name val comment
  687           .if true, OUTPUT_LANG != LANG_NONE
  688           	.if true, (OUTPUT_LANG != LANG_C) 
  689           .define	name	val
  690           	.endc	; All assemblers 
  691           .endc
  692           .endm
  693           ;
  694           ;
  695           .MACRO	VAR name type val comment
  696           name	==	val
  697           .if true, OUTPUT_LANG != LANG_NONE
  698           ...rad	== 10
  699           	.radix	16.
  700           	__VR__ name <'type'> \('name') <'comment'>
  701           	.radix	...rad
  702           .endc
  703           	.endm
  704           ;
  705           .MACRO	ADDR name type val comment
  706           name	==	val
  707           .if true, OUTPUT_LANG != LANG_NONE
  708           ...rad	== 10
  709           	.radix	16.
  710           	.if	eq,OUTPUT_LANG-LANG_ASM
  711           	.endc
  712           	__AC__ name <'type'> \('name') <'comment'>
  713           	.radix	...rad
  714           .endc
  715           	.endm
  716           ;
  717           .MACRO	TYPE name type size_in_bytes comment
  718           .if true, OUTPUT_LANG != LANG_NONE
  719           	.if	eq,OUTPUT_LANG-LANG_C
  720           #ifndef __'name'_TYPE_DEFINED
  721           #define __'name'_TYPE_DEFINED
  722           	.if	b,comment
  723           typedef type name;
  724           	.iff
  725           typedef type name;	/*'comment'*/
  726           	.endc
  727           #endif /* __'name'_TYPE_DEFINED */
  728           	.endc
  729           .endc
  730           name'_size == size_in_bytes
  731           	.endm
  732           ;
  733           .MACRO	sval base sub val
  734           base'sub == val
  735           	.endm
  736           ;
  737           .MACRO	DECL_C_ARRAY_1 name base_type dim_1 comment
  738           .if true, OUTPUT_LANG != LANG_NONE
  739           	.if	b,comment
  740           extern base_type name['dim_1'];
dispatch.c                               Atari Games Corp. macpp v9.12   "Oct 16 1997 13:26:41"


  741           	.iff
  742           extern base_type name['dim_1'];	/*'comment'*/
  743           	.endc
  744           .endc
  745           	.endm
  746           ;
  747           .MACRO	DECL_C_ARRAY_2 name base_type dim_1 dim_2 comment
  748           .if true, OUTPUT_LANG != LANG_NONE
  749           	.if	b,comment
  750           extern base_type name['dim_1']['dim_2'];
  751           	.iff
  752           extern base_type name['dim_1']['dim_2'];	/*'comment'*/
  753           	.endc
  754           .endc
  755           	.endm
  756           ;
  757           .MACRO	DECL_C_ARRAY_3 name base_type dim_1 dim_2 dim_3 comment
  758           .if true, OUTPUT_LANG != LANG_NONE
  759           	.if	b,comment
  760           extern base_type name['dim_1']['dim_2']['dim_3'];
  761           	.iff
  762           extern base_type name['dim_1']['dim_2']['dim_3'];	/*'comment'*/
  763           	.endc
  764           .endc
  765           	.endm
  766           ;
  767           .MACRO	ARRAY	name base_type address dimensions comment
  768           ...dims == 0
  769           ...tot_siz == 1
  770           ...rad	==	10
  771           	.radix	10.
  772           	.irp	...dim_siz,<'dimensions'>
  773           	sval dim_ \...dims \...dim_siz
  774           ...tot_siz == ...tot_siz * ...dim_siz
  775           ...dims	==	...dims+1
  776           	.endr
  777           	.if	df,base_type'_size
  778           ...tot_siz	== ...tot_siz * base_type'_size
  779           	.endc
  780           ;
  781           	.if	eq,OUTPUT_LANG-LANG_C
  782           name	==	address
  783           	.if	eq,...dims-1
  784           DECL_C_ARRAY_1 name base_type \dim_0 <'comment'>
  785           	.endc
  786           	.if	eq,...dims-2
  787           DECL_C_ARRAY_2 name base_type \dim_0 \dim_1 <'comment'>
  788           	.endc
  789           	.if	eq,...dims-3
  790           DECL_C_ARRAY_3 name base_type \dim_0 \dim_1 \dim_2 <'comment'>
  791           	.endc
  792           	HEX_CONST name'_ADDR \address
  793            	.iff
  794           ; Assembly
  795           	HEX_CONST name address <'comment'>
  796           	HEX_CONST name'_size \...tot_siz
  797           	.endc
dispatch.c                               Atari Games Corp. macpp v9.12   "Oct 16 1997 13:26:41"


  798           	.radix	...rad
  799           	.endm
  800           ;
  801    (0)    .if	true, OUTPUT_LANG == LANG_C
  802     X     	.MACRO	REM comments
  803     X     		.REM. </*>
  804     X     		.REM. < *> <'comments'>
  805     X     		.REM. < */>
  806     X     		.endm
  807    (0)    .iff
  808    (1)        .if	true, OUTPUT_LANG == LANG_TXT
  809     X     	.MACRO	REM comments
  810     X     		.REM. <  >
  811     X     		.REM. <  > <'comments'>
  812     X     		.REM. <  >
  813     X     		.endm
  814    (1)        .iff
  815    (2)    	.if true, OUTPUT_LANG == LANG_ASRxk
  816     X     	    .MACRO   REM comments
  817     X     		    .REM. <;#* >
  818     X     		    .REM. <;#* 'comments'>
  819     X     		    .REM. <;#* >
  820     X     		    .endm
  821    (2)    	.iff
  822    (3)    	    .if true, OUTPUT_LANG != LANG_NONE
  823     X     		.MACRO   REM comments
  824     X     			.REM. *
  825     X     			.REM. * <'comments'>
  826     X     			.REM. *
  827     X     			.endm
  828    (3)    	    .iff
  829           		.MACRO REM comments
  830           			.endm
  831    (3)    	    .endc
  832    (2)    	.endc
  833    (1)        .endc
  834    (0)    .endc
  835           ;
  836           ; Use REMB,REMM,REME for multi-line comments, to be set off in output
  837           ;
  838           .MACRO	REMB comments
  839           .if true, OUTPUT_LANG != LANG_NONE
  840               .if true, OUTPUT_LANG == LANG_C
  841           	    .REM. </*>
  842               .iff
  843           	.if	true, OUTPUT_LANG == LANG_TXT
  844           	    .REM. <  >
  845           	.iff
  846           	    .if true, OUTPUT_LANG == LANG_ASRxk
  847           		.REM. <;#*>
  848           	    .iff
  849           		.REM. *
  850           	    .endc
  851           	.endc
  852               .endc
  853           .endc
  854           .endm
dispatch.c                               Atari Games Corp. macpp v9.12   "Oct 16 1997 13:26:41"


  855           ;
  856           .MACRO	REMM comments
  857           .if true, OUTPUT_LANG != LANG_NONE
  858               .if true, OUTPUT_LANG == LANG_C
  859           	.REM. < *> <'comments'>
  860               .iff
  861           	.if true, OUTPUT_LANG == LANG_TXT
  862           	    .REM. <  > <'comments'>
  863           	.iff
  864           	    .if true, OUTPUT_LANG == LANG_ASRxk
  865           		.REM. <;#* 'comments'>
  866           	    .iff
  867           		.REM. * <'comments'>
  868           	    .endc
  869           	.endc
  870               .endc
  871           .endc
  872           .endm
  873           ;
  874           .MACRO	REME comments
  875           .if true, OUTPUT_LANG != LANG_NONE
  876               .if true, OUTPUT_LANG == LANG_C
  877           	.REM. < */>
  878               .iff
  879           	.if true, OUTPUT_LANG == LANG_TXT
  880           	    .REM. <  >
  881           	.iff
  882           	    .if true, OUTPUT_LANG == LANG_ASRxk
  883           		.REM. <;#*>
  884           	    .iff
  885           		.REM. *
  886           	    .endc
  887           	.endc
  888               .endc
  889           .endc
  890           .endm
  891           ;
  892  0000000A 	.radix	10.
    1           ;/*		phx_vecs.mac
    2           ; *
    3           ; *		Copyright 1996 Atari Games Corporation
    4           ; *	Unauthorized reproduction, adaptation, distribution, performance or 
    5           ; *	display of this computer program or the associated audiovisual work
    6           ; *	is strictly prohibited.
    7           ; *
    8           ; *	This file is processed by MACPP to produce dispatch.c and intvecs.h.
    9           ; *
   10           ; *	The definitions placed in intvecs.h declare virtual vector numbers
   11           ; *	in the form of xxx_INTVEC and a cross reference table(s) so the
   12           ; *	dispatcher can call the appropriate functions.
   13           ; *
   14           ; *	intvecs.h should be #include'd by any module that uses prc_set_vec().
   15           ; */
   16           ;
   17           ; This file recursivley '.includes' itself to succesively build up the approprate
   18           ; tables and functions in C and places the results in one of two files (the
   19           ; first -out=file supplied on the MACPP command line is expected to be dispatch.c
dispatch.c                               Atari Games Corp. macpp v9.12   "Oct 16 1997 13:26:41"


   20           ; and the second -out=file is expected to be intvecs.h and the third is expected to
   21           ; be /dev/null). If you don't speak fluent MACPP, then you probably shouldn't be
   22           ; changing anything in this file other than the VDF table listed below.
   23           ;
   24    (0)    .if not_defined, _DISPATCH_MAC_		;1 +++++
   25  00000000 _DISPATCH_MAC_ == 0			;2 Don't move ...
   26  00000005 OUTPUT_LANG == 5 ;LANG_NONE		;3 ... or change ... 
   27  00000002 	.outfile 2			;4 ... anything on ...
   28           	.include config.mac		;5 ... these ...
    1+          ;	config.mac
    2+          ;
    3+          ;	This file defines which game (for the game-specific stuff) and
    4+          ;	"includes" the appropriate files for host board, video hardware,
    5+          ;	and game controls.
    6+          ;
    7+          ;	Project:	Phoenix
    8+          ;	Date:		April 1996
    9+          ;	Team:		Dave Shepperd, Forrest Miller, Mike Albaugh
   10+          ;
   11+   (1)    .if true, OUTPUT_LANG == LANG_C
   12+    X     #if !defined(_CONFIG_H_)
   13+    X     #define _CONFIG_H_
   14+   (1)    .endc
   15+          REM < Special Game Flags	>
   16+          ;
   17+          ; >>->  Define your processor and other hardware features
   18+          ;
   19+          	.include constants.mac
    1+          ; $Id: constants.mac,v 1.23 1997/07/01 20:54:19 shepperd Exp $
    2+          ;
    3+   (1)    .if ndf, _CONSTANTS_MAC_
    4+ 00000000 _CONSTANTS_MAC_ == 0
    5+   (2)     .if ndf,LANG_C
    6+    X       .error ;You must .include def_pp.mac before .including constants.mac
    7+   (2)     .endc
    8+   (2)    .if true, OUTPUT_LANG == LANG_C
    9+    X     #if !defined(_CONSTANTS_H_)
   10+    X     #define _CONSTANTS_H_
   11+   (2)    .endc
   12+          ;
   13+          ; Available processors (set the variable PROCESSOR to one of these)
   14+          ;
   15+          	HEX_CONST PROCESSOR_CLASS 0xFFFFFFF0
   16+          	HEX_CONST M68000	0x01
   17+          	HEX_CONST M68010	0x02
   18+          	HEX_CONST M68EC020	0x03
   19+          	HEX_CONST M68020	0x03
   20+          	HEX_CONST ASAP		0x10
   21+          	HEX_CONST MIPS3000	0x20		< MIPS 30x1 processor, big endian >
   22+          	HEX_CONST MIPS30x1	0x21		< MIPS 30x1 processor, big endian >
   23+          	HEX_CONST MIPS30x1L	0x22		< MIPS 30x1 processor, little endian >
   24+          	HEX_CONST MIPS4000	0x30		< MIPS 4000 processor, big endian >
   25+          	HEX_CONST MIPS4000L	0x31		< MIPS 4000 processor, little endian >
   26+          	HEX_CONST MIPS4600	0x32		< MIPS 4600 processor, big endian >
   27+          	HEX_CONST MIPS4600L	0x33		< MIPS 4600 processor, little endian >
   28+          	HEX_CONST MIPS4650	0x34		< MIPS 4650 processor, big endian >
   29+          	HEX_CONST MIPS4650L	0x35		< MIPS 4650 processor, little endian >
dispatch.c                               Atari Games Corp. macpp v9.12   "Oct 16 1997 13:26:41"


   30+          	HEX_CONST MIPS4700	0x36		< MIPS 4700 processor, big endian >
   31+          	HEX_CONST MIPS4700L	0x37		< MIPS 4700 processor, little endian >
   32+          	HEX_CONST MIPS5000	0x38		< MIPS 5000 processor, big endian >
   33+          	HEX_CONST MIPS5000L	0x39		< MIPS 5000 processor, little endian >
   34+          	HEX_CONST MIPS4300	0x3A		< MIPS 4300 processor, big endian >
   35+          	HEX_CONST MIPS4300L	0x3B		< MIPS 4300 processor, little endian >
   36+          ;
   37+          ; Various host boards (set the variable HOST_BOARD to one of these)
   38+          ;
   39+          	HEX_CONST HOST_BOARD_CLASS 0xFFFFFFF0
   40+          	HEX_CONST EC020cojag	1*0x10		< McKee's low cost EC020 host board, CoJag version >
   41+          	HEX_CONST EC020zoid10	2*0x10		< McKee's low cost EC020 host board, Zoid 10 version >
   42+          	HEX_CONST EC020zoid20	3*0x10		< McKee's low cost EC020 host board, Zoid 20 version >
   43+          	HEX_CONST MCUBE		4*0x10		< Mokris's 68k based host board >
   44+          	HEX_CONST ASCLEAP	5*0x10		< The ASAP based ASCLEAP >
   45+          	HEX_CONST LCR3K		6*0x10		< Low cost R3k host board >
   46+          	HEX_CONST IDT3xEVAL	7*0x10		< IDT's 3000 eval board with XBUS adapter >
   47+          	HEX_CONST IDT4xEVAL	8*0x10		< IDT's 4000 eval board with XBUS adapter >
   48+          	HEX_CONST MB4600	9*0x10		< Senthil and Mark's 4600 MathBox board >
   49+          	HEX_CONST HCR4K		10*0x10		< Senthil and Mark's 4600 Host board >
   50+          	HEX_CONST PSX		11*0x10		< Sony PSX >
   51+          	HEX_CONST PHOENIX	12*0x10+0	< WMS Host board >
   52+          	HEX_CONST PHOENIX_AD	12*0x10+1	< WMS Phoenix-AD board (Hockey) board >
   53+          	HEX_CONST FLAGSTAFF	12*0x10+2	< WMS Phoenix-Flagstaff (Rush) board >
   54+          	HEX_CONST SEATTLE	12*0x10+3	< WMS Phoenix-Seattle (Mace/CSpeed/Genocide) board >
   55+          	HEX_CONST VEGAS		12*0x10+4	< WMS Phoenix-Vegas (?) board >
   56+          	HEX_CONST CHAMELEON	12*0x10+5	< WMS Chameleon board >
   57+          ;
   58+          ; Various video boards (set the variable VIDEO_BOARD to one of these)
   59+          ;
   60+          	HEX_CONST ZOID10_V	1		< Zoid 10 stack		>
   61+          	HEX_CONST ZOID20_V	2		< Zoid 20 stack 	>
   62+          	HEX_CONST COJAG_V	3		< CoJag stack 		>
   63+          	HEX_CONST GX1_V		4		< FSG42 board		>
   64+          	HEX_CONST GX2_V		5		< GX2 board		>
   65+          	HEX_CONST GT_V		6		< GT board		>
   66+          	HEX_CONST SST_V		7		< 3DFX video board	>
   67+          	HEX_CONST PSX_V		8		< Sony PSX >
   68+          ;
   69+          ; Various game id's (set the variable COJAG_GAME to one of these)
   70+          ;
   71+          	HEX_CONST COJAG_PROTO	0x01		< Non-Game specific running on COJAG >
   72+          	HEX_CONST COJAG_HERO	0x02		< Hero on COJAG >
   73+          	HEX_CONST COJAG_AREA51	0x04		< Area 51 on COJAG >
   74+          	HEX_CONST COJAG_RAGE	0x08		< RAGE 2 on COJAG >
   75+          	HEX_CONST COJAG_FISH	0x10		< Tropical Fish on COJAG >
   76+          ;
   77+          ; Various game id's (set the variable ZOID_GAME to one of these)
   78+          ;
   79+          	HEX_CONST ZOID_PROTO	0x01		< Non-Game specific running on ZOID >
   80+          	HEX_CONST ZOID_HOCKEY	0x02		< Wayne Gretzky Hocky running on ZOID >
   81+          	HEX_CONST ZOID_GAUNTLET	0x04		< 3D Gauntlet running on ZOID >
   82+          	HEX_CONST ZOID20_DIAG	0x08		< Mike Albaugh developing ZOID 20 >
   83+          	HEX_CONST ZOID_RUSH	0x10		< SF Rush running on ZOID >
   84+          	HEX_CONST ZOID_MACE	0x20		< Mace running on ZOID >
   85+          	HEX_CONST ZOID20_DMS	0x40		< Dave Shepperd test ZOID >
   86+          ;
dispatch.c                               Atari Games Corp. macpp v9.12   "Oct 16 1997 13:26:41"


   87+          ; Various game id's (set the variable SST_GAME to one of these)
   88+          ;
   89+          	HEX_CONST SST_PROTO	0x01		< Non-Game specific running on 3DFX >
   90+          	HEX_CONST SST_DMS	0x02		< Dave Shepperd test 3DFX >
   91+          	HEX_CONST SST_RUSH	0x04		< RUSH 3DFX >
   92+          	HEX_CONST SST_HOCKEY	0x08		< Hockey 3DFX >
   93+          	HEX_CONST SST_MACE	0x10		< Mace 3DFX >
   94+          	HEX_CONST SST_SPEED	0x20		< Speed 3DFX >
   95+          	HEX_CONST SST_STAR	0x40		< Star (working title) 3DFX >
   96+          	HEX_CONST SST_JUKO	0x80		< Juko Thread 3DFX >
   97+          	HEX_CONST SST_GENO	0x100		< Genocide 3DFX >
   98+          	HEX_CONST SST_GAUNTLET	0x200		< 3Dfx Gauntlet >
   99+          	HEX_CONST SST_CRASH	0x400		< Crash (game) 3DFX >
  100+          	HEX_CONST SST_AIRRACE	0x800		< AirRace 3DFX (Blueshift) >
  101+          ;
  102+          ; Various game id's (set the variable PSX_GAME to one of these)
  103+          ;
  104+          	HEX_CONST PSX_PROTO	0x01		< Non-Game specific running on PSX >
  105+          	HEX_CONST PSX_RAGE2	0x02		< Primal Rage II on PSX >
  106+          ;
  107+          	HEX_CONST TRUE	1
  108+          	HEX_CONST FALSE	0
  109+          ;
  110+          	HEX_CONST ABORT	0
  111+          	HEX_CONST FAIL	-1
  112+          ;
  113+          	HEX_CONST IDE_COJAG	0x01		< For IDE on COJAG boards >
  114+          	HEX_CONST IDE_STREAM	0x02		< For IDE on STREAM boards >
  115+          	HEX_CONST IDE_PCI	0x03		< For IDE on PCI bus >
  116+          	HEX_CONST IDE_PSX	0x4		< For IDE on PSeXtra >
  117+          ;
  118+   (2)     .if ndf,ANSI_OK
  119+          	HEX_CONST ANSI_OK	1
  120+   (2)     .endc
  121+   (2)    .if true, OUTPUT_LANG == LANG_C
  122+    X     #endif			/* _CONSTANTS_H_ */
  123+   (2)    .endc
  124+   (1)    .endc			; _CONSTANTS_MAC_
   20+          	HEX_CONST PROCESSOR		MIPS5000L
   21+          ;
   22+          	.include pptypes.mac
    1+          ; $Id: pptypes.mac,v 1.13 1997/07/01 20:54:19 shepperd Exp $
    2+          ;
    3+   (1)    .if ndf, _PPTYPES_MAC_
    4+ 00000000 _PPTYPES_MAC_	== 0
    5+   (2)     .if ndf,M68000
    6+    X        .warn ;You should .include constants.mac before .including pptypes.mac
    7+    X        .include constants.mac
    8+   (2)     .endc
    9+   (2)     .if ndf,PROCESSOR
   10+    X        .error ;You need to define PROCESSOR before .including pptypes.mac
   11+    X        HEX_CONST PROCESSOR 0
   12+   (2)     .endc
   13+   (2)    .if true, OUTPUT_LANG == LANG_C
   14+    X     #if !defined(_PPTYPES_H_)
   15+    X     #define _PPTYPES_H_
   16+   (2)    .endc
dispatch.c                               Atari Games Corp. macpp v9.12   "Oct 16 1997 13:26:41"


   17+   (2)     .if ndf,NO_LONGLONG
   18+             HEX_CONST NO_LONGLONG 1
   19+   (2)     .endc
   20+          ;
   21+          ;
   22+          REM <	Actual Type Declarations>
   23+          ;
   24+   (2)     .if ne,ANSI_OK
   25+   (3)      .if true, ((NO_LONGLONG == 0) && ((PROCESSOR & -16) == MIPS4000))
   26+    X     	TYPE	VS64	<volatile long long> 8
   27+    X     	TYPE	VU64	<volatile unsigned long long> 8
   28+   (3)      .endc
   29+          	TYPE	VS32	<volatile long> 4
   30+          	TYPE	VS16	<volatile short> 2
   31+          	TYPE	VS8	<volatile signed char> 1
   32+          	TYPE	VS08	<volatile signed char> 1
   33+          	TYPE	VU32	<volatile unsigned long> 4
   34+          	TYPE	VU16	<volatile unsigned short> 2
   35+          	TYPE	VU8	<volatile unsigned char> 1
   36+          	TYPE	VU08	<volatile unsigned char> 1
   37+          	TYPE	VF32	<volatile float> 4
   38+          	TYPE	VF64	<volatile double> 8
   39+   (2)     .endc
   40+   (2)     .if eq,ANSI_OK
   41+    X       .if true, ((NO_LONGLONG == 0) && ((PROCESSOR & -16) == MIPS4000))
   42+    X     	TYPE	VS64	< long long> 8
   43+    X     	TYPE	VU64	< unsigned long long> 8
   44+    X       .endc
   45+    X     	TYPE	VS32	< long> 4
   46+    X     	TYPE	VS16	< short> 2
   47+    X     	TYPE	VS8	< char> 1
   48+    X     	TYPE	VS08	< char> 1
   49+    X     	TYPE	VU32	< unsigned long> 4
   50+    X     	TYPE	VU16	< unsigned short> 2
   51+    X     	TYPE	VU8	< unsigned char> 1
   52+    X     	TYPE	VU08	< unsigned char> 1
   53+    X     	TYPE	VF32	< float> 4
   54+    X     	TYPE	VF64	< double> 8
   55+   (2)     .endc
   56+   (2)     .if true ,(PROCESSOR == M68010) || (PROCESSOR == M68000)
   57+    X     	TYPE	m_int	<short> 2 
   58+    X     	TYPE	m_uint	<unsigned short> 2
   59+   (2)     .iff
   60+          	TYPE	m_int	<int> 4 
   61+          	TYPE	m_uint	<unsigned int> 4
   62+   (2)     .endc
   63+          	TYPE	U8	<unsigned char> 1
   64+          	TYPE	U08	<unsigned char> 1
   65+   (2)     .if ne,ANSI_OK
   66+          	TYPE	S8	<signed char> 1
   67+          	TYPE	S08	<signed char> 1
   68+   (2)     .iff
   69+    X     	TYPE	S8	<char> 1
   70+    X     	TYPE	S08	<char> 1
   71+   (2)     .endc
   72+          	TYPE	U16	<unsigned short> 2
   73+          	TYPE	S16	<short> 2
dispatch.c                               Atari Games Corp. macpp v9.12   "Oct 16 1997 13:26:41"


   74+          	TYPE	U32	<unsigned long> 4
   75+          	TYPE	S32	<long> 4
   76+          	TYPE	F32	<float> 4
   77+          	TYPE	F64	<double> 8
   78+   (2)     .if true, ((NO_LONGLONG == 0) && ((PROCESSOR & -16) == MIPS4000))
   79+    X     	TYPE	U64	< unsigned long long> 8
   80+    X     	TYPE	S64	< long long> 8
   81+   (2)     .endc
   82+          	TYPE	RD_TYP	<struct rdb> 12
   83+          	TYPE	RR_TYP	<struct rrb> 16
   84+          	TYPE	MN_TYP	<struct menub> 8
   85+          	TYPE	PB_TYP	<struct pconfigp> 8
   86+          	TYPE	CR_TYP	<struct creditsb> 4
   87+          ;
   88+   (2)    	.if	eq,OUTPUT_LANG-LANG_C
   89+    X     struct menu_d {
   90+    X     	char	*mn_label;		    /* menu item label		*/
   91+    X     	int	(*mn_call)(const struct menu_d*); /* menu item routine call	*/
   92+    X     };
   93+          ;
   94+    X     struct menub {
   95+    X     	char		*mn_label;	/* menu item label		*/
   96+    X     	void		(*mn_call)();	/* menu item routine call	*/
   97+    X     };
   98+          ;
   99+    X     struct creditsb {
  100+    X     	unsigned short	crd_whole;	/* Integer part of coins	*/
  101+    X     	unsigned char	crd_num;	/* numerator			*/
  102+    X     	unsigned char	crd_denom;	/* denominator			*/
  103+    X     };
  104+    X     REM <	General purpose Environment Table structure>
  105+    X     	STR_START	st_envar
  106+    X     	STR_ELT		name <const char *> 1 < for lookup>
  107+    X     	STR_ELT		value <const void *> 1 < could point to anything>
  108+    X     	STR_ELT		next <const struct st_envar *> 1 < chain >
  109+    X     	STR_ELT		version <unsigned long> 1 < not yet used>
  110+    X     	STR_END		st_envar
  111+   (2)    	.endc
  112+          ;
  113+          REM <	Structure to describe RAM area to test>
  114+          	STR_START	rdb
  115+          	STR_ELT		rd_base	<unsigned long *> 1 < Starting address >
  116+          	STR_ELT		rd_len	<unsigned long>	1 < Length in bytes >
  117+          	STR_ELT		rd_misc	<unsigned long>	1 < Which bits exist>
  118+          	STR_END		rdb
  119+          ;
  120+          REM <	Structure to describe the non-processor specific post mortem variables >
  121+   (2)    .if not_defined, PM_TEXT_SIZE
  122+          	DEC_CONST PM_TEXT_SIZE	80	<Up to 80 bytes of postmortem text>
  123+   (2)    .endc
  124+          	STR_START pm_general
  125+          	STR_ELT	pm_msg		<const char *> 1 <Pointer to message>
  126+          	STR_ELT pm_text		char PM_TEXT_SIZE <Local copy of text message>
  127+          	STR_ELT	pm_stack	U32* 1	<Stack pointer in target's address space>
  128+          	STR_ELT pm_stkupper	U32* 1  <Stack upper limit in target's address space>
  129+          	STR_ELT pm_stklower	U32* 1  <Stack lower limit in target's address space>
  130+          	STR_ELT pm_stkrelative	U32* 1  <Stack pointer in host's address space>
dispatch.c                               Atari Games Corp. macpp v9.12   "Oct 16 1997 13:26:41"


  131+          	STR_ELT	pm_cntr		S32  1	<Post mortem flag>
  132+          	STR_ELT	pm_pc		U32  1	<Program counter>
  133+          	STR_ELT	pm_sr		U32  1	<Status register>
  134+          	STR_ELT pm_regs		U32  32 <ASAP/R3K/R4K have 32. 68k only uses 16 of these>
  135+          	STR_ELT pm_cause	U32  1	<R3K/R4K cause register>
  136+          	STR_ELT pm_badvaddr	U32  1  <R3K/R4K bad virtual address register>
  137+          	STR_END pm_general
  138+   (2)    .if true, OUTPUT_LANG == LANG_C
  139+    X     # define _PM_GENERAL_STRUCT_	0	/* Disable the definition in st_proto.h */
  140+    X     # define PM_68K_SIZE	(sizeof(struct pm_general)-(18*4))
  141+    X     # define PM_RxK_SIZE	(sizeof(struct pm_general))
  142+   (2)    .iff
  143+   (3)     .if true, OUTPUT_LANG == LANG_ASRxK		;GNU assembler
  144+    X     	DEC_CONST PM_68K_SIZE	(S_SIZ_PM_GENERAL-(18*4))
  145+    X     	DEC_CONST PM_RxK_SIZE	(S_SIZ_PM_GENERAL)
  146+   (3)     .endc
  147+   (2)    .endc
  148+          ;
  149+          ;
  150+          REM <	Structure for optional return of RAM test results>
  151+          	STR_START	rrb
  152+          	STR_ELT		rr_addr <unsigned long *>	1 < Where it choked >
  153+          	STR_ELT		rr_expected <unsigned long>	1 < What it wanted >
  154+          	STR_ELT		rr_got	<unsigned long>		1 < What it got>
  155+          	STR_ELT		rr_test_no	<int>		1 < Which test >
  156+          	STR_END		rrb
  157+          ;
  158+          	HEX_CONST B_NO_ROM_TEST	0	< bit # in p_debug_options to skip ROM checksum	>
  159+          	HEX_CONST NO_ROM_TEST	(1<<B_NO_ROM_TEST)
  160+          	HEX_CONST B_NO_RAM_TEST	1	< bit # in p_debug_options to skip RAM test	>
  161+          	HEX_CONST NO_RAM_TEST	(1<<B_NO_RAM_TEST)
  162+          	HEX_CONST B_NO_LOG_RESET 2	< bit # in p_debug_options to skip logging RESET>
  163+          	HEX_CONST NO_LOG_RESET	(1<<B_NO_LOG_RESET)
  164+   (2)    .if true, OUTPUT_LANG == LANG_C
  165+    X     #endif			/* _PPTYPES_H_ */
  166+   (2)    .endc
  167+   (1)    .endc			;_PPTYPES_MAC_
   23+          ;
   24+          	HEX_CONST VIDEO_BOARD 		SST_V
   25+          ;
   26+          	DEC_CONST VIS_H_PIX		512.
   27+          	DEC_CONST VIS_V_PIX		384
   28+          	DEC_CONST DYNAMIC_PIXEL_CLOCK	1	;Enable pixel clock selection
   29+          	DEC_CONST DYNAMIC_GAMMA_CORRECTION 1	;Enable dynamic gamma correction
   30+          	DEC_CONST NO_FRBIT		0	< Allow the FR bit >
   31+          	DEC_CONST SQUAWK_ON_EXCEPT	0
   32+          	DEC_CONST TIME_EXCEPTIONS	0
   33+          	DEC_CONST BOOT_COPY_SELF	1	;Boot ourself
   34+          	DEC_CONST BOOT_FROM_DISK	1	;Boot from H.D.
   35+          	DEC_CONST NO_NMI_DETECTION	1	;Don't check for NMI
   36+          ;	DEC_CONST NO_FFUNCTS		1	;Don't include fputs() et al. in phx_stubs.c
   37+          	DEC_CONST NO_EXIT_FUNC		1	;Don't include exit() et al. in phx_stubs.c
   38+          ;	DEC_CONST STOP_ON_ERROR		1	;stop and loop on memory errors
   39+          	DEC_CONST NO_AUTO_TEST_MENU	1	;Don't put up a RAM TEST ALL menu item
   40+          	DEC_CONST NO_EER_WRITE		1	< Disable BRAM updates >
   41+          	DEC_CONST NO_BRAM_AUS		1	;Don't prompt for 'ok' in bram test.
   42+          	DEC_CONST NO_WDOG		1	;No WDOG in this code
dispatch.c                               Atari Games Corp. macpp v9.12   "Oct 16 1997 13:26:41"


   43+          	DEC_CONST NO_ROM_TEST_MENU	1	;Don't include standard ROM test menu item
   44+          	DEC_CONST ANNOUNCE_BOOT_ACTIONS 1	;squawk at boot
   45+          ;	DEC_CONST TEST_MEM64		1	;do 64 bit memory test
   46+          ;	DEC_CONST TEST_MEM32		1	;do 32 bit memory test
   47+          ;	DEC_CONST TEST_WALKING1		1	;enable walking one's
   48+          ;	DEC_CONST TEST_REFRESH		1	;enable refresh test
   49+          	DEC_CONST SMC_SA_TESTS		1	;enable standalone test messages
   50+          	DEC_CONST SA_DIAGS		1	;enable standalone diags
   51+          ;
   52+          	DEC_CONST INCLUDE_QIO		1	< Include the QIO subsystem >
   53+          	DEC_CONST INCLUDE_FSYS		1	< Include the FSYS subsystem >
   54+          	DEC_CONST INCLUDE_IDE		1	< Include special IDE interrupt in shims >
   55+          	DEC_CONST QIO_POOL_SIZE		(512*1024) < QIO and FSYS use this area. >
   56+          	DEC_CONST JUNK_POOL_SIZE	-1	< Use all available space for malloc et al >
   57+                  DEC_CONST ICELESS_AST           1	< Use the new method of vectoring iceless interrupts >
   58+          ;
   59+   (1)    .if true, OUTPUT_LANG == LANG_C
   60+    X     #define NO_GAME_LINKTIME		1	/* Don't show game link time */
   61+    X     #define LINKTIME_X			((AN_VIS_COL-26)/2)	/* Center the link time(s) */
   62+    X     #define SST_REFRESH_RATE		GR_REFRESH_60Hz
   63+    X     #define SST_COLOR_FORMAT		GR_COLORFORMAT_ARGB
   64+    X     #define SST_ORIGIN			GR_ORIGIN_LOWER_LEFT
   65+    X      .if defined, ANNOUNCE_BOOT_ACTIONS
   66+    X       .if true, ANNOUNCE_BOOT_ACTIONS
   67+    X     extern int shims_puts(const char *s);
   68+    X     extern int shims_printf(const char *ctl, ...);
   69+    X     #define BLAB(x) shims_puts(x)
   70+    X     #define BLABF(x) shims_printf x
   71+    X       .endc
   72+    X      .endc
   73+   (1)    .endc
   74+          ;
   75+          	DEC_CONST MENU_X_DEFAULT	-1	< Default X position for menu items >
   76+          ;	DEC_CONST INCLUDE_FEXCP		1	< Include floating point exception handler >
   77+          	DEC_CONST IDE_TYPE	IDE_PCI		< PCI I/O >
   78+          	DEC_CONST IDE_RW_VIA_DMA 1		< Allow DMA r/w >
   79+          	DEC_CONST ICELESS_IO		FALSE
   80+          ;
   81+          	DEC_CONST CPU_SPEED	150000000	< CPU clock speed in Hertz >
   82+          	DEC_CONST BUS_SPEED	 50000000	< Bus (Galileo) clock speed in Hertz >
   83+          	DEC_CONST PCI_SPEED	 33333333	< PCI (Galileo) clock speed in Hertz >
   84+          	DEC_CONST SST_GAME	SST_DMS		< test game >
   85+          ;
   86+   (1)    .if true, (OUTPUT_LANG == LANG_C)
   87+    X     #define DEBUG		1
   88+    X     #ifndef HDW_INIT
   89+    X     # define HDW_INIT(x) do { \
   90+    X     	extern void hdw_init(int); \
   91+    X     	hdw_init(x);\
   92+    X     } while (0)
   93+    X     #endif
   94+   (1)    .endc
   95+          ;
   96+          ;NOTE: For ICELESS turn on DBG_ASN and assign it to interrupt 5 since that is where the
   97+          ;dispatcher is expecting the iceless interrupt to appear (CPU level 7). Next assign ICELESS_LVL
   98+          ;to either a 1 or 3 depending on which expansion slot.
   99+          ;
dispatch.c                               Atari Games Corp. macpp v9.12   "Oct 16 1997 13:26:41"


  100+ 00000005 	DBG_ASN == 5				; DEBUG switch interrupt comes in on level 5
  101+ 00000000 	TM3_ASN == 0				;Enable Galileo interrupt code on INT0_LVL
  102+ 00000000 	DM0_ASN == 0
  103+          ;	DM1_ASN == 0
  104+          ;	DM2_ASN == 0
  105+          ;	DM3_ASN == 0
  106+ 00000001         IOA_ASN == 1                            ;Enable I/O ASIC interrupt code on INT1_LVL
  107+ 00000002 	IDE_ASN == 2				;Enable IDE interrupt servicing on INT2_LVL
  108+ 00000003 	VSY_ASN == 3				;Enable VSYNC interrupt servicing in INT3_LVL
  109+ 00000004 	NSS_ASN == 4
  110+ 00000005 	EXP_ASN == 5				;Enable expansion slot (ICELESS) interrupt on INT5_LVL
  111+          ;
  112+          	.include seattle.mac
    1+          ; $Id: seattle.mac,v 1.8 1997/09/02 22:14:17 shepperd Exp $
    2+          ;
    3+   (1)    .if ndf, _SEATTLE_MAC_
    4+ 00000000 _SEATTLE_MAC_ == 0
    5+   (2)    .if ndf, _CONSTANTS_MAC_
    6+    X       .warn ;You should .include constants.mac before including seattle.mac
    7+    X       .include constants.mac
    8+   (2)    .endc
    9+   (2)    .if ndf, _PPTYPES_MAC_
   10+    X       .warn ;You should .include pptypes.mac before including seattle.mac
   11+    X       .include pptypes.mac
   12+   (2)    .endc
   13+          ;
   14+   (2)    .if ndf,HOST_BOARD
   15+          	HEX_CONST HOST_BOARD	SEATTLE
   16+   (2)    .endc
   17+   (2)    .if ndf,NUCLEUS_OS
   18+          	HEX_CONST NUCLEUS_OS	0
   19+   (2)    .endc
   20+   (2)    .if ndf,PROCESSOR
   21+    X     	HEX_CONST PROCESSOR	MIPS5000L
   22+   (2)    .endc
   23+          ;
   24+          REM <	WMS Seattle board specific definitions (almost the same as PHOENIX_AD)>
   25+          ;
   26+          ; Little-Endian Byte offset is (bit offset)>>3
   27+          	HEX_CONST WORD0_OFFS 0
   28+          	HEX_CONST WORD32_OFFS 4
   29+          	HEX_CONST SHORT0_OFFS 0
   30+          	HEX_CONST SHORT16_OFFS 2
   31+          	HEX_CONST BYTE0_OFFS 0
   32+          	HEX_CONST BYTE8_OFFS 1
   33+          	HEX_CONST BYTE16_OFFS 2
   34+          	HEX_CONST BYTE24_OFFS 3
   35+          ; Little-Endian Byte offset (in 64 bit address space) is (bit offset)>>3
   36+          	HEX_CONST HWORD0_OFFS 0
   37+          	HEX_CONST HWORD32_OFFS 4
   38+          	HEX_CONST HSHORT0_OFFS 0
   39+          	HEX_CONST HSHORT16_OFFS 2
   40+          	HEX_CONST HSHORT32_OFFS 4
   41+          	HEX_CONST HSHORT48_OFFS 6
   42+          	HEX_CONST HBYTE0_OFFS 0
   43+          	HEX_CONST HBYTE8_OFFS 1
   44+          	HEX_CONST HBYTE16_OFFS 2
dispatch.c                               Atari Games Corp. macpp v9.12   "Oct 16 1997 13:26:41"


   45+          	HEX_CONST HBYTE24_OFFS 3
   46+          	HEX_CONST HBYTE32_OFFS 4
   47+          	HEX_CONST HBYTE40_OFFS 5
   48+          	HEX_CONST HBYTE48_OFFS 6
   49+          	HEX_CONST HBYTE56_OFFS 7
   50+          REMB
   51+          REMM <The R4k virtual memory map appears as the	following:		>
   52+          REME
   53+          ;  
   54+          	HEX_CONST MEM_KUSEG	0x00000000 < -0x7FFFFFFF (  2GB, mapped, cached)	>
   55+          	HEX_CONST MEM_KSEG0	0x80000000 < -0x9FFFFFFF phys 00000000-1FFFFFFF (512MB, unmapped, cached)	>
   56+          	HEX_CONST MEM_KSEG1	0xA0000000 < -0xBFFFFFFF phys 00000000-1FFFFFFF (512MB, unmapped, uncached)	>
   57+          	HEX_CONST MEM_KSSEG	0xC0000000 < -0xDFFFFFFF (512MB, mapped)		>
   58+          	HEX_CONST MEM_KSEG3	0xE0000000 < -0xFFFFFFFF (512MB, mapped)		>
   59+          ;
   60+          	HEX_CONST DRAM_BASE	0x80000000 < DRAM phys 0x00000000-0x007FFFFF >
   61+          	HEX_CONST DRAM_BASEnc	0xA0000000 < DRAM phys 0x00000000-0x007FFFFF (uncached) >
   62+   (2)    .if not_defined, DRAM_BANK_SIZE
   63+          	HEX_CONST DRAM_BANK_SIZE 0x00800000 < Defaults to 8MB per bank >
   64+   (2)    .endc
   65+   (2)    .if not_defined, DRAM_BANKS
   66+          	DEC_CONST DRAM_BANKS	1	   < Defaults to 1 banks of DRAM >
   67+   (2)    .endc
   68+   (2)    .if not_defined, DRAM_SIZE
   69+          	HEX_CONST DRAM_SIZE	DRAM_BANKS*DRAM_BANK_SIZE < DRAM size >
   70+   (2)    .endc
   71+          	HEX_CONST PCI_MEM_BASE	0xA8000000 < -0x29FFFFFF PCI Memory bus (uncached) >
   72+          	HEX_CONST PCI_IO_BASE	0xAA000000 < -0x2BFFFFFF PCI I/O bus (uncached) >
   73+          	HEX_CONST GALILEO_BOOT_BASE 0xB4000000 < -0xB40FFFFF GALILEO registers right after reset >
   74+          	HEX_CONST GALILEO_BASE	0xAC000000 < -0x2C0FFFFF GALILEO registers (uncached) >
   75+          	HEX_CONST GALILEO_CS0	0xB0000000 < -0x31FFFFFF CS0, debug connector, (uncached) >
   76+          	HEX_CONST GALILEO_CS1	0xB2000000 < -0x32FFFFFF CS1, debug connector, (uncached) >
   77+          	HEX_CONST AUDIO_FIFO	0xB3000000 < -0x33FFFFFF CS1, audio FIFO's, (uncached) >
   78+          	HEX_CONST GALILEO_CS2	0xB4000000 < -0x35FFFFFF CS2, A/D convertor (uncached) >
   79+          	HEX_CONST A_TO_D	GALILEO_CS2 < bits  7:0 (rw) = A/D converter >
   80+          	HEX_CONST GALILEO_CS3	0xB6000000 < -0x37FFFFFF CS3, Motherboard I/O and registers >
   81+          	HEX_CONST OBIO_BASE	GALILEO_CS3 <            On board I/O base (uncached) >
   82+          	HEX_CONST PROM_BASEnc	0xBFC00000 < -0xBFFFFFFF PROM phys (uncached) >
   83+          	HEX_CONST PROM_BASE	0x9FC00000 < -0x9FFFFFFF PROM phys (cached) >
   84+          	HEX_CONST CACHE_MEM_BASE DRAM_BASE+0x00000000
   85+          ;
   86+          	HEX_CONST IOASIC_BASE	OBIO_BASE+0x00000000
   87+          	HEX_CONST BUS_SCALE	4
   88+   (2)    .if not_defined, WHICH_IOASIC
   89+          	.include ioasic.mac
    1+   (3)    .if ndf, _IOASIC_MAC_
    2+ 00000000   _IOASIC_MAC_ == 0
    3+   (4)      .if ndf, IOASIC_BASE
    4+    X         .error ;You must define IOASIC_BASE before including ioasic.mac
    5+    X         HEX_CONST IOASIC_BASE 0
    6+   (4)      .endc
    7+   (4)      .if ndf, BUS_SCALE
    8+    X         .error ;You must define BUS_SCALE before including ioasic.mac
    9+    X         HEX_CONST BUS_SCALE 0
   10+   (4)      .endc
   11+          ;
   12+          .define IOASIC_BASIC_TYPE VU16
dispatch.c                               Atari Games Corp. macpp v9.12   "Oct 16 1997 13:26:41"


   13+          	.macro IO_ASIC_REG sym, comments
   14+          	 HEX_CONST sym	IOASIC_BASE+(...n*BUS_SCALE)	<comments>
   15+          	VAR	'sym'_T	VU16	sym	<comments>
   16+          	 ...n == ...n + 1
   17+          	.endm
   18+          ;
   19+ 00000000 	...n == 0
   20+          ;
   21+          	IO_ASIC_REG		IO_DIPSW		< bits 15:0 (ro) = dip switches >
   22+          	HEX_CONST IO_DIPSW0	0x00000001		< dip switch 0 >
   23+          	HEX_CONST IO_DIPSW1	0x00000002		< dip switch 1 >
   24+          	HEX_CONST IO_DIPSW2	0x00000004		< dip switch 2 >
   25+          	HEX_CONST IO_DIPSW3	0x00000008		< dip switch 3 >
   26+          	HEX_CONST IO_DIPSW4	0x00000010		< dip switch 4 >
   27+          	HEX_CONST IO_DIPSW5	0x00000020		< dip switch 5 >
   28+          	HEX_CONST IO_DIPSW6	0x00000040		< dip switch 6 >
   29+          	HEX_CONST IO_DIPSW7	0x00000080		< dip switch 7 >
   30+          	HEX_CONST IO_DIPSW8	0x00000100		< dip switch 8 >
   31+          	HEX_CONST IO_DIPSW9	0x00000200		< dip switch 9 >
   32+          	HEX_CONST IO_DIPSW10	0x00000400		< dip switch 10 >
   33+          	HEX_CONST IO_DIPSW11	0x00000800		< dip switch 11 >
   34+          	HEX_CONST IO_DIPSW12	0x00001000		< dip switch 12 >
   35+          	HEX_CONST IO_DIPSW13	0x00002000		< dip switch 13 >
   36+          	HEX_CONST IO_DIPSW14	0x00004000		< dip switch 14 >
   37+          	HEX_CONST IO_DIPSW15	0x00008000		< dip switch 15 >
   38+          ;
   39+          	IO_ASIC_REG		IO_MISC			< bits 15:0 (ro) = misc inputs >
   40+          	HEX_CONST IO_MISC0	0x00000001		< miscellaneos input 0 >
   41+          	HEX_CONST IO_MISC1	0x00000002		< miscellaneos input 1 >
   42+          	HEX_CONST IO_MISC2	0x00000004		< miscellaneos input 2 >
   43+          	HEX_CONST IO_MISC3	0x00000008		< miscellaneos input 3 >
   44+          	HEX_CONST IO_MISC4	0x00000010		< miscellaneos input 4 >
   45+          	HEX_CONST IO_MISC5	0x00000020		< miscellaneos input 5 >
   46+          	HEX_CONST IO_MISC6	0x00000040		< miscellaneos input 6 >
   47+          	HEX_CONST IO_MISC7	0x00000080		< miscellaneos input 7 >
   48+          	HEX_CONST IO_MISC8	0x00000100		< miscellaneos input 8 >
   49+          	HEX_CONST IO_MISC9	0x00000200		< miscellaneos input 9 >
   50+          	HEX_CONST IO_MISC10	0x00000400		< miscellaneos input 10 >
   51+          	HEX_CONST IO_MISC11	0x00000800		< miscellaneos input 11 >
   52+          	HEX_CONST IO_MISC12	0x00001000		< miscellaneos input 12 >
   53+          	HEX_CONST IO_MISC13	0x00002000		< miscellaneos input 13 >
   54+          	HEX_CONST IO_MISC14	0x00004000		< miscellaneos input 14 >
   55+          	HEX_CONST IO_MISC15	0x00008000		< miscellaneos input 15 >
   56+          ;
   57+          	IO_ASIC_REG		IO_PLAYER_21		< bits 15:0 (ro) = player 1 and player 2 inputs >
   58+          	HEX_CONST IO_PLYR1_0	0x00000001		< player 1 switch 0 >
   59+          	HEX_CONST IO_PLYR1_1	0x00000002		< player 1 switch 1 >
   60+          	HEX_CONST IO_PLYR1_2	0x00000004		< player 1 switch 2 >
   61+          	HEX_CONST IO_PLYR1_3	0x00000008		< player 1 switch 3 >
   62+          	HEX_CONST IO_PLYR1_4	0x00000010		< player 1 switch 4 >
   63+          	HEX_CONST IO_PLYR1_5	0x00000020		< player 1 switch 5 >
   64+          	HEX_CONST IO_PLYR1_6	0x00000040		< player 1 switch 6 >
   65+          	HEX_CONST IO_PLYR1_7	0x00000080		< player 1 switch 7 >
   66+          	HEX_CONST IO_PLYR2_0	0x00000100		< player 2 switch 0 >
   67+          	HEX_CONST IO_PLYR2_1	0x00000200		< player 2 switch 1 >
   68+          	HEX_CONST IO_PLYR2_2	0x00000400		< player 2 switch 2 >
   69+          	HEX_CONST IO_PLYR2_3	0x00000800		< player 2 switch 3 >
dispatch.c                               Atari Games Corp. macpp v9.12   "Oct 16 1997 13:26:41"


   70+          	HEX_CONST IO_PLYR2_4	0x00001000		< player 2 switch 4 >
   71+          	HEX_CONST IO_PLYR2_5	0x00002000		< player 2 switch 5 >
   72+          	HEX_CONST IO_PLYR2_6	0x00004000		< player 2 switch 6 >
   73+          	HEX_CONST IO_PLYR2_7	0x00008000		< player 2 switch 7 >
   74+          ;
   75+          	IO_ASIC_REG		IO_PLAYER_43		< bits 15:0 (ro) = player 3 and player 4 inputs >
   76+          	HEX_CONST IO_PLYR3_0	0x00000001		< player 3 switch 0 >
   77+          	HEX_CONST IO_PLYR3_1	0x00000002		< player 3 switch 1 >
   78+          	HEX_CONST IO_PLYR3_2	0x00000004		< player 3 switch 2 >
   79+          	HEX_CONST IO_PLYR3_3	0x00000008		< player 3 switch 3 >
   80+          	HEX_CONST IO_PLYR3_4	0x00000010		< player 3 switch 4 >
   81+          	HEX_CONST IO_PLYR3_5	0x00000020		< player 3 switch 5 >
   82+          	HEX_CONST IO_PLYR3_6	0x00000040		< player 3 switch 6 >
   83+          	HEX_CONST IO_PLYR3_7	0x00000080		< player 3 switch 7 >
   84+          	HEX_CONST IO_PLYR4_0	0x00000100		< player 4 switch 0 >
   85+          	HEX_CONST IO_PLYR4_1	0x00000200		< player 4 switch 1 >
   86+          	HEX_CONST IO_PLYR4_2	0x00000400		< player 4 switch 2 >
   87+          	HEX_CONST IO_PLYR4_3	0x00000800		< player 4 switch 3 >
   88+          	HEX_CONST IO_PLYR4_4	0x00001000		< player 4 switch 4 >
   89+          	HEX_CONST IO_PLYR4_5	0x00002000		< player 4 switch 5 >
   90+          	HEX_CONST IO_PLYR4_6	0x00004000		< player 4 switch 6 >
   91+          	HEX_CONST IO_PLYR4_7	0x00008000		< player 4 switch 7 >
   92+          ;
   93+          	IO_ASIC_REG		IO_UART_CTL		< bits 15:0 (rw) = UART control bits >
   94+   (4)    .if not_defined,IO_XTAL_FREQ
   95+          	DEC_CONST IO_XTAL_FREQ	16667000		< XTAL frequency for IOASIC >
   96+   (4)    .endc
   97+          	HEX_CONST IO_UART_CTL_BAUD_MASK		0x7f	< Register Baud Rate Field >
   98+          	DEC_CONST IO_UART_CTL_38_4_BAUD		(IO_XTAL_FREQ/(32*38400))-1 < Code for 38.4K Baud >
   99+          	DEC_CONST IO_UART_CTL_19_2_BAUD		(IO_XTAL_FREQ/(32*19200))-1 < Code for 19.2K Baud >
  100+          	DEC_CONST IO_UART_CTL_9600_BAUD		(IO_XTAL_FREQ/(32*9600))-1  < Code for 9600 Baud >
  101+          	DEC_CONST IO_UART_CTL_4800_BAUD		(IO_XTAL_FREQ/(32*4800))-1  < Code for 4800 Baud >
  102+          	HEX_CONST IO_UART_CTL_GP_OUT		0x0080	< General Purpose Output Bit >
  103+          	HEX_CONST IO_UART_CTL_INTERNAL_ENA	0x0200	< 1 = Enable UART; 0 = Clear UART >
  104+          	HEX_CONST IO_UART_CTL_ENABLE_ERRORS	0x0400	< 1 = Enable Overrun and Framing Errors and Break Detect >
  105+          	HEX_CONST IO_UART_CTL_ENABLE_LOOP_BACK	0x0800	< 1 = Enable Internal Loop-back Mode >
  106+          	HEX_CONST IO_UART_CTL_DISABLE_XMITTER	0x1000	< 1 = Prevents data from being sent to the wire >
  107+          	HEX_CONST IO_UART_CTL_FORCE_BREAK_OUT	0x2000	< 1 = Force Transmitter Data Output True (BREAK) >
  108+          	HEX_CONST IO_UART_CTL_IGNORE_CTS_IN	0x4000	< 1 = Ignore CTS Input >
  109+          	HEX_CONST IO_UART_CTL_FORCE_CTS_OUT	0x8000	< 1 = Force CTS False; 0 = Receiver controls CTS >
  110+          ;
  111+          	IO_ASIC_REG		IO_UART_TX		< bits  7:0 (rw) = UART transmit register >
  112+          	IO_ASIC_REG		IO_UART_RCV		< bits 15:0 (ro) = UART receive/status registers >
  113+          	HEX_CONST IO_UART_RCV_CHAR_MASK		0x00ff	< Character Mask >
  114+          	HEX_CONST IO_UART_RCV_BREAK_DETECT	0x0100	< Break Detect Status >
  115+          	HEX_CONST IO_UART_RCV_FRAME_ERROR	0x0200	< Framing Error Status >
  116+          	HEX_CONST IO_UART_RCV_OVER_RUN		0x0400	< Overrun Error Status >
  117+          	HEX_CONST IO_UART_RCV_FULL		0x0800	< Receiver FIFO Full >
  118+          	HEX_CONST IO_UART_RCV_CHAR		0x1000	< Received Character Ready >
  119+          	HEX_CONST IO_UART_XMT_EMPTY		0x2000	< Transmitter Empty >
  120+          	HEX_CONST IO_UART_RCV_CTS_IN		0x4000	< CTS In True >
  121+          	HEX_CONST IO_UART_RCV_CTS_OUT		0x8000	< CTS Out True >
  122+          	HEX_CONST IO_UART_RCV_FIFO_SIZE		4	< Internal Receiver FIFO Size >
  123+          ;
  124+          	IO_ASIC_REG		IO_METER		< bits  4:0 (rw) = meter control register >
  125+          	IO_ASIC_REG		IO_H2SND_CTL		< bits 15:0 (rw) = Host to Sound control register >
  126+          	HEX_CONST IO_H2SND_CTL_SND_ENA		0x0001	< Resets (0) or Enables (1) the Sound Sub-System >
dispatch.c                               Atari Games Corp. macpp v9.12   "Oct 16 1997 13:26:41"


  127+          	HEX_CONST B_IO_H2SND_CTL_SND_ENA	0	< Resets (0) or Enables (1) the Sound Sub-System bit number >
  128+          	HEX_CONST IO_H2SND_CTL_FIFO_ENA_STS	0x0002	< FIFO Disable (0) or Enable (1) Status to DSP >
  129+          	HEX_CONST IO_H2SND_CTL_FIFO_ENA		0x0004	< Clears (0) or Enables (1) the Sound System FIFOs >
  130+          	HEX_CONST IO_H2SND_CTL_FIFO_STS_LATCH	0x0008	< Flow Through (0) or Latch (1) the FIFO Status Bits >
  131+          	HEX_CONST IO_H2SND_CTL_FLAG_MASK	0xFF00	< Host Flag bits written by Host and read by DSP >
  132+          ;
  133+          	IO_ASIC_REG		IO_H2SND_DTA		< bits 15:0 (rw) = Host to Sound data register >
  134+          	IO_ASIC_REG		IO_SND_STS		< bits 15:0 (ro) = Host Sound status >
  135+          	HEX_CONST IO_SND_STS_SND_ENA		0x0001	< IO_H2SND_CTL_SND_ENA >
  136+          	HEX_CONST IO_SND_STS_FIFO_ENA_STS	0x0002	< IO_H2SND_CTL_FIFO_ENA_STS >
  137+          	HEX_CONST IO_SND_STS_FIFO_ENA		0x0004	< IO_H2SND_CTL_FIFO_ENA >
  138+          	HEX_CONST IO_SND_STS_FIFO_EMPTY		0x0008	< FIFO Not Empty (0) / Empty (1) Status Flag >
  139+          	HEX_CONST IO_SND_STS_FIFO_HALF		0x0010	< FIFO Not Half Full (0) / Half Full (1) Status Flag >
  140+          	HEX_CONST IO_SND_STS_FIFO_FULL		0x0020	< FIFO Not Full (0) / Full (1) Status Flag >
  141+          	HEX_CONST IO_SND_STS_DATA_FROM		0x0040	< Sound to Host Data Empty (0) / Full (1) Status bit >
  142+          	HEX_CONST B_IO_SND_STS_DATA_FROM	6	< Sound to Host Data Empty (0) / Full (1) Status bit number >
  143+          	HEX_CONST IO_SND_STS_DATA_TO		0x0080	< Host to Sound Data Full (0) / Empty (1) Status bit >
  144+          	HEX_CONST B_IO_SND_STS_DATA_TO		7	< Host to Sound Data Full (0) / Empty (1) Status bit number >
  145+          	HEX_CONST IO_SND_STS_FLAG_MASK		0xFF00	< Sound System Flag bits written by DSP and read by Host >
  146+          ;
  147+          	IO_ASIC_REG		IO_SND2H_DTA		< bits 15:0 (ro) = Sound to Host data register >
  148+          	IO_ASIC_REG		IO_H2MIC_CMD		< bits  3:0 (rw) = Host to microcontroller control >
  149+          	IO_ASIC_REG		IO_MIC2H_DTA		< bits  7:0 (ro) = MIC to host data register >
  150+          	IO_ASIC_REG		IO_MAIN_STS		< bits 15:0 (ro) = Main status register >
  151+          	IO_ASIC_REG		IO_MAIN_CTL		< bits 15:0 (rw) = Main control register >
  152+          	HEX_CONST IO_MAIN_GLOBAL_INT		0x0001	< Global Interrupt Enable >
  153+          	HEX_CONST IO_MAIN_FRC_HOST_INT		0x0002	< Force Host Interrupt >
  154+          	HEX_CONST IO_MAIN_MC_ACK		0x0004	< Microcontroller Acknowledge >
  155+          	HEX_CONST IO_MAIN_FIFO_EMPTY		0x0008	< FIFO Empty Flag >
  156+          	HEX_CONST IO_MAIN_FIFO_HALF		0x0010	< FIFO Half Full >
  157+          	HEX_CONST IO_MAIN_FIFO_FULL		0x0020	< FIFO Full Flag >
  158+          	HEX_CONST IO_MAIN_STH_DATA_FULL		0x0040	< Sound to Host Data Full >
  159+          	HEX_CONST IO_MAIN_HTS_DATA_EMPTY	0x0080	< Host to Sound Data Empty >
  160+          	HEX_CONST IO_MAIN_UART_BRK_DETECT	0x0100	< UART Break Detect >
  161+          	HEX_CONST IO_MAIN_UART_FRAME_ERROR	0x0200	< UART Frame Error >
  162+          	HEX_CONST IO_MAIN_UART_OVER_RUN		0x0400	< UART Over Run >
  163+          	HEX_CONST IO_MAIN_UART_RCV_FULL		0x0800	< UART Receiver Full >
  164+          	HEX_CONST IO_MAIN_UART_RCV_CHAR		0x1000	< UART Received Character >
  165+          	HEX_CONST IO_MAIN_UART_XMT_EMPTY	0x2000	< UART Transmitter Empty >
  166+          	HEX_CONST IO_MAIN_UART_CTS_IN		0x4000	< UART CTS In (Status Register) >
  167+          	HEX_CONST IO_MAIN_UART_CTS_OUT		0x8000	< UART CTS Out (Status Register) >
  168+          	HEX_CONST IO_MAIN_LED_ON		0x4000	< LED O/P On (Control Register) >
  169+          	HEX_CONST IO_MAIN_TI320cx_MODE		0x8000	< TI-320cx Mode (Control Register) >
  170+          ;
  171+   (3)    .endc 		;_IOASIC_MAC_
   90+   (2)    .iff
   91+    X        .macro which_ioasic val
   92+    X     	.include ioasic'val'.mac
   93+    X        .endm
   94+    X     	which_ioasic \WHICH_IOASIC
   95+   (2)    .endc
   96+          ;
   97+          ;
   98+          	HEX_CONST BRAM_BASE	OBIO_BASE+0x00100000	< bits  7:0 (rw) = NVRAM bytes >
   99+   (2)    .if not_defined,BRAM_SIZE
  100+          	HEX_CONST BRAM_SIZE	(8192*4*4)   		< BRAM size (32k words) >
  101+   (2)    .endc
dispatch.c                               Atari Games Corp. macpp v9.12   "Oct 16 1997 13:26:41"


  102+          	HEX_CONST SPARE_EXP_CS	 OBIO_BASE+0x00200000	< Spare CS, run to expansion connector >
  103+          	HEX_CONST SPARE_FAST_CS0 OBIO_BASE+0x00300000	< Spare CS, not used >
  104+          	HEX_CONST SPARE_FAST_CS1 OBIO_BASE+0x00400000	< Spare CS, not used >
  105+          	HEX_CONST SPARE_FAST_CS2 OBIO_BASE+0x00500000	< Spare CS, not used >
  106+          	HEX_CONST SPARE_GPIO	 OBIO_BASE+0x00600000	< Spare GPIO, run to expansion connector >
  107+          	HEX_CONST NSS_BASE	OBIO_BASE+0x00800000
  108+          	HEX_CONST NSS_CTL	NSS_BASE+0x00		< bits 15:0 (rw) = NSS control register >
  109+          	HEX_CONST NSS_GAME_CTL	NSS_BASE+0x04		< bits 15:0 (ro) = NSS game control register >
  110+          	HEX_CONST NSS_FIFO_STS	NSS_BASE+0x08		< bits 15:0 (ro) = NSS FIFO status >
  111+          	HEX_CONST NSS_GAMEINT	NSS_BASE+0x0C		< bits 15:0 (ro) = NSS Game interrupt status >
  112+          	HEX_CONST NSS_FIFO_DTA	NSS_BASE+0x10		< bits 15:0 (rw) = NSS read/write FIFO >
  113+          	HEX_CONST NSS_FIFO_RST	NSS_BASE+0x14		< bits 15:0 (wo) = NSS FIFO reset register >
  114+          	HEX_CONST WB_BASE	OBIO_BASE+0x00C00000	< Widget Board, has RDY ( alias of NSS_BASE ) >
  115+          	HEX_CONST BRAM_UNLK	OBIO_BASE+0x01000000	< bits  x:x (wo) = BRAM unlock >
  116+          	HEX_CONST WATCHDOG	OBIO_BASE+0x01100000	< bits  x:x (wo) = Watch dog timer > 
  117+          	HEX_CONST INTCTL_NMI	OBIO_BASE+0x01200000	< bits  3:0 (rw) = NMI select/enable register >
  118+          	HEX_CONST INTCTL_IE	OBIO_BASE+0x01300000	< bits 15:0 (rw) = Interrupt enable register >
  119+          	HEX_CONST INTCTL_MAPA	OBIO_BASE+0x01400000	< bits 15:0 (rw) = Interrupt Map register >
  120+          	HEX_CONST INTCTL_CAUSE	OBIO_BASE+0x01500000	< bits 15:0 (ro) = Interrupt cause register >
  121+          	HEX_CONST INTCTL_STS	OBIO_BASE+0x01600000	< bits 15:0 (rw) = Interrupt status >
  122+          	HEX_CONST GP_STS	OBIO_BASE+0x01600000	< bits 15:0 (rw) = General purpose status >
  123+          	DEC_CONST B_GPSTS_EXP	0			< Expansion bus interrupt >
  124+          	DEC_CONST B_GPSTS_NSS	1			< NSS interrupt >
  125+          	DEC_CONST B_GPSTS_WD1	2			< Widget board interrupt 1 >
  126+          	DEC_CONST B_GPSTS_PCI	3			< PCI slot interrupt >
  127+          	DEC_CONST B_GPSTS_AD	4			< A/D interrupt >
  128+          	DEC_CONST B_GPSTS_WD2	5			< Widget board interrupt 2 >
  129+          	DEC_CONST B_GPSTS_DBG	6			< Debug switch interrupt >
  130+          	DEC_CONST B_GPSTS_VSYZL	7			< Latched Vsync interrupt >
  131+          	DEC_CONST B_GPSTS_VSY	8			< VSYNC input pin >
  132+          	DEC_CONST B_GPSTS_BLOW	9			< Battery low indication (1=low) >
  133+          	DEC_CONST B_GPSTS_WDOG	10			< WDOG timeout occured >
  134+          	DEC_CONST B_GPSTS_AUX	11			< Aux output latch bit >
  135+          	DEC_CONST B_GPSTS_NMI	12			< NMI input >
  136+          	HEX_CONST INTCTL_VSY_ACK OBIO_BASE+0x01700000	< bits  x:x (wo) = ACK Vsync interrupt >
  137+   (2)    .if true, OUTPUT_LANG == LANG_C
  138+    X     #define SST_VSYNC_ACK() (*(VU32*)INTCTL_VSY_ACK = 0)
  139+   (2)    .endc
  140+          	HEX_CONST ARB_CTL	OBIO_BASE+0x01800000	< bits  2:0 (rw) = ARB control + 2 spare >
  141+          	HEX_CONST B_ARB_PARK	0			<	bit 0 = 0=park on PCI, 1=Round robin >
  142+          	HEX_CONST B_ARB_TP0	1			<	bit 1 = test point >
  143+          	HEX_CONST B_ARB_TP1	2			<	bit 2 = test point >
  144+          	HEX_CONST LED_OUT	OBIO_BASE+0x01900000	< bits  2:0 (rw) = LED control >
  145+          	HEX_CONST B_LED_RED	0			< 	bit 0 = red >
  146+          	HEX_CONST B_LED_YEL	1			<	bit 1 = yellow >
  147+          	HEX_CONST B_LED_GRN	2			<	bit 2 = green >
  148+          	HEX_CONST RESET_CTL	OBIO_BASE+0x01F00000	< bits  6:0 (rw) = Reset bits >
  149+          	HEX_CONST B_RESET_EXP	 0			<	bit 0 = Expansion slot reset >
  150+          	HEX_CONST B_RESET_IOASIC 1			<	bit 1 = IOASIC reset >
  151+          	HEX_CONST B_RESET_IDE	 2			<	bit 2 = PCI bus and IDE reset >
  152+          	HEX_CONST B_RESET_3DFX	 3			<	bit 3 = 3DFX subsystem reset >
  153+          	HEX_CONST B_RESET_NSS	 4			<	bit 4 = NSS reset >
  154+          	HEX_CONST B_RESET_WIDGET 5			<	bit 5 = Widget board reset (spare) >
  155+          ;
  156+          	.include galileo.mac			; Get galileo defines
    1+          ; $Id: galileo.mac,v 1.10 1997/07/01 20:54:19 shepperd Exp $
    2+          ;
dispatch.c                               Atari Games Corp. macpp v9.12   "Oct 16 1997 13:26:41"


    3+   (2)    .if not_defined, _GALILEO_MAC_
    4+ 00000000 _GALILEO_MAC_ == 0
    5+ AC000000 GB == GALILEO_BASE
    6+          	HEX_CONST GALILEO_CPUINTFC	GB+0x000	<CPU Interface configuration>
    7+          	HEX_CONST GALILEO_CPUINTFC_CacheOpMap_b	0
    8+          	HEX_CONST GALILEO_CPUINTFC_CachePres_b	9
    9+          	HEX_CONST GALILEO_CPUINTFC_WriteMod_b	11
   10+          	HEX_CONST GALILEO_CPUINTFC_Endian_b	12
   11+          	HEX_CONST GALILEO_CPUINTFC_CacheOpMap_m	1<<0
   12+          	HEX_CONST GALILEO_CPUINTFC_CachePres_m	1<<9
   13+          	HEX_CONST GALILEO_CPUINTFC_WriteMod_m	1<<11
   14+          	HEX_CONST GALILEO_CPUINTFC_Endian_m	1<<12
   15+          	HEX_CONST GALILEO_RAS10_LOW	GB+0x008	< RAS[1:0] Low decode Address >
   16+          	HEX_CONST GALILEO_RAS10_HIGH	GB+0x010	< RAS[1:0] High decode Address >
   17+          	HEX_CONST GALILEO_RAS32_LOW	GB+0x018	< RAS[3:2] Low decode Address >
   18+          	HEX_CONST GALILEO_RAS32_HIGH	GB+0x020	< RAS[3:2] High decode Address >
   19+          	HEX_CONST GALILEO_CS20_LOW	GB+0x028	< CS[2:0] Low decode Address >
   20+          	HEX_CONST GALILEO_CS20_HIGH	GB+0x030	< CS[2:0] High decode Address >
   21+          	HEX_CONST GALILEO_CS3BOOT_LOW	GB+0x038	< CS[3] & Boot Low decode Address >
   22+          	HEX_CONST GALILEO_CS3BOOT_HIGH	GB+0x040	< CS[3] & Boot High decode Address >
   23+          	HEX_CONST GALILEO_PCIIO_LOW	GB+0x048	< PCI I/O Low decode Address >
   24+          	HEX_CONST GALILEO_PCIIO_HIGH	GB+0x050	< PCI I/O High decode Address >
   25+          	HEX_CONST GALILEO_PCIMEM_LOW	GB+0x058	< PCI Memory Low decode Address >
   26+          	HEX_CONST GALILEO_PCIMEM_HIGH	GB+0x060	< PCI Memory High decode Address >
   27+          	HEX_CONST GALILEO_Internal 	GB+0x068	< Galileo internal space decode Address >
   28+          	HEX_CONST GALILEO_BUSERR_LOW	GB+0x070	< Address bits 31:0 after Bus Error >
   29+          	HEX_CONST GALILEO_BUSERR_HIGH	GB+0x078	< Address bits 35:32 after Bus Error >
   30+          	HEX_CONST GALILEO_RAS0_LOW	GB+0x400	< RAS[0] Low decode Address >
   31+          	HEX_CONST GALILEO_RAS0_HIGH	GB+0x404	< RAS[0] High decode Address >
   32+          	HEX_CONST GALILEO_RAS1_LOW	GB+0x408	< RAS[1] Low decode Address >
   33+          	HEX_CONST GALILEO_RAS1_HIGH	GB+0x40C	< RAS[1] High decode Address >
   34+          	HEX_CONST GALILEO_RAS2_LOW	GB+0x410	< RAS[2] Low decode Address >
   35+          	HEX_CONST GALILEO_RAS2_HIGH	GB+0x414	< RAS[2] High decode Address >
   36+          	HEX_CONST GALILEO_RAS3_LOW	GB+0x418	< RAS[3] Low decode Address >
   37+          	HEX_CONST GALILEO_RAS3_HIGH	GB+0x41C	< RAS[3] High decode Address >
   38+          	HEX_CONST GALILEO_CS0_LOW	GB+0x420	< CS[0] Low decode Address >
   39+          	HEX_CONST GALILEO_CS0_HIGH	GB+0x424	< CS[0] High decode Address >
   40+          	HEX_CONST GALILEO_CS1_LOW	GB+0x428	< CS[1] Low decode Address >
   41+          	HEX_CONST GALILEO_CS1_HIGH	GB+0x42C	< CS[1] High decode Address >
   42+          	HEX_CONST GALILEO_CS2_LOW	GB+0x430	< CS[2] Low decode Address >
   43+          	HEX_CONST GALILEO_CS2_HIGH	GB+0x434	< CS[2] High decode Address >
   44+          	HEX_CONST GALILEO_CS3_LOW	GB+0x438	< CS[3] Low decode Address >
   45+          	HEX_CONST GALILEO_CS3_HIGH	GB+0x43C	< CS[3] High decode Address >
   46+          	HEX_CONST GALILEO_BOOT_LOW	GB+0x440	< CS[3] Low decode Address >
   47+          	HEX_CONST GALILEO_BOOT_HIGH	GB+0x444	< CS[3] High decode Address >
   48+          	HEX_CONST GALILEO_DRAM_CFG	GB+0x448	< DRAM configuration >
   49+          	HEX_CONST GALILEO_DRAM_CFG_RefIntCnt_b	0	< Refresh interval count >
   50+          	HEX_CONST GALILEO_DRAM_CFG_StagRef_b	16	< Staggered Refresh >
   51+          	HEX_CONST GALILEO_DRAM_CFG_ADSFunct_b	17	< ADS pin function >
   52+          	HEX_CONST GALILEO_DRAM_CFG_DRAMLatch_b	18	< DRAM latch operation >
   53+          	HEX_CONST GALILEO_DRAM_CFG_RefIntCnt_m	1<<0	< Refresh interval count >
   54+          	HEX_CONST GALILEO_DRAM_CFG_StagRef_m	1<<16	< Staggered Refresh >
   55+          	HEX_CONST GALILEO_DRAM_CFG_ADSFunct_m	1<<17	< ADS pin function >
   56+          	HEX_CONST GALILEO_DRAM_CFG_DRAMLatch_m	1<<18	< DRAM latch operation >
   57+          	HEX_CONST GALILEO_DRAM0_CFG	GB+0x44c	< DRAM Bank 0 configuration >
   58+          	HEX_CONST GALILEO_DRAMBK_CFG_CASWr_b	0	< Number of CAS cycles during writes >
   59+          	HEX_CONST GALILEO_DRAMBK_CFG_RAStoCASWr_b 1	< Number of cycles between RAS and CAS during writes >
dispatch.c                               Atari Games Corp. macpp v9.12   "Oct 16 1997 13:26:41"


   60+          	HEX_CONST GALILEO_DRAMBK_CFG_CASRd_b	2	< Number of CAS cycles during read >
   61+          	HEX_CONST GALILEO_DRAMBK_CFG_RAStoCASRd_b 3	< Number of cycles between RAS and CAS during reads >
   62+          	HEX_CONST GALILEO_DRAMBK_CFG_Refresh_b	4	< Refresh type >
   63+          	HEX_CONST GALILEO_DRAMBK_CFG_BankWidth_b 6	< Width (32/64) >
   64+          	HEX_CONST GALILEO_DRAMBK_CFG_BankLoc_b	7	< Even/Odd side if width = 32 >
   65+          	HEX_CONST GALILEO_DRAMBK_CFG_Parity_b	8	< Parity support >
   66+          	HEX_CONST GALILEO_DRAMBK_CFG_CASWr_m	1<<0	< Number of CAS cycles during writes >
   67+          	HEX_CONST GALILEO_DRAMBK_CFG_RAStoCASWr_m 1<<1	< Number of cycles between RAS and CAS during writes >
   68+          	HEX_CONST GALILEO_DRAMBK_CFG_CASRd_m	1<<2	< Number of CAS cycles during read >
   69+          	HEX_CONST GALILEO_DRAMBK_CFG_RAStoCASRd_m 1<<3	< Number of cycles between RAS and CAS during reads >
   70+          	HEX_CONST GALILEO_DRAMBK_CFG_Refresh_m	1<<4	< Refresh type >
   71+          	HEX_CONST GALILEO_DRAMBK_CFG_BankWidth_m 1<<6	< Width (32/64) >
   72+          	HEX_CONST GALILEO_DRAMBK_CFG_BankLoc_m	1<<7	< Even/Odd side if width = 32 >
   73+          	HEX_CONST GALILEO_DRAMBK_CFG_Parity_m	1<<8	< Parity support >
   74+          	HEX_CONST GALILEO_DRAM1_CFG	GB+0x450	< DRAM Bank 1 configuration >
   75+          	HEX_CONST GALILEO_DRAM2_CFG	GB+0x454	< DRAM Bank 2 configuration >
   76+          	HEX_CONST GALILEO_DRAM3_CFG	GB+0x458	< DRAM Bank 3 configuration >
   77+          	HEX_CONST GALILEO_DEV0_CFG	GB+0x45c	< Device Bank 0 (PCS0) Configuration >
   78+          	HEX_CONST GALILEO_DEV_CFG_TurnOff_b	0	< Cycles between OE's >
   79+          	HEX_CONST GALILEO_DEV_CFG_AccToFirst_b	3	< Cycles between CS's >
   80+          	HEX_CONST GALILEO_DEV_CFG_AccToNext_b	7	< Cycles between CS's >
   81+          	HEX_CONST GALILEO_DEV_CFG_ADStoWr_b	11	< Cycles between ADS and WR >
   82+          	HEX_CONST GALILEO_DEV_CFG_WrActive_b	14	< Cycles Wr held assetred >
   83+          	HEX_CONST GALILEO_DEV_CFG_WrHigh_b	17	< Cycles between assertions of Wr >
   84+          	HEX_CONST GALILEO_DEV_CFG_DevWidth_b	20	< Device bus width >
   85+          	HEX_CONST GALILEO_DEV_CFG_DevLoc_b	23	< Even/Odd side if width != 64>
   86+          	HEX_CONST GALILEO_DEV_CFG_LatchFunct_b	25	< Latch enable function >
   87+          	HEX_CONST GALILEO_DEV_CFG_Parity_b	30	< Parity support >
   88+          	HEX_CONST GALILEO_DEV_CFG_TurnOff_m	1<<0	< Cycles between OE's >
   89+          	HEX_CONST GALILEO_DEV_CFG_AccToFirst_m	1<<3	< Cycles between CS's >
   90+          	HEX_CONST GALILEO_DEV_CFG_AccToNext_m	1<<7	< Cycles between CS's >
   91+          	HEX_CONST GALILEO_DEV_CFG_ADStoWr_m	1<<11	< Cycles between ADS and WR >
   92+          	HEX_CONST GALILEO_DEV_CFG_WrActive_m	1<<14	< Cycles Wr held assetred >
   93+          	HEX_CONST GALILEO_DEV_CFG_WrHigh_m	1<<17	< Cycles between assertions of Wr >
   94+          	HEX_CONST GALILEO_DEV_CFG_DevWidth_m	1<<20	< Device bus width >
   95+          	HEX_CONST GALILEO_DEV_CFG_DevLoc_m	1<<23	< Even/Odd side if width != 64>
   96+          	HEX_CONST GALILEO_DEV_CFG_LatchFunct_m	1<<25	< Latch enable function >
   97+          	HEX_CONST GALILEO_DEV_CFG_Parity_m	1<<30	< Parity support >
   98+          	HEX_CONST GALILEO_DEV1_CFG	GB+0x460	< Device Bank 0 (PCS0) Configuration >
   99+          	HEX_CONST GALILEO_DEV2_CFG	GB+0x464	< Device Bank 0 (PCS0) Configuration >
  100+          	HEX_CONST GALILEO_DEV3_CFG	GB+0x468	< Device Bank 0 (PCS0) Configuration >
  101+          	HEX_CONST GALILEO_BOOT_CFG	GB+0x46C	< Boot Device (BOOTCS) Configuration >
  102+          	HEX_CONST GALILEO_ERRADDR	GB+0x470	< Address of accesses to invalid ranges >
  103+          	HEX_CONST GALILEO_DMA0_BC	GB+0x800	< DMA channel 0 byte count >
  104+          	HEX_CONST GALILEO_DMA1_BC	GB+0x804	< DMA channel 1 byte count >
  105+          	HEX_CONST GALILEO_DMA2_BC	GB+0x808	< DMA channel 2 byte count >
  106+          	HEX_CONST GALILEO_DMA3_BC	GB+0x80C	< DMA channel 3 byte count >
  107+          	HEX_CONST GALILEO_DMA0_SRC	GB+0x810	< DMA channel 0 Source address >
  108+          	HEX_CONST GALILEO_DMA1_SRC	GB+0x814	< DMA channel 1 Source address >
  109+          	HEX_CONST GALILEO_DMA2_SRC	GB+0x818	< DMA channel 2 Source address >
  110+          	HEX_CONST GALILEO_DMA3_SRC	GB+0x81C	< DMA channel 3 Source address >
  111+          	HEX_CONST GALILEO_DMA0_DST	GB+0x820	< DMA channel 0 Destination address >
  112+          	HEX_CONST GALILEO_DMA1_DST	GB+0x824	< DMA channel 1 Destination address >
  113+          	HEX_CONST GALILEO_DMA2_DST	GB+0x828	< DMA channel 2 Destination address >
  114+          	HEX_CONST GALILEO_DMA3_DST	GB+0x82C	< DMA channel 3 Destination address >
  115+          	HEX_CONST GALILEO_DMA0_NXTRCD	GB+0x830	< DMA channel 0 Next Record pointer >
  116+          	HEX_CONST GALILEO_DMA1_NXTRCD	GB+0x834	< DMA channel 1 Next Record pointer >
dispatch.c                               Atari Games Corp. macpp v9.12   "Oct 16 1997 13:26:41"


  117+          	HEX_CONST GALILEO_DMA2_NXTRCD	GB+0x838	< DMA channel 2 Next Record pointer >
  118+          	HEX_CONST GALILEO_DMA3_NXTRCD	GB+0x83C	< DMA channel 3 Next Record pointer >
  119+          	HEX_CONST GALILEO_DMA0_CTL	GB+0x840	< DMA channel 0 control register >
  120+          	HEX_CONST GALILEO_DMA1_CTL	GB+0x844	< DMA channel 0 control register >
  121+          	HEX_CONST GALILEO_DMA2_CTL	GB+0x848	< DMA channel 0 control register >
  122+          	HEX_CONST GALILEO_DMA3_CTL	GB+0x84C	< DMA channel 0 control register >
  123+          	DEC_CONST GALILEO_DMA_INC	0		< DMA Increment the address >
  124+          	DEC_CONST GALILEO_DMA_DEC	1		< DMA Decrement the address >
  125+          	DEC_CONST GALILEO_DMA_HOLD	2		< DMA Hold the address >
  126+          	DEC_CONST GALILEO_DMA_XFER4	0		< DMA Xfer 4 bytes per transaction >
  127+          	DEC_CONST GALILEO_DMA_XFER8	1		< DMA Xfer 8 bytes per transaction >
  128+          	DEC_CONST GALILEO_DMA_XFER16	3		< DMA Xfer 16 bytes per transaction >
  129+          	DEC_CONST GALILEO_DMA_XFER32	7		< DMA Xfer 32 bytes per transaction >
  130+          	DEC_CONST GALILEO_DMA_SRCDIR_b	2		< DMA Source direction bits start here >
  131+          	DEC_CONST GALILEO_DMA_DSTDIR_b	4		< DMA Destination direction bits start here >
  132+          	DEC_CONST GALILEO_DMA_XFER_b	6		< DMA Xfer size bits start here >
  133+          	DEC_CONST GALILEO_DMA_NCHAIN_b	9		< DMA Not chained mode bit >
  134+          	DEC_CONST GALILEO_DMA_INTMODE_b	10		< DMA Interrupt mode bit >
  135+          	DEC_CONST GALILEO_DMA_BLOCK_b	11		< DMA Block mode XFER bit >
  136+          	DEC_CONST GALILEO_DMA_ENABLE_b	12		< DMA Channel enable bit >
  137+          	DEC_CONST GALILEO_DMA_FNEXT_b	13		< DMA Fetch next record enable bit >
  138+          	DEC_CONST GALILEO_DMA_ACTIVE_b	14		< DMA Channel active status bit >
  139+          	HEX_CONST GALILEO_TIMER0	GB+0x850	< TIMER/COUNTER 0 >
  140+          	HEX_CONST GALILEO_TIMER1	GB+0x854	< TIMER/COUNTER 0 >
  141+          	HEX_CONST GALILEO_TIMER2	GB+0x858	< TIMER/COUNTER 0 >
  142+          	HEX_CONST GALILEO_TIMER3	GB+0x85C	< TIMER/COUNTER 0 >
  143+          	HEX_CONST GALILEO_TIMER_CTL	GB+0x864	< Timer/Counter control >
  144+          	HEX_CONST GALILEO_PCI_CMD	GB+0xC00	< PCI Command register >
  145+          	HEX_CONST GALILEO_PCI_CMD_SWAP	GB+0x000	< PCI byte swap >
  146+          	HEX_CONST GALILEO_PCI_CMD_SYNC	GB+0x001	< Sync mode: 0=normal, 1=Pclk>Tclk/2, 2=Pclk==Tclk/2>
  147+          	HEX_CONST GALILEO_PCI_RETRY	GB+0xC04	< Timeout and retry register >
  148+          	HEX_CONST GALILEO_PCI_RETRY_TO0_b  0x00		< Timeout 0, 8 bits (default to 0xF) >
  149+          	HEX_CONST GALILEO_PCI_RETRY_TO1_b  0x08		< Timeout 1, 8 bits (default to 0x7) >
  150+          	HEX_CONST GALILEO_PCI_RETRY_CTR_b  0x10		< Number of retries, 24 bits >
  151+          	HEX_CONST GALILEO_PCI_RETRY_TO0_m  (1<<0x00)	< Timeout 0, 8 bits (default to 0xF) >
  152+          	HEX_CONST GALILEO_PCI_RETRY_TO1_m  (1<<0x08)	< Timeout 1, 8 bits (default to 0x7) >
  153+          	HEX_CONST GALILEO_PCI_RETRY_CTR_m  (1<<0x10)	< Number of retries, 24 bits >
  154+          	HEX_CONST GALILEO_PCI_CFG	GB+0xCF8	< PCI Configuration register >
  155+          	HEX_CONST GALILEO_PCI_DTA	GB+0xCFC	< PCI Configuration data register >
  156+          	HEX_CONST GALILEO_INT_CAUSE	GB+0xC18	< Galileo Interrupt Cause register >
  157+          	HEX_CONST GALILEO_INT_DMA0_b	(4)		< DMA 0 interrupt >
  158+          	HEX_CONST GALILEO_INT_DMA1_b	(5)		< DMA 1 interrupt >
  159+          	HEX_CONST GALILEO_INT_DMA2_b	(6)		< DMA 2 interrupt >
  160+          	HEX_CONST GALILEO_INT_DMA3_b	(7)		< DMA 3 interrupt >
  161+          	HEX_CONST GALILEO_INT_DMA0_m	(1<<4)		< DMA 0 interrupt >
  162+          	HEX_CONST GALILEO_INT_DMA1_m	(1<<5)		< DMA 1 interrupt >
  163+          	HEX_CONST GALILEO_INT_DMA2_m	(1<<6)		< DMA 2 interrupt >
  164+          	HEX_CONST GALILEO_INT_DMA3_m	(1<<7)		< DMA 3 interrupt >
  165+          	HEX_CONST GALILEO_INT_TIMER0_b	(8)		< Timer 0 interrupt >
  166+          	HEX_CONST GALILEO_INT_TIMER1_b	(9)		< Timer 1 interrupt >
  167+          	HEX_CONST GALILEO_INT_TIMER2_b	(10)		< Timer 2 interrupt >
  168+          	HEX_CONST GALILEO_INT_TIMER3_b	(11)		< Timer 3 interrupt >
  169+          	HEX_CONST GALILEO_INT_TIMER0_m	(1<<8)		< Timer 0 interrupt >
  170+          	HEX_CONST GALILEO_INT_TIMER1_m	(1<<9)		< Timer 1 interrupt >
  171+          	HEX_CONST GALILEO_INT_TIMER2_m	(1<<10)		< Timer 2 interrupt >
  172+          	HEX_CONST GALILEO_INT_TIMER3_m	(1<<11)		< Timer 3 interrupt >
  173+          	HEX_CONST GALILEO_CPU_INT_m	0x03E00000	< Galileo CPU Interrupt Mask (to PCI) >
dispatch.c                               Atari Games Corp. macpp v9.12   "Oct 16 1997 13:26:41"


  174+          	HEX_CONST GALILEO_PCI_INT_m	0x3C000000	< Galileo PCI Interrupt Mask (to CPU) >
  175+          	HEX_CONST GALILEO_CPU_I_ENA	GB+0xC1C	< Galileo CPU Interrupt Mask register >
  176+          	HEX_CONST GALILEO_PCI_I_ENA	GB+0xC24	< Galileo PCI Interrupt Mask register >
  177+   (3)     .if true, OUTPUT_LANG == LANG_C
  178+    X     #  define FLUSH_WB() do { U32 junk; junk = *(VU32 *)GALILEO_PCI_CFG; } while (0)
  179+   (3)     .endc
  180+   (2)    .endc
  157+          ;
  158+          	DEC_CONST SWINT0_LVL	0		< Software interrupt 0 >
  159+          	DEC_CONST SWINT1_LVL	1		< Software interrupt 1 >
  160+          	DEC_CONST INT0_LVL	2		< Galileo system interrupt >
  161+          	DEC_CONST INT1_LVL	3		< I/O Asic interrupt >
  162+          	DEC_CONST INT2_LVL	4		< IDE interrupt >
  163+          	DEC_CONST INT3_LVL	5		< Interrupt Control PLD >
  164+          	DEC_CONST INT4_LVL	6		< Interrupt Control PLD >
  165+          	DEC_CONST INT5_LVL	7		< Interrupt Control PLD >
  166+ 00000001 	IOA == 1				;Enable I/O ASIC vectors
  167+          	DEC_CONST IOA_LVL	INT1_LVL	< IOASIC is connected to Int 1 >
  168+          	DEC_CONST IOASIC_LVL	INT1_LVL	< IOASIC is connected to Int 1 >
  169+ 00000001 	IDE == 1				; Enable IDE vectors
  170+          	DEC_CONST IDE_LVL	INT2_LVL	< IDE is connected here >
  171+          ;
  172+          ; macro ASNP - assign Phoenix interrupt
  173+          ;
  174+          ; usage:  ASNP sym, val, bit
  175+          ;
  176+          ;	sym - symbol used by VDF in phx_vecs.mac, derived from the
  177+          ;	      descriptions given in the Phoenix Development System
  178+          ;	      Programmers Guide.
  179+          ;
  180+          ;	val - CPU interrupt pin, set in config.mac by the user to
  181+          ;	      map and/or enable the specific interrupt as follows...
  182+          ;
  183+          ;	      XS0_ASN == 2  Assigns and maps Phoenix Expansion Slot 0
  184+          ;			    interrupt to CPU interrupt level 2.
  185+          ;	      XS1_ASN == 3  Assigns and maps Phoenix Expansion Slot 1
  186+          ;			    interrupt to CPU interrupt level 3.
  187+          ;
  188+          ;	      The valid CPU interrupt levels are 5, 6 and 7 for Phoenix-AD.
  189+          ;
  190+          ;	bit - bit number in registers INTCTL_IE, INTCTL_CAUSE and INTCTL_STS.
  191+          ;
  192+          ;
  193+          ; synopsis:  Validates the parameter val, and sets sym to true or false to be
  194+          ;	     used by macro VDF in phx_vecs.mac
  195+          ;	     If true, defines sym_LVL to equal INTval_LVL, and "validates" the
  196+          ;	     bit assignment.  The bit values below are valid according to the
  197+          ;	     documentation available 5/14/96.  Defines B_PIC_sym and sym_NOTES
  198+          ;	     to be used by the interrupt installer unless sym_NOTES is defined
  199+          ;	     previously in config.mac.  Accumulates the appropriate bits for
  200+          ;	     defining the constants INTCTL_MAP_INIT and PHOENIX_INTCTL_MASK.
  201+          ;
  202+          	.macro ASNP sym, val, bit
  203+          	...0 == 0
  204+          	.if identical,<val>,<3>
  205+          	 ...0 == 1
  206+          	 ...P == 1
dispatch.c                               Atari Games Corp. macpp v9.12   "Oct 16 1997 13:26:41"


  207+          	.endc
  208+          	.if identical,<val>,<4>
  209+          	 ...0 == 1
  210+          	 ...P == 2
  211+          	.endc
  212+          	.if identical,<val>,<5>
  213+          	 ...0 == 1
  214+          	 ...P == 3
  215+          	.endc
  216+          	sym == ...0
  217+          	.if true, ...0
  218+          	 HEX_CONST sym'_LVL INT'val'_LVL
  219+          	.iff
  220+          	 .iif b,val,.mexit 2
  221+          	 .iif identical,<val>,<NULL>,.mexit 2
  222+          	 .error ; macro ASN - parameter val out of range (can only be 3, 4 or 5)
  223+          	.endc
  224+          	.iif b,<bit>,.error ; macro ASN - parameter 'bit' missing
  225+          	.iif lt,bit,.error ; macro ASN - parameter bit out of range
  226+          	.iif true, bit > 7,.error ; macro ASN - parameter bit out of range (must be < 8)
  227+          	DEC_CONST B_PIC_'sym	('bit')	< Phoenix Interrupt Control >
  228+          	.iif ndf,sym'_NOTES,HEX_CONST sym'_NOTES (1<<bit)
  229+          	...C == ...C + ( 1 << bit )
  230+          	...A == ...A + ( ...P << ( 2 * (bit) ) )
  231+          	..AA == 1
  232+          	.mexit 2
  233+          	.endm
  234+          ;
  235+          ;
  236+          ; macro ASNG - assign Galileo interrupt
  237+          ;
  238+          ; usage:  ASNG sym, val, bit
  239+          ;
  240+          ;	sym - symbol used by VDF in phx_vecs.mac, derived from the
  241+          ;	      descriptions given in the GT-64010 Data Sheet.
  242+          ;
  243+          ;	val - CPU interrupt pin, set in config.mac by the user to
  244+          ;	      map and/or enable the specific interrupt as follows...
  245+          ;
  246+          ;	      PC0_ASN == 0  Enables the Galileo interrupt from the PCI to
  247+          ;			    the CPU in Galileo cause register bit 26.
  248+          ;
  249+          ;	      The only valid CPU interrupt pin is 0 for the Galileo.
  250+          ;
  251+          ;	bit - bit number in registers GALILEO_INT_CAUSE and GALILEO_CPU_I_ENA.
  252+          ;
  253+          ;
  254+          ; synopsis:  Validates the parameter val, and sets sym to true or false to be
  255+          ;	     used by macro VDF in phx_vecs.mac
  256+          ;	     If true, defines sym_LVL to equal INTval_LVL, and "validates" the
  257+          ;	     bit assignment.  The bit values below are valid according to the
  258+          ;	     documentation available 4/14/96.  Defines B_GIC_sym and sym_NOTES
  259+          ;	     to be used by the interrupt installer unless sym_NOTES is defined
  260+          ;	     previously in config.mac.  Accumulates the appropriate bits for
  261+          ;	     defining the constant GALILEO_INTCTL_MASK.
  262+          ;
  263+          	.macro ASNG sym, val, bit
dispatch.c                               Atari Games Corp. macpp v9.12   "Oct 16 1997 13:26:41"


  264+          	...0 == 0
  265+          	.iif identical,<val>,<0>,...0 == 1
  266+          	sym == ...0
  267+          	.if true, ...0
  268+          	 sym'_LVL == INT'val'_LVL
  269+          	.iff
  270+          	 .iif b,val,.mexit 2
  271+          	 .iif identical,<val>,<NULL>,.mexit 2
  272+          	 .error ; macro ASN - parameter val out of range
  273+          	.endc
  274+          	.iif b,<bit>,.error ; macro ASN - parameter 'bit' missing
  275+          	.iif le,bit,.error ; macro ASN - parameter bit out of range
  276+          	.iif gt,bit-29,.error ; macro ASN - parameter bit out of range
  277+          	DEC_CONST B_GIC_'sym	('bit')	< Galileo Interrupt Control >
  278+          	.iif ndf,sym'_NOTES,HEX_CONST sym'_NOTES (1<<bit)
  279+          	...D == ...D + ( 1 << bit )
  280+          	.iif ne,GALILEO_CPU_INT_m&...D,.error ; macro ASN - parameter bit out of range
  281+          	.mexit 2
  282+          	.endm
  283+          ;
  284+          ;
  285+          ; macro ASNGM - assign Galileo interrupt mask
  286+          ;
  287+          ; usage:  ASNGM sym, val, mask
  288+          ;
  289+          ;	sym - symbol used by VDF in phx_vecs.mac, derived from the
  290+          ;	      descriptions given in the GT-64010 Data Sheet.
  291+          ;
  292+          ;	val - CPU interrupt pin, set in config.mac by the user to
  293+          ;	      map and/or enable the specific interrupt as follows...
  294+          ;
  295+          ;	      PC0_ASN == 0  Enables the Galileo interrupt from the PCI to
  296+          ;			    the CPU in Galileo cause register bit 26.
  297+          ;
  298+          ;	      The only valid CPU interrupt pin is 0 for the Galileo.
  299+          ;
  300+          ;	mask - bit mask in registers GALILEO_INT_CAUSE and GALILEO_CPU_I_ENA.
  301+          ;
  302+          ; synopsis:  Validates the parameter val, and sets sym to true or false to be
  303+          ;	     used by macro VDF in phx_vecs.mac
  304+          ;	     If true, defines sym_LVL to equal INTval_LVL, and "validates" the
  305+          ;	     mask.  The mask values below are valid according to the
  306+          ;	     documentation available 4/14/96.  Defines sym_NOTES
  307+          ;	     to be used by the interrupt installer unless sym_NOTES is defined
  308+          ;	     previously in config.mac.  Accumulates the appropriate bits for
  309+          ;	     defining the constant GALILEO_INTCTL_MASK.
  310+          ;
  311+          	.macro ASNGM sym, val, mask
  312+          	...0 == 0
  313+          	.iif identical,<val>,<0>,...0 == 1
  314+          	sym == ...0
  315+          	.if true, ...0
  316+          	 sym'_LVL == INT'val'_LVL
  317+          	.iff
  318+          	 .iif b,val,.mexit 2
  319+          	 .iif identical,<val>,<NULL>,.mexit 2
  320+          	 .error ; macro ASN - parameter val out of range
dispatch.c                               Atari Games Corp. macpp v9.12   "Oct 16 1997 13:26:41"


  321+          	.endc
  322+          	.iif b,<mask>,.error ; macro ASN - parameter 'mask' missing
  323+          	.iif ndf,sym'_NOTES,HEX_CONST sym'_NOTES (mask)
  324+          	...D == ...D | ( mask )
  325+          	.iif ne,GALILEO_CPU_INT_m&...D,.error ; macro ASN - parameter mask out of range
  326+          	.mexit 2
  327+          	.endm
  328+          ;
  329+          ;
  330+          ; macro ASNL - assign Logical interrupt level
  331+          ;
  332+          ; usage:  ASNL sym, val
  333+          ;
  334+          ;	sym - symbol used by GUTS which needs to be connected to a
  335+          ;	      Phoenix or a Galileo interrupt.  The symbol XBUS is
  336+          ;	      defined below and assigned to the Expansion Slot Dave
  337+          ;	      is currently using.
  338+          ;
  339+          ;	val - previously defined symbol used by VDF in phx_vecs.mac,
  340+          ;	      used here to make the logical connection by equating
  341+          ;	      sym to val, and by equating sym_LVL to val_LVL if val
  342+          ;	      is true.
  343+          ;
  344+          ;
  345+          	.macro ASNL sym, val
  346+          	.if df,val
  347+          	 sym == val
  348+          	 .iif ne,val,sym'_LVL == val'_LVL
  349+          	.endc
  350+          	.mexit 2
  351+          	.endm
  352+          ;
  353+          ;
  354+          ; macro ASN - assign Phoenix, Galileo, or Logical interrupt
  355+          ;
  356+          ; usage:  ASN sym, val, typ, bit
  357+          ;
  358+          ;	sym - symbol used by VDF in phx_vecs.mac, derived from the
  359+          ;	      descriptions given in the Phoenix Development System
  360+          ;	      Programmers Guide and the GT-64010 Data Sheet.
  361+          ;
  362+          ;	val - CPU interrupt pin, set in config.mac by the user to
  363+          ;	      map and/or enable the specific interrupt as follows...
  364+          ;
  365+          ;	      PC0_ASN == 0  Enables the Galileo interrupt from the PCI to
  366+          ;			    the CPU in Galileo cause register bit 26.
  367+          ;			    The only valid CPU interrupt pin is 0 for the
  368+          ;			    Galileo.
  369+          ;	      XS0_ASN == 2  Assigns and maps Phoenix Expansion Slot 0
  370+          ;			    interrupt to CPU interrupt pin 2.
  371+          ;	      XS1_ASN == 3  Assigns and maps Phoenix Expansion Slot 1
  372+          ;			    interrupt to CPU interrupt pin 3.
  373+          ;
  374+          ;	typ - P or p for Phoenix; G or g for Galileo; L or l for Logical.
  375+          ;
  376+          ;	bit - bit number in the appropriate cause, enable, or status register.
  377+          ;	      This field is not used if typ is L or l.
dispatch.c                               Atari Games Corp. macpp v9.12   "Oct 16 1997 13:26:41"


  378+          ;
  379+          	.macro ASN sym, val, typ, bit
  380+          	.if ndf,val
  381+          	 .define num NULL
  382+          	.iff
  383+          	 .define num \val
  384+          	 ...I == val
  385+          	.endc
  386+          	.iif identical,<typ>,<P>,ASNP sym, num, bit
  387+          	.iif identical,<typ>,<p>,ASNP sym, num, bit
  388+          	.iif identical,<typ>,<G>,ASNG sym, num, bit
  389+          	.iif identical,<typ>,<g>,ASNG sym, num, bit
  390+          	.iif identical,<typ>,<M>,ASNGM sym, num, bit
  391+          	.iif identical,<typ>,<m>,ASNGM sym, num, bit
  392+          	.iif identical,<typ>,<L>,ASNL sym, val
  393+          	.iif identical,<typ>,<l>,ASNL sym, val
  394+          	.error ; macro ASN - bad parameter 'typ'
  395+          	.endm
  396+          ;
  397+          ; Symbols set by the ASN macros to indicate usage - see below.
  398+          ;
  399+ 00000000 	...A == 0
  400+ 00000000 	..AA == 0
  401+ 00000000 	...B == 0
  402+ 00000000 	..BB == 0
  403+ 00000000 	...C == 0
  404+ 00000000 	...D == 0
  405+ FFFFFFFF 	...I == -1
  406+          ;
  407+          	ASN EXP, EXP_ASN, P,  0 ; Expansion Slot interrupt
  408+          	ASN NSS, NSS_ASN, P,  1 ; NSS/Hi-Link interrupt
  409+          	ASN WD1, WD1_ASN, P,  2 ; Widget board interrupt 1
  410+          	ASN PCI, PCI_ASN, P,  3 ; PCI slot interrupt
  411+          	ASN ADC, ADC_ASN, P,  4 ; A/D Converter interrupt
  412+          	ASN WD2, WD2_ASN, P,  5 ; Widget board interrupt 1
  413+          	ASN DBG, DBG_ASN, P,  6 ; Debug switch interrupt
  414+          	ASN VSY, VSY_ASN, P,  7 ; VSYNC interrupt
  415+          ;
  416+          	ASN MOE, MOE_ASN, G,  1 ; Galileo MemOut
  417+          	ASN DOE, DOE_ASN, G,  2 ; Galileo DMAOut
  418+          	ASN COE, COE_ASN, G,  3 ; Galileo CPUOut
  419+          	ASN DM0, DM0_ASN, G,  4 ; Galileo DMA0Comp
  420+          	ASN DM1, DM1_ASN, G,  5 ; Galileo DMA1Comp
  421+          	ASN DM2, DM2_ASN, G,  6 ; Galileo DMA2Comp
  422+          	ASN DM3, DM3_ASN, G,  7 ; Galileo DMA3Comp
  423+          	ASN TM0, TM0_ASN, G,  8 ; Galileo T0Exp
  424+          	ASN TM1, TM1_ASN, G,  9 ; Galileo T1Exp
  425+          	ASN TM2, TM2_ASN, G, 10 ; Galileo T2Exp
  426+          	ASN TM3, TM3_ASN, G, 11 ; Galileo T3Exp
  427+          	ASN MRE, MRE_ASN, G, 12 ; Galileo MasRdErr
  428+          	ASN SWE, SWE_ASN, G, 13 ; Galileo SlvWrErr
  429+          	ASN MWE, MWE_ASN, G, 14 ; Galileo MasWrErr
  430+          	ASN SRE, SRE_ASN, G, 15 ; Galileo SlvRdErr
  431+          	ASN AEP, AEP_ASN, G, 16 ; Galileo AddrErr
  432+          	ASN MEP, MEP_ASN, G, 17 ; Galileo MemErr
  433+          	ASN MAS, MAS_ASN, G, 18 ; Galileo MasAbort
  434+          	ASN TAR, TAR_ASN, G, 19 ; Galileo TarAbort
dispatch.c                               Atari Games Corp. macpp v9.12   "Oct 16 1997 13:26:41"


  435+          	ASN RTY, RTY_ASN, G, 20 ; Galileo RetryCtr
  436+          	ASN PC0, PC0_ASN, G, 26 ; Galileo PCI Interrupt
  437+          	ASN PC1, PC1_ASN, G, 27 ; Galileo PCI Interrupt
  438+          	ASN PC2, PC2_ASN, G, 28 ; Galileo PCI Interrupt
  439+          	ASN PC3, PC3_ASN, G, 29 ; Galileo PCI Interrupt
  440+ 00000000 	...GAL == 0
  441+   (2)    .if not_defined, NO_GAL_MasRdErr
  442+ 00001000 	...GAL == ...GAL | (1<<12)
  443+   (2)    .endc
  444+   (2)    .if not_defined, NO_GAL_SlvWrErr
  445+ 00003000 	...GAL == ...GAL | (1<<13)
  446+   (2)    .endc
  447+   (2)    .if not_defined, NO_GAL_MasWrErr
  448+ 00007000 	...GAL == ...GAL | (1<<14)
  449+   (2)    .endc
  450+   (2)    .if not_defined, NO_GAL_SlvRdErr
  451+ 0000F000 	...GAL == ...GAL | (1<<15)
  452+   (2)    .endc
  453+   (2)    .if not_defined, NO_GAL_AddrErr
  454+ 0001F000 	...GAL == ...GAL | (1<<16)
  455+   (2)    .endc
  456+   (2)    .if not_defined, NO_GAL_MemErr
  457+ 0003F000 	...GAL == ...GAL | (1<<17)
  458+   (2)    .endc
  459+   (2)    .if not_defined, NO_GAL_MasAbort
  460+ 0007F000 	...GAL == ...GAL | (1<<18)
  461+   (2)    .endc
  462+   (2)    .if not_defined, NO_GAL_TarAbort
  463+ 000FF000 	...GAL == ...GAL | (1<<19)
  464+   (2)    .endc
  465+   (2)    .if not_defined, NO_GAL_RetryCtr
  466+ 001FF000 	...GAL == ...GAL | (1<<20)
  467+   (2)    .endc
  468+          	ASN GAL, GAL_ASN, M, ...GAL	; Many Galileo Errors
  469+          ;
  470+          ; Make definitions according to usage.
  471+          ;
  472+          .iif true,..AA,HEX_CONST INTCTL_MAPA_INIT ...A	< Phoenix Interrupt Map Register >
  473+          .iif ne,...C,HEX_CONST PHOENIX_INTCTL_MASK ...C	< Phoenix Interrupt Control >
  474+          .iif ne,...D,HEX_CONST GALILEO_INTCTL_MASK ...D	< Galileo Interrupt Control >
  475+          .iif true,...I >= 0,DEC_CONST GALILEO_LVL ...I	< Galileo Error interrupt level >
  476+          ;
  477+          	HEX_CONST INTS_ON	0xFF01		< Enable all interrupts >
  478+          	HEX_CONST INTS_OFF	(INTS_ON&~1)	< Disable all interrupts >
  479+          ;
  480+          	STR_START diag_params
  481+          	STR_ELT	  actual_msb	U32  1	<Actual data read from mem (upper 32 bits)>
  482+          	STR_ELT	  actual_lsb	U32  1	<Actual data read from mem (lower 32 bits)>
  483+          	STR_ELT	  expected_msb	U32  1  <Expected data (upper 32 bits)>
  484+          	STR_ELT	  expected_lsb	U32  1	<Expected data (Lower 32 bits)>
  485+          	STR_ELT	  bad_address	U32  1  <Failing address>
  486+          	STR_ELT	  subtest	U32  1	<Subtest number>
  487+          	STR_END	  diag_params
  488+          ;
  489+   (2)    .if true, OUTPUT_LANG == LANG_C
  490+    X     #define WDOG *(VU32 *)WATCHDOG
  491+   (2)    .endc
dispatch.c                               Atari Games Corp. macpp v9.12   "Oct 16 1997 13:26:41"


  492+          REM <	Work RAM>
  493+          	ARRAY	WRAM,	U32, 	DRAM_BASE, DRAM_SIZE < Working RAM	>
  494+          REM <	EEPROM>
  495+            .ifndf EEPROM_SIZE
  496+ 00020000 	EEPROM_SIZE == BRAM_SIZE ; Guaranteed minimum
  497+   (2)      .endc
  498+          	ARRAY	EEPROM	U8	BRAM_BASE		EEPROM_SIZE < EEPROM 		>
  499+          REM <	BRAM>
  500+          	ADDR	BRAM 	U8	BRAM_BASE		< BRAM	(non-cached)	>
  501+          	VAR	UNLK_EP VU32	BRAM_UNLK		< BRAM unlock >
  502+          ;
  503+          	.include idt.mac
    1+          ; $Id: idt.mac,v 1.30 1997/07/01 20:54:19 shepperd Exp $
    2+          ;
    3+   (2)    .if ndf, _CONSTANTS_MAC_
    4+    X       .warn ;You should .include constants.mac before including lcr3k.mac
    5+    X       .include constants.mac
    6+   (2)    .endc
    7+   (2)    .if ndf, _PPTYPES_MAC_
    8+    X       .warn ;You should .include types.mac before including lcr3k.mac
    9+    X       .include pptypes.mac
   10+   (2)    .endc
   11+          ;
   12+   (2)    .if ndf,PROCESSOR
   13+    X       .warn ;You need to define PROCESSOR before including idt.mac
   14+    X     	HEX_CONST PROCESSOR	0
   15+   (2)    .endc
   16+          ;
   17+ 00000000 HB_PHOENIX == 0
   18+ 00000001 .iif true, ((HOST_BOARD&HOST_BOARD_CLASS) == PHOENIX), HB_PHOENIX == 1
   19+          ;
   20+          REMB
   21+          REMM ** Exception Vectors
   22+          REME
   23+          ;
   24+   (2)    .if true, (PROCESSOR&-16) == MIPS3000
   25+    X     	HEX_CONST RST_VEC	(MEM_KSEG1|0x1fc00000+0x000)	< reset and NMI vector >
   26+    X     	HEX_CONST TLB_VEC	(MEM_KSEG1|0x1fc00000+0x100)	< tlb refill vector >
   27+    X     	HEX_CONST EXCEPT_VEC	(MEM_KSEG1|0x1fc00000+0x180)	< Normal exception vector >
   28+   (2)    .endc
   29+   (2)    .if true, (PROCESSOR&-16) == MIPS4000
   30+          	HEX_CONST RST_VEC	(MEM_KSEG1|0x1fc00000+0x000)	< reset and NMI vector >
   31+          	HEX_CONST TLB_VEC	(MEM_KSEG1|0x1fc00200+0x000)	< tlb refill vector >
   32+          	HEX_CONST XTLB_VEC	(MEM_KSEG1|0x1fc00200+0x080)	< XTLB refill vevtor (64 bit) >
   33+          	HEX_CONST CACHE_VEC	(MEM_KSEG1|0x1fc00200+0x100)	< CACHE Error vector >
   34+          	HEX_CONST EXCEPT_VEC	(MEM_KSEG1|0x1fc00200+0x180)	< Normal exception vector >
   35+   (2)    .endc
   36+          ;
   37+          ; Translated from IDT's idtcpu.h
   38+          ;
   39+          REMB <** >
   40+          REMM <** memory configuration and mapping >
   41+          REME <** >
   42+          ;
   43+          	HEX_CONST	K0BASE	0x80000000
   44+          	HEX_CONST	K0SIZE	0x20000000
   45+          	HEX_CONST	K1BASE	0xa0000000
dispatch.c                               Atari Games Corp. macpp v9.12   "Oct 16 1997 13:26:41"


   46+          	HEX_CONST	K1SIZE	0x20000000
   47+          	HEX_CONST	K2BASE	0xc0000000
   48+          	HEX_CONST	K2SIZE	0x20000000
   49+   (2)    .if true, (PROCESSOR&-16) == MIPS4000
   50+          	HEX_CONST	KSBASE	0xe0000000
   51+          	HEX_CONST	KSSIZE	0x20000000
   52+   (2)    .endc
   53+          ;
   54+          	HEX_CONST	KUBASE	0
   55+          	HEX_CONST	KUSIZE	0x80000000
   56+          ;
   57+          REMB <** >
   58+          REMM <** Exception Vectors>
   59+          REME <** >
   60+   (2)    .if true, (PROCESSOR&-16) == MIPS3000
   61+    X     	HEX_CONST	UT_VEC	K0BASE			< utlbmiss vector >
   62+    X     	HEX_CONST	E_VEC	(K0BASE+0x80)		< exception vevtor >
   63+   (2)    .endc
   64+   (2)    .if true, (PROCESSOR&-16) == MIPS4000
   65+          	HEX_CONST	T_VEC	(K0BASE+0x000)		< tlbmiss vector >
   66+          	HEX_CONST	X_VEC	(K0BASE+0x080)		< xtlbmiss vector >
   67+          	HEX_CONST	C_VEC	(K0BASE+0x100)		< cache error vector >
   68+          	HEX_CONST	E_VEC	(K0BASE+0x180)		< exception vector >
   69+   (2)    .endc
   70+          	HEX_CONST	R_VEC	(K1BASE+0x1fc00000)	< reset vector >
   71+          ;
   72+          REMB <** >
   73+          REMM <** Address conversion macros >
   74+          REME <** >
   75+   (2)    .if true, OUTPUT_LANG == LANG_C
   76+    X     #define 	CAST(as) (as)
   77+    X     #define	K0_TO_K1(x)	(CAST(unsigned)(x)|0xA0000000)	/* kseg0 to kseg1 */
   78+    X     #define	K1_TO_K0(x)	(CAST(unsigned)(x)&0x9FFFFFFF)	/* kseg1 to kseg0 */
   79+    X     #define	K0_TO_PHYS(x)	(CAST(unsigned)(x)&0x1FFFFFFF)	/* kseg0 to physical */
   80+    X     #define	K1_TO_PHYS(x)	(CAST(unsigned)(x)&0x1FFFFFFF)	/* kseg1 to physical */
   81+    X     #define	PHYS_TO_K0(x)	(CAST(unsigned)(x)|0x80000000)	/* physical to kseg0 */
   82+    X     #define	PHYS_TO_K1(x)	(CAST(unsigned)(x)|0xA0000000)	/* physical to kseg1 */
   83+   (2)    .endc
   84+          ;
   85+   (2)    .if true, (PROCESSOR&-16) == MIPS3000
   86+    X     REMB
   87+    X     REMM **	Cache size constants
   88+    X     REME
   89+          ;
   90+    X     	HEX_CONST MIN_CACHE_SIZE	0x00200		< 2*256      512  >
   91+    X     	HEX_CONST MAX_CACHE_SIZE	0x40000		< 256*1024   256k >	
   92+   (2)    .endc
   93+   (2)    .if true, (PROCESSOR&-16) == MIPS4000
   94+          REMB <** >
   95+          REMM <** Cache size constants >
   96+          REME <** >
   97+          	HEX_CONST	MINCACHE	0x800		< 2*1024     2k   >
   98+          	HEX_CONST	MAXCACHE	0x40000		< 256*1024   256k >	
   99+   (2)    .endc
  100+          ;
  101+   (2)    .if true, (PROCESSOR&-16) == MIPS3000
  102+    X     REMB
dispatch.c                               Atari Games Corp. macpp v9.12   "Oct 16 1997 13:26:41"


  103+    X     REMM < see the IDT/c 4.1.1 User's Manual Table 6.9 Coprocessor 0 Regs >
  104+    X     REME
  105+    X     	REG_CONST C0_BUSCTRL		$2		< bus control >
  106+    X     	DEC_CONST    C0_BUSC_LOCK_v	(31)	< lock the register      (1) >
  107+    X     	DEC_CONST    C0_BUSC_MEM_v	(26)	< Memstrobe control bits (2) >
  108+    X     	DEC_CONST    C0_BUSC_ED_v	(24)	< ExtDataEn control bits (2) >
  109+    X     	DEC_CONST    C0_BUSC_IO_v	(22)	< IOstrobe control bits  (2) >
  110+    X     	DEC_CONST    C0_BUSC_BE16_v	(21)	< BE16(1:0) control bit  (1) >
  111+    X     	DEC_CONST    C0_BUSC_BE_v	(19)	< BE(3:0) control bit    (1) >
  112+    X     	DEC_CONST    C0_BUSC_BTA_v	(14)	< BTA Bus turn around time (2) >
  113+    X     	DEC_CONST    C0_BUSC_DMA_v	(13)	< DMA protocol control   (1) >
  114+    X     	DEC_CONST    C0_BUSC_TC_v	(12)	< TC negation control    (1) >
  115+    X     	DEC_CONST    C0_BUSC_BR_v	(11)	< SBrCond(3:2) control   (1) >
  116+    X     .TEMP == ((1<<29)|(1<<20)|(1<<16)|(1<<8))
  117+    X     	HEX_CONST    C0_BUSC_DEFAULT	.TEMP
  118+    X     	REG_CONST C0_CONFIG		$3	< cache config >
  119+    X     	DEC_CONST    C0_CONF_LOCK_v	(31)	< lock the register 	(1) >
  120+    X     	DEC_CONST    C0_CONF_SLOWB_v	(30)	< slow bus (3081) 	(1) >
  121+    X     	DEC_CONST    C0_CONF_DBLOCK_v	(29)	< DBLOCK refill size (1 or 4 words/miss) >
  122+    X     	DEC_CONST    C0_CONF_FPINT_v	(26)	< FPInt pin (3081)	(3) >
  123+    X     	DEC_CONST    C0_CONF_HALT_v	(25)	< HALT the CPU (3081)	(1) >
  124+    X     	DEC_CONST    C0_CONF_RF_v	(24)	< Reduced freq (3081)	(1) >
  125+    X     	DEC_CONST    C0_CONF_ALTC_c	(23)	< Make I and D caches 8k each (3081) (1) >
  126+    X     	DEC_CONST    C0_CONF_FDM_v	(19)	< Force D-cache miss >
  127+    X     .TEMP == (1<<30)
  128+    X     	HEX_CONST    C0_CONF_DEFAULT_3041 .TEMP	< bits that must be set in config register >
  129+    X     .if not_defined, C0_CONF_DEFAULT_3081
  130+    X     .TEMP == (1<<C0_CONF_SLOWB_v) | (7<<C0_CONF_FPINT_v)
  131+    X     	HEX_CONST    C0_CONF_DEFAULT_3081 .TEMP < bits that must be set in config register >
  132+    X     .endc
  133+    X     .TEMP == (1<<C0_CONF_SLOWB_v) 
  134+    X     	HEX_CONST    C0_CONF_DEFAULT_3071 .TEMP < bits that must be set in config register >
  135+    X     	REG_CONST C0_COUNT		$9	< count >
  136+    X     	REG_CONST C0_PORTSIZE		$10	< port size >
  137+    X     	REG_CONST C0_COMPARE		$11	< compare >
  138+    X     	REG_CONST C1_FIR		$0	< FPU implementation register >
  139+    X     	REG_CONST C1_FCSR		$31	< FPU control and status register >
  140+          ;
  141+   (2)    .endc
  142+   (2)    .if true, (PROCESSOR&-16) == MIPS4000
  143+          REMB <** >
  144+          REMM <** R4000 configuration register definitions >
  145+          REME <** >
  146+          	HEX_CONST	CFG_CM		0x80000000	< Master-Checker mode >
  147+          	HEX_CONST	CFG_ECMASK	0x70000000	< System Clock Ratio >
  148+          	HEX_CONST	CFG_ECBY2	0x00000000 	< divide by 2 >
  149+          	HEX_CONST	CFG_ECBY3	0x10000000 	< divide by 3 >
  150+          	HEX_CONST	CFG_ECBY4	0x20000000 	< divide by 4 >
  151+          	HEX_CONST	CFG_EPMASK	0x0f000000	< Transmit data pattern >
  152+          	HEX_CONST	CFG_EPD		0x00000000	< D >
  153+          	HEX_CONST	CFG_EPDDX	0x01000000	< DDX >
  154+          	HEX_CONST	CFG_EPDDXX	0x02000000	< DDXX >
  155+          	HEX_CONST	CFG_EPDXDX	0x03000000	< DXDX >
  156+          	HEX_CONST	CFG_EPDDXXX	0x04000000	< DDXXX >
  157+          	HEX_CONST	CFG_EPDDXXXX	0x05000000	< DDXXXX >
  158+          	HEX_CONST	CFG_EPDXXDXX	0x06000000	< DXXDXX >
  159+          	HEX_CONST	CFG_EPDDXXXXX	0x07000000	< DDXXXXX >
dispatch.c                               Atari Games Corp. macpp v9.12   "Oct 16 1997 13:26:41"


  160+          	HEX_CONST	CFG_EPDXXXDXXX	0x08000000	< DXXXDXXX >
  161+          	HEX_CONST	CFG_SBMASK	0x00c00000	< Secondary cache block size >
  162+          	HEX_CONST	CFG_SBSHIFT	22
  163+          	HEX_CONST	CFG_SB4		0x00000000	< 4 words >
  164+          	HEX_CONST	CFG_SB8		0x00400000	< 8 words >
  165+          	HEX_CONST	CFG_SB16	0x00800000	< 16 words >
  166+          	HEX_CONST	CFG_SB32	0x00c00000	< 32 words >
  167+          	HEX_CONST	CFG_SS		0x00200000	< Split secondary cache >
  168+          	HEX_CONST	CFG_SW		0x00100000	< Secondary cache port width >
  169+          	HEX_CONST	CFG_EWMASK	0x000c0000	< System port width >
  170+          	HEX_CONST	CFG_EWSHIFT	18
  171+          	HEX_CONST	CFG_EW64	0x00000000	< 64 bit >
  172+          	HEX_CONST	CFG_EW32	0x00010000	< 32 bit >
  173+          	HEX_CONST	CFG_SC		0x00020000	< Secondary cache absent >
  174+          	HEX_CONST	CFG_SM		0x00010000	< Dirty Shared mode disabled >
  175+          	HEX_CONST	CFG_BE		0x00008000	< Big Endian >
  176+          	HEX_CONST	CFG_LE		0x00000000	< Little Endian >
  177+          	HEX_CONST	CFG_EM		0x00004000	< ECC mode enable >
  178+          	HEX_CONST	CFG_EB		0x00002000	< Block ordering >
  179+          	HEX_CONST	CFG_ICMASK	0x00000e00	< Instruction cache size >
  180+          	HEX_CONST	CFG_ICSHIFT	9
  181+          	HEX_CONST	CFG_DCMASK	0x000001c0	< Data cache size >
  182+          	HEX_CONST	CFG_DCSHIFT	6
  183+          	HEX_CONST	CFG_IB		0x00000020	< Instruction cache block size >
  184+          	HEX_CONST	CFG_DB		0x00000010	< Data cache block size >
  185+          	HEX_CONST	CFG_CU		0x00000008	< Update on Store Conditional >
  186+          	HEX_CONST	CFG_K0MASK	0x00000007	< KSEG0 coherency algorithm >
  187+          ;
  188+          REMB <** >
  189+          REMM <** R4000 primary cache mode >
  190+          REME <** >
  191+          ;
  192+          	HEX_CONST	CFG_C_UNCACHED		2
  193+          	HEX_CONST	CFG_C_NONCOHERENT	3
  194+          	HEX_CONST	CFG_C_COHERENTXCL	4
  195+          	HEX_CONST	CFG_C_COHERENTXCLW	5
  196+          	HEX_CONST	CFG_C_COHERENTUPD	6
  197+          ;
  198+          REMB <** >
  199+          REMM <** R4000 cache operations >
  200+          REME <** >
  201+          ;
  202+          	HEX_CONST	Index_Invalidate_I               ((0<<2)|0)
  203+          	HEX_CONST	Index_Writeback_Inv_D            ((0<<2)|1)
  204+          	HEX_CONST	Scache_clear			 ((0<<2)|3)
  205+          	HEX_CONST	Index_Load_Tag_I                 ((1<<2)|0)
  206+          	HEX_CONST	Index_Load_Tag_D                 ((1<<2)|1)
  207+          	HEX_CONST	Index_Load_Tag_S                 ((1<<2)|3)
  208+          	HEX_CONST	Index_Store_Tag_I                ((2<<2)|0)
  209+          	HEX_CONST	Index_Store_Tag_D                ((2<<2)|1)
  210+          	HEX_CONST	Index_Store_Tag_S                ((2<<2)|3)
  211+          	HEX_CONST	Create_Dirty_Exc_D               ((3<<2)|1)
  212+          	HEX_CONST	Create_Dirty_Exc_S               ((3<<2)|3)
  213+          	HEX_CONST	Hit_Invalidate_I                 ((4<<2)|0)
  214+          	HEX_CONST	Hit_Invalidate_D                 ((4<<2)|1)
  215+          	HEX_CONST	Hit_Invalidate_S                 ((4<<2)|3)
  216+          	HEX_CONST	Fill_I                           ((5<<2)|0)
dispatch.c                               Atari Games Corp. macpp v9.12   "Oct 16 1997 13:26:41"


  217+          	HEX_CONST	Hit_Writeback_Inv_D              ((5<<2)|1)
  218+          	HEX_CONST	Cache_Page_Inv_S                 ((5<<2)|3)
  219+          	HEX_CONST	Hit_Writeback_I                  ((6<<2)|0)
  220+          	HEX_CONST	Hit_Writeback_D                  ((6<<2)|1)
  221+   (2)    .endc
  222+          ;
  223+          REMB <** >
  224+          REMM <** TLB resource defines >
  225+          REME <** >
  226+   (2)    .if true, (PROCESSOR&-16) == MIPS3000
  227+    X     	HEX_CONST	N_TLB_ENTRIES	64
  228+    X     	HEX_CONST	TLB_PGSIZE	0x1000
  229+    X     	HEX_CONST	RANDBASE	8
  230+    X     	HEX_CONST	TLBLO_PFNMASK	0xfffff000
  231+    X     	HEX_CONST	TLBLO_PFNSHIFT	12
  232+    X     	HEX_CONST	TLBLO_N		0x800	< non-cacheable >
  233+    X     	HEX_CONST	TLBLO_D		0x400	< writeable >
  234+    X     	HEX_CONST	TLBLO_V		0x200	< valid bit >
  235+    X     	HEX_CONST	TLBLO_G		0x100	< global access bit >
  236+          ;
  237+    X     	HEX_CONST	TLBHI_VPNMASK	0xfffff000
  238+    X     	HEX_CONST	TLBHI_VPNSHIFT	12
  239+    X     	HEX_CONST	TLBHI_PIDMASK	0xfc0
  240+    X     	HEX_CONST	TLBHI_PIDSHIFT	6
  241+    X     	HEX_CONST	TLBHI_NPID	64
  242+          ;
  243+    X     	HEX_CONST	TLBINX_PROBE	0x80000000
  244+    X     	HEX_CONST	TLBINX_INXMASK	0x00003f00
  245+    X     	HEX_CONST	TLBINX_INXSHIFT	8
  246+          ;
  247+    X     	HEX_CONST	TLBRAND_RANDMASK	0x00003f00
  248+    X     	HEX_CONST	TLBRAND_RANDSHIFT	8
  249+          ;
  250+    X     	HEX_CONST	TLBCTXT_BASEMASK	0xffe00000
  251+    X     	HEX_CONST	TLBCTXT_BASESHIFT	21
  252+          ;
  253+    X     	HEX_CONST	TLBCTXT_VPNMASK		0x001ffffc
  254+    X     	HEX_CONST	TLBCTXT_VPNSHIFT	2
  255+   (2)    .endc
  256+   (2)    .if true, (PROCESSOR&-16) == MIPS4000
  257+   (3)     .if true, (PROCESSOR == MIPS4300L) || (PROCESSOR != MIPS4300)
  258+          	HEX_CONST	N_TLB_ENTRIES	32
  259+   (3)     .iff
  260+    X     	HEX_CONST	N_TLB_ENTRIES	48
  261+   (3)     .endc
  262+          ;
  263+          	HEX_CONST	TLBHI_VPN2MASK	0xffffe000
  264+          	HEX_CONST	TLBHI_PIDMASK	0x000000ff
  265+          	HEX_CONST	TLBHI_NPID	256
  266+          ;
  267+          	HEX_CONST	TLBLO_PFNMASK	0x3fffffc0
  268+          	HEX_CONST	TLBLO_PFNSHIFT	6
  269+          	HEX_CONST	TLBLO_D		0x00000004	< writeable >
  270+          	HEX_CONST	TLBLO_V		0x00000002	< valid bit >
  271+          	HEX_CONST	TLBLO_G		0x00000001	< global access bit >
  272+          	HEX_CONST	TLBLO_CMASK	0x00000038	< cache algorithm mask >
  273+          	HEX_CONST	TLBLO_CSHIFT	3
dispatch.c                               Atari Games Corp. macpp v9.12   "Oct 16 1997 13:26:41"


  274+          ;
  275+          	HEX_CONST	TLBLO_UNCACHED		(CFG_C_UNCACHED<<TLBLO_CSHIFT)
  276+          	HEX_CONST	TLBLO_NONCOHERENT	(CFG_C_NONCOHERENT<<TLBLO_CSHIFT)
  277+          	HEX_CONST	TLBLO_COHERENTXCL	(CFG_C_COHERENTXCL<<TLBLO_CSHIFT)
  278+          	HEX_CONST	TLBLO_COHERENTXCLW	(CFG_C_COHERENTXCLW<<TLBLO_CSHIFT)
  279+          	HEX_CONST	TLBLO_COHERENTUPD	(CFG_C_COHERENTUPD<<TLBLO_CSHIFT)
  280+          ;
  281+          	HEX_CONST	TLBINX_PROBE	0x80000000
  282+          	HEX_CONST	TLBINX_INXMASK	0x0000003f
  283+          ;
  284+          	HEX_CONST	TLBRAND_RANDMASK	0x0000003f
  285+          ;
  286+          	HEX_CONST	TLBCTXT_BASEMASK	0xff800000
  287+          	HEX_CONST	TLBCTXT_BASESHIFT	23
  288+          ;
  289+          	HEX_CONST	TLBCTXT_VPN2MASK	0x007ffff0
  290+          	HEX_CONST	TLBCTXT_VPN2SHIFT	4
  291+          ;
  292+          	HEX_CONST	TLBPGMASK_MASK		0x01ffe000
  293+   (2)    .endc
  294+          ;
  295+   (2)    .if true, (PROCESSOR&-16) == MIPS3000
  296+    X     	HEX_CONST	SR_CUMASK	0xf0000000	< coproc usable bits >
  297+    X     	HEX_CONST	SR_CU3		0x80000000	< Coprocessor 3 usable >
  298+    X     	HEX_CONST	SR_CU2		0x40000000	< Coprocessor 2 usable >
  299+    X     	HEX_CONST	SR_CU1		0x20000000	< Coprocessor 1 usable >
  300+    X     	HEX_CONST	SR_CU0		0x10000000	< Coprocessor 0 usable >
  301+          ;
  302+    X     	HEX_CONST	SR_BEV		0x00400000	< use boot exception vectors >
  303+          ;
  304+    X     REMB <** >
  305+    X     REMM <** Cache control bits >
  306+    X     REME <** >
  307+          ;
  308+    X     	HEX_CONST	SR_TS		0x00200000	< TLB shutdown >
  309+    X     	HEX_CONST	SR_PE		0x00100000	< cache parity error >
  310+    X     	HEX_CONST	SR_CM		0x00080000	< cache miss >
  311+    X     	HEX_CONST	SR_PZ		0x00040000	< cache parity zero >
  312+    X     	HEX_CONST	SR_SWC		0x00020000	< swap cache >
  313+    X     	HEX_CONST	SR_ISC		0x00010000	< Isolate data cache >
  314+          ;
  315+    X     REMB <** >
  316+    X     REMM <** status register interrupt masks and bits >
  317+    X     REME <** >
  318+          ;
  319+    X     	HEX_CONST	SR_IMASK	0x0000ff00	< Interrupt mask >
  320+    X     	HEX_CONST	SR_IMASK8	0x00000000	< mask level 8 >
  321+    X     	HEX_CONST	SR_IMASK7	0x00008000	< mask level 7 >
  322+    X     	HEX_CONST	SR_IMASK6	0x0000c000	< mask level 6 >
  323+    X     	HEX_CONST	SR_IMASK5	0x0000e000	< mask level 5 >
  324+    X     	HEX_CONST	SR_IMASK4	0x0000f000	< mask level 4 >
  325+    X     	HEX_CONST	SR_IMASK3	0x0000f800	< mask level 3 >
  326+    X     	HEX_CONST	SR_IMASK2	0x0000fc00	< mask level 2 >
  327+    X     	HEX_CONST	SR_IMASK1	0x0000fe00	< mask level 1 >
  328+    X     	HEX_CONST	SR_IMASK0	0x0000ff00	< mask level 0 >
  329+          ;
  330+    X     	HEX_CONST	SR_IMASKSHIFT	8
dispatch.c                               Atari Games Corp. macpp v9.12   "Oct 16 1997 13:26:41"


  331+          ;
  332+    X     	HEX_CONST	SR_IBIT8	0x00008000	< bit level 8 >
  333+    X     	HEX_CONST	SR_IBIT7	0x00004000	< bit level 7 >
  334+    X     	HEX_CONST	SR_IBIT6	0x00002000	< bit level 6 >
  335+    X     	HEX_CONST	SR_IBIT5	0x00001000	< bit level 5 >
  336+    X     	HEX_CONST	SR_IBIT4	0x00000800	< bit level 4 >
  337+    X     	HEX_CONST	SR_IBIT3	0x00000400	< bit level 3 >
  338+    X     	HEX_CONST	SR_IBIT2	0x00000200	< bit level 2 >
  339+    X     	HEX_CONST	SR_IBIT1	0x00000100	< bit level 1 >
  340+          ;
  341+    X     	HEX_CONST	SR_KUO		0x00000020	< old kernel/user, 0 => k, 1 => u >
  342+    X     	HEX_CONST	SR_IEO		0x00000010	< old interrupt enable, 1 => enable >
  343+    X     	HEX_CONST	SR_KUP		0x00000008	< prev kernel/user, 0 => k, 1 => u >
  344+    X     	HEX_CONST	SR_IEP		0x00000004	< prev interrupt enable, 1 => enable >
  345+    X     	HEX_CONST	SR_KUC		0x00000002	< cur kernel/user, 0 => k, 1 => u >
  346+    X     	HEX_CONST	SR_IE		0x00000001	< cur interrupt enable, 1 => enable >
  347+    X     	HEX_CONST	SR_IEC		0x00000001	< cur interrupt enable, 1 => enable >
  348+   (2)    .endc
  349+          ;
  350+   (2)    .if true, (PROCESSOR&-16) == MIPS4000
  351+          	HEX_CONST	SR_CUMASK	0xf0000000	< coproc usable bits >
  352+          	HEX_CONST	SR_CU3		0x80000000	< Coprocessor 3 usable >
  353+          	HEX_CONST	SR_CU2		0x40000000	< Coprocessor 2 usable >
  354+          	HEX_CONST	SR_CU1		0x20000000	< Coprocessor 1 usable >
  355+          	HEX_CONST	SR_CU0		0x10000000	< Coprocessor 0 usable >
  356+          ;
  357+          	HEX_CONST	SR_RP		0x08000000      < Reduced power operation >
  358+          	HEX_CONST	SR_FR		0x04000000	< Additional floating point registers >
  359+          	HEX_CONST	SR_RE		0x02000000	< Reverse endian in user mode >
  360+   (3)     .if true, (PROCESSOR&-2) == MIPS4300
  361+    X     	HEX_CONST	SR_ITS		0x01000000	< Instruction trace support >
  362+   (3)     .endc
  363+          ;
  364+          	HEX_CONST	SR_BEV		0x00400000	< Use boot exception vectors >
  365+          	HEX_CONST	SR_TS		0x00200000	< TLB shutdown >
  366+          	HEX_CONST	SR_SR		0x00100000	< Soft reset >
  367+          	HEX_CONST	SR_CH		0x00040000	< Cache hit >
  368+          	HEX_CONST	SR_CE		0x00020000	< Use cache ECC  >
  369+          	HEX_CONST	SR_DE		0x00010000	< Disable cache exceptions >
  370+          ;
  371+          REMB <** >
  372+          REMM <** status register interrupt masks and bits >
  373+          REME <** >
  374+          ;
  375+          	HEX_CONST	SR_IMASK	0x0000ff00	< Interrupt mask >
  376+          	HEX_CONST	SR_IMASK8	0x00000000	< mask level 8 >
  377+          	HEX_CONST	SR_IMASK7	0x00008000	< mask level 7 >
  378+          	HEX_CONST	SR_IMASK6	0x0000c000	< mask level 6 >
  379+          	HEX_CONST	SR_IMASK5	0x0000e000	< mask level 5 >
  380+          	HEX_CONST	SR_IMASK4	0x0000f000	< mask level 4 >
  381+          	HEX_CONST	SR_IMASK3	0x0000f800	< mask level 3 >
  382+          	HEX_CONST	SR_IMASK2	0x0000fc00	< mask level 2 >
  383+          	HEX_CONST	SR_IMASK1	0x0000fe00	< mask level 1 >
  384+          	HEX_CONST	SR_IMASK0	0x0000ff00	< mask level 0 >
  385+          ;
  386+          	HEX_CONST	SR_IMASKSHIFT	8
  387+          ;
dispatch.c                               Atari Games Corp. macpp v9.12   "Oct 16 1997 13:26:41"


  388+          	HEX_CONST	SR_IBIT8	0x00008000	< bit level 8 >
  389+          	HEX_CONST	SR_IBIT7	0x00004000	< bit level 7 >
  390+          	HEX_CONST	SR_IBIT6	0x00002000	< bit level 6 >
  391+          	HEX_CONST	SR_IBIT5	0x00001000	< bit level 5 >
  392+          	HEX_CONST	SR_IBIT4	0x00000800	< bit level 4 >
  393+          	HEX_CONST	SR_IBIT3	0x00000400	< bit level 3 >
  394+          	HEX_CONST	SR_IBIT2	0x00000200	< bit level 2 >
  395+          	HEX_CONST	SR_IBIT1	0x00000100	< bit level 1 >
  396+          ;
  397+          	HEX_CONST	SR_KX		0x00000080	< TLB vector offset = 0x80 >
  398+          	HEX_CONST	SR_SX		0x00000040	< Supervisor mode 64 bit >
  399+          	HEX_CONST	SR_UX		0x00000020	< User mode 64 bit >
  400+          	HEX_CONST	SR_KSMASK	0x00000018	< Kernel mode mask >
  401+          	HEX_CONST	SR_KSUSER	0x00000010	< User mode >
  402+          	HEX_CONST	SR_KSSUPER	0x00000008	< Supervisor mode >
  403+          	HEX_CONST	SR_KSKERNEL	0x00000000	< Kernel mode >
  404+          	HEX_CONST	SR_ERL		0x00000004	< Error level >
  405+          	HEX_CONST	SR_EXL		0x00000002	< Exception level >
  406+          	HEX_CONST	SR_IE		0x00000001	< Interrupts enabled >
  407+          	HEX_CONST	SR_IEC		0x00000001	< Interrupts enabled >
  408+   (2)    .endc
  409+          ;
  410+          REMB <** >
  411+          REMM <** Cause Register >
  412+          REME <** >
  413+          ;
  414+          	HEX_CONST	CAUSE_BD	0x80000000	< Branch delay slot >
  415+          	HEX_CONST	CAUSE_CEMASK	0x30000000	< coprocessor error >
  416+          	HEX_CONST	CAUSE_CESHIFT	28
  417+          ;
  418+          	HEX_CONST	CAUSE_IPMASK	0x0000FF00	< Pending interrupt mask >
  419+          	HEX_CONST	CAUSE_IPSHIFT	8
  420+          ;
  421+          	HEX_CONST	CAUSE_EXCMASK	0x0000007C	< Cause code bits >
  422+          	HEX_CONST	CAUSE_EXCSHIFT	2
  423+          ;
  424+          REMB <** >
  425+          REMM <**  Coprocessor 0 registers >
  426+          REME <** >
  427+          ;
  428+          	REG_CONST	C0_INX		$0		< tlb index >
  429+          	REG_CONST	C0_RAND		$1		< tlb random >
  430+   (2)    .if true, (PROCESSOR&-16) == MIPS3000
  431+    X     	REG_CONST	C0_TLBLO	$2		< tlb entry low >
  432+   (2)    .endc
  433+   (2)    .if true, (PROCESSOR&-16) == MIPS4000
  434+          	REG_CONST	C0_TLBLO0	$2		< tlb entry low 0 >
  435+          	REG_CONST	C0_TLBLO1	$3		< tlb entry low 1 >
  436+   (2)    .endc
  437+          ;
  438+          	REG_CONST	C0_CTXT		$4		< tlb context >
  439+          ;
  440+   (2)    .if true, (PROCESSOR&-16) == MIPS4000
  441+          	REG_CONST	C0_PAGEMASK	$5		< tlb page mask >
  442+          	REG_CONST	C0_WIRED	$6		< number of wired tlb entries >
  443+   (2)    .endc
  444+          ;
dispatch.c                               Atari Games Corp. macpp v9.12   "Oct 16 1997 13:26:41"


  445+          	REG_CONST	C0_BADVADDR	$8		< bad virtual address >
  446+          ;
  447+   (2)    .if true, (PROCESSOR&-16) == MIPS4000
  448+          	REG_CONST	C0_COUNT	$9		< cycle count >
  449+   (2)    .endc
  450+          ;
  451+          	REG_CONST	C0_TLBHI	$10		< tlb entry hi >
  452+          ;
  453+   (2)    .if true, (PROCESSOR&-16) == MIPS4000
  454+          	REG_CONST	C0_COMPARE	$11		< cyccle count comparator  >
  455+   (2)    .endc
  456+          ;
  457+          	REG_CONST	C0_SR		$12		< status register >
  458+          	REG_CONST	C0_CAUSE	$13		< exception cause >
  459+          	REG_CONST	C0_EPC		$14		< exception pc >
  460+          	REG_CONST	C0_PRID		$15		< revision identifier >
  461+          ;
  462+   (2)    .if true, (PROCESSOR&-16) == MIPS4000
  463+          	REG_CONST	C0_CONFIG	$16		< configuration register >
  464+          	REG_CONST	C0_LLADDR	$17		< linked load address >
  465+   (3)     .if true, PROCESSOR != MIPS4600
  466+          	REG_CONST	C0_WATCHLO	$18		< watchpoint trap register >
  467+          	REG_CONST	C0_WATCHHI	$19		< watchpoint trap register >
  468+   (3)     .iff
  469+    X     	REG_CONST	C0_WATCHLO_U	$18
  470+    X     	REG_CONST	C0_WATCHHI_U	$19
  471+   (3)     .endc
  472+          	REG_CONST	C0_XCTXT	$20		< 64 bit context register >
  473+          	REG_CONST	C0_ECC		$26		< secondary cache ECC control >
  474+          	REG_CONST	C0_CACHEERR	$27		< cache error status >
  475+          	REG_CONST	C0_TAGLO	$28		< cache tag lo >
  476+          	REG_CONST	C0_TAGHI	$29		< cache tag hi >
  477+          	REG_CONST	C0_ERRPC	$30		< cache error pc >
  478+          	REG_CONST	C1_FIR		$0		< FPU implementation register >
  479+          	REG_CONST	C1_FCSR		$31		< FPU Control and status register >
  480+          	DEC_CONST		C1_FCSR_FS	(1<<24)	< Flush denormalized results to 0>
  481+          	DEC_CONST		C1_FCSR_C	(1<<23)	< Condition bit >
  482+          	DEC_CONST		C1_FCSR_CA_E	(1<<17)	< Unimplemented operation exception >
  483+          	DEC_CONST		C1_FCSR_CA_V	(1<<16)	< Invalid operation exception >
  484+          	DEC_CONST		C1_FCSR_CA_Z	(1<<15)	< Divide by 0 exception >
  485+          	DEC_CONST		C1_FCSR_CA_O	(1<<14)	< Overflow exception >
  486+          	DEC_CONST		C1_FCSR_CA_U	(1<<13)	< Undeflow exception >
  487+          	DEC_CONST		C1_FCSR_CA_I	(1<<12)	< Inexact exception >
  488+          	DEC_CONST		C1_FCSR_EN_V	(1<<11)	< Enable invalid operation exception >
  489+          	DEC_CONST		C1_FCSR_EN_Z	(1<<10)	< Enable divide by 0 exception >
  490+          	DEC_CONST		C1_FCSR_EN_O	(1<<9)	< Enable overflow exception >
  491+          	DEC_CONST		C1_FCSR_EN_U	(1<<8)	< Enable underflow exception >
  492+          	DEC_CONST		C1_FCSR_EN_I	(1<<7)	< Enable inexact exception >
  493+          	DEC_CONST		C1_FCSR_FLG_V	(1<<6)	< Invalid operation >
  494+          	DEC_CONST		C1_FCSR_FLG_Z	(1<<5)	< Divide by 0 >
  495+          	DEC_CONST		C1_FCSR_FLG_O	(1<<4)	< Overflow >
  496+          	DEC_CONST		C1_FCSR_FLG_U	(1<<3)	< Undeflow >
  497+          	DEC_CONST		C1_FCSR_FLG_I	(1<<2)	< Inexact >
  498+          	DEC_CONST		C1_FCSR_RM_RN	0	< Round to nearest representable >
  499+          	DEC_CONST		C1_FCSR_RM_RZ	1	< Round toward 0 >
  500+          	DEC_CONST		C1_FCSR_RM_RP	2	< Round toward +infinity >
  501+          	DEC_CONST		C1_FCSR_RM_RM	3	< Round toward -infinity >
dispatch.c                               Atari Games Corp. macpp v9.12   "Oct 16 1997 13:26:41"


  502+   (2)    .endc
  503+          ;
  504+          	STR_START cpu_params
  505+          	STR_ELT	  cpu_type	U32 1	<cpu type (3041, 3051, etc)>
  506+          	STR_ELT	  cpu_prid	U32 1	<copy of C0_PRID register>
  507+          	STR_ELT	  cpu_icache	U32 1	<size of I cache in bytes>
  508+          	STR_ELT	  cpu_dcache	U32 1	<size of D cache in bytes>
  509+   (2)    .if true, (PROCESSOR&-16) == MIPS4000
  510+                  STR_ELT   cpu_icache_ls U32 1   <linesize of I cache in bytes>
  511+                  STR_ELT   cpu_dcache_ls U32 1   <linesize of D cache in bytes>
  512+   (2)    .endc
  513+          	STR_END	  cpu_params
  514+          ;
  515+          	DEC_CONST CPU_ID_TYPE	0	< Index into cpu_ident[] for TYPE >
  516+          	DEC_CONST CPU_ID_PRID	1	< Index into cpu_ident[] for PRID >
  517+          	DEC_CONST CPU_ID_ICACHE	2	< Index into cpu_ident[] for ICACHE size >
  518+          	DEC_CONST CPU_ID_DCACHE	3	< Index into cpu_ident[] for DCACHE size >
  519+          ;
  520+          .macro MK_VECTOR name type qty comment
  521+          	STR_ELT	  ROMV_'name' type qty <comment>
  522+          .endm
  523+          ;**********************************************************************************
  524+          ;*  WARNING DANGER 
  525+          ;*  DO NOT CHANGE THE ORDER OF ANY OF THE ENTRIES IN THIS STRUCTURE OR ADD ANYTHING
  526+          ;*  EXCEPT TO THE END.
  527+          ;**********************************************************************************
  528+          	STR_START ROM_VECTOR_STR
  529+   (2)    .if true, HB_PHOENIX
  530+          	MK_VECTOR   JUMP	U32 1	<Jump (or branch) to start address>
  531+          	MK_VECTOR   JNOP	U32 1	<Delay slot after jump>
  532+          	MK_VECTOR   SENTINEL	U32 1	<FEEDFACE or FEEDFADE sentinel>
  533+          	MK_VECTOR   TSIZE	U32 1	<Size of data to copy>
  534+          	MK_VECTOR   STUB_INIT	U32 1	<Entry point to stub's init>
  535+          	MK_VECTOR   STUB_FLAG	U32 1	<Stub init marker>
  536+          	MK_VECTOR   STUB_EH	U32 1	<Stub exception handler entry>
  537+          	MK_VECTOR   STUB_VECS	U32 1	<Ptr to list of functions provided by stub>
  538+          	MK_VECTOR   RAMVBR	U32 1	<Pointer to RAM based array of pointers to functions>
  539+          	MK_VECTOR   STACK	U32 1	<Last usable address in SRAM>
  540+          	MK_VECTOR   ENTRY	U32 1	<reset entry point>
  541+          	MK_VECTOR   EXCEPT	U32 1	<Pointer to game's exception handler>
  542+          	MK_VECTOR   STUB_REASON U32 1	<Pointer to game's exception message (or 0)>
  543+   (2)    .iff
  544+    X     	MK_VECTOR   RAMVBR	U32 1	<Pointer to RAM based array of pointers to functions>
  545+    X     	MK_VECTOR   ROMVBR	U32 1	<Not used anymore. Remains for compatibility with old code>
  546+    X     	MK_VECTOR   STACK	U32 1	<Last usable address in SRAM>
  547+    X     	MK_VECTOR   ENTRY	U32 1	<reset entry point>
  548+    X     	MK_VECTOR   PKTINIT	U32 1	<Packet init>
  549+    X     	MK_VECTOR   PKTPOLL	U32 1	<Packet poll>
  550+    X     	MK_VECTOR   PKTRECV	U32 1	<Packet recv>
  551+    X     	MK_VECTOR   PKTSEND	U32 1	<Packet send>
  552+    X     	MK_VECTOR   TLBPTR	U32 1	<Not used anymore. Remains for compatibility with old code>
  553+    X     	MK_VECTOR   IRQPTR	U32 8	<Not used anymore. Remains for compatibility with old code>
  554+    X     .if true, (PROCESSOR&-16) == MIPS3000
  555+    X     	MK_VECTOR   TEMP	U32 1	<Not used anymore. Remains for compatibility with old code>
  556+    X     	MK_VECTOR   NORMAL	U32 1	<Not used anymore. Remains for compatibility with old code>
  557+    X     	MK_VECTOR   CHEAP	U32 1	<Not used anymore. Remains for compatibility with old code>
  558+    X     .endc
dispatch.c                               Atari Games Corp. macpp v9.12   "Oct 16 1997 13:26:41"


  559+    X     	MK_VECTOR   EXPTR	U32 15	<Not used anymore. Remains for compatibility with old code>
  560+    X     	MK_VECTOR   CTSINIT	U32 1	<Initial control register for 4K>
  561+    X     	MK_VECTOR   EXCEPT	U32 1	<Pointer to exception handler>
  562+    X     	MK_VECTOR   SW_ADDR	U32 1	<Pointer to switch>
  563+    X     	MK_VECTOR   SW_BIT	U32 1	<Bit within SW_ADDR for stub start switch>
  564+    X     	MK_VECTOR   STUB_EH	U32 1	<Pointer to stub's exception handler (or 0)>
  565+    X     	MK_VECTOR   STUB_REASON U32 1	<Pointer to game's exception message (or 0)>
  566+   (2)    .endc
  567+          	STR_END	  ROM_VECTOR_STR
  568+          ;
  569+          .macro MK_VECTOR name type qty comment
  570+          	STR_ELT	  RAMV_'name' type qty <comment>
  571+          .endm
  572+          	STR_START RAM_VECTOR_STR
  573+          	.include  idt_vectors.mac
    1+          ; $Id: idt_vectors.mac,v 1.4 1997/07/01 20:54:19 shepperd Exp $
    2+          	MK_VECTOR   IRQ0	U32 1	< Interrupt 0>
    3+          	MK_VECTOR   IRQ1	U32 1	< Interrupt 1>
    4+          	MK_VECTOR   IRQ2	U32 1	< Interrupt 2>
    5+          	MK_VECTOR   IRQ3	U32 1	< Interrupt 3>
    6+          	MK_VECTOR   IRQ4	U32 1	< Interrupt 4>
    7+          	MK_VECTOR   IRQ5	U32 1	< Interrupt 5>
    8+          	MK_VECTOR   IRQ6	U32 1	< Interrupt 6>
    9+          	MK_VECTOR   IRQ7	U32 1	< Interrupt 7>
   10+          	MK_VECTOR   TLB		U32 1	< TLB exception >
   11+          	MK_VECTOR   TMP		U32 1	<Not used anymore, remains only for compatibility with old stub>
   12+          	MK_VECTOR   NORMAL	U32 1	<Not used anymore, remains only for compatibility with old stub>
   13+          	MK_VECTOR   CHEAP	U32 1	<Not used anymore, remains only for compatibility with old stub>
   14+          	MK_VECTOR   TLBM	U32 1	<TLB modification exception address>
   15+          	MK_VECTOR   TLBL	U32 1	<TLB Load exception address>
   16+          	MK_VECTOR   TLBS	U32 1	<TLB store exception address>
   17+          	MK_VECTOR   ADDRL	U32 1	<Address exception on load or I-fetch>
   18+          	MK_VECTOR   ADDRS	U32 1	<Address exception on store>
   19+          	MK_VECTOR   BUSERRI	U32 1	<Bus error on I-fetch>
   20+          	MK_VECTOR   BUSERRD	U32 1	<Bus error on data load>
   21+          	MK_VECTOR   SYSCALL	U32 1	<SYSCALL exception>
   22+          	MK_VECTOR   BREAK	U32 1	<Breakpoint exception>
   23+          	MK_VECTOR   RESERV	U32 1	<Reserved instruction exception>
   24+          	MK_VECTOR   COPROC	U32 1	<Coprocessor unusable exception>
   25+          	MK_VECTOR   OVERFL	U32 1	<Integer overflow exception>
   26+   (2)    .if true, (PROCESSOR&-16) == MIPS4000
   27+          	MK_VECTOR   TRAPV	U32 1	<Trap exception>
   28+          	MK_VECTOR   FILL0	U32 1	<Reserved entry>
   29+          	MK_VECTOR   FPE		U32 1	<Floating point exception>
   30+   (2)    .endc
  574+          	STR_END   RAM_VECTOR_STR
  575+          ;
  576+          .macro MK_VECTOR name type qty comment
  577+          	STR_ELT	  STUBVEC_'name' type qty <comment>
  578+          .endm
  579+          	STR_START IIO_VECTOR_STR
  580+          	MK_VECTOR   PKTINIT	U32 1	<Ptr to pktinit function (not used)>
  581+          	MK_VECTOR   PKTPOLL	U32 1	<Ptr to pktpoll function>
  582+          	MK_VECTOR   PKTQRECV	U32 1	<Ptr to pktquerecv function>
  583+          	MK_VECTOR   PKTQSEND	U32 1	<Ptr to pktquesend function>
  584+          	MK_VECTOR   PKTIOCTL	U32 1	<Ptr to pktioctl function>
  585+          	MK_VECTOR   NMI		U32 1	<Ptr to stub's NMI handler>
dispatch.c                               Atari Games Corp. macpp v9.12   "Oct 16 1997 13:26:41"


  586+          	MK_VECTOR   FAKE_EH	U32 1	<Ptr to stub's fake exception handler>
  587+          	MK_VECTOR   GOT_ATTEN	U32 1	<Ptr to stub's got_attention function>
  588+          	MK_VECTOR   PKTSCAN	U32 1	<Ptr to stub's pktScan function>
  589+          	STR_END	  IIO_VECTOR_STR
  590+          ;
  591+ 00000000 ...1 == 0
  592+          .macro MK_VECTOR name type qty comment
  593+          .if true, OUTPUT_LANG == LANG_C
  594+          	VN_'name',
  595+          .endc
  596+          	VN_'name' == ...1
  597+          	...1 == ...1 + 1
  598+          .endm
  599+   (2)    .if true, OUTPUT_LANG == LANG_C
  600+    X     enum vecnums {
  601+   (2)    .endc
  602+          	.include  idt_vectors.mac
    1+          ; $Id: idt_vectors.mac,v 1.4 1997/07/01 20:54:19 shepperd Exp $
    2+          	MK_VECTOR   IRQ0	U32 1	< Interrupt 0>
    3+          	MK_VECTOR   IRQ1	U32 1	< Interrupt 1>
    4+          	MK_VECTOR   IRQ2	U32 1	< Interrupt 2>
    5+          	MK_VECTOR   IRQ3	U32 1	< Interrupt 3>
    6+          	MK_VECTOR   IRQ4	U32 1	< Interrupt 4>
    7+          	MK_VECTOR   IRQ5	U32 1	< Interrupt 5>
    8+          	MK_VECTOR   IRQ6	U32 1	< Interrupt 6>
    9+          	MK_VECTOR   IRQ7	U32 1	< Interrupt 7>
   10+          	MK_VECTOR   TLB		U32 1	< TLB exception >
   11+          	MK_VECTOR   TMP		U32 1	<Not used anymore, remains only for compatibility with old stub>
   12+          	MK_VECTOR   NORMAL	U32 1	<Not used anymore, remains only for compatibility with old stub>
   13+          	MK_VECTOR   CHEAP	U32 1	<Not used anymore, remains only for compatibility with old stub>
   14+          	MK_VECTOR   TLBM	U32 1	<TLB modification exception address>
   15+          	MK_VECTOR   TLBL	U32 1	<TLB Load exception address>
   16+          	MK_VECTOR   TLBS	U32 1	<TLB store exception address>
   17+          	MK_VECTOR   ADDRL	U32 1	<Address exception on load or I-fetch>
   18+          	MK_VECTOR   ADDRS	U32 1	<Address exception on store>
   19+          	MK_VECTOR   BUSERRI	U32 1	<Bus error on I-fetch>
   20+          	MK_VECTOR   BUSERRD	U32 1	<Bus error on data load>
   21+          	MK_VECTOR   SYSCALL	U32 1	<SYSCALL exception>
   22+          	MK_VECTOR   BREAK	U32 1	<Breakpoint exception>
   23+          	MK_VECTOR   RESERV	U32 1	<Reserved instruction exception>
   24+          	MK_VECTOR   COPROC	U32 1	<Coprocessor unusable exception>
   25+          	MK_VECTOR   OVERFL	U32 1	<Integer overflow exception>
   26+   (2)    .if true, (PROCESSOR&-16) == MIPS4000
   27+          	MK_VECTOR   TRAPV	U32 1	<Trap exception>
   28+          	MK_VECTOR   FILL0	U32 1	<Reserved entry>
   29+          	MK_VECTOR   FPE		U32 1	<Floating point exception>
   30+   (2)    .endc
  603+   (2)    .if true, OUTPUT_LANG == LANG_C
  604+    X     	VN_MAX
  605+    X     };
  606+    X     #define NUM_RVECS VN_MAX
  607+   (2)    .endc
  608+          ;
  609+          ; MIPS gdb register placement (stub uses this)
  610+          ;
  611+   (2)    .if true, (PROCESSOR&-16) == MIPS4000
  612+   (3)     .if defined, BYTE0_OFFS
dispatch.c                               Atari Games Corp. macpp v9.12   "Oct 16 1997 13:26:41"


  613+ 00000000    endian == (BYTE0_OFFS != 0)	;.ne. if big, .eq. if little
  614+   (3)     .iff
  615+    X        endian == 1			;assume big endian
  616+   (3)     .endc
  617+ 00000000  ls32 == endian
  618+ 00000001  ms32 == endian ^ 1
  619+            .macro MK_REGNUM name	number size comment
  620+          	DEC_CONST name number <comment>
  621+          	DEC_CONST 'name'_W (number*2)+ls32 <comment>
  622+              .if true, 1 || (size == 32)
  623+          	DEC_CONST 'name'_U (number*2)+ms32   <comment>
  624+              .endc
  625+            .endm
  626+   (2)    .iff
  627+    X       .macro MK_REGNUM name	number size comment
  628+    X     	DEC_CONST name number <comment>
  629+    X     	DEC_CONST 'name'_W number <comment>
  630+    X       .endm
  631+   (2)    .endc
  632+          ;
  633+   (2)    .if true, (PROCESSOR&-16) == MIPS4000
  634+          	DEC_CONST REGISTER_SIZE		 8	< Size of the registers in bytes >
  635+          	DEC_CONST MIPS_REGSIZE		 8	< Size of the registers in bytes >
  636+   (2)    .iff
  637+    X     	DEC_CONST REGISTER_SIZE		 4	< Size of the registers in bytes >
  638+    X     	DEC_CONST MIPS_REGSIZE		 4	< Size of the registers in bytes >
  639+   (2)    .endc
  640+          	MK_REGNUM ZERO_REGNUM		 0			64	< read-only register, always 0 >
  641+          	MK_REGNUM AT_REGNUM		 1			64	< reg used by assembler >
  642+          	MK_REGNUM V0_REGNUM		 2			64	< Function integer return value >
  643+          	MK_REGNUM A0_REGNUM		 4			64	< Loc of first arg during a subr call >
  644+          	MK_REGNUM SP_REGNUM		29			64	< Contains address of top of stack >
  645+          	MK_REGNUM S8_REGNUM		30			64	< S8/FP register >
  646+          	MK_REGNUM RA_REGNUM		31			64	< Contains return address value >
  647+          	MK_REGNUM PS_REGNUM		32			32	< Contains processor status >
  648+          	MK_REGNUM HI_REGNUM		34      		32	< Multiply/divide high byte >
  649+          	MK_REGNUM LO_REGNUM		33      		32	< Multiply/divide low byte >
  650+          	MK_REGNUM BADVADDR_REGNUM	35			64	< bad vaddr for addressing exception >
  651+          	MK_REGNUM CAUSE_REGNUM		36			32	< describes last exception >
  652+          	MK_REGNUM PC_REGNUM		37			64	< Contains program counter >
  653+          	MK_REGNUM FP0_REGNUM		38      		64	< Floating point register 0 (single float) >
  654+          	MK_REGNUM FCRCS_REGNUM		70      		32	< FP control/status >
  655+          	MK_REGNUM FCRIR_REGNUM		71      		32	< FP implementation/revision >
  656+          	MK_REGNUM FP_REGNUM		72			64	< Pseudo register that contains true address of executing stack frame >
  657+          	MK_REGNUM FIRST_EMBED_REGNUM	73			64	< First supervisor register for embedded use >
  658+   (2)    .if true, (PROCESSOR&-16) == MIPS4000
  659+          	MK_REGNUM INX_REGNUM		(FIRST_EMBED_REGNUM+0)	32
  660+          	MK_REGNUM RAND_REGNUM		(FIRST_EMBED_REGNUM+1)	32
  661+          	MK_REGNUM TLBLO0_REGNUM		(FIRST_EMBED_REGNUM+2)	64
  662+          	MK_REGNUM TLBLO1_REGNUM		(FIRST_EMBED_REGNUM+3)	64
  663+          	MK_REGNUM CTXT_REGNUM		(FIRST_EMBED_REGNUM+4)	64
  664+          	MK_REGNUM PAGEMASK_REGNUM	(FIRST_EMBED_REGNUM+5)	32
  665+          	MK_REGNUM WIRED_REGNUM		(FIRST_EMBED_REGNUM+6)	32
  666+          	MK_REGNUM COUNT_REGNUM		(FIRST_EMBED_REGNUM+7)	32
  667+          	MK_REGNUM TLBHI_REGNUM		(FIRST_EMBED_REGNUM+8)	64
  668+          	MK_REGNUM COMPARE_REGNUM	(FIRST_EMBED_REGNUM+9)	32
  669+          	MK_REGNUM EPC_REGNUM		(FIRST_EMBED_REGNUM+10)	64
dispatch.c                               Atari Games Corp. macpp v9.12   "Oct 16 1997 13:26:41"


  670+          	MK_REGNUM PRID_REGNUM		(FIRST_EMBED_REGNUM+11)	32
  671+          	MK_REGNUM CONFIG_REGNUM		(FIRST_EMBED_REGNUM+12)	32
  672+          	MK_REGNUM LLADDR_REGNUM		(FIRST_EMBED_REGNUM+13)	32
  673+   (3)     .if true, PROCESSOR != MIPS4600
  674+          	MK_REGNUM WATCHLO_REGNUM	(FIRST_EMBED_REGNUM+14)	64
  675+          	MK_REGNUM WATCHHI_REGNUM	(FIRST_EMBED_REGNUM+15)	64
  676+   (3)     .endc
  677+          	MK_REGNUM XCTXT_REGNUM		(FIRST_EMBED_REGNUM+16)	64
  678+          	MK_REGNUM ECC_REGNUM		(FIRST_EMBED_REGNUM+17)	32
  679+          	MK_REGNUM CACHEERR_REGNUM	(FIRST_EMBED_REGNUM+18)	32
  680+          	MK_REGNUM TAGLO_REGNUM		(FIRST_EMBED_REGNUM+19)	32
  681+          	MK_REGNUM TAGHI_REGNUM		(FIRST_EMBED_REGNUM+20)	32
  682+          	MK_REGNUM ERRPC_REGNUM		(FIRST_EMBED_REGNUM+21)	64
  683+          	MK_REGNUM LAST_EMBED_REGNUM	(FIRST_EMBED_REGNUM+22-1) 32	< Last one >
  684+   (2)    .iff
  685+    X     	MK_REGNUM INX_REGNUM		(FIRST_EMBED_REGNUM+0)	32
  686+    X     	MK_REGNUM RAND_REGNUM		(FIRST_EMBED_REGNUM+1)	32
  687+    X     	MK_REGNUM TLBLO_REGNUM		(FIRST_EMBED_REGNUM+2)	32
  688+    X     	MK_REGNUM CTXT_REGNUM		(FIRST_EMBED_REGNUM+3)	32
  689+    X     	MK_REGNUM TLBHI_REGNUM		(FIRST_EMBED_REGNUM+4)	32
  690+    X     	MK_REGNUM EPC_REGNUM		(FIRST_EMBED_REGNUM+5)	32
  691+    X     	MK_REGNUM PRID_REGNUM		(FIRST_EMBED_REGNUM+6)	32
  692+    X     	MK_REGNUM LAST_EMBED_REGNUM	(FIRST_EMBED_REGNUM+7-1) 32	< Last one >
  693+   (2)    .endc
  694+          	DEC_CONST NUM_REGS		(LAST_EMBED_REGNUM+1)	< Number of machine registers >
  695+          	DEC_CONST REGISTER_BYTES (NUM_REGS*MIPS_REGSIZE) < Total number of register bytes >
  696+          ;
  697+   (2)    .if true, OUTPUT_LANG != LANG_C
  698+          	DEC_CONST CPU_FRAME_SIZE S_SIZ_cpu_params
  699+   (2)    .endc
  700+          ;
  701+          	DEC_CONST MAX_IRQS		8	< RxK has only 8 possible interrupts >
  702+   (2)    .if true, (PROCESSOR&-16) == MIPS4000
  703+          	DEC_CONST MAX_EXCEPTIONS 	16	< R4k has only 16 possible exceptions >
  704+   (2)    .iff
  705+    X     	DEC_CONST MAX_EXCEPTIONS 	13	< R3k has only 13 possible exceptions >
  706+   (2)    .endc
  707+          ;
  708+   (2)    .if true, OUTPUT_LANG != LANG_C
  709+          .DEFINE zero	$0
  710+          .DEFINE r0	$0
  711+          .DEFINE r1	$1
  712+          .DEFINE r2	$2
  713+          .DEFINE r3	$3
  714+          .DEFINE r4	$4
  715+          .DEFINE r5	$5
  716+          .DEFINE r6	$6
  717+          .DEFINE r7	$7
  718+          .DEFINE r8	$8
  719+          .DEFINE r9	$9
  720+          .DEFINE r10	$10
  721+          .DEFINE r11	$11
  722+          .DEFINE r12	$12
  723+          .DEFINE r13	$13
  724+          .DEFINE r14	$14
  725+          .DEFINE r15	$15
  726+          .DEFINE r16	$16
dispatch.c                               Atari Games Corp. macpp v9.12   "Oct 16 1997 13:26:41"


  727+          .DEFINE r17	$17
  728+          .DEFINE r18	$18
  729+          .DEFINE r19	$19
  730+          .DEFINE r20	$20
  731+          .DEFINE r21	$21
  732+          .DEFINE r22	$22
  733+          .DEFINE r23	$23
  734+          .DEFINE r24	$24
  735+          .DEFINE r25	$25
  736+          .DEFINE r26	$26
  737+          .DEFINE r27	$27
  738+          .DEFINE r28	$28
  739+          .DEFINE r29	$29
  740+          .DEFINE r30	$30
  741+          .DEFINE r31	$31
  742+          ;
  743+          .DEFINE f0	$f0
  744+          .DEFINE f1	$f1
  745+          .DEFINE f2	$f2
  746+          .DEFINE f3	$f3
  747+          .DEFINE f4	$f4
  748+          .DEFINE f5	$f5
  749+          .DEFINE f6	$f6
  750+          .DEFINE f7	$f7
  751+          .DEFINE f8	$f8
  752+          .DEFINE f9	$f9
  753+          .DEFINE f10	$f10
  754+          .DEFINE f11	$f11
  755+          .DEFINE f12	$f12
  756+          .DEFINE f13	$f13
  757+          .DEFINE f14	$f14
  758+          .DEFINE f15	$f15
  759+          .DEFINE f16	$f16
  760+          .DEFINE f17	$f17
  761+          .DEFINE f18	$f18
  762+          .DEFINE f19	$f19
  763+          .DEFINE f20	$f20
  764+          .DEFINE f21	$f21
  765+          .DEFINE f22	$f22
  766+          .DEFINE f23	$f23
  767+          .DEFINE f24	$f24
  768+          .DEFINE f25	$f25
  769+          .DEFINE f26	$f26
  770+          .DEFINE f27	$f27
  771+          .DEFINE f28	$f28
  772+          .DEFINE f29	$f29
  773+          .DEFINE f30	$f30
  774+          .DEFINE f31	$f31
  775+          ;
  776+          .DEFINE v0	$2
  777+          .DEFINE v1	$3
  778+          .DEFINE a0	$4
  779+          .DEFINE a1	$5
  780+          .DEFINE a2	$6
  781+          .DEFINE a3	$7
  782+          .DEFINE t0	$8
  783+          .DEFINE t1	$9
dispatch.c                               Atari Games Corp. macpp v9.12   "Oct 16 1997 13:26:41"


  784+          .DEFINE t2	$10
  785+          .DEFINE t3	$11
  786+          .DEFINE t4	$12
  787+          .DEFINE t5	$13
  788+          .DEFINE t6	$14
  789+          .DEFINE t7	$15
  790+          .DEFINE t8	$24
  791+          .DEFINE t9	$25
  792+          .DEFINE s0	$16
  793+          .DEFINE s1	$17
  794+          .DEFINE s2	$18
  795+          .DEFINE s3	$19
  796+          .DEFINE s4	$20
  797+          .DEFINE s5	$21
  798+          .DEFINE s6	$22
  799+          .DEFINE s7	$23
  800+          .DEFINE k0	$26
  801+          .DEFINE k1	$27
  802+          .DEFINE gp	$28
  803+          .DEFINE sp	$29
  804+          .DEFINE fp	$30
  805+          .DEFINE s8	$30
  806+          .DEFINE ra	$31
  807+          ;
  808+          ;
  809+          .macro SYSERR message, arg
  810+          	.set noreorder
  811+          	mfc0 $8, C0_SR
  812+          	li $5, arg
  813+          	andi $8, ~SR_IEC
  814+          	la $9, TrapIt
  815+          	mtc0 $8, C0_SR
  816+          	jalr $4, $9
  817+          	nop
  818+          	DC.B	"'message'"
  819+          	DC.B	0
  820+          	.align	2
  821+          	.set reorder
  822+          .endm SYSERR
  823+          ;			
  824+          .macro frame entry, frame=$29, size=0, return=$31, global=1, mask=0, offset=0, fmask=0, foff=0
  825+           .if defined, PROCESSOR
  826+            .if true, (PROCESSOR == MIPS5000) || (PROCESSOR == MIPS5000L)
  827+              .align 3
  828+            .endc
  829+           .endc
  830+          	.iif true,global,.globl entry
  831+          	.ent entry
  832+          entry:
  833+          	.frame	frame, size, return
  834+          	.mask	mask, offset
  835+          	.fmask	fmask, foff
  836+          	.endm
  837+          ;
  838+          .macro endframe entry
  839+          .end entry
  840+          .endm
dispatch.c                               Atari Games Corp. macpp v9.12   "Oct 16 1997 13:26:41"


  841+   (2)    .endc
  504+   (1)    .endc 		;_SEATTLE_MAC_
  505+          
  113+          	.include nss_wb.mac
    1+          
    2+   (1)    .if ndf, _NSS_WB_MAC_
    3+ 00000000 _NSS_WB_MAC_ == 0
    4+          ;
    5+   (2)    .if ndf, WB_BASE
    6+    X       .error ;You need to define WB_BASE before using nss_wb.mac
    7+   (2)    .endc
    8+          ;
    9+          	HEX_CONST WB_ADR	WB_BASE+0x00	< Address Register >
   10+          	HEX_CONST WB_INT	WB_BASE+0x04	< Interrupt Register >
   11+          	HEX_CONST WB_LED	WB_BASE+0x08	< LED Register >
   12+          	HEX_CONST WB_AUX	WB_BASE+0x0C	< Wheel Driver Register >
   13+          	HEX_CONST WB_A2D	WB_BASE+0x10	< A to D Converter >
   14+          	HEX_CONST WB_ETH	WB_BASE+0x14	< Ethernet Controller >
   15+          	HEX_CONST WB_NSS	WB_BASE+0x18	< NSS Board >
   16+          	HEX_CONST WB_RST	WB_BASE+0x1C	< Reset Register >
   17+          ;
   18+          ;	Interrupt register bit assignments
   19+          ;
   20+          	HEX_CONST B_WBINT_A2D	0		< Bit 0 -- A/D Interrupt >
   21+          	HEX_CONST B_WBINT_NSS	1		< Bit 1 -- NSS Interrupt >
   22+          	HEX_CONST B_WBINT_ETH	2		< Bit 2 -- ETH Interrupt >
   23+          ;
   24+          ;	Interrupt register mask assignments
   25+          ;
   26+          	HEX_CONST M_WBINT_A2D	1<<B_WBINT_A2D	< Bit 0 -- A/D Interrupt >
   27+          	HEX_CONST M_WBINT_NSS	1<<B_WBINT_NSS	< Bit 1 -- NSS Interrupt >
   28+          	HEX_CONST M_WBINT_ETH	1<<B_WBINT_ETH	< Bit 2 -- ETH Interrupt >
   29+          ;
   30+          ;	Reset register bit assignments
   31+          ;
   32+          	HEX_CONST B_WBRST_AUX	0		< Bit 0 -- A/D Reset >
   33+          	HEX_CONST B_WBRST_NSS	1		< Bit 1 -- NSS Reset >
   34+          	HEX_CONST B_WBRST_ETH	2		< Bit 2 -- ETH Reset >
   35+          ;
   36+          ;	Reset register mask assignments
   37+          ;
   38+          	HEX_CONST M_WBRST_AUX	1<<M_WBRST_AUX	< Bit 0 -- A/D Reset >
   39+          	HEX_CONST M_WBRST_NSS	1<<M_WBRST_NSS	< Bit 1 -- NSS Reset >
   40+          	HEX_CONST M_WBRST_ETH	1<<M_WBRST_ETH	< Bit 2 -- ETH Reset >
   41+          ;
   42+   (1)    .endc 		;_NSS_WB_MAC_
  114+          	.include vmdvr.mac
    1+          
    2+   (1)    .if ndf, _VMDVR_MAC_
    3+ 00000000 _VMDVR_MAC_ == 0
    4+          ;
    5+          ;	VMDVR definitions
    6+          ;
    7+          	HEX_CONST VMDVR_WHEEL		4
    8+          	HEX_CONST VMDVR_LAMPS		5
    9+          ;
   10+          	HEX_CONST M_VMDVR_DATA		0x00FF
dispatch.c                               Atari Games Corp. macpp v9.12   "Oct 16 1997 13:26:41"


   11+          ;
   12+          	HEX_CONST M_VMDVR_SETUP_HOLD	0xFF00
   13+          	HEX_CONST M_VMDVR_ADDR_STROBE	0xF700
   14+          	HEX_CONST M_VMDVR_DATA_STROBE	0xFB00
   15+          ;
   16+   (1)    .endc 		;_VMDVR_MAC_
  115+          ;
  116+          	DEC_CONST ICELESS_LVL	B_PIC_DBG+1	< bit within control register + 1 >
  117+          	DEC_CONST UART_LVL      IOASIC_LVL      < Turn on the I/O ASIC UART interrupt code >
  118+          	DEC_CONST SND_LVL	IOASIC_LVL	< Turn on the I/O ASIC AUDIO interrupt code >
  119+          ;
  120+          	HEX_CONST XBUS_BASE	GALILEO_CS0+0x00000000	< XBUS i/f board >
  121+          	HEX_CONST RAMROM_BASE	XBUS_BASE+0x00400000	< RamRom board starts here (slot 1) >
  122+          	.include generic_switches.mac
    1+   (1)    .if not_defined, _GENERIC_SWITCHES_MAC_
    2+ 00000000 _GENERIC_SWITCHES_MAC_ == 0
    3+          ;
    4+          REM <	SELFTEST switch definitions >
    5+          ;
    6+          	VAR	  INPUTS	VU16	IO_PLAYER_21
    7+          	VAR	  EXTEND	VU16	IO_PLAYER_43
    8+          	VAR	  MISC		VU16	IO_MISC
    9+          	VAR	  DIAG		VU16	IO_DIPSW
   10+          ;
   11+          	VAR	  TEST		VU16	IO_MISC
   12+          	HEX_CONST B_TEST	4
   13+          ;
   14+          ; Where they go in the switch word.
   15+          ;
   16+          	HEX_CONST SH_INPUTS	0
   17+          	HEX_CONST SH_EXTEND	16
   18+          	HEX_CONST SH_MISC	0
   19+          	HEX_CONST SH_DIAG	16
   20+          ;
   21+   (2)    .if true, OUTPUT_LANG == LANG_C
   22+    X     #define INPUT_SWITCHES ( INPUTS << SH_INPUTS )
   23+    X     #define EXTEND_SWITCHES ( EXTEND << SH_EXTEND )
   24+    X     #define MISC_SWITCHES ( MISC << SH_MISC )
   25+    X     #define DIAG_SWITCHES ( DIAG << SH_DIAG )
   26+    X     #define READ_RAW_SWITCHES(x) ( (x) ?\
   27+    X     			    ~( DIAG_SWITCHES | MISC_SWITCHES )  : \
   28+    X     			    ~( EXTEND_SWITCHES | INPUT_SWITCHES ) )
   29+   (2)    .endc
   30+          ;
   31+          	HEX_CONST SW_EDGES	0xFFFFFFFF
   32+          	HEX_CONST SW_LEVELS	0x00000000
   33+          ;
   34+          REM <	SELFTEST switch definitions >
   35+          ;
   36+          ; DIP Switches
   37+          ;
   38+          	HEX_CONST SW_OPT0	(IO_DIPSW0<<SH_DIAG)
   39+          	HEX_CONST SW_OPT1	(IO_DIPSW1<<SH_DIAG)
   40+          	HEX_CONST SW_OPT2	(IO_DIPSW2<<SH_DIAG)
   41+          	HEX_CONST SW_OPT3	(IO_DIPSW3<<SH_DIAG)
   42+          	HEX_CONST SW_OPT4	(IO_DIPSW4<<SH_DIAG)
   43+          	HEX_CONST SW_OPT5	(IO_DIPSW5<<SH_DIAG)
dispatch.c                               Atari Games Corp. macpp v9.12   "Oct 16 1997 13:26:41"


   44+          	HEX_CONST SW_OPT6	(IO_DIPSW6<<SH_DIAG)
   45+          	HEX_CONST SW_OPT7	(IO_DIPSW7<<SH_DIAG)
   46+          	HEX_CONST SW_OPT8	(IO_DIPSW8<<SH_DIAG)
   47+          	HEX_CONST SW_OPT9	(IO_DIPSW9<<SH_DIAG)
   48+          	HEX_CONST SW_OPT10	(IO_DIPSW10<<SH_DIAG)
   49+          	HEX_CONST SW_OPT11	(IO_DIPSW11<<SH_DIAG)
   50+          	HEX_CONST SW_OPT12	(IO_DIPSW12<<SH_DIAG)
   51+          	HEX_CONST SW_OPT13	(IO_DIPSW13<<SH_DIAG)
   52+          	HEX_CONST SW_OPT14	(IO_DIPSW14<<SH_DIAG)
   53+          	HEX_CONST SW_OPT15	(IO_DIPSW15<<SH_DIAG)
   54+          ;
   55+          	HEX_CONST SW_BITS	0xFFFFFFFF
   56+          ;
   57+          ; Misc switches
   58+          ;
   59+          	HEX_CONST SW_COIN1	(IO_MISC0<<SH_MISC)
   60+          	HEX_CONST SW_COIN2	(IO_MISC1<<SH_MISC)
   61+          	HEX_CONST SW_P1START	(IO_MISC2<<SH_MISC)
   62+          	HEX_CONST SW_TILT	(IO_MISC3<<SH_MISC)
   63+          	HEX_CONST SW_TEST	(IO_MISC4<<SH_MISC)
   64+          	HEX_CONST SW_P2START	(IO_MISC5<<SH_MISC)
   65+          	HEX_CONST SW_CREDIT	(IO_MISC6<<SH_MISC)
   66+          	HEX_CONST SW_COIN3	(IO_MISC7<<SH_MISC)
   67+          	HEX_CONST SW_COIN4	(IO_MISC8<<SH_MISC)
   68+          	HEX_CONST SW_P3START	(IO_MISC9<<SH_MISC)
   69+          	HEX_CONST SW_P4START	(IO_MISC10<<SH_MISC)
   70+          	HEX_CONST SW_VOLM	(IO_MISC11<<SH_MISC)
   71+          	HEX_CONST SW_VOLP	(IO_MISC12<<SH_MISC)
   72+          	HEX_CONST SW_UNUSED0	(IO_MISC13<<SH_MISC)
   73+          	HEX_CONST SW_INTER	(IO_MISC14<<SH_MISC)
   74+          	HEX_CONST SW_BILL	(IO_MISC15<<SH_MISC)
   75+          ;
   76+          ; Coin stuff
   77+          ;
   78+   (2)    .if true, OUTPUT_LANG == LANG_C
   79+    X     #ifndef IO_METER_T
   80+    X     # define IO_METER_T	*(VU32*)IO_METER
   81+    X     #endif
   82+    X     # define COUNTER_ON(x)	do { IO_METER_T = 0x10; IO_METER_T |= 1<<(x); } while (0)
   83+    X     # define COUNTER_OFF(x)	do { IO_METER_T = 0x10; IO_METER_T &= ~(1<<(x)); } while (0)
   84+          
   85+    X     #define B_COINL		(0)		/* COIN LEFT */
   86+    X     #define B_COINR		(1)		/* COIN RIGHT */
   87+    X     #define B_COIN3		(2)		/* COIN 3 */
   88+    X     #define B_COIN4		(3)		/* COIN 4 */
   89+    X     #define B_CREDIT	(6)		/* FE's Coin switch */
   90+    X     #define B_DOLLAR	(7)		/* Dollar acceptor */
   91+    X     #define CN_STATUS	((MISC&0x43)|((MISC&0x8000)>>8)|((MISC&0x180)>>5))
   92+   (2)    .endc		; LANG_C
   93+          ;
   94+          	HEX_CONST J1_UP		(IO_PLYR1_0<<SH_INPUTS)	< SW07 >
   95+          	HEX_CONST J1_DOWN	(IO_PLYR1_1<<SH_INPUTS)	< SW06 >
   96+          	HEX_CONST J1_LEFT	(IO_PLYR1_2<<SH_INPUTS)	< SW05 >
   97+          	HEX_CONST J1_RIGHT	(IO_PLYR1_3<<SH_INPUTS)	< SW04 >
   98+          	HEX_CONST J2_UP		(IO_PLYR2_0<<SH_INPUTS)
   99+          	HEX_CONST J2_DOWN	(IO_PLYR2_1<<SH_INPUTS)
  100+          	HEX_CONST J2_LEFT	(IO_PLYR2_2<<SH_INPUTS)
dispatch.c                               Atari Games Corp. macpp v9.12   "Oct 16 1997 13:26:41"


  101+          	HEX_CONST J2_RIGHT	(IO_PLYR2_3<<SH_INPUTS)
  102+          	HEX_CONST J3_UP		(IO_PLYR3_0<<SH_EXTEND)	< SW07 >
  103+          	HEX_CONST J3_DOWN	(IO_PLYR3_1<<SH_EXTEND)	< SW06 >
  104+          	HEX_CONST J3_LEFT	(IO_PLYR3_2<<SH_EXTEND)	< SW05 >
  105+          	HEX_CONST J3_RIGHT	(IO_PLYR3_3<<SH_EXTEND)	< SW04 >
  106+          	HEX_CONST J4_UP		(IO_PLYR4_0<<SH_EXTEND)
  107+          	HEX_CONST J4_DOWN	(IO_PLYR4_1<<SH_EXTEND)
  108+          	HEX_CONST J4_LEFT	(IO_PLYR4_2<<SH_EXTEND)
  109+          	HEX_CONST J4_RIGHT	(IO_PLYR4_3<<SH_EXTEND)
  110+          	HEX_CONST J_UP		<J1_UP | J2_UP | J3_UP | J4_UP>
  111+          	HEX_CONST J_DOWN	<J1_DOWN | J2_DOWN | J3_DOWN | J3_DOWN>
  112+          	HEX_CONST J_LEFT	<J1_LEFT | J2_LEFT | J3_LEFT | J3_LEFT>
  113+          	HEX_CONST J_RIGHT	<J1_RIGHT | J2_RIGHT | J3_RIGHT | J3_RIGHT>
  114+          ;
  115+          ; Toggles
  116+          ;
  117+          REM <	J_LEFT/RIGHT, JOY_ defs moved below so the can use SW_ defs	>
  118+          ;
  119+          	HEX_CONST J1_VERT	<J1_UP | J1_DOWN>
  120+          	HEX_CONST J1_BITS	<J1_UP | J1_DOWN | J1_LEFT | J1_RIGHT>
  121+          ;
  122+          	HEX_CONST J2_VERT	<J2_UP | J2_DOWN>
  123+          	HEX_CONST J2_BITS	<J2_UP | J2_DOWN | J2_LEFT | J2_RIGHT>
  124+          ;
  125+          	HEX_CONST J3_VERT	<J3_UP | J3_DOWN>
  126+          	HEX_CONST J3_BITS	<J3_UP | J3_DOWN | J3_LEFT | J3_RIGHT>
  127+          ;
  128+          	HEX_CONST J4_VERT	<J4_UP | J4_DOWN>
  129+          	HEX_CONST J4_BITS	<J4_UP | J4_DOWN | J4_LEFT | J4_RIGHT>
  130+          ;
  131+          	HEX_CONST JOY_BITS	<J_UP | J_DOWN | J_LEFT | J_RIGHT>
  132+          	HEX_CONST JOY_VERT	<J_UP | J_DOWN>
  133+          ;
  134+          	HEX_CONST P1_START	IO_MISC2<<SH_MISC
  135+          	HEX_CONST P2_START	IO_MISC5<<SH_MISC
  136+          	HEX_CONST P3_START	IO_MISC9<<SH_MISC
  137+          	HEX_CONST P4_START	IO_MISC10<<SH_MISC
  138+          	HEX_CONST P1_A		IO_PLYR1_4<<SH_INPUTS
  139+          	HEX_CONST P1_B		IO_PLYR1_5<<SH_INPUTS
  140+          	HEX_CONST P1_C		IO_PLYR1_6<<SH_INPUTS
  141+          	HEX_CONST P1_D		IO_PLYR1_7<<SH_INPUTS
  142+          	HEX_CONST P2_A		IO_PLYR2_4<<SH_INPUTS
  143+          	HEX_CONST P2_B		IO_PLYR2_5<<SH_INPUTS
  144+          	HEX_CONST P2_C		IO_PLYR2_6<<SH_INPUTS
  145+          	HEX_CONST P2_D		IO_PLYR2_7<<SH_INPUTS
  146+          	HEX_CONST P3_A		IO_PLYR3_4<<SH_EXTEND
  147+          	HEX_CONST P3_B		IO_PLYR3_5<<SH_EXTEND
  148+          	HEX_CONST P3_C		IO_PLYR3_6<<SH_EXTEND
  149+          	HEX_CONST P3_D		IO_PLYR3_7<<SH_EXTEND
  150+          	HEX_CONST P4_A		IO_PLYR4_4<<SH_EXTEND
  151+          	HEX_CONST P4_B		IO_PLYR4_5<<SH_EXTEND
  152+          	HEX_CONST P4_C		IO_PLYR4_6<<SH_EXTEND
  153+          	HEX_CONST P4_D		IO_PLYR4_7<<SH_EXTEND
  154+          ;
  155+          	HEX_CONST SW_NEXT	(P1_A|P2_A)		< Player A >
  156+          	HEX_CONST SW_ACTION	(P1_B|P2_B)		< Player B >
  157+          	HEX_CONST SW_EXTRA	(P1_C|P2_C)		< Player C >
dispatch.c                               Atari Games Corp. macpp v9.12   "Oct 16 1997 13:26:41"


  158+          ;
  159+          	HEX_CONST JOY_ALL	<JOY_BITS | SW_NEXT | SW_ACTION>
  160+          	HEX_CONST SW_ALL	<SW_ACTION | SW_NEXT | SW_EXTRA>
  161+          	HEX_CONST SW_BITS	0xFFFFFFFF
  162+          ;
  163+          	HEX_CONST LA_START      0x01
  164+          	HEX_CONST LA_VIEW1      0x02
  165+          	HEX_CONST LA_VIEW2      0x04
  166+          	HEX_CONST LA_VIEW3      0x08
  167+          	HEX_CONST LA_WINNER     0x40
  168+          	HEX_CONST LA_LEADER     0x80
  169+          ;
  170+   (1)    .endc		; _GENERIC_SWITCHES_MAC_
  123+          ;
  124+          	HEX_CONST POT_CNT	8
  125+          	HEX_CONST AD_PORTS_ADDR WB_A2D	< pots.c uses this symbol >
  126+          	HEX_CONST POT_WHEEL	0		< Pot wheel index >
  127+          	HEX_CONST POT_GAS	1		< Pot gas index >
  128+          	HEX_CONST POT_BRAKE	2		< Pot brake index >
  129+          	DEC_CONST POT_WHEN_OK	1		< Only touch pots when GUTS says it's ok >
  130+          ;
  131+          ; Video
  132+          	.include sst.mac
    1+   (1)    .if not_defined,_3DFX_MAC_
    2+ 00000000 _3DFX_MAC_ == 0
    3+          ;
    4+   (2)    .if not_defined, SST_BASE
    5+          	HEX_CONST SST_BASE	(0xA8000000)	< Address of 3DFX board >
    6+   (2)    .endc
    7+          REM <	Color pair constants>
    8+          ; >>-> Set appropriately for your game
    9+   (2)    .if not_defined, DYNAMIC_VIS_PIX
   10+ 00000000 	DYNAMIC_VIS_PIX == 0
   11+   (2)    .endc
   12+   (2)    .if true, DYNAMIC_VIS_PIX
   13+    X      .if not_defined,VIS_H_PIX_MAX
   14+    X     	DEC_CONST VIS_H_PIX_MAX	640
   15+    X      .endc
   16+    X      .if not_defined,VIS_V_PIX_MAX
   17+    X     	DEC_CONST VIS_H_PIX_MAX	480
   18+    X      .endc
   19+    X      .if true, OUTPUT_LANG == LANG_C
   20+    X     extern int SST_RESOLUTION, VIS_V_PIX, VIS_H_PIX, AN_VIS_COL, AN_VIS_ROW;
   21+    X     #define AN_VIS_COL_MAX (VIS_H_PIX_MAX/8)
   22+    X     #define AN_VIS_ROW_MAX (VIS_V_PIX_MAX/8)
   23+    X      .endc
   24+   (2)    .iff
   25+   (3)     .if defined, VIS_H_PIX_MAX
   26+    X       .if not_defined, VIS_H_PIX
   27+    X     	DEC_CONST VIS_H_PIX VIS_H_PIX_MAX
   28+    X       .endc
   29+   (3)     .iff
   30+   (4)      .if not_defined, VIS_H_PIX
   31+    X     	DEC_CONST VIS_H_PIX	640
   32+   (4)      .endc
   33+          	DEC_CONST VIS_H_PIX_MAX	VIS_H_PIX
   34+   (3)     .endc
dispatch.c                               Atari Games Corp. macpp v9.12   "Oct 16 1997 13:26:41"


   35+   (3)     .if defined, VIS_V_PIX_MAX
   36+    X       .if not_defined, VIS_V_PIX
   37+    X     	DEC_CONST VIS_V_PIX VIS_V_PIX_MAX
   38+    X       .endc
   39+   (3)     .iff
   40+   (4)      .if not_defined, VIS_V_PIX
   41+    X     	DEC_CONST VIS_V_PIX	480
   42+   (4)      .endc
   43+          	DEC_CONST VIS_V_PIX_MAX	VIS_V_PIX
   44+   (3)     .endc
   45+          	DEC_CONST AN_VIS_COL 	(VIS_H_PIX/8)
   46+          	DEC_CONST AN_VIS_ROW 	(VIS_V_PIX/8)
   47+          	DEC_CONST AN_VIS_COL_MAX (VIS_H_PIX_MAX/8)
   48+          	DEC_CONST AN_VIS_ROW_MAX (VIS_V_PIX_MAX/8)
   49+   (2)    .endc
   50+          	HEX_CONST TOT_H_PIX	1024.	< pixel count to next line	>
   51+          	HEX_CONST TOT_V_PIX	1024.	< Total vertical screen size	>
   52+          ;
   53+          	HEX_CONST RED_LSB	0x0400		< RED gun LSB		>
   54+          	HEX_CONST GRN_LSB	0x0020		< GREEN gun LSB		>
   55+          	HEX_CONST BLU_LSB	0x0001		< BLUE gun LSB		>
   56+          	HEX_CONST ALL_LSB	<RED_LSB | GRN_LSB | BLU_LSB>
   57+          	HEX_CONST INTEN_MSK	0x8000		< INTENSITY MASK	>
   58+          ;
   59+          	HEX_CONST RED_MSK	0x7C00		< RED INTENSITY MASK	>
   60+          	HEX_CONST GRN_MSK	0x03E0		< GREEN INTENSITY MASK	>
   61+          	HEX_CONST BLU_MSK	0x001F		< BLUE INTENSITY MASK	>
   62+          	HEX_CONST RED_SHF	10.		< RED INTENSITY SHIFT	>
   63+          	HEX_CONST GRN_SHF	5		< GREEN INTENSITY SHIFT	>
   64+          	HEX_CONST BLU_SHF	0		< BLUE INTENSITY SHIFT	>
   65+          ;
   66+          	HEX_CONST ALL_MSK	<RED_MSK | GRN_MSK | BLU_MSK>
   67+          	HEX_CONST BITS_PER_GUN	5		< # of bits/gun	>
   68+          ;
   69+          	HEX_CONST YEL_MSK	<RED_MSK | GRN_MSK>
   70+          	HEX_CONST CYN_MSK	<GRN_MSK | BLU_MSK>
   71+          	HEX_CONST VIO_MSK	<RED_MSK | BLU_MSK>
   72+          	HEX_CONST RED_QTR	((RED_MSK+RED_LSB)>>2)
   73+          	HEX_CONST GRN_QTR	((GRN_MSK+GRN_LSB)>>2)
   74+          	HEX_CONST BLU_QTR	((BLU_MSK+BLU_LSB)>>2)
   75+          	HEX_CONST WHT_FUL	(ALL_MSK-RED_QTR-GRN_QTR-BLU_QTR)
   76+          	HEX_CONST SLT_FUL	(ALL_MSK-(2*(RED_QTR+GRN_QTR+BLU_QTR)))
   77+          	HEX_CONST GRY_FUL	(ALL_MSK-(3*(RED_QTR+GRN_QTR+BLU_QTR)))
   78+          	HEX_CONST GRY_BAK	(GRY_FUL<<16.)
   79+          ;
   80+          	HEX_CONST BLK_SLT	SLT_FUL		< Slate on black	>
   81+          	HEX_CONST BLK_WHT	WHT_FUL		< White on black	>
   82+          	HEX_CONST BLK_YEL	YEL_MSK		< Yellow on Black	>
   83+          	HEX_CONST BLK_RED	RED_MSK		< Red on black		>
   84+          	HEX_CONST BLK_GRN	GRN_MSK		< Green on Black	>
   85+          	HEX_CONST BLK_CYN	CYN_MSK		< Cyan on black		>
   86+          	HEX_CONST BLK_VIO	VIO_MSK		< Violet on black	>
   87+          	HEX_CONST BLK_BLU	BLU_MSK		< Blue on black		>
   88+          	HEX_CONST GRY_SLT	<GRY_BAK + SLT_FUL>
   89+          	HEX_CONST GRY_WHT	<GRY_BAK + WHT_FUL>
   90+          	HEX_CONST GRY_YEL 	<GRY_BAK + YEL_MSK>
   91+          	HEX_CONST GRY_RED	<GRY_BAK + RED_MSK>
dispatch.c                               Atari Games Corp. macpp v9.12   "Oct 16 1997 13:26:41"


   92+          	HEX_CONST GRY_GRN	<GRY_BAK + GRN_MSK>
   93+          	HEX_CONST GRY_CYN	<GRY_BAK + CYN_MSK>
   94+          	HEX_CONST GRY_VIO	<GRY_BAK + VIO_MSK>
   95+          	HEX_CONST GRY_BLU	<GRY_BAK + BLU_MSK>
   96+          ;
   97+   (2)    .if not_defined, DYNAMIC_VIS_PIX
   98+    X      .if not_defined, AN_VIS_COL
   99+    X     	HEX_CONST AN_VIS_COL	VIS_H_PIX/8	< AN visible stamps horiz.	>
  100+    X      .endc
  101+    X      .if not_defined, AN_VIS_ROW
  102+    X     	HEX_CONST AN_VIS_ROW	VIS_V_PIX/8	< AN visible stamps vert.	>
  103+    X      .endc
  104+   (2)    .endc
  105+          ;
  106+          	HEX_CONST AN_A_STMP	0x47	< code for 'A' stamp		>
  107+          	HEX_CONST AN_SQUARE	0x3	< AN stamp # completely filled	>
  108+          	HEX_CONST AN_BORDER	AN_SQUARE
  109+          	HEX_CONST AN_VOL_BAR	0x11E	< AN stamp for volume stamp	>
  110+          ;
  111+          	HEX_CONST BGBIT		0x8000
  112+          	HEX_CONST AN_PAL_MSK	0x7C00
  113+          	HEX_CONST AN_PAL_SHF	0xA
  114+          	HEX_CONST AN_NXT_PAL	(1<<AN_PAL_SHF)
  115+          	HEX_CONST GRY_PAL	0		< GREY is palette 0	>
  116+          	HEX_CONST GRY_PALB	(GRY_PAL|BGBIT)
  117+          	HEX_CONST BLU_PAL	(1<<AN_PAL_SHF)	< BLUE is palette 1	>
  118+          	HEX_CONST BLU_PALB	(BLU_PAL|BGBIT)
  119+          	HEX_CONST GRN_PAL	(2<<AN_PAL_SHF)	< GREEN is palette 2	>
  120+          	HEX_CONST GRN_PALB	(GRN_PAL|BGBIT)
  121+          	HEX_CONST CYN_PAL	(3<<AN_PAL_SHF)	< CYAN is palette 3	>
  122+          	HEX_CONST CYN_PALB	(CYN_PAL|BGBIT)
  123+          	HEX_CONST RED_PAL	(4<<AN_PAL_SHF)	< RED is palette 4	>
  124+          	HEX_CONST RED_PALB	(RED_PAL|BGBIT)
  125+          	HEX_CONST VIO_PAL	(5<<AN_PAL_SHF)	< VIOLET is palette 5	>
  126+          	HEX_CONST VIO_PALB	(VIO_PAL|BGBIT)
  127+          	HEX_CONST YEL_PAL	(6<<AN_PAL_SHF)	< YELLOW is palette 6	>
  128+          	HEX_CONST YEL_PALB	(YEL_PAL|BGBIT)
  129+          	HEX_CONST WHT_PAL	(7<<AN_PAL_SHF)	< WHITE is palette 7	>
  130+          	HEX_CONST WHT_PALB	(WHT_PAL|BGBIT)
  131+          ;
  132+          	HEX_CONST BOLD_FONT	(1)
  133+          	HEX_CONST UL_FONT	(2)
  134+          	HEX_CONST REVERSE_FONT	(4)
  135+          	HEX_CONST NORMAL_FONT	(0)
  136+          	HEX_CONST MNORMAL_PAL NORMAL_FONT
  137+          	HEX_CONST TITLE_PAL	RED_PALB
  138+          	HEX_CONST INSTR_PAL	GRN_PALB
  139+          	HEX_CONST BORDER_PAL	RED_PAL
  140+          	HEX_CONST VERSION_PAL	CYN_PALB
  141+          	HEX_CONST MHILITE_PAL	YEL_PALB
  142+          	HEX_CONST MNORMAL_PAL	GRY_PAL
  143+          	HEX_CONST ERROR_PAL	RED_PALB
  144+          ;
  145+          REM <	MESSAGE ROUTINE CONFIGURATION>
  146+          	HEX_CONST MAX_MESS	3	< maximum # of special message types	>
  147+          	HEX_CONST BIG_CHAR	0x0080	< BIG character bit offset		>
  148+          	HEX_CONST COLMSK	<BGBIT | AN_PAL_MSK>	< palette mask+bgbit	>
dispatch.c                               Atari Games Corp. macpp v9.12   "Oct 16 1997 13:26:41"


  149+          	HEX_CONST SETMSK	0x0003	< character set mask	>
  150+          	HEX_CONST AN_SET0	0x0000		
  151+          	HEX_CONST AN_SET1	0x0001
  152+          	HEX_CONST AN_SET2	0x0002
  153+          	HEX_CONST AN_BIG_SET	0x0003
  154+          ;
  155+   (1)    .endc				; _3DFX_MAC_
  133+          ;
  134+          REM <	Hardware I/O>
  135+          	HEX_CONST VCR_RECORD	-1	< turn on vcr RECORD		>
  136+          	HEX_CONST VCR_STOP	0	< STOP vcr			>
  137+   (1)    .if not_defined, VCR_HOLD_TIME
  138+          	DEC_CONST VCR_HOLD_TIME	20
  139+   (1)    .endc
  140+          REM <	SELFTEST common definitions>
  141+          	DEC_CONST TEST_DWELL	<15.*60.> < How long to wait for NEXT in P.O.R>
  142+          	HEX_CONST WDI_MASK	0x3FF	< longwords to try to clear btw wdogs>
  143+          ;
  144+   (1)    .if true, OUTPUT_LANG == LANG_C
  145+    X     #define NETWORK_ID_ADJUST ( 100000 )
  146+    X     #define NET_INTVEC NSS_INTVEC	/* tmp */
  147+    X     #define NET_LVL NSS_LVL		/* tmp */
  148+    X     #undef B_TEST
  149+    X     #define B_TEST (-1)
  150+    X     #define ST_SWITCH (1)			/* Always go into selftest */
  151+   (1)    .endc
  152+          ;
  153+   (1)    .if not_defined, PB_VALID
  154+          REM <	Game config (PBASE) structure >
  155+          	STR_START	pconfigb 
  156+          	STR_FPTR	p_reset	void	1	< Points to code >
  157+          	STR_ELT		p_optmenu <const unsigned char *> 1 < game option menu >
  158+          	STR_ELT		p_coinmenu <const unsigned char *> 1 < coin opt menu >
  159+          	STR_ELT		p_linktime <const char *> 1 < Main program link time >
  160+          	STR_ELT		p_trapmode char	1	< trap type 0:STOP +:68K -:68010 >
  161+          	STR_ELT		p_debug_options char 1	< Normally 0>
  162+   (2)    	.if df,GAME_SPECIFIC
  163+    X     	STR_FPTR	p_pf_draw int	1	< Points to code >
  164+   (2)    	.endc
  165+          	STR_ELT		p_oblist <void *> 1 <game-allocated object list memory>
  166+          	STR_ELT		p_oblen <unsigned long> 1 <length in bytes of above>
  167+          	STR_ELT		p_vers_valid <unsigned long> 1 <pconfigb version and validation>
  168+          	STR_ELT		p_bss_start <const void *> 1 <start of working ram>
  169+          	STR_ELT		p_bss_end <const void *> 1 <end of working ram>
  170+          	STR_ELT		p_stats <const void *> 1 < pointer to game stats >
  171+          ;
  172+          	STR_END		pconfigb
  173+          ;
  174+          	STR_START	pconfigp
  175+          	STR_ELT		p_validate long 1	< validation word	>
  176+          	STR_PTR		p_configb <pconfigb> 1	< configuration pointer	>
  177+          	STR_END		pconfigp
  178+          ;
  179+          	HEX_CONST PB_VALID 0xDEADBEEF		<value to validate PTR	>
  180+   (1)    .endc
  181+          ;
  182+   (1)    .if true, OUTPUT_LANG == LANG_C
dispatch.c                               Atari Games Corp. macpp v9.12   "Oct 16 1997 13:26:41"


  183+    X     REM < Audio Configuration Vars >
  184+          ; /* temp - o - ary (SOUND_NEW_WRAPPER)  (keeps older systems building without a new makefile (but with new phx_audio.c))
  185+    X     #define SOUND_NEW_MAKEFILE
  186+          ;
  187+    X     #define SOUND_DEFAULT_OS 		 
  188+    X     #define SOUND_TEST_BANK    
  189+    X     #define SOUND_QUEUED_LATCH
  190+    X     #define SOUND_DCS_STREAMED_AUDIO 
  191+          ; #define SOUND_DEBUG
  192+          ;
  193+          ; Overwriteable audio defaults
  194+          ; #define SOUND_SELF_TEST_BANK /*(U16 *data[])*/
  195+          ; #define SOUND_CALL_TABLE_SIZE 0x1000
  196+          ; #define SOUND_MAX_PARTITIONS 32
  197+          ; #define SOUND_DCS_CHANNELS 6
  198+    X     #define SOUND_QUEUE_TIMER_TIME 1000   
  199+          ; #define SOUND_QUEUE_SIZE (1<<8)
  200+          ; /* note: SOUND_QUEUE_SIZE must be a power of 2 */
  201+          ;
  202+   (1)    .endc
  203+          REM <			EOF				>
  204+          ;
  205+   (1)    .if true, OUTPUT_LANG == LANG_C
  206+    X     #endif				/* _CONFIG_H_ */
  207+   (1)    .endc
   29  00000000 	.outfile 0			;6 ... nine  ...
   30    (0)    .endc					;7 ... lines ...
   31    (0)    .if true, (_DISPATCH_MAC_&1) != 0	;8
   32     X      .if true, 0				;9 -----
   33           
   34     X     You are free to add or remove entries from this table according to your
   35     X     requirements. There are 10 fields used on each line in this table. The
   36     X     description of each field follows:
   37           
   38     X     Field 1 = macro call
   39           
   40     X     It must always be the keyword VDF (case is not significant).
   41           
   42     X     Field 2 = condition
   43           
   44     X     This is a dual operand field, so the two operands together must be enclosed in
   45     X     <>'s. The first operand is one of T, F, D or N representing True, False,
   46     X     Defined or Not_defined respectively. Case is significant, use uppercase only
   47     X     please. For the conditions T or F the second operand must be an expression
   48     X     which must resolve to non-$0 (True) or $0 (False) in order for the macro
   49     X     to be processed (else it is ignored). The expression can contain no embedded
   50     X     spaces. For the conditions D and N, the second operand must only be a symbol
   51     X     which must be Defined or Not-defined respectively in order for the macro to be
   52     X     processed. Some short cut expressions have been preprocessed to make using the
   53     X     expressions a little more concise. These are:
   54           
   55     X     	PHX = not $0 if HOST_BOARD == PHOENIX
   56     X     	PAD = not $0 if HOST_BOARD == PHOENIX_AD
   57     X     	FLG = not $0 if HOST_BOARD == FLAGSTAFF
   58     X     	SEA = not $0 if HOST_BOARD == SEATTLE
   59     X     	VEG = not $0 if HOST_BOARD == VEGAS
   60           
dispatch.c                               Atari Games Corp. macpp v9.12   "Oct 16 1997 13:26:41"


   61     X     Field 3 = vector name
   62           
   63     X     The NAME field is the name of the virtual vector. An _INTVEC will be appended
   64     X     to it in the C definitions in intvecs.h, but otherwise the name is unmolested.
   65     X     Case is significant only if you want it to be. The R3K/R4K has an option where
   66     X     a number of vectors are maintained in an array of pointers rather than each
   67     X     one having its own name. The index into the array is same as the number
   68     X     returned in the processor's CAUSE register for that particluar interrupt. This
   69     X     procedure is done simply for performance reasons. The option is selected by
   70     X     using a 0 for this field and using an installer function with the vector index
   71     X     as the parameter to the installer.
   72           
   73     X     Field 4 = Vector pointer
   74           
   75     X     This field identifies the name of a variable in BSS that contains a pointer
   76     X     to the function to call at interrupt (or will be set by the prc_set_vec()
   77     X     function). This is the name of the "soft" or logical vector and is either
   78     X     declared in dispatch.c or externally according to the INT/EXT field described
   79     X     next.
   80           
   81     X     Field 5 = INTernal or EXTernal vector
   82           
   83     X     This field contains the keywords INT, EXT, VINT or VEXT identifying the vector
   84     X     in field 4 as being defined INTernally, EXTernally, Volatile INTernally or
   85     X     Volatile Externally to dispatch.c respectively.
   86           
   87     X     Field 6 = name of vector installer
   88           
   89     X     This field identifies the name of a function that prc_set_vec() will call to
   90     X     actually install the vector or 0 if there is no special stuff that needs to
   91     X     be performed during vector installation.
   92           
   93     X     Field 7 = Notes for the installer.
   94           
   95     X     The Notes field is a parameter that is passed to the installer if there is one.
   96           
   97     X     Field 8 = Physical vector attachment.
   98           
   99     X     A dispatch routine is constructed for each of the 4 XBUS interrupts and for each of
  100     X     the 6 CPU interrupts.  This field instructs phx_vecs.mac into which of the XBUS or
  101     X     INTx dispatchers a caller to this vector belongs.  If this vector is not associated
  102     X     with an XBUS or an INTx interrupt, it needs to be -1.  Place the interrupt routines
  103     X     in this table in the order in which you want them executed.
  104           
  105     X     Field 9 = Default function.
  106           
  107     X     Name of default routine to install in the vector, or 0 if none.  phx_vecs.mac builds
  108     X     a function called prc_init_vecs(void) which, when called, will perform a string of
  109     X     prc_set_vec()'s for all the vectors having this field non-zero.  After the vectors
  110     X     have been loaded, prc_init_vecs(void) will map the phoenix and galileo interrupts as
  111     X     specified in phoenix.mac.
  112           
  113     X     Field 10 = Comments.
  114           
  115     X     The Comments field is placed on selected lines in intvecs.h and/or dispatch.c
  116     X     as simple 'C' comments.
  117           
dispatch.c                               Atari Games Corp. macpp v9.12   "Oct 16 1997 13:26:41"


  118     X      .endc				; Don't move this line
  119           ;
  120           ;   Condit	Name	   Vector   I/E	Installer   Notes      Phys	Default	Comments
  121           ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  122     X     VDF <T,1>	GAMEVB,	   gameint, EXT	0,          0,		-1,	0,	< post-wierdness Vblank >
  123     X     VDF <T,1>	MS4,       ms4vec,  EXT	0,          0,		-1,	0,	< 4 Millisecond timer >
  124     X     VDF <T,1>	PRC_DELAY, prc_delay_vec, EXT 0,    0,		-1,	sst_prc_delay, < prc_delay soft vector >
  125     X     VDF <T,1>	PRC_SET_IPL, set_ipl_vec, INT 0,    0,		-1,	0,	< prc_set_ipl soft vector >
  126     X     VDF <T,1>	SAVE,      savintp, EXT 0,          0,		-1,	0,	< context save soft vector >
  127     X     VDF <T,1>	RESTORE,   restintp,EXT 0,          0,		-1,	0,	< context restore soft vector >
  128     X     VDF <T,1>	SW0,	   0,	    INT hwvinst,    VN_IRQ0,    -1,	0,	< Software interrupt 0 >
  129     X     VDF <T,1>	SW1,	   0,       INT hwvinst,    VN_IRQ1,    -1,	0,	< Software interrupt 0 >
  130     X     VDF <T,1>	INT0,	   0,       INT hwvinst,    VN_IRQ2,    -1,	int0_irq, < Hardware interrupt 0 >
  131     X     VDF <T,1>	INT1,	   0,	    INT hwvinst,    VN_IRQ3,    -1,	int1_irq, < Hardware interrupt 1 >
  132     X     VDF <T,PHX>	INT2,	   0,	    INT hwvinst,    VN_IRQ4,    -1,	int2_irq, < Hardware interrupt 2 >
  133     X     VDF <T,1>	INT3,	   0,       INT hwvinst,    VN_IRQ5,    -1,	int3_irq, < Hardware interrupt 3 >
  134     X     VDF <T,1>	INT4,	   0,	    INT hwvinst,    VN_IRQ6,    -1,	int4_irq, < Hardware interrupt 4 >
  135     X     VDF <T,1>	INT5,	   0,	    INT hwvinst,    VN_IRQ7,    -1,	int5_irq, < Hardware interrupt 5 >
  136     X     VDF <T,1>	TLBMOD,	   0,	    INT hwvinst,    VN_TLBM,    -1,	0,	< TLB modification >
  137     X     VDF <T,1>	TLBLOAD,   0,	    INT hwvinst,    VN_TLBL,    -1,	0,	< TLB miss on I or D fetch >
  138     X     VDF <T,1>	TLBSTORE,  0,	    INT hwvinst,    VN_TLBS,    -1,	0,	< TLB miss on store >
  139     X     VDF <T,1>	ADDRERRL,  0,	    INT hwvinst,    VN_ADDRL,   -1,	0,	< Address error on I or D fetch >
  140     X     VDF <T,1>	ADDRERRS,  0,	    INT hwvinst,    VN_ADDRS,   -1,	0,	< Address error on store >
  141     X     VDF <T,1>	BUSERRI,   0,	    INT hwvinst,    VN_BUSERRI, -1,	0,	< Bus error on I-fetch >
  142     X     VDF <T,1>	BUSERRD,   0,	    INT hwvinst,    VN_BUSERRD, -1,	0,	< Bus error on D-fetch >
  143     X     VDF <T,1>	SYSCALL,   0,       INT hwvinst,    VN_SYSCALL, -1,	0,	< SYSCALL instruction >
  144     X     VDF <T,1>	BREAK,     0,       INT hwvinst,    VN_BREAK,   -1,	0,	< Breakpoint instruction >
  145     X     VDF <T,1>	RESERV,    0,       INT hwvinst,    VN_RESERV,  -1,	0,	< Reserved instruction >
  146     X     VDF <T,1>	COPROC,    0,       INT hwvinst,    VN_COPROC,  -1,	0,	< Coprocessor unusable >
  147     X     VDF <T,1>	OVRFLOW,   0,       INT hwvinst,    VN_OVERFL,  -1,	0,	< Integer Arithmetic Overflow >
  148     X     VDF <T,1>	TRAP,      0,       INT hwvinst,    VN_TRAPV,   -1,	0,	< TRAP exception >
  149     X     VDF <T,1>	FLOAT,     0,       INT hwvinst,    VN_FPE,     -1,	0,	< FLoating point exception >
  150     X     VDF <T,1>	TIMER,	   timervec, INT 0,	    0,          -1,	0,	< Soft Timer interrupt >
  151     X     VDF <T,1>	TIMERPLL,  tpllvec, VEXT 0,	    0,		-1,	0,	<Adjust 1MS timer>
  152     X     VDF <T,1>	GAMEFRAME, framevec,INT 0,	    0,		-1,	0,	< Frame complete >
  153     X     .if true, PHX
  154     X     VDF <D,NET_LVL>	NET,       netintp, INT 0,          0,		NET_LVL,0,	< network int soft vector >
  155     X     VDF <D,XBUS>	XBUS,	   xbusintp, INT pvinst,    XBUS_NOTES,	XBUS_LVL,xbus_irq, < Any XBUS interrupt >
  156     X     VDF <T,XS0>	XS0,       xs0intp, INT pvinst,	    XS0_NOTES,	XS0_LVL,0,	< Expansion Slot 0 interrupt >
  157     X     VDF <T,XS1>	XS1,       xs1intp, INT pvinst,	    XS1_NOTES,	XS1_LVL,0,	< Expansion Slot 1 interrupt >
  158     X     VDF <T,XS2>	XS2,       xs2intp, INT pvinst,	    XS2_NOTES,	XS2_LVL,0,	< Expansion Slot 2 interrupt >
  159     X     VDF <T,XS3>	XS3,       xs3intp, INT pvinst,	    XS3_NOTES,	XS3_LVL,0,	< Expansion Slot 3 interrupt >
  160     X     VDF <T,MIO>	MIO,       miointp, INT pvinst,	    MIO_NOTES,	MIO_LVL,0,	< Miscellaneous I/O interrupt >
  161     X     VDF <T,CU1>	CU1,       cu1intp, INT pvinst,	    CU1_NOTES,	CU1_LVL,0,	< Combo UART 1 interrupt >
  162     X     VDF <T,CU2>	CU2,       cu2intp, INT pvinst,	    CU2_NOTES,	CU2_LVL,0,	< Combo UART 2 interrupt >
  163     X     VDF <T,CPP>	CPP,       cppintp, INT pvinst,	    CPP_NOTES,	CPP_LVL,0,	< Combo Parallel Port interrupt >
  164     X     VDF <T,PCA>	PCA,       pcaintp, INT pvinst,	    PCA_NOTES,	PCA_LVL,0,	< PCI A interrupt >
  165     X     VDF <T,PCB>	PCB,       pcbintp, INT pvinst,	    PCB_NOTES,	PCB_LVL,0,	< PCI B interrupt >
  166     X     VDF <T,PCC>	PCC,       pccintp, INT pvinst,	    PCC_NOTES,	PCC_LVL,0,	< PCI C interrupt >
  167     X     VDF <T,VSY>	VSY,       vsyintp, INT pvinst,	    VSY_NOTES,	VSY_LVL,0,	< PCI D (VSYNC) interrupt >
  168     X     VDF <T,IDE>	IDE,	   ideintp, INT pvinst,	    IDE_NOTES,	IDE_LVL,0,	< IDE interrupt >
  169     X     VDF <T,IOA>	IOA,	   ioaintp, INT pvinst,	    IOA_NOTES,	IOA_LVL,ioa_irq,< I/O Asic interrupt >
  170     X     VDF <T,ADC>	ADC,	   adcintp, INT pvinst,	    ADC_NOTES,	ADC_LVL,0,	< A/D Converter interrupt >
  171     X     VDF <D,SND_I>	CAGE,      cagevec, INT 0,          0,		CAGE_LVL,aud_irq, < CAGE interrupt >
  172     X     .endc
  173     X     .if true, PAD || FLG || SEA || VEG
  174           ;VDF <T,1>	IOA,	   0,	    INT hwvinst,    VN_IRQ3,	-1,	0,	< I/O Asic interrupt >
dispatch.c                               Atari Games Corp. macpp v9.12   "Oct 16 1997 13:26:41"


  175     X     VDF <T,1>	IDE,	   0,	    INT hwvinst,    VN_IRQ4,    -1,	0,	< IDE interrupt >
  176     X     VDF <T,EXP>	EXP,       expintp, INT pvinst,	    EXP_NOTES,	EXP_LVL,0,	< Expansion Slot interrupt >
  177     X      .if true, PAD || SEA
  178     X     VDF <T,NSS>	NSS,	   nssintp, INT pvinst,	    NSS_NOTES,  NSS_LVL,0,	< NSS/Hi-Link interrupt>
  179     X      .endc
  180     X      .if true, FLG
  181     X     VDF <T,ETH>	ETH,	   ethintp, INT pvinst,     ETH_NOTES,  ETH_LVL,0,	< ethernet interrupt >
  182     X     VDF <D,SND_I>	CAGE,	   cagevec, INT ioainst,    CAGE_NOTES, CAGE_LVL,aud_irq, < CAGE interrupt >
  183     X      .endc
  184     X     VDF <T,WD1>	WD1,	   wd1intp, INT pvinst,	    WD1_NOTES,  WD1_LVL,0,	< Widget interrupt 1>
  185     X     VDF <T,PCI>	PCI,       pciintp, INT pvinst,	    PCI_NOTES,	PCI_LVL,0,	< PCI interrupt >
  186     X     VDF <T,ADC>	ADC,	   adcintp, INT pvinst,	    ADC_NOTES,	ADC_LVL,0,	< A/D Converter interrupt >
  187     X     VDF <T,WD2>	WD2,	   wd2intp, INT pvinst,	    WD2_NOTES,  WD2_LVL,0,	< Widget interrupt 2>
  188     X     VDF <T,DBG>	DBG,	   dbgintp, INT pvinst,	    DBG_NOTES,	DBG_LVL,0,	< Debug switch interrupt >
  189     X     VDF <T,VSY>	VSY,	   vsyintp, INT pvinst,	    VSY_NOTES,	VSY_LVL,0,	< VSYNC interrupt >
  190     X     .endc
  191     X     VDF <T,GAL>	GAL,	   0,       INT gvinst,	    GAL_NOTES,  GAL_LVL,galileoint, < Any Galileo Error Interrupt >
  192     X     VDF <T,MOE>	MOE,	   moeintp, INT gvinst,	    MOE_NOTES,	MOE_LVL,0,	< Galileo MemOut >
  193     X     VDF <T,DOE>	DOE,	   doeintp, INT gvinst,	    DOE_NOTES,	DOE_LVL,0,	< Galileo DMAOut >
  194     X     VDF <T,COE>	COE,	   coeintp, INT gvinst,	    COE_NOTES,	COE_LVL,0,	< Galileo CPUOut >
  195     X     VDF <T,DM0>	DM0,	   dm0intp, INT gvinst,	    DM0_NOTES,	DM0_LVL,0,	< Galileo DMA0Comp >
  196     X     VDF <T,DM1>	DM1,	   dm1intp, INT gvinst,	    DM1_NOTES,	DM1_LVL,0,	< Galileo DMA1Comp >
  197     X     VDF <T,DM2>	DM2,	   dm2intp, INT gvinst,	    DM2_NOTES,	DM2_LVL,0,	< Galileo DMA2Comp >
  198     X     VDF <T,DM3>	DM3,	   dm3intp, INT gvinst,	    DM3_NOTES,	DM3_LVL,0,	< Galileo DMA3Comp >
  199     X     VDF <T,TM0>	TM0,	   tm0intp, INT gvinst,	    TM0_NOTES,	TM0_LVL,0,	< Galileo T0Exp >
  200     X     VDF <T,TM1>	TM1,	   tm1intp, INT gvinst,	    TM1_NOTES,	TM1_LVL,0,	< Galileo T1Exp >
  201     X     VDF <T,TM2>	TM2,	   tm2intp, INT gvinst,	    TM2_NOTES,	TM2_LVL,0,	< Galileo T2Exp >
  202     X     VDF <T,TM3>	TM3,	   tm3intp, INT gvinst,	    TM3_NOTES,	TM3_LVL,cputimerint, < Galileo T3EXP timer interrupt >
  203     X     VDF <T,MRE>	MRE,	   mreintp, INT gvinst,	    MRE_NOTES,	MRE_LVL,0,	< Galileo MasRdErr >
  204     X     VDF <T,SWE>	SWE,	   sweintp, INT gvinst,	    SWE_NOTES,	SWE_LVL,0,	< Galileo SlvWrErr >
  205     X     VDF <T,MWE>	MWE,	   mweintp, INT gvinst,	    MWE_NOTES,	MWE_LVL,0,	< Galileo MasWrErr >
  206     X     VDF <T,SRE>	SRE,	   sreintp, INT gvinst,	    SRE_NOTES,	SRE_LVL,0,	< Galileo SlvRdErr >
  207     X     VDF <T,AEP>	AEP,	   aepintp, INT gvinst,	    AEP_NOTES,	AEP_LVL,0,	< Galileo AddrErr >
  208     X     VDF <T,MEP>	MEP,	   mepintp, INT gvinst,	    MEP_NOTES,	MEP_LVL,0,	< Galileo MemErr >
  209     X     VDF <T,MAS>	MAS,	   masintp, INT gvinst,	    MAS_NOTES,	MAS_LVL,0,	< Galileo MasAbort >
  210     X     VDF <T,TAR>	TAR,	   tarintp, INT gvinst,	    TAR_NOTES,	TAR_LVL,0,	< Galileo TarAbort >
  211     X     VDF <T,RTY>	RTY,	   rtyintp, INT gvinst,	    RTY_NOTES,	RTY_LVL,0,	< Galileo RetryCtr >
  212     X     VDF <T,PC0>	PC0,	   pc0intp, INT gvinst,	    PC0_NOTES,	PC0_LVL,0,	< Galileo PCI Interrupt >
  213     X     VDF <T,PC1>	PC1,	   pc1intp, INT gvinst,	    PC1_NOTES,	PC1_LVL,0,	< Galileo PCI Interrupt >
  214     X     VDF <T,PC2>	PC2,	   pc2intp, INT gvinst,	    PC2_NOTES,	PC2_LVL,0,	< Galileo PCI Interrupt >
  215     X     VDF <T,PC3>	PC3,	   pc3intp, INT gvinst,	    PC3_NOTES,	PC3_LVL,0,	< Galileo PCI Interrupt >
  216     X     VDF <D,UART_LVL> UART,	   uartintp,INT ioainst,    UART_NOTES,	UART_LVL,0,	< I/O ASIC UART interrupts >
  217     X     VDF <D,SND_LVL>	SND,	   sndintp, INT ioainst,    SND_NOTES,	SND_LVL, 0,	< I/O ASIC Sound interrupts >
  218     X     VDF <D,MC_LVL>	MC,	   mcintp,  INT ioainst,    MC_NOTES,	MC_LVL,	0,	< I/O ASIC Microcontroller interrupt >
  219           ;
  220    (0)    .endc			; (_DISPATCH_MAC_&1) != 0 *** DON'T MOVE THIS LINE EITHER ***
  221           ;
  222           ;+++++++ From here on, there are few user servicable parts inside. ++++
  223           ;
  224           ; This is sortof how it works:
  225           ; The first pass through, _DISPATCH_MAC_ will be 0 (set above by the .if not_defined).
  226           ; First the copyright boilerplate is inserted into both output files and the macro VDF
  227           ; is defined to create externs. Some struct definitions and unique externs are depositied
  228           ; into the .h file. Next _DISPATCH_MAC_ is set to 1 and this file is .included
  229           ; again. This will cause MACPP to read the VDF table above and output the appropriate
  230           ; information in the .h file but ignore the rest of the file. The VDF macro is redefined,
  231           ; and the procedure is repeated causing the creation of different items according to what
dispatch.c                               Atari Games Corp. macpp v9.12   "Oct 16 1997 13:26:41"


  232           ; is needed. Once the whole .h file is built, the procedure repeats for the building of the
  233           ; .c file.
  234           ;
  235    (0)    .if true, _DISPATCH_MAC_ == 0		; First (main) pass
  236  00000000  PHX == 0
  237  00000000  PAD == 0
  238  00000000  FLG == 0
  239  00000000  SEA == 0
  240  00000000  VEG == 0
  241     X      .iif true, HOST_BOARD == PHOENIX, PHX == 1 ;set the appropriate ones true as desired
  242     X      .iif true, HOST_BOARD == PHOENIX_AD, PAD == 1 ;set the appropriate ones true as desired
  243     X      .iif true, HOST_BOARD == FLAGSTAFF, FLG == 1 ;set the appropriate ones true as desired
  244  00000001  .iif true, HOST_BOARD == SEATTLE, SEA == 1 ;set the appropriate ones true as desired
  245     X      .iif true, HOST_BOARD == VEGAS, VEG == 1 ;set the appropriate ones true as desired
  246           ;
  247           	.macro .condit flag,exp		; The .condit macro does an expression test ...
  248           	.if identical,<flag>,<T>
  249           		.iif false,exp,.mexit 10 ; ... and aborts higher level macros if false
  250           		.mexit
  251           	.endc
  252           	.if identical,<flag>,<F>
  253           		.iif true,exp,.mexit 10	; ... etc.
  254           		.mexit
  255           	.endc
  256           	.if identical,<flag>,<D>
  257           		.iif not_defined,exp,.mexit 10
  258           		.mexit
  259           	.endc
  260           	.if identical,<flag>,<N>
  261           		.iif defined,exp,.mexit 10
  262           		.mexit
  263           	.endc
  264           	.endm
  265           ;	
  266           	.macro boilerplate file_name
  267           /*		file_name
  268            *
  269            *		Copyright 1996 Atari Games Corporation
  270            *	Unauthorized reproduction, adaptation, distribution, performance or 
  271            *	display of this computer program or the associated audiovisual work
  272            *	is strictly prohibited.
  273            *
  274            * ++++++ WARNING WARNING WARNING WARNING WARNING +++++
  275            * This file is machine generated. Any changes you put in here will be lost
  276            * the next time phx_vecs.mac is touched. You need to make your changes to
  277            * phx_vecs.mac instead of this file.
  278            */
  279           	.endm
  280           	boilerplate dispatch.c
  281  00000001 	.outfile	1		;The externs go into the .h file
  282           	boilerplate intvecs.h
  283           #if !defined(_INTVECS_H_)
  284           #define _INTVECS_H_
  285           
  286           struct irq_tab {
  287           	void 	(**softvec)();
  288           	void    (*(*installer)(const struct irq_tab *, void(*new)()))();
dispatch.c                               Atari Games Corp. macpp v9.12   "Oct 16 1997 13:26:41"


  289           	int	notes;
  290           };
  291           ;
  292           	.macro VDF cond, name, softvec, intern, installer, notes, physical, default, comments
  293           	.condit cond	
  294            .if dif,<softvec>,<0>
  295             ...1 == 0
  296             .iif idn,<intern>,<VINT>,...1 == 1
  297             .iif idn,<intern>,<VEXT>,...1 == 1
  298             .if true, ...1
  299           extern	void (* volatile softvec)();	/* comments */
  300             .iff
  301           extern  void (*softvec)();	/* comments */
  302             .endc
  303            .endc
  304           	.endm
  305           ;
  306  00000001 	_DISPATCH_MAC_ == 1		;next time we process the IRQ table
  307           	.include phx_vecs.mac		;Make the externs
    1+          ;/*		phx_vecs.mac
    2+          ; *
    3+          ; *		Copyright 1996 Atari Games Corporation
    4+          ; *	Unauthorized reproduction, adaptation, distribution, performance or 
    5+          ; *	display of this computer program or the associated audiovisual work
    6+          ; *	is strictly prohibited.
    7+          ; *
    8+          ; *	This file is processed by MACPP to produce dispatch.c and intvecs.h.
    9+          ; *
   10+          ; *	The definitions placed in intvecs.h declare virtual vector numbers
   11+          ; *	in the form of xxx_INTVEC and a cross reference table(s) so the
   12+          ; *	dispatcher can call the appropriate functions.
   13+          ; *
   14+          ; *	intvecs.h should be #include'd by any module that uses prc_set_vec().
   15+          ; */
   16+          ;
   17+          ; This file recursivley '.includes' itself to succesively build up the approprate
   18+          ; tables and functions in C and places the results in one of two files (the
   19+          ; first -out=file supplied on the MACPP command line is expected to be dispatch.c
   20+          ; and the second -out=file is expected to be intvecs.h and the third is expected to
   21+          ; be /dev/null). If you don't speak fluent MACPP, then you probably shouldn't be
   22+          ; changing anything in this file other than the VDF table listed below.
   23+          ;
   24+   (1)    .if not_defined, _DISPATCH_MAC_		;1 +++++
   25+    X     _DISPATCH_MAC_ == 0			;2 Don't move ...
   26+    X     OUTPUT_LANG == 5 ;LANG_NONE		;3 ... or change ... 
   27+    X     	.outfile 2			;4 ... anything on ...
   28+    X     	.include config.mac		;5 ... these ...
   29+    X     	.outfile 0			;6 ... nine  ...
   30+   (1)    .endc					;7 ... lines ...
   31+   (1)    .if true, (_DISPATCH_MAC_&1) != 0	;8
   32+   (2)     .if true, 0				;9 -----
   33+          
   34+    X     You are free to add or remove entries from this table according to your
   35+    X     requirements. There are 10 fields used on each line in this table. The
   36+    X     description of each field follows:
   37+          
   38+    X     Field 1 = macro call
dispatch.c                               Atari Games Corp. macpp v9.12   "Oct 16 1997 13:26:41"


   39+          
   40+    X     It must always be the keyword VDF (case is not significant).
   41+          
   42+    X     Field 2 = condition
   43+          
   44+    X     This is a dual operand field, so the two operands together must be enclosed in
   45+    X     <>'s. The first operand is one of T, F, D or N representing True, False,
   46+    X     Defined or Not_defined respectively. Case is significant, use uppercase only
   47+    X     please. For the conditions T or F the second operand must be an expression
   48+    X     which must resolve to non-$0 (True) or $0 (False) in order for the macro
   49+    X     to be processed (else it is ignored). The expression can contain no embedded
   50+    X     spaces. For the conditions D and N, the second operand must only be a symbol
   51+    X     which must be Defined or Not-defined respectively in order for the macro to be
   52+    X     processed. Some short cut expressions have been preprocessed to make using the
   53+    X     expressions a little more concise. These are:
   54+          
   55+    X     	PHX = not $0 if HOST_BOARD == PHOENIX
   56+    X     	PAD = not $0 if HOST_BOARD == PHOENIX_AD
   57+    X     	FLG = not $0 if HOST_BOARD == FLAGSTAFF
   58+    X     	SEA = not $0 if HOST_BOARD == SEATTLE
   59+    X     	VEG = not $0 if HOST_BOARD == VEGAS
   60+          
   61+    X     Field 3 = vector name
   62+          
   63+    X     The NAME field is the name of the virtual vector. An _INTVEC will be appended
   64+    X     to it in the C definitions in intvecs.h, but otherwise the name is unmolested.
   65+    X     Case is significant only if you want it to be. The R3K/R4K has an option where
   66+    X     a number of vectors are maintained in an array of pointers rather than each
   67+    X     one having its own name. The index into the array is same as the number
   68+    X     returned in the processor's CAUSE register for that particluar interrupt. This
   69+    X     procedure is done simply for performance reasons. The option is selected by
   70+    X     using a 0 for this field and using an installer function with the vector index
   71+    X     as the parameter to the installer.
   72+          
   73+    X     Field 4 = Vector pointer
   74+          
   75+    X     This field identifies the name of a variable in BSS that contains a pointer
   76+    X     to the function to call at interrupt (or will be set by the prc_set_vec()
   77+    X     function). This is the name of the "soft" or logical vector and is either
   78+    X     declared in dispatch.c or externally according to the INT/EXT field described
   79+    X     next.
   80+          
   81+    X     Field 5 = INTernal or EXTernal vector
   82+          
   83+    X     This field contains the keywords INT, EXT, VINT or VEXT identifying the vector
   84+    X     in field 4 as being defined INTernally, EXTernally, Volatile INTernally or
   85+    X     Volatile Externally to dispatch.c respectively.
   86+          
   87+    X     Field 6 = name of vector installer
   88+          
   89+    X     This field identifies the name of a function that prc_set_vec() will call to
   90+    X     actually install the vector or 0 if there is no special stuff that needs to
   91+    X     be performed during vector installation.
   92+          
   93+    X     Field 7 = Notes for the installer.
   94+          
   95+    X     The Notes field is a parameter that is passed to the installer if there is one.
dispatch.c                               Atari Games Corp. macpp v9.12   "Oct 16 1997 13:26:41"


   96+          
   97+    X     Field 8 = Physical vector attachment.
   98+          
   99+    X     A dispatch routine is constructed for each of the 4 XBUS interrupts and for each of
  100+    X     the 6 CPU interrupts.  This field instructs phx_vecs.mac into which of the XBUS or
  101+    X     INTx dispatchers a caller to this vector belongs.  If this vector is not associated
  102+    X     with an XBUS or an INTx interrupt, it needs to be -1.  Place the interrupt routines
  103+    X     in this table in the order in which you want them executed.
  104+          
  105+    X     Field 9 = Default function.
  106+          
  107+    X     Name of default routine to install in the vector, or 0 if none.  phx_vecs.mac builds
  108+    X     a function called prc_init_vecs(void) which, when called, will perform a string of
  109+    X     prc_set_vec()'s for all the vectors having this field non-zero.  After the vectors
  110+    X     have been loaded, prc_init_vecs(void) will map the phoenix and galileo interrupts as
  111+    X     specified in phoenix.mac.
  112+          
  113+    X     Field 10 = Comments.
  114+          
  115+    X     The Comments field is placed on selected lines in intvecs.h and/or dispatch.c
  116+    X     as simple 'C' comments.
  117+          
  118+   (2)     .endc				; Don't move this line
  119+          ;
  120+          ;   Condit	Name	   Vector   I/E	Installer   Notes      Phys	Default	Comments
  121+          ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  122+          VDF <T,1>	GAMEVB,	   gameint, EXT	0,          0,		-1,	0,	< post-wierdness Vblank >
  123+          VDF <T,1>	MS4,       ms4vec,  EXT	0,          0,		-1,	0,	< 4 Millisecond timer >
  124+          VDF <T,1>	PRC_DELAY, prc_delay_vec, EXT 0,    0,		-1,	sst_prc_delay, < prc_delay soft vector >
  125+          VDF <T,1>	PRC_SET_IPL, set_ipl_vec, INT 0,    0,		-1,	0,	< prc_set_ipl soft vector >
  126+          VDF <T,1>	SAVE,      savintp, EXT 0,          0,		-1,	0,	< context save soft vector >
  127+          VDF <T,1>	RESTORE,   restintp,EXT 0,          0,		-1,	0,	< context restore soft vector >
  128+          VDF <T,1>	SW0,	   0,	    INT hwvinst,    VN_IRQ0,    -1,	0,	< Software interrupt 0 >
  129+          VDF <T,1>	SW1,	   0,       INT hwvinst,    VN_IRQ1,    -1,	0,	< Software interrupt 0 >
  130+          VDF <T,1>	INT0,	   0,       INT hwvinst,    VN_IRQ2,    -1,	int0_irq, < Hardware interrupt 0 >
  131+          VDF <T,1>	INT1,	   0,	    INT hwvinst,    VN_IRQ3,    -1,	int1_irq, < Hardware interrupt 1 >
  132+          VDF <T,PHX>	INT2,	   0,	    INT hwvinst,    VN_IRQ4,    -1,	int2_irq, < Hardware interrupt 2 >
  133+          VDF <T,1>	INT3,	   0,       INT hwvinst,    VN_IRQ5,    -1,	int3_irq, < Hardware interrupt 3 >
  134+          VDF <T,1>	INT4,	   0,	    INT hwvinst,    VN_IRQ6,    -1,	int4_irq, < Hardware interrupt 4 >
  135+          VDF <T,1>	INT5,	   0,	    INT hwvinst,    VN_IRQ7,    -1,	int5_irq, < Hardware interrupt 5 >
  136+          VDF <T,1>	TLBMOD,	   0,	    INT hwvinst,    VN_TLBM,    -1,	0,	< TLB modification >
  137+          VDF <T,1>	TLBLOAD,   0,	    INT hwvinst,    VN_TLBL,    -1,	0,	< TLB miss on I or D fetch >
  138+          VDF <T,1>	TLBSTORE,  0,	    INT hwvinst,    VN_TLBS,    -1,	0,	< TLB miss on store >
  139+          VDF <T,1>	ADDRERRL,  0,	    INT hwvinst,    VN_ADDRL,   -1,	0,	< Address error on I or D fetch >
  140+          VDF <T,1>	ADDRERRS,  0,	    INT hwvinst,    VN_ADDRS,   -1,	0,	< Address error on store >
  141+          VDF <T,1>	BUSERRI,   0,	    INT hwvinst,    VN_BUSERRI, -1,	0,	< Bus error on I-fetch >
  142+          VDF <T,1>	BUSERRD,   0,	    INT hwvinst,    VN_BUSERRD, -1,	0,	< Bus error on D-fetch >
  143+          VDF <T,1>	SYSCALL,   0,       INT hwvinst,    VN_SYSCALL, -1,	0,	< SYSCALL instruction >
  144+          VDF <T,1>	BREAK,     0,       INT hwvinst,    VN_BREAK,   -1,	0,	< Breakpoint instruction >
  145+          VDF <T,1>	RESERV,    0,       INT hwvinst,    VN_RESERV,  -1,	0,	< Reserved instruction >
  146+          VDF <T,1>	COPROC,    0,       INT hwvinst,    VN_COPROC,  -1,	0,	< Coprocessor unusable >
  147+          VDF <T,1>	OVRFLOW,   0,       INT hwvinst,    VN_OVERFL,  -1,	0,	< Integer Arithmetic Overflow >
  148+          VDF <T,1>	TRAP,      0,       INT hwvinst,    VN_TRAPV,   -1,	0,	< TRAP exception >
  149+          VDF <T,1>	FLOAT,     0,       INT hwvinst,    VN_FPE,     -1,	0,	< FLoating point exception >
  150+          VDF <T,1>	TIMER,	   timervec, INT 0,	    0,          -1,	0,	< Soft Timer interrupt >
  151+          VDF <T,1>	TIMERPLL,  tpllvec, VEXT 0,	    0,		-1,	0,	<Adjust 1MS timer>
  152+          VDF <T,1>	GAMEFRAME, framevec,INT 0,	    0,		-1,	0,	< Frame complete >
dispatch.c                               Atari Games Corp. macpp v9.12   "Oct 16 1997 13:26:41"


  153+   (2)    .if true, PHX
  154+    X     VDF <D,NET_LVL>	NET,       netintp, INT 0,          0,		NET_LVL,0,	< network int soft vector >
  155+    X     VDF <D,XBUS>	XBUS,	   xbusintp, INT pvinst,    XBUS_NOTES,	XBUS_LVL,xbus_irq, < Any XBUS interrupt >
  156+    X     VDF <T,XS0>	XS0,       xs0intp, INT pvinst,	    XS0_NOTES,	XS0_LVL,0,	< Expansion Slot 0 interrupt >
  157+    X     VDF <T,XS1>	XS1,       xs1intp, INT pvinst,	    XS1_NOTES,	XS1_LVL,0,	< Expansion Slot 1 interrupt >
  158+    X     VDF <T,XS2>	XS2,       xs2intp, INT pvinst,	    XS2_NOTES,	XS2_LVL,0,	< Expansion Slot 2 interrupt >
  159+    X     VDF <T,XS3>	XS3,       xs3intp, INT pvinst,	    XS3_NOTES,	XS3_LVL,0,	< Expansion Slot 3 interrupt >
  160+    X     VDF <T,MIO>	MIO,       miointp, INT pvinst,	    MIO_NOTES,	MIO_LVL,0,	< Miscellaneous I/O interrupt >
  161+    X     VDF <T,CU1>	CU1,       cu1intp, INT pvinst,	    CU1_NOTES,	CU1_LVL,0,	< Combo UART 1 interrupt >
  162+    X     VDF <T,CU2>	CU2,       cu2intp, INT pvinst,	    CU2_NOTES,	CU2_LVL,0,	< Combo UART 2 interrupt >
  163+    X     VDF <T,CPP>	CPP,       cppintp, INT pvinst,	    CPP_NOTES,	CPP_LVL,0,	< Combo Parallel Port interrupt >
  164+    X     VDF <T,PCA>	PCA,       pcaintp, INT pvinst,	    PCA_NOTES,	PCA_LVL,0,	< PCI A interrupt >
  165+    X     VDF <T,PCB>	PCB,       pcbintp, INT pvinst,	    PCB_NOTES,	PCB_LVL,0,	< PCI B interrupt >
  166+    X     VDF <T,PCC>	PCC,       pccintp, INT pvinst,	    PCC_NOTES,	PCC_LVL,0,	< PCI C interrupt >
  167+    X     VDF <T,VSY>	VSY,       vsyintp, INT pvinst,	    VSY_NOTES,	VSY_LVL,0,	< PCI D (VSYNC) interrupt >
  168+    X     VDF <T,IDE>	IDE,	   ideintp, INT pvinst,	    IDE_NOTES,	IDE_LVL,0,	< IDE interrupt >
  169+    X     VDF <T,IOA>	IOA,	   ioaintp, INT pvinst,	    IOA_NOTES,	IOA_LVL,ioa_irq,< I/O Asic interrupt >
  170+    X     VDF <T,ADC>	ADC,	   adcintp, INT pvinst,	    ADC_NOTES,	ADC_LVL,0,	< A/D Converter interrupt >
  171+    X     VDF <D,SND_I>	CAGE,      cagevec, INT 0,          0,		CAGE_LVL,aud_irq, < CAGE interrupt >
  172+   (2)    .endc
  173+   (2)    .if true, PAD || FLG || SEA || VEG
  174+          ;VDF <T,1>	IOA,	   0,	    INT hwvinst,    VN_IRQ3,	-1,	0,	< I/O Asic interrupt >
  175+          VDF <T,1>	IDE,	   0,	    INT hwvinst,    VN_IRQ4,    -1,	0,	< IDE interrupt >
  176+          VDF <T,EXP>	EXP,       expintp, INT pvinst,	    EXP_NOTES,	EXP_LVL,0,	< Expansion Slot interrupt >
  177+   (3)     .if true, PAD || SEA
  178+          VDF <T,NSS>	NSS,	   nssintp, INT pvinst,	    NSS_NOTES,  NSS_LVL,0,	< NSS/Hi-Link interrupt>
  179+   (3)     .endc
  180+   (3)     .if true, FLG
  181+    X     VDF <T,ETH>	ETH,	   ethintp, INT pvinst,     ETH_NOTES,  ETH_LVL,0,	< ethernet interrupt >
  182+    X     VDF <D,SND_I>	CAGE,	   cagevec, INT ioainst,    CAGE_NOTES, CAGE_LVL,aud_irq, < CAGE interrupt >
  183+   (3)     .endc
  184+          VDF <T,WD1>	WD1,	   wd1intp, INT pvinst,	    WD1_NOTES,  WD1_LVL,0,	< Widget interrupt 1>
  185+          VDF <T,PCI>	PCI,       pciintp, INT pvinst,	    PCI_NOTES,	PCI_LVL,0,	< PCI interrupt >
  186+          VDF <T,ADC>	ADC,	   adcintp, INT pvinst,	    ADC_NOTES,	ADC_LVL,0,	< A/D Converter interrupt >
  187+          VDF <T,WD2>	WD2,	   wd2intp, INT pvinst,	    WD2_NOTES,  WD2_LVL,0,	< Widget interrupt 2>
  188+          VDF <T,DBG>	DBG,	   dbgintp, INT pvinst,	    DBG_NOTES,	DBG_LVL,0,	< Debug switch interrupt >
  189+          VDF <T,VSY>	VSY,	   vsyintp, INT pvinst,	    VSY_NOTES,	VSY_LVL,0,	< VSYNC interrupt >
  190+   (2)    .endc
  191+          VDF <T,GAL>	GAL,	   0,       INT gvinst,	    GAL_NOTES,  GAL_LVL,galileoint, < Any Galileo Error Interrupt >
  192+          VDF <T,MOE>	MOE,	   moeintp, INT gvinst,	    MOE_NOTES,	MOE_LVL,0,	< Galileo MemOut >
  193+          VDF <T,DOE>	DOE,	   doeintp, INT gvinst,	    DOE_NOTES,	DOE_LVL,0,	< Galileo DMAOut >
  194+          VDF <T,COE>	COE,	   coeintp, INT gvinst,	    COE_NOTES,	COE_LVL,0,	< Galileo CPUOut >
  195+          VDF <T,DM0>	DM0,	   dm0intp, INT gvinst,	    DM0_NOTES,	DM0_LVL,0,	< Galileo DMA0Comp >
  196+          VDF <T,DM1>	DM1,	   dm1intp, INT gvinst,	    DM1_NOTES,	DM1_LVL,0,	< Galileo DMA1Comp >
  197+          VDF <T,DM2>	DM2,	   dm2intp, INT gvinst,	    DM2_NOTES,	DM2_LVL,0,	< Galileo DMA2Comp >
  198+          VDF <T,DM3>	DM3,	   dm3intp, INT gvinst,	    DM3_NOTES,	DM3_LVL,0,	< Galileo DMA3Comp >
  199+          VDF <T,TM0>	TM0,	   tm0intp, INT gvinst,	    TM0_NOTES,	TM0_LVL,0,	< Galileo T0Exp >
  200+          VDF <T,TM1>	TM1,	   tm1intp, INT gvinst,	    TM1_NOTES,	TM1_LVL,0,	< Galileo T1Exp >
  201+          VDF <T,TM2>	TM2,	   tm2intp, INT gvinst,	    TM2_NOTES,	TM2_LVL,0,	< Galileo T2Exp >
  202+          VDF <T,TM3>	TM3,	   tm3intp, INT gvinst,	    TM3_NOTES,	TM3_LVL,cputimerint, < Galileo T3EXP timer interrupt >
  203+          VDF <T,MRE>	MRE,	   mreintp, INT gvinst,	    MRE_NOTES,	MRE_LVL,0,	< Galileo MasRdErr >
  204+          VDF <T,SWE>	SWE,	   sweintp, INT gvinst,	    SWE_NOTES,	SWE_LVL,0,	< Galileo SlvWrErr >
  205+          VDF <T,MWE>	MWE,	   mweintp, INT gvinst,	    MWE_NOTES,	MWE_LVL,0,	< Galileo MasWrErr >
  206+          VDF <T,SRE>	SRE,	   sreintp, INT gvinst,	    SRE_NOTES,	SRE_LVL,0,	< Galileo SlvRdErr >
  207+          VDF <T,AEP>	AEP,	   aepintp, INT gvinst,	    AEP_NOTES,	AEP_LVL,0,	< Galileo AddrErr >
  208+          VDF <T,MEP>	MEP,	   mepintp, INT gvinst,	    MEP_NOTES,	MEP_LVL,0,	< Galileo MemErr >
  209+          VDF <T,MAS>	MAS,	   masintp, INT gvinst,	    MAS_NOTES,	MAS_LVL,0,	< Galileo MasAbort >
dispatch.c                               Atari Games Corp. macpp v9.12   "Oct 16 1997 13:26:41"


  210+          VDF <T,TAR>	TAR,	   tarintp, INT gvinst,	    TAR_NOTES,	TAR_LVL,0,	< Galileo TarAbort >
  211+          VDF <T,RTY>	RTY,	   rtyintp, INT gvinst,	    RTY_NOTES,	RTY_LVL,0,	< Galileo RetryCtr >
  212+          VDF <T,PC0>	PC0,	   pc0intp, INT gvinst,	    PC0_NOTES,	PC0_LVL,0,	< Galileo PCI Interrupt >
  213+          VDF <T,PC1>	PC1,	   pc1intp, INT gvinst,	    PC1_NOTES,	PC1_LVL,0,	< Galileo PCI Interrupt >
  214+          VDF <T,PC2>	PC2,	   pc2intp, INT gvinst,	    PC2_NOTES,	PC2_LVL,0,	< Galileo PCI Interrupt >
  215+          VDF <T,PC3>	PC3,	   pc3intp, INT gvinst,	    PC3_NOTES,	PC3_LVL,0,	< Galileo PCI Interrupt >
  216+          VDF <D,UART_LVL> UART,	   uartintp,INT ioainst,    UART_NOTES,	UART_LVL,0,	< I/O ASIC UART interrupts >
  217+          VDF <D,SND_LVL>	SND,	   sndintp, INT ioainst,    SND_NOTES,	SND_LVL, 0,	< I/O ASIC Sound interrupts >
  218+          VDF <D,MC_LVL>	MC,	   mcintp,  INT ioainst,    MC_NOTES,	MC_LVL,	0,	< I/O ASIC Microcontroller interrupt >
  219+          ;
  220+   (1)    .endc			; (_DISPATCH_MAC_&1) != 0 *** DON'T MOVE THIS LINE EITHER ***
  221+          ;
  222+          ;+++++++ From here on, there are few user servicable parts inside. ++++
  223+          ;
  224+          ; This is sortof how it works:
  225+          ; The first pass through, _DISPATCH_MAC_ will be 0 (set above by the .if not_defined).
  226+          ; First the copyright boilerplate is inserted into both output files and the macro VDF
  227+          ; is defined to create externs. Some struct definitions and unique externs are depositied
  228+          ; into the .h file. Next _DISPATCH_MAC_ is set to 1 and this file is .included
  229+          ; again. This will cause MACPP to read the VDF table above and output the appropriate
  230+          ; information in the .h file but ignore the rest of the file. The VDF macro is redefined,
  231+          ; and the procedure is repeated causing the creation of different items according to what
  232+          ; is needed. Once the whole .h file is built, the procedure repeats for the building of the
  233+          ; .c file.
  234+          ;
  235+   (1)    .if true, _DISPATCH_MAC_ == 0		; First (main) pass
  236+    X      PHX == 0
  237+    X      PAD == 0
  238+    X      FLG == 0
  239+    X      SEA == 0
  240+    X      VEG == 0
  241+    X      .iif true, HOST_BOARD == PHOENIX, PHX == 1 ;set the appropriate ones true as desired
  242+    X      .iif true, HOST_BOARD == PHOENIX_AD, PAD == 1 ;set the appropriate ones true as desired
  243+    X      .iif true, HOST_BOARD == FLAGSTAFF, FLG == 1 ;set the appropriate ones true as desired
  244+    X      .iif true, HOST_BOARD == SEATTLE, SEA == 1 ;set the appropriate ones true as desired
  245+    X      .iif true, HOST_BOARD == VEGAS, VEG == 1 ;set the appropriate ones true as desired
  246+          ;
  247+    X     	.macro .condit flag,exp		; The .condit macro does an expression test ...
  248+    X     	.if identical,<flag>,<T>
  249+    X     		.iif false,exp,.mexit 10 ; ... and aborts higher level macros if false
  250+    X     		.mexit
  251+    X     	.endc
  252+    X     	.if identical,<flag>,<F>
  253+    X     		.iif true,exp,.mexit 10	; ... etc.
  254+    X     		.mexit
  255+    X     	.endc
  256+    X     	.if identical,<flag>,<D>
  257+    X     		.iif not_defined,exp,.mexit 10
  258+    X     		.mexit
  259+    X     	.endc
  260+    X     	.if identical,<flag>,<N>
  261+    X     		.iif defined,exp,.mexit 10
  262+    X     		.mexit
  263+    X     	.endc
  264+    X     	.endm
  265+          ;	
  266+    X     	.macro boilerplate file_name
dispatch.c                               Atari Games Corp. macpp v9.12   "Oct 16 1997 13:26:41"


  267+    X     /*		file_name
  268+    X      *
  269+    X      *		Copyright 1996 Atari Games Corporation
  270+    X      *	Unauthorized reproduction, adaptation, distribution, performance or 
  271+    X      *	display of this computer program or the associated audiovisual work
  272+    X      *	is strictly prohibited.
  273+    X      *
  274+    X      * ++++++ WARNING WARNING WARNING WARNING WARNING +++++
  275+    X      * This file is machine generated. Any changes you put in here will be lost
  276+    X      * the next time phx_vecs.mac is touched. You need to make your changes to
  277+    X      * phx_vecs.mac instead of this file.
  278+    X      */
  279+    X     	.endm
  280+    X     	boilerplate dispatch.c
  281+    X     	.outfile	1		;The externs go into the .h file
  282+    X     	boilerplate intvecs.h
  283+    X     #if !defined(_INTVECS_H_)
  284+    X     #define _INTVECS_H_
  285+          
  286+    X     struct irq_tab {
  287+    X     	void 	(**softvec)();
  288+    X     	void    (*(*installer)(const struct irq_tab *, void(*new)()))();
  289+    X     	int	notes;
  290+    X     };
  291+          ;
  292+    X     	.macro VDF cond, name, softvec, intern, installer, notes, physical, default, comments
  293+    X     	.condit cond	
  294+    X      .if dif,<softvec>,<0>
  295+    X       ...1 == 0
  296+    X       .iif idn,<intern>,<VINT>,...1 == 1
  297+    X       .iif idn,<intern>,<VEXT>,...1 == 1
  298+    X       .if true, ...1
  299+    X     extern	void (* volatile softvec)();	/* comments */
  300+    X       .iff
  301+    X     extern  void (*softvec)();	/* comments */
  302+    X       .endc
  303+    X      .endc
  304+    X     	.endm
  305+          ;
  306+    X     	_DISPATCH_MAC_ == 1		;next time we process the IRQ table
  307+    X     	.include phx_vecs.mac		;Make the externs
  308+          
  309+    X     enum vecs {
  310+    X     	.macro VDF cond, name, softvec, intern, installer, notes, physical, default, comments
  311+    X     	.condit cond	
  312+    X         name'_INTVEC,
  313+    X     	.endm
  314+    X     	.include phx_vecs.mac		;Make the enums
  315+    X         N_INTVECS
  316+    X     };
  317+          
  318+    X     void (*prc_set_vec (unsigned int vecnum, void (*routine)() ))();
  319+    X     void prc_init_vecs(void);		/* set the default vectors */
  320+          ;
  321+          ; Add a prototype for an as yet unused function
  322+    X     .if true, 0
  323+          
dispatch.c                               Atari Games Corp. macpp v9.12   "Oct 16 1997 13:26:41"


  324+    X     /*		prc_set_vecp(which, what)
  325+    X      *	Sets a special vector for the interrupt identified by <which>
  326+    X      *	to call the routine specified by <what>. <what> is
  327+    X      *	a struct that contains both a pointer to the code
  328+    X      *	to execute and an optional pointer to the private
  329+    X      *	variables for that routine. This is a change from the
  330+    X      *	behavior of prc_set_vec, and is intended to allow
  331+    X      *	multiple incarnations of a given device to share code.
  332+    X      */
  333+          
  334+    X     struct opaque;
  335+    X     extern struct VECP_vector {
  336+    X         void (*function)(struct opaque *);	/* Who you gonna call */
  337+    X         struct opaque *cookie;		/* a magic cookie to hand him */
  338+    X     } prc_set_vecp (
  339+    X         int __which,			/* one of xxx_INTVEC */
  340+    X         struct IRQ_vector __what		/* BY VALUE!!! */
  341+    X     );
  342+    X     .endc
  343+    X     #endif		/* _INTVECS_H_ */
  344+          ;
  345+          ; At this point, we have completed all processing of the .h file
  346+          ; so switch back to the .c file
  347+          ;
  348+    X     	.outfile	0		;switch back to dispatch.c
  349+          ;
  350+    X     #include <config.h>			/* begining of dispatch.c */
  351+    X     #include <os_proto.h>
  352+    X     #include <intvecs.h>
  353+          
  354+    X     #ifndef BLABF
  355+    X     # define BLABF(x)
  356+    X     #endif
  357+          
  358+    X     #ifndef BLAB
  359+    X     # define BLAB(x)
  360+    X     #endif
  361+          
  362+    X      .if true, 1
  363+    X     	.macro VDF cond, name, softvec, intern, installer, notes, physical, default, comments
  364+    X     	.condit cond	
  365+    X       .iif idn,<name>,<XBUS0>,.mexit
  366+    X       .iif idn,<name>,<XBUS1>,.mexit
  367+    X       .iif idn,<name>,<XBUS2>,.mexit
  368+    X       .iif idn,<name>,<XBUS3>,.mexit
  369+    X       .iif idn,<name>,<INT0>,.mexit
  370+    X       .iif idn,<name>,<INT1>,.mexit
  371+    X       .iif idn,<name>,<INT2>,.mexit
  372+    X       .iif idn,<name>,<INT3>,.mexit
  373+    X       .iif idn,<name>,<INT4>,.mexit
  374+    X       .iif idn,<name>,<INT5>,.mexit
  375+    X       .if true, PHX
  376+    X         .if true, physical == XBUS0_LVL
  377+    X     	  ...XBUS0 == ...XBUS0 + 1
  378+    X     	  .mexit
  379+    X         .endc
  380+    X         .if true, physical == XBUS1_LVL
dispatch.c                               Atari Games Corp. macpp v9.12   "Oct 16 1997 13:26:41"


  381+    X     	  ...XBUS1 == ...XBUS1 + 1
  382+    X     	  .mexit
  383+    X         .endc
  384+    X         .if true, physical == XBUS2_LVL
  385+    X     	  ...XBUS2 == ...XBUS2 + 1
  386+    X     	  .mexit
  387+    X         .endc
  388+    X         .if true, physical == XBUS3_LVL
  389+    X     	  ...XBUS3 == ...XBUS3 + 1
  390+    X     	  .mexit
  391+    X         .endc
  392+    X       .endc
  393+    X       .if true, physical == INT0_LVL
  394+    X         	...INT0 == ...INT0 + 1
  395+    X     	.mexit
  396+    X       .endc
  397+    X       .if true, physical == INT1_LVL
  398+    X         	...INT1 == ...INT1 + 1
  399+    X        .if true, PAD || FLG || SEA || VEG
  400+    X     	...IOA == ...IOA + 1
  401+    X         .if ndf, notes
  402+    X     #define notes IO_MAIN_GLOBAL_INT
  403+    X         .endc
  404+    X        .endc
  405+    X     	.mexit
  406+    X       .endc
  407+    X       .if true, physical == INT2_LVL
  408+    X         	...INT2 == ...INT2 + 1
  409+    X     	.mexit
  410+    X       .endc
  411+    X       .if true, physical == INT3_LVL
  412+    X         	...INT3 == ...INT3 + 1
  413+    X     	.mexit
  414+    X       .endc
  415+    X       .if true, physical == INT4_LVL
  416+    X         	...INT4 == ...INT4 + 1
  417+    X     	.mexit
  418+    X       .endc
  419+    X       .if true, physical == INT5_LVL
  420+    X         	...INT5 == ...INT5 + 1
  421+    X     	.mexit
  422+    X       .endc
  423+    X       .if true, physical == IOASIC_LVL
  424+    X         	...IOA == ...IOA + 1
  425+    X        .if ndf, notes
  426+    X     #define notes IO_MAIN_GLOBAL_INT
  427+    X        .endc
  428+    X     	.mexit
  429+    X       .endc
  430+    X     	.endm
  431+    X     ...XBUS0 == 0
  432+    X     ...XBUS1 == 0
  433+    X     ...XBUS2 == 0
  434+    X     ...XBUS3 == 0
  435+    X     ...INT0 == 0
  436+    X     ...INT1 == 0
  437+    X     ...INT2 == 0
dispatch.c                               Atari Games Corp. macpp v9.12   "Oct 16 1997 13:26:41"


  438+    X     ...INT3 == 0
  439+    X     ...INT4 == 0
  440+    X     ...INT5 == 0
  441+    X     ...IOA == 0
  442+    X     	.include phx_vecs.mac	; count vectors requiring dispatch
  443+    X      .endc
  444+          ; 
  445+    X     .macro VDF cond, name, softvec, intern, installer, notes, physical, default, comments
  446+    X      .condit cond	
  447+    X      .if dif,<softvec>,<0>
  448+    X       .if idn,<intern>,<INT>
  449+    X     void (*softvec)();	/* comments */
  450+    X       .endc
  451+    X       .if idn,<intern>,<VINT>
  452+    X     void (* volatile softvec)();	/* comments */
  453+    X       .endc
  454+    X      .endc
  455+    X      .if dif,<default>,<0>
  456+    X       .if idn,<name>,<INT0>
  457+    X        .if true, ...INT0
  458+    X     static void 'default'(void);	/* comments */
  459+    X        .endc
  460+    X        .mexit
  461+    X       .endc
  462+    X       .if idn,<name>,<INT1>
  463+    X        .if true, ...INT1
  464+    X     static void 'default'(void);	/* comments */
  465+    X        .endc
  466+    X        .mexit
  467+    X       .endc
  468+    X       .if idn,<name>,<INT2>
  469+    X        .if true, ...INT2
  470+    X     static void 'default'(void);	/* comments */
  471+    X        .endc
  472+    X        .mexit
  473+    X       .endc
  474+    X       .if idn,<name>,<INT3>
  475+    X        .if true, ...INT3
  476+    X     static void 'default'(void);	/* comments */
  477+    X        .endc
  478+    X        .mexit
  479+    X       .endc
  480+    X       .if idn,<name>,<INT4>
  481+    X        .if true, ...INT4
  482+    X     static void 'default'(void);	/* comments */
  483+    X        .endc
  484+    X        .mexit
  485+    X       .endc
  486+    X       .if idn,<name>,<INT5>
  487+    X        .if true, ...INT5
  488+    X     static void 'default'(void);	/* comments */
  489+    X        .endc
  490+    X        .mexit
  491+    X       .endc
  492+    X       .if idn,<name>,<INT6>
  493+    X        .if true, ...INT6
  494+    X     static void 'default'(void);	/* comments */
dispatch.c                               Atari Games Corp. macpp v9.12   "Oct 16 1997 13:26:41"


  495+    X        .endc
  496+    X        .mexit
  497+    X       .endc
  498+    X       .if idn,<name>,<INT7>
  499+    X        .if true, ...INT7
  500+    X     static void 'default'(void);	/* comments */
  501+    X        .endc
  502+    X        .mexit
  503+    X       .endc
  504+    X       .if true, PHX
  505+    X        .if idn,<name>,<XBUS>
  506+    X         .if true, ...XBUS0|...XBUS1|...XBUS2|...XBUS3
  507+    X     static void 'default'(void);
  508+    X         .endc
  509+    X         .mexit
  510+    X        .endc
  511+    X        .if idn,<name>,<XBUS0>
  512+    X         .if true, ...XBUS0
  513+    X     static void 'default'(void);
  514+    X         .endc
  515+    X         .mexit
  516+    X        .endc
  517+    X        .if idn,<name>,<XBUS1>
  518+    X         .if true, ...XBUS1
  519+    X     static void 'default'(void);
  520+    X         .endc
  521+    X         .mexit
  522+    X        .endc
  523+    X        .if idn,<name>,<XBUS2>
  524+    X         .if true, ...XBUS2
  525+    X     static void 'default'(void);
  526+    X         .endc
  527+    X         .mexit
  528+    X        .endc
  529+    X        .if idn,<name>,<XBUS3>
  530+    X         .if true, ...XBUS3
  531+    X     static void 'default'(void);
  532+    X         .endc
  533+    X         .mexit
  534+    X        .endc
  535+    X       .endc			; PHX
  536+    X       .if idn,<name>,<IOA>
  537+    X        .if true, ...IOA
  538+    X     static void 'default'(void);
  539+    X        .endc
  540+    X        .mexit
  541+    X       .endc
  542+    X     extern void 'default'(void);
  543+    X      .endc
  544+    X     .endm
  545+    X     	.include phx_vecs.mac		;Declare the non-extern vectors
  546+          ;
  547+    X      .if true, ((PROCESSOR&-16) == MIPS3000) || ((PROCESSOR&-16) == MIPS4000)
  548+    X     static void (*hwvinst(const struct irq_tab *, void (*)()))();
  549+    X      .endc
  550+          ;
  551+    X     .if df, PHOENIX_INTCTL_MASK
dispatch.c                               Atari Games Corp. macpp v9.12   "Oct 16 1997 13:26:41"


  552+    X     static void (*pvinst(const struct irq_tab *, void (*)()))();
  553+    X     .endc
  554+          ;
  555+    X     .if df, GALILEO_INTCTL_MASK
  556+    X     static void (*gvinst(const struct irq_tab *, void (*)()))();
  557+    X     .endc
  558+          ;
  559+    X     .if true, ...IOA
  560+    X     static void (*ioainst(const struct irq_tab *, void (*)()))();
  561+    X     .endc
  562+          ;
  563+    X     static const struct irq_tab irq_inits[] = {
  564+    X     	.macro VDF cond, name, softvec, intern, installer, notes, physical, default, comments
  565+    X     	.condit cond	
  566+    X      .if dif,<softvec>,<0>
  567+    X      { (void (**)())&softvec, installer, notes },	/* comments */
  568+    X      .iff
  569+    X      { 0, installer, notes },	/* comments */
  570+    X      .endc
  571+    X     	.endm
  572+    X     	.include phx_vecs.mac		;Build the irq_inits array
  573+    X      { 0, 0, 0} };
  574+          ;
  575+    X     .if true, ((PROCESSOR&-16) == MIPS3000) || ((PROCESSOR&-16) == MIPS4000)
  576+          
  577+    X     extern void (*ramv_tbl[])();
  578+          
  579+    X     static void (*hwvinst(const struct irq_tab *it, void (*new)()))() {
  580+    X         int indx;
  581+    X         void (*old_rtn)();
  582+          
  583+    X         indx = it->notes;
  584+    X         if (indx >= VN_MAX) return 0;
  585+    X         old_rtn = ramv_tbl[indx];
  586+    X         ramv_tbl[indx] = new;
  587+    X         return old_rtn;
  588+    X     }
  589+          
  590+    X      .if df, PHOENIX_INTCTL_MASK
  591+    X     static void (*pvinst(const struct irq_tab *it, void (*new)()))() {
  592+          
  593+    X         if (it->notes) {
  594+    X     	BLABF(("\ndispatch: Adding 0x%08lX to main INTCTL (0x%08lX)...", it->notes, *(VU32*)INTCTL_IE));
  595+    X     	*((VU32 *)(INTCTL_IE)) |= it->notes;
  596+    X         }
  597+    X         return 0;
  598+    X     }
  599+    X      .endc
  600+          
  601+    X      .if df, GALILEO_INTCTL_MASK
  602+    X     static void (*gvinst(const struct irq_tab *it, void (*new)()))() {
  603+          
  604+    X         if (it->notes) {
  605+    X     	BLABF(("\ndispatch: Adding 0x%08lX to Galileo INTCTL (0x%08lX)...", it->notes, \
  606+    X     			*(VU32*)GALILEO_CPU_I_ENA));
  607+    X     	*((VU32 *)(GALILEO_CPU_I_ENA)) |= it->notes;
  608+    X         }
dispatch.c                               Atari Games Corp. macpp v9.12   "Oct 16 1997 13:26:41"


  609+    X         return 0;
  610+    X     }
  611+    X      .endc
  612+          
  613+    X      .if true, ...IOA
  614+    X     static void (*ioainst(const struct irq_tab *it, void (*new)()))() {
  615+    X     extern void prc_wait_n_usecs( int );
  616+    X         if (it->notes)
  617+    X         {
  618+    X          BLABF(("\ndispatch: Adding 0x%04X to IOASIC INTCTL: (0x%04X)...", (int)it->notes, \
  619+    X     		*(VU32*)IO_MAIN_CTL&0xFFFF));
  620+    X          while ( ( *((VU32 *)IO_MAIN_CTL) & it->notes ) != it->notes )
  621+    X          {
  622+    X     #ifdef LED_OUT
  623+    X           *(VU32 *)LED_OUT = ~( 1 << B_LED_RED );
  624+    X     #endif
  625+    X           do
  626+    X           {
  627+    X            *((VU32 *)IO_MAIN_CTL) |= it->notes;
  628+    X            prc_wait_n_usecs( 1000 );
  629+    X           } while ( ( *((VU32 *)IO_MAIN_CTL) & it->notes ) != it->notes );
  630+    X           prc_wait_n_usecs( 1000 );
  631+    X     #ifdef LED_OUT
  632+    X           *(VU32 *)LED_OUT |= ( 1 << B_LED_RED );
  633+    X     #endif
  634+    X          }
  635+    X         }
  636+    X         return 0;
  637+    X     }
  638+    X      .endc
  639+    X     .endc
  640+          
  641+    X     void (*prc_set_vec (unsigned int vecnum, void (*routine)() ))()
  642+    X     {
  643+    X         void (*old_rtn)();
  644+    X         void (**softvec)();
  645+    X         const struct irq_tab *tbp;
  646+    X         int old_ipl;
  647+          
  648+    X         if ( vecnum >= N_INTVECS ) return 0;
  649+    X         tbp = irq_inits+vecnum;
  650+    X         softvec = tbp->softvec;
  651+    X         old_rtn = 0;
  652+    X         old_ipl = prc_set_ipl(INTS_OFF);
  653+    X         if ( tbp->installer ) old_rtn = tbp->installer(tbp, routine);
  654+    X         if ( softvec ) {
  655+    X     	if (!old_rtn) old_rtn = *softvec;
  656+    X     	*softvec = routine;
  657+    X         }
  658+    X         prc_set_ipl(old_ipl);
  659+    X         return old_rtn;
  660+    X     }
  661+          
  662+    X      .if true, PHX
  663+    X       .if true, ...XBUS0
  664+    X     static void xbus0_irq(void) {
  665+    X     	.macro VDF cond, name, softvec, intern, installer, notes, physical, default, comments
dispatch.c                               Atari Games Corp. macpp v9.12   "Oct 16 1997 13:26:41"


  666+    X     	.condit cond	
  667+    X       .iif idn,<name>,<XBUS0>,.mexit
  668+    X       .iif idn,<softvec>,<0>,.mexit
  669+    X       .if true, physical == XBUS0_LVL
  670+    X         if (softvec) softvec();
  671+    X       .endc
  672+    X     	.endm
  673+    X     	.include phx_vecs.mac		; pickup all vectors assigned to XBUS0_LVL
  674+    X         return;
  675+    X     }
  676+          
  677+    X       .endc		; ...XBUS0
  678+    X       .if true, ...XBUS1
  679+    X     static void xbus1_irq(void) {
  680+    X     	.macro VDF cond, name, softvec, intern, installer, notes, physical, default, comments
  681+    X     	.condit cond	
  682+    X       .iif idn,<name>,<XBUS1>,.mexit
  683+    X       .iif idn,<softvec>,<0>,.mexit
  684+    X       .if true, physical == XBUS1_LVL
  685+    X         if (softvec) softvec();
  686+    X       .endc
  687+    X     	.endm
  688+    X     	.include phx_vecs.mac		; pickup all vectors assigned to XBUS1_LVL
  689+    X         return;
  690+    X     }
  691+          
  692+    X       .endc		; ...XBUS1
  693+    X       .if true, ...XBUS2
  694+    X     static void xbus2_irq(void) {
  695+    X     	.macro VDF cond, name, softvec, intern, installer, notes, physical, default, comments
  696+    X     	.condit cond	
  697+    X       .iif idn,<name>,<XBUS2>,.mexit
  698+    X       .iif idn,<softvec>,<0>,.mexit
  699+    X       .if true, physical == XBUS2_LVL
  700+    X         if (softvec) softvec();
  701+    X       .endc
  702+    X     	.endm
  703+    X     	.include phx_vecs.mac		; pickup all vectors assigned to XBUS2_LVL
  704+    X         return;
  705+    X     }
  706+          
  707+    X       .endc		; ...XBUS2
  708+    X       .if true, ...XBUS3
  709+    X     static void xbus3_irq(void) {
  710+    X     	.macro VDF cond, name, softvec, intern, installer, notes, physical, default, comments
  711+    X     	.condit cond	
  712+    X       .iif idn,<name>,<XBUS3>,.mexit
  713+    X       .iif idn,<softvec>,<0>,.mexit
  714+    X       .if true, physical == XBUS3_LVL
  715+    X         if (softvec) softvec();
  716+    X       .endc
  717+    X     	.endm
  718+    X     	.include phx_vecs.mac		; pickup all vectors assigned to XBUS3_LVL
  719+    X         return;
  720+    X     }
  721+          
  722+    X       .endc		; ...XBUS3
dispatch.c                               Atari Games Corp. macpp v9.12   "Oct 16 1997 13:26:41"


  723+    X      .endc		; PHX
  724+    X      .if true, ...INT0
  725+    X     static void int0_irq(void) {
  726+    X     	.macro VDF cond, name, softvec, intern, installer, notes, physical, default, comments
  727+    X     	.condit cond	
  728+    X       .iif idn,<name>,<INT0>,.mexit
  729+    X       .iif idn,<softvec>,<0>,.mexit
  730+    X       .if true, physical == INT0_LVL
  731+    X         if (softvec) softvec();
  732+    X       .endc
  733+    X     	.endm
  734+    X     	.include phx_vecs.mac		; pickup all vectors assigned to IRQ 0
  735+    X         return;
  736+    X     }
  737+          
  738+    X      .endc		; ...INT0
  739+    X      .if true, ...INT1
  740+    X     static void int1_irq(void) {
  741+    X     	.macro VDF cond, name, softvec, intern, installer, notes, physical, default, comments
  742+    X     	.condit cond	
  743+    X       .iif idn,<name>,<INT1>,.mexit
  744+    X       .iif idn,<softvec>,<0>,.mexit
  745+    X       .if true, physical == INT1_LVL
  746+    X         if (softvec) softvec();
  747+    X       .endc
  748+    X     	.endm
  749+    X     	.include phx_vecs.mac		; pickup all vectors assigned to IRQ 1
  750+    X         return;
  751+    X     }
  752+          
  753+    X      .endc		; ...INT1
  754+    X      .if true, ...INT2
  755+    X     static void int2_irq(void) {
  756+    X     	.macro VDF cond, name, softvec, intern, installer, notes, physical, default, comments
  757+    X     	.condit cond	
  758+    X       .iif idn,<name>,<INT2>,.mexit
  759+    X       .iif idn,<softvec>,<0>,.mexit
  760+    X       .if true, physical == INT2_LVL
  761+    X         if (softvec) softvec();
  762+    X       .endc
  763+    X     	.endm
  764+    X     	.include phx_vecs.mac		; pickup all vectors assigned to IRQ 2
  765+    X         return;
  766+    X     }
  767+          
  768+    X      .endc		; ...INT2
  769+    X      .if true, ...INT3
  770+    X     static void int3_irq(void) {
  771+    X     	.macro VDF cond, name, softvec, intern, installer, notes, physical, default, comments
  772+    X     	.condit cond	
  773+    X       .iif idn,<name>,<INT3>,.mexit
  774+    X       .iif idn,<softvec>,<0>,.mexit
  775+    X       .if true, physical == INT3_LVL
  776+    X         if (softvec) softvec();
  777+    X       .endc
  778+    X     	.endm
  779+    X     	.include phx_vecs.mac		; pickup all vectors assigned to IRQ 3
dispatch.c                               Atari Games Corp. macpp v9.12   "Oct 16 1997 13:26:41"


  780+    X         return;
  781+    X     }
  782+          
  783+    X      .endc		; ...INT3
  784+    X      .if true, ...INT4
  785+    X     static void int4_irq(void) {
  786+    X     	.macro VDF cond, name, softvec, intern, installer, notes, physical, default, comments
  787+    X     	.condit cond	
  788+    X       .iif idn,<name>,<INT4>,.mexit
  789+    X       .iif idn,<softvec>,<0>,.mexit
  790+    X       .if true, physical == INT4_LVL
  791+    X         if (softvec) softvec();
  792+    X       .endc
  793+    X     	.endm
  794+    X     	.include phx_vecs.mac		; pickup all vectors assigned to IRQ 4
  795+    X         return;
  796+    X     }
  797+          
  798+    X      .endc		; ...INT4
  799+    X      .if true, ...INT5
  800+    X     static void int5_irq(void) {
  801+    X     	.macro VDF cond, name, softvec, intern, installer, notes, physical, default, comments
  802+    X     	.condit cond	
  803+    X       .iif idn,<name>,<INT5>,.mexit
  804+    X       .iif idn,<softvec>,<0>,.mexit
  805+    X       .if true, physical == INT5_LVL
  806+    X         if (softvec) softvec();
  807+    X       .endc
  808+    X     	.endm
  809+    X     	.include phx_vecs.mac		; pickup all vectors assigned to IRQ 5
  810+    X         return;
  811+    X     }
  812+          
  813+    X      .endc		; ...INT5
  814+    X      .if true, ...IOA && PHX
  815+    X     static void ioa_irq(void) {
  816+    X     	.macro VDF cond, name, softvec, intern, installer, notes, physical, default, comments
  817+    X     	.condit cond	
  818+    X       .iif idn,<name>,<IOA>,.mexit
  819+    X       .iif idn,<softvec>,<0>,.mexit
  820+    X       .if true, physical == IOASIC_LVL
  821+    X         if (softvec) softvec();
  822+    X       .endc
  823+    X     	.endm
  824+    X     	.include phx_vecs.mac		; pickup all vectors assigned to IRQ 5
  825+    X         return;
  826+    X     }
  827+          
  828+    X      .endc		; ...IOA
  829+    X      .if true, PHX
  830+    X       .if true, ...XBUS0|...XBUS1|...XBUS2|...XBUS3
  831+    X     static void xbus_irq(void) {
  832+    X         int which;
  833+    X         which = *(VU32 *)(XBUS_SLOT0+4);
  834+    X       .if true, ...XBUS0
  835+    X         if (!(which&1)) xbus0_irq();
  836+    X       .endc
dispatch.c                               Atari Games Corp. macpp v9.12   "Oct 16 1997 13:26:41"


  837+    X       .if true, ...XBUS1
  838+    X         if (!(which&2)) xbus1_irq();
  839+    X       .endc
  840+    X       .if true, ...XBUS2
  841+    X         if (!(which&4)) xbus2_irq();
  842+    X       .endc
  843+    X       .if true, ...XBUS3
  844+    X         if (!(which&8)) xbus3_irq();
  845+    X       .endc
  846+    X         return;
  847+    X     }
  848+    X       .endc
  849+    X      .endc		; PHX
  850+    X     void prc_init_vecs(void) {
  851+    X     	.macro VDF cond, name, softvec, intern, installer, notes, physical, default, comments
  852+    X     	.condit cond	
  853+    X     .if dif,<default>,<0>
  854+    X      .if true, PHX
  855+    X       .if idn,<name>,<XBUS0>
  856+    X        .iif true, ...XBUS0 == 0, .mexit
  857+    X       .endc
  858+    X       .if idn,<name>,<XBUS1>
  859+    X        .iif true, ...XBUS1 == 0, .mexit
  860+    X       .endc
  861+    X       .if idn,<name>,<XBUS2>
  862+    X        .iif true, ...XBUS2 == 0, .mexit
  863+    X       .endc
  864+    X       .if idn,<name>,<XBUS3>
  865+    X        .iif true, ...XBUS3 == 0, .mexit
  866+    X       .endc
  867+    X       .if idn,<name>,<XBUS>
  868+    X        .iif true, (...XBUS0|...XBUS1|...XBUS2|...XBUS3) == 0, .mexit
  869+    X       .endc
  870+    X      .endc	; PHX
  871+    X      .if idn,<name>,<INT0>
  872+    X       .iif true, ...INT0 == 0, .mexit
  873+    X      .endc
  874+    X      .if idn,<name>,<INT1>
  875+    X       .iif true, ...INT1 == 0, .mexit
  876+    X      .endc
  877+    X      .if idn,<name>,<INT2>
  878+    X       .iif true, ...INT2 == 0, .mexit
  879+    X      .endc
  880+    X      .if idn,<name>,<INT3>
  881+    X       .iif true, ...INT3 == 0, .mexit
  882+    X      .endc
  883+    X      .if idn,<name>,<INT4>
  884+    X       .iif true, ...INT4 == 0, .mexit
  885+    X      .endc
  886+    X      .if idn,<name>,<INT5>
  887+    X       .iif true, ...INT5 == 0, .mexit
  888+    X      .endc
  889+    X      .if idn,<name>,<IOA>
  890+    X       .iif true, ...IOA == 0, .mexit
  891+    X      .endc
  892+    X         prc_set_vec('name'_INTVEC, default);
  893+    X     .endc
dispatch.c                               Atari Games Corp. macpp v9.12   "Oct 16 1997 13:26:41"


  894+    X     	.endm
  895+    X     	.include phx_vecs.mac
  896+          
  897+    X     /* Map the Phoenix interrupts */
  898+          
  899+    X     .if df, INTCTL_MAPA_INIT
  900+    X         BLABF(("\ndispatch: Mapping the A interrupts: 0x%08lX...", INTCTL_MAPA_INIT));
  901+    X         *((VU32 *)(INTCTL_MAPA)) = INTCTL_MAPA_INIT;
  902+    X     .endc
  903+    X     .if df, INTCTL_MAPB_INIT
  904+    X         BLABF(("\ndispatch: Mapping the B interrupts: 0x%08lX...", INTCTL_MAPB_INIT));
  905+    X         *((VU32 *)(INTCTL_MAPB)) = INTCTL_MAPB_INIT;
  906+    X     .endc
  907+          
  908+    X     .if defined, ANNOUNCE_BOOT_ACTIONS
  909+    X      .if true, ANNOUNCE_BOOT_ACTIONS
  910+    X         {
  911+    X     	int jj;
  912+    X     	extern int prc_get_cause(void), prc_get_ipl(void);
  913+    X     	jj = prc_get_cause();
  914+    X     	if (jj&0xFF00) BLABF(("\ndispatch: CPU cause reg: %08lX, CPU SR reg: %08lX", jj, prc_get_ipl()));
  915+    X     	if (jj&0x0400) {
  916+    X       .if true, ...INT0
  917+    X     	.macro VDF cond, name, softvec, intern, installer, notes, physical, default, comments
  918+    X     	.condit cond	
  919+    X        .iif idn,<name>,<INT0>,.mexit
  920+    X        .iif idn,<softvec>,<0>,.mexit
  921+    X        .if true, physical == INT0_LVL
  922+    X     	    if (!softvec) BLAB("\ndispatch: Warning, IRQ 0 pending \"'comments'\"");
  923+    X        .endc
  924+    X     	.endm
  925+    X     	.include phx_vecs.mac		; pickup all vectors assigned to IRQ 0
  926+    X       .iff
  927+    X     	    BLAB("\ndispatch: Warning, IRQ 0 pending with no vector assigned");
  928+    X       .endc		; ...INT0
  929+    X     	}
  930+    X     	if (jj&0x0800) {
  931+    X       .if true, ...INT1
  932+    X     	.macro VDF cond, name, softvec, intern, installer, notes, physical, default, comments
  933+    X     	.condit cond	
  934+    X        .iif idn,<name>,<INT1>,.mexit
  935+    X        .iif idn,<softvec>,<0>,.mexit
  936+    X        .if true, physical == INT1_LVL
  937+    X     	    if (!softvec) BLAB("\ndispatch: Warning, IRQ 1 pending \"'comments'\"");
  938+    X        .endc
  939+    X     	.endm
  940+    X     	.include phx_vecs.mac		; pickup all vectors assigned to IRQ 1
  941+    X       .iff
  942+    X     	    BLAB("\ndispatch: Warning, IRQ 1 pending with no vector assigned");
  943+    X       .endc		; ...INT1
  944+    X     	}
  945+    X     	if (jj&0x1000) {
  946+    X       .if true, ...INT2
  947+    X     	.macro VDF cond, name, softvec, intern, installer, notes, physical, default, comments
  948+    X     	.condit cond	
  949+    X        .iif idn,<name>,<INT2>,.mexit
  950+    X        .iif idn,<softvec>,<0>,.mexit
dispatch.c                               Atari Games Corp. macpp v9.12   "Oct 16 1997 13:26:41"


  951+    X        .if true, physical == INT2_LVL
  952+    X     	    if (!softvec) BLAB("\ndispatch: Warning, IRQ 2 pending \"'comments'\"");
  953+    X        .endc
  954+    X     	.endm
  955+    X     	.include phx_vecs.mac		; pickup all vectors assigned to IRQ 2
  956+    X       .iff
  957+    X     	    BLAB("\ndispatch: Warning, IRQ 2 pending with no vector assigned");
  958+    X       .endc		; ...INT2
  959+    X     	}
  960+    X     	if (jj&0x2000) {
  961+    X       .if true, ...INT3
  962+    X     	.macro VDF cond, name, softvec, intern, installer, notes, physical, default, comments
  963+    X     	.condit cond	
  964+    X        .iif idn,<name>,<INT3>,.mexit
  965+    X        .iif idn,<softvec>,<0>,.mexit
  966+    X        .if true, physical == INT3_LVL
  967+    X     	    if (!softvec) BLAB("\ndispatch: Warning, IRQ 3 pending \"'comments'\"");
  968+    X        .endc
  969+    X     	.endm
  970+    X     	.include phx_vecs.mac		; pickup all vectors assigned to IRQ 3
  971+    X       .iff
  972+    X     	    BLAB("\ndispatch: Warning, IRQ 3 pending with no vector assigned");
  973+    X       .endc		; ...INT3
  974+    X     	}
  975+    X     	if (jj&0x4000) {
  976+    X       .if true, ...INT4
  977+    X     	.macro VDF cond, name, softvec, intern, installer, notes, physical, default, comments
  978+    X     	.condit cond	
  979+    X        .iif idn,<name>,<INT4>,.mexit
  980+    X        .iif idn,<softvec>,<0>,.mexit
  981+    X        .if true, physical == INT4_LVL
  982+    X     	    if (!softvec) BLAB("\ndispatch: Warning, IRQ 4 pending \"'comments'\"");
  983+    X        .endc
  984+    X     	.endm
  985+    X     	.include phx_vecs.mac		; pickup all vectors assigned to IRQ 4
  986+    X       .iff
  987+    X     	    BLAB("\ndispatch: Warning, IRQ 4 pending with no vector assigned");
  988+    X       .endc		; ...INT4
  989+    X     	}
  990+    X     	if (jj&0x8000) {
  991+    X       .if true, ...INT5
  992+    X     	.macro VDF cond, name, softvec, intern, installer, notes, physical, default, comments
  993+    X     	.condit cond	
  994+    X        .iif idn,<name>,<INT5>,.mexit
  995+    X        .iif idn,<softvec>,<0>,.mexit
  996+    X        .if true, physical == INT5_LVL
  997+    X     	    if (!softvec) BLAB("\ndispatch: Warning, IRQ 5 pending \"'comments'\"");
  998+    X        .endc
  999+    X     	.endm
 1000+    X     	.include phx_vecs.mac		; pickup all vectors assigned to IRQ 5
 1001+    X       .iff
 1002+    X     	    BLAB("\ndispatch: Warning, IRQ 5 pending with no vector assigned");
 1003+    X       .endc		; ...INT5
 1004+    X     	}
 1005+    X         }
 1006+    X      .endc		; true, ANNOUNCE_BOOT_ACTIONS
 1007+    X     .endc		; defined, ANNOUNCE_BOOT_ACTIONS
dispatch.c                               Atari Games Corp. macpp v9.12   "Oct 16 1997 13:26:41"


 1008+    X         return;
 1009+    X     }
 1010+   (1)    .endc		; _DISPATCH_MAC_ == 0
  308           
  309           enum vecs {
  310           	.macro VDF cond, name, softvec, intern, installer, notes, physical, default, comments
  311           	.condit cond	
  312               name'_INTVEC,
  313           	.endm
  314           	.include phx_vecs.mac		;Make the enums
    1+          ;/*		phx_vecs.mac
    2+          ; *
    3+          ; *		Copyright 1996 Atari Games Corporation
    4+          ; *	Unauthorized reproduction, adaptation, distribution, performance or 
    5+          ; *	display of this computer program or the associated audiovisual work
    6+          ; *	is strictly prohibited.
    7+          ; *
    8+          ; *	This file is processed by MACPP to produce dispatch.c and intvecs.h.
    9+          ; *
   10+          ; *	The definitions placed in intvecs.h declare virtual vector numbers
   11+          ; *	in the form of xxx_INTVEC and a cross reference table(s) so the
   12+          ; *	dispatcher can call the appropriate functions.
   13+          ; *
   14+          ; *	intvecs.h should be #include'd by any module that uses prc_set_vec().
   15+          ; */
   16+          ;
   17+          ; This file recursivley '.includes' itself to succesively build up the approprate
   18+          ; tables and functions in C and places the results in one of two files (the
   19+          ; first -out=file supplied on the MACPP command line is expected to be dispatch.c
   20+          ; and the second -out=file is expected to be intvecs.h and the third is expected to
   21+          ; be /dev/null). If you don't speak fluent MACPP, then you probably shouldn't be
   22+          ; changing anything in this file other than the VDF table listed below.
   23+          ;
   24+   (1)    .if not_defined, _DISPATCH_MAC_		;1 +++++
   25+    X     _DISPATCH_MAC_ == 0			;2 Don't move ...
   26+    X     OUTPUT_LANG == 5 ;LANG_NONE		;3 ... or change ... 
   27+    X     	.outfile 2			;4 ... anything on ...
   28+    X     	.include config.mac		;5 ... these ...
   29+    X     	.outfile 0			;6 ... nine  ...
   30+   (1)    .endc					;7 ... lines ...
   31+   (1)    .if true, (_DISPATCH_MAC_&1) != 0	;8
   32+   (2)     .if true, 0				;9 -----
   33+          
   34+    X     You are free to add or remove entries from this table according to your
   35+    X     requirements. There are 10 fields used on each line in this table. The
   36+    X     description of each field follows:
   37+          
   38+    X     Field 1 = macro call
   39+          
   40+    X     It must always be the keyword VDF (case is not significant).
   41+          
   42+    X     Field 2 = condition
   43+          
   44+    X     This is a dual operand field, so the two operands together must be enclosed in
   45+    X     <>'s. The first operand is one of T, F, D or N representing True, False,
   46+    X     Defined or Not_defined respectively. Case is significant, use uppercase only
   47+    X     please. For the conditions T or F the second operand must be an expression
dispatch.c                               Atari Games Corp. macpp v9.12   "Oct 16 1997 13:26:41"


   48+    X     which must resolve to non-$0 (True) or $0 (False) in order for the macro
   49+    X     to be processed (else it is ignored). The expression can contain no embedded
   50+    X     spaces. For the conditions D and N, the second operand must only be a symbol
   51+    X     which must be Defined or Not-defined respectively in order for the macro to be
   52+    X     processed. Some short cut expressions have been preprocessed to make using the
   53+    X     expressions a little more concise. These are:
   54+          
   55+    X     	PHX = not $0 if HOST_BOARD == PHOENIX
   56+    X     	PAD = not $0 if HOST_BOARD == PHOENIX_AD
   57+    X     	FLG = not $0 if HOST_BOARD == FLAGSTAFF
   58+    X     	SEA = not $0 if HOST_BOARD == SEATTLE
   59+    X     	VEG = not $0 if HOST_BOARD == VEGAS
   60+          
   61+    X     Field 3 = vector name
   62+          
   63+    X     The NAME field is the name of the virtual vector. An _INTVEC will be appended
   64+    X     to it in the C definitions in intvecs.h, but otherwise the name is unmolested.
   65+    X     Case is significant only if you want it to be. The R3K/R4K has an option where
   66+    X     a number of vectors are maintained in an array of pointers rather than each
   67+    X     one having its own name. The index into the array is same as the number
   68+    X     returned in the processor's CAUSE register for that particluar interrupt. This
   69+    X     procedure is done simply for performance reasons. The option is selected by
   70+    X     using a 0 for this field and using an installer function with the vector index
   71+    X     as the parameter to the installer.
   72+          
   73+    X     Field 4 = Vector pointer
   74+          
   75+    X     This field identifies the name of a variable in BSS that contains a pointer
   76+    X     to the function to call at interrupt (or will be set by the prc_set_vec()
   77+    X     function). This is the name of the "soft" or logical vector and is either
   78+    X     declared in dispatch.c or externally according to the INT/EXT field described
   79+    X     next.
   80+          
   81+    X     Field 5 = INTernal or EXTernal vector
   82+          
   83+    X     This field contains the keywords INT, EXT, VINT or VEXT identifying the vector
   84+    X     in field 4 as being defined INTernally, EXTernally, Volatile INTernally or
   85+    X     Volatile Externally to dispatch.c respectively.
   86+          
   87+    X     Field 6 = name of vector installer
   88+          
   89+    X     This field identifies the name of a function that prc_set_vec() will call to
   90+    X     actually install the vector or 0 if there is no special stuff that needs to
   91+    X     be performed during vector installation.
   92+          
   93+    X     Field 7 = Notes for the installer.
   94+          
   95+    X     The Notes field is a parameter that is passed to the installer if there is one.
   96+          
   97+    X     Field 8 = Physical vector attachment.
   98+          
   99+    X     A dispatch routine is constructed for each of the 4 XBUS interrupts and for each of
  100+    X     the 6 CPU interrupts.  This field instructs phx_vecs.mac into which of the XBUS or
  101+    X     INTx dispatchers a caller to this vector belongs.  If this vector is not associated
  102+    X     with an XBUS or an INTx interrupt, it needs to be -1.  Place the interrupt routines
  103+    X     in this table in the order in which you want them executed.
  104+          
dispatch.c                               Atari Games Corp. macpp v9.12   "Oct 16 1997 13:26:41"


  105+    X     Field 9 = Default function.
  106+          
  107+    X     Name of default routine to install in the vector, or 0 if none.  phx_vecs.mac builds
  108+    X     a function called prc_init_vecs(void) which, when called, will perform a string of
  109+    X     prc_set_vec()'s for all the vectors having this field non-zero.  After the vectors
  110+    X     have been loaded, prc_init_vecs(void) will map the phoenix and galileo interrupts as
  111+    X     specified in phoenix.mac.
  112+          
  113+    X     Field 10 = Comments.
  114+          
  115+    X     The Comments field is placed on selected lines in intvecs.h and/or dispatch.c
  116+    X     as simple 'C' comments.
  117+          
  118+   (2)     .endc				; Don't move this line
  119+          ;
  120+          ;   Condit	Name	   Vector   I/E	Installer   Notes      Phys	Default	Comments
  121+          ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  122+          VDF <T,1>	GAMEVB,	   gameint, EXT	0,          0,		-1,	0,	< post-wierdness Vblank >
  123+          VDF <T,1>	MS4,       ms4vec,  EXT	0,          0,		-1,	0,	< 4 Millisecond timer >
  124+          VDF <T,1>	PRC_DELAY, prc_delay_vec, EXT 0,    0,		-1,	sst_prc_delay, < prc_delay soft vector >
  125+          VDF <T,1>	PRC_SET_IPL, set_ipl_vec, INT 0,    0,		-1,	0,	< prc_set_ipl soft vector >
  126+          VDF <T,1>	SAVE,      savintp, EXT 0,          0,		-1,	0,	< context save soft vector >
  127+          VDF <T,1>	RESTORE,   restintp,EXT 0,          0,		-1,	0,	< context restore soft vector >
  128+          VDF <T,1>	SW0,	   0,	    INT hwvinst,    VN_IRQ0,    -1,	0,	< Software interrupt 0 >
  129+          VDF <T,1>	SW1,	   0,       INT hwvinst,    VN_IRQ1,    -1,	0,	< Software interrupt 0 >
  130+          VDF <T,1>	INT0,	   0,       INT hwvinst,    VN_IRQ2,    -1,	int0_irq, < Hardware interrupt 0 >
  131+          VDF <T,1>	INT1,	   0,	    INT hwvinst,    VN_IRQ3,    -1,	int1_irq, < Hardware interrupt 1 >
  132+          VDF <T,PHX>	INT2,	   0,	    INT hwvinst,    VN_IRQ4,    -1,	int2_irq, < Hardware interrupt 2 >
  133+          VDF <T,1>	INT3,	   0,       INT hwvinst,    VN_IRQ5,    -1,	int3_irq, < Hardware interrupt 3 >
  134+          VDF <T,1>	INT4,	   0,	    INT hwvinst,    VN_IRQ6,    -1,	int4_irq, < Hardware interrupt 4 >
  135+          VDF <T,1>	INT5,	   0,	    INT hwvinst,    VN_IRQ7,    -1,	int5_irq, < Hardware interrupt 5 >
  136+          VDF <T,1>	TLBMOD,	   0,	    INT hwvinst,    VN_TLBM,    -1,	0,	< TLB modification >
  137+          VDF <T,1>	TLBLOAD,   0,	    INT hwvinst,    VN_TLBL,    -1,	0,	< TLB miss on I or D fetch >
  138+          VDF <T,1>	TLBSTORE,  0,	    INT hwvinst,    VN_TLBS,    -1,	0,	< TLB miss on store >
  139+          VDF <T,1>	ADDRERRL,  0,	    INT hwvinst,    VN_ADDRL,   -1,	0,	< Address error on I or D fetch >
  140+          VDF <T,1>	ADDRERRS,  0,	    INT hwvinst,    VN_ADDRS,   -1,	0,	< Address error on store >
  141+          VDF <T,1>	BUSERRI,   0,	    INT hwvinst,    VN_BUSERRI, -1,	0,	< Bus error on I-fetch >
  142+          VDF <T,1>	BUSERRD,   0,	    INT hwvinst,    VN_BUSERRD, -1,	0,	< Bus error on D-fetch >
  143+          VDF <T,1>	SYSCALL,   0,       INT hwvinst,    VN_SYSCALL, -1,	0,	< SYSCALL instruction >
  144+          VDF <T,1>	BREAK,     0,       INT hwvinst,    VN_BREAK,   -1,	0,	< Breakpoint instruction >
  145+          VDF <T,1>	RESERV,    0,       INT hwvinst,    VN_RESERV,  -1,	0,	< Reserved instruction >
  146+          VDF <T,1>	COPROC,    0,       INT hwvinst,    VN_COPROC,  -1,	0,	< Coprocessor unusable >
  147+          VDF <T,1>	OVRFLOW,   0,       INT hwvinst,    VN_OVERFL,  -1,	0,	< Integer Arithmetic Overflow >
  148+          VDF <T,1>	TRAP,      0,       INT hwvinst,    VN_TRAPV,   -1,	0,	< TRAP exception >
  149+          VDF <T,1>	FLOAT,     0,       INT hwvinst,    VN_FPE,     -1,	0,	< FLoating point exception >
  150+          VDF <T,1>	TIMER,	   timervec, INT 0,	    0,          -1,	0,	< Soft Timer interrupt >
  151+          VDF <T,1>	TIMERPLL,  tpllvec, VEXT 0,	    0,		-1,	0,	<Adjust 1MS timer>
  152+          VDF <T,1>	GAMEFRAME, framevec,INT 0,	    0,		-1,	0,	< Frame complete >
  153+   (2)    .if true, PHX
  154+    X     VDF <D,NET_LVL>	NET,       netintp, INT 0,          0,		NET_LVL,0,	< network int soft vector >
  155+    X     VDF <D,XBUS>	XBUS,	   xbusintp, INT pvinst,    XBUS_NOTES,	XBUS_LVL,xbus_irq, < Any XBUS interrupt >
  156+    X     VDF <T,XS0>	XS0,       xs0intp, INT pvinst,	    XS0_NOTES,	XS0_LVL,0,	< Expansion Slot 0 interrupt >
  157+    X     VDF <T,XS1>	XS1,       xs1intp, INT pvinst,	    XS1_NOTES,	XS1_LVL,0,	< Expansion Slot 1 interrupt >
  158+    X     VDF <T,XS2>	XS2,       xs2intp, INT pvinst,	    XS2_NOTES,	XS2_LVL,0,	< Expansion Slot 2 interrupt >
  159+    X     VDF <T,XS3>	XS3,       xs3intp, INT pvinst,	    XS3_NOTES,	XS3_LVL,0,	< Expansion Slot 3 interrupt >
  160+    X     VDF <T,MIO>	MIO,       miointp, INT pvinst,	    MIO_NOTES,	MIO_LVL,0,	< Miscellaneous I/O interrupt >
  161+    X     VDF <T,CU1>	CU1,       cu1intp, INT pvinst,	    CU1_NOTES,	CU1_LVL,0,	< Combo UART 1 interrupt >
dispatch.c                               Atari Games Corp. macpp v9.12   "Oct 16 1997 13:26:41"


  162+    X     VDF <T,CU2>	CU2,       cu2intp, INT pvinst,	    CU2_NOTES,	CU2_LVL,0,	< Combo UART 2 interrupt >
  163+    X     VDF <T,CPP>	CPP,       cppintp, INT pvinst,	    CPP_NOTES,	CPP_LVL,0,	< Combo Parallel Port interrupt >
  164+    X     VDF <T,PCA>	PCA,       pcaintp, INT pvinst,	    PCA_NOTES,	PCA_LVL,0,	< PCI A interrupt >
  165+    X     VDF <T,PCB>	PCB,       pcbintp, INT pvinst,	    PCB_NOTES,	PCB_LVL,0,	< PCI B interrupt >
  166+    X     VDF <T,PCC>	PCC,       pccintp, INT pvinst,	    PCC_NOTES,	PCC_LVL,0,	< PCI C interrupt >
  167+    X     VDF <T,VSY>	VSY,       vsyintp, INT pvinst,	    VSY_NOTES,	VSY_LVL,0,	< PCI D (VSYNC) interrupt >
  168+    X     VDF <T,IDE>	IDE,	   ideintp, INT pvinst,	    IDE_NOTES,	IDE_LVL,0,	< IDE interrupt >
  169+    X     VDF <T,IOA>	IOA,	   ioaintp, INT pvinst,	    IOA_NOTES,	IOA_LVL,ioa_irq,< I/O Asic interrupt >
  170+    X     VDF <T,ADC>	ADC,	   adcintp, INT pvinst,	    ADC_NOTES,	ADC_LVL,0,	< A/D Converter interrupt >
  171+    X     VDF <D,SND_I>	CAGE,      cagevec, INT 0,          0,		CAGE_LVL,aud_irq, < CAGE interrupt >
  172+   (2)    .endc
  173+   (2)    .if true, PAD || FLG || SEA || VEG
  174+          ;VDF <T,1>	IOA,	   0,	    INT hwvinst,    VN_IRQ3,	-1,	0,	< I/O Asic interrupt >
  175+          VDF <T,1>	IDE,	   0,	    INT hwvinst,    VN_IRQ4,    -1,	0,	< IDE interrupt >
  176+          VDF <T,EXP>	EXP,       expintp, INT pvinst,	    EXP_NOTES,	EXP_LVL,0,	< Expansion Slot interrupt >
  177+   (3)     .if true, PAD || SEA
  178+          VDF <T,NSS>	NSS,	   nssintp, INT pvinst,	    NSS_NOTES,  NSS_LVL,0,	< NSS/Hi-Link interrupt>
  179+   (3)     .endc
  180+   (3)     .if true, FLG
  181+    X     VDF <T,ETH>	ETH,	   ethintp, INT pvinst,     ETH_NOTES,  ETH_LVL,0,	< ethernet interrupt >
  182+    X     VDF <D,SND_I>	CAGE,	   cagevec, INT ioainst,    CAGE_NOTES, CAGE_LVL,aud_irq, < CAGE interrupt >
  183+   (3)     .endc
  184+          VDF <T,WD1>	WD1,	   wd1intp, INT pvinst,	    WD1_NOTES,  WD1_LVL,0,	< Widget interrupt 1>
  185+          VDF <T,PCI>	PCI,       pciintp, INT pvinst,	    PCI_NOTES,	PCI_LVL,0,	< PCI interrupt >
  186+          VDF <T,ADC>	ADC,	   adcintp, INT pvinst,	    ADC_NOTES,	ADC_LVL,0,	< A/D Converter interrupt >
  187+          VDF <T,WD2>	WD2,	   wd2intp, INT pvinst,	    WD2_NOTES,  WD2_LVL,0,	< Widget interrupt 2>
  188+          VDF <T,DBG>	DBG,	   dbgintp, INT pvinst,	    DBG_NOTES,	DBG_LVL,0,	< Debug switch interrupt >
  189+          VDF <T,VSY>	VSY,	   vsyintp, INT pvinst,	    VSY_NOTES,	VSY_LVL,0,	< VSYNC interrupt >
  190+   (2)    .endc
  191+          VDF <T,GAL>	GAL,	   0,       INT gvinst,	    GAL_NOTES,  GAL_LVL,galileoint, < Any Galileo Error Interrupt >
  192+          VDF <T,MOE>	MOE,	   moeintp, INT gvinst,	    MOE_NOTES,	MOE_LVL,0,	< Galileo MemOut >
  193+          VDF <T,DOE>	DOE,	   doeintp, INT gvinst,	    DOE_NOTES,	DOE_LVL,0,	< Galileo DMAOut >
  194+          VDF <T,COE>	COE,	   coeintp, INT gvinst,	    COE_NOTES,	COE_LVL,0,	< Galileo CPUOut >
  195+          VDF <T,DM0>	DM0,	   dm0intp, INT gvinst,	    DM0_NOTES,	DM0_LVL,0,	< Galileo DMA0Comp >
  196+          VDF <T,DM1>	DM1,	   dm1intp, INT gvinst,	    DM1_NOTES,	DM1_LVL,0,	< Galileo DMA1Comp >
  197+          VDF <T,DM2>	DM2,	   dm2intp, INT gvinst,	    DM2_NOTES,	DM2_LVL,0,	< Galileo DMA2Comp >
  198+          VDF <T,DM3>	DM3,	   dm3intp, INT gvinst,	    DM3_NOTES,	DM3_LVL,0,	< Galileo DMA3Comp >
  199+          VDF <T,TM0>	TM0,	   tm0intp, INT gvinst,	    TM0_NOTES,	TM0_LVL,0,	< Galileo T0Exp >
  200+          VDF <T,TM1>	TM1,	   tm1intp, INT gvinst,	    TM1_NOTES,	TM1_LVL,0,	< Galileo T1Exp >
  201+          VDF <T,TM2>	TM2,	   tm2intp, INT gvinst,	    TM2_NOTES,	TM2_LVL,0,	< Galileo T2Exp >
  202+          VDF <T,TM3>	TM3,	   tm3intp, INT gvinst,	    TM3_NOTES,	TM3_LVL,cputimerint, < Galileo T3EXP timer interrupt >
  203+          VDF <T,MRE>	MRE,	   mreintp, INT gvinst,	    MRE_NOTES,	MRE_LVL,0,	< Galileo MasRdErr >
  204+          VDF <T,SWE>	SWE,	   sweintp, INT gvinst,	    SWE_NOTES,	SWE_LVL,0,	< Galileo SlvWrErr >
  205+          VDF <T,MWE>	MWE,	   mweintp, INT gvinst,	    MWE_NOTES,	MWE_LVL,0,	< Galileo MasWrErr >
  206+          VDF <T,SRE>	SRE,	   sreintp, INT gvinst,	    SRE_NOTES,	SRE_LVL,0,	< Galileo SlvRdErr >
  207+          VDF <T,AEP>	AEP,	   aepintp, INT gvinst,	    AEP_NOTES,	AEP_LVL,0,	< Galileo AddrErr >
  208+          VDF <T,MEP>	MEP,	   mepintp, INT gvinst,	    MEP_NOTES,	MEP_LVL,0,	< Galileo MemErr >
  209+          VDF <T,MAS>	MAS,	   masintp, INT gvinst,	    MAS_NOTES,	MAS_LVL,0,	< Galileo MasAbort >
  210+          VDF <T,TAR>	TAR,	   tarintp, INT gvinst,	    TAR_NOTES,	TAR_LVL,0,	< Galileo TarAbort >
  211+          VDF <T,RTY>	RTY,	   rtyintp, INT gvinst,	    RTY_NOTES,	RTY_LVL,0,	< Galileo RetryCtr >
  212+          VDF <T,PC0>	PC0,	   pc0intp, INT gvinst,	    PC0_NOTES,	PC0_LVL,0,	< Galileo PCI Interrupt >
  213+          VDF <T,PC1>	PC1,	   pc1intp, INT gvinst,	    PC1_NOTES,	PC1_LVL,0,	< Galileo PCI Interrupt >
  214+          VDF <T,PC2>	PC2,	   pc2intp, INT gvinst,	    PC2_NOTES,	PC2_LVL,0,	< Galileo PCI Interrupt >
  215+          VDF <T,PC3>	PC3,	   pc3intp, INT gvinst,	    PC3_NOTES,	PC3_LVL,0,	< Galileo PCI Interrupt >
  216+          VDF <D,UART_LVL> UART,	   uartintp,INT ioainst,    UART_NOTES,	UART_LVL,0,	< I/O ASIC UART interrupts >
  217+          VDF <D,SND_LVL>	SND,	   sndintp, INT ioainst,    SND_NOTES,	SND_LVL, 0,	< I/O ASIC Sound interrupts >
  218+          VDF <D,MC_LVL>	MC,	   mcintp,  INT ioainst,    MC_NOTES,	MC_LVL,	0,	< I/O ASIC Microcontroller interrupt >
dispatch.c                               Atari Games Corp. macpp v9.12   "Oct 16 1997 13:26:41"


  219+          ;
  220+   (1)    .endc			; (_DISPATCH_MAC_&1) != 0 *** DON'T MOVE THIS LINE EITHER ***
  221+          ;
  222+          ;+++++++ From here on, there are few user servicable parts inside. ++++
  223+          ;
  224+          ; This is sortof how it works:
  225+          ; The first pass through, _DISPATCH_MAC_ will be 0 (set above by the .if not_defined).
  226+          ; First the copyright boilerplate is inserted into both output files and the macro VDF
  227+          ; is defined to create externs. Some struct definitions and unique externs are depositied
  228+          ; into the .h file. Next _DISPATCH_MAC_ is set to 1 and this file is .included
  229+          ; again. This will cause MACPP to read the VDF table above and output the appropriate
  230+          ; information in the .h file but ignore the rest of the file. The VDF macro is redefined,
  231+          ; and the procedure is repeated causing the creation of different items according to what
  232+          ; is needed. Once the whole .h file is built, the procedure repeats for the building of the
  233+          ; .c file.
  234+          ;
  235+   (1)    .if true, _DISPATCH_MAC_ == 0		; First (main) pass
  236+    X      PHX == 0
  237+    X      PAD == 0
  238+    X      FLG == 0
  239+    X      SEA == 0
  240+    X      VEG == 0
  241+    X      .iif true, HOST_BOARD == PHOENIX, PHX == 1 ;set the appropriate ones true as desired
  242+    X      .iif true, HOST_BOARD == PHOENIX_AD, PAD == 1 ;set the appropriate ones true as desired
  243+    X      .iif true, HOST_BOARD == FLAGSTAFF, FLG == 1 ;set the appropriate ones true as desired
  244+    X      .iif true, HOST_BOARD == SEATTLE, SEA == 1 ;set the appropriate ones true as desired
  245+    X      .iif true, HOST_BOARD == VEGAS, VEG == 1 ;set the appropriate ones true as desired
  246+          ;
  247+    X     	.macro .condit flag,exp		; The .condit macro does an expression test ...
  248+    X     	.if identical,<flag>,<T>
  249+    X     		.iif false,exp,.mexit 10 ; ... and aborts higher level macros if false
  250+    X     		.mexit
  251+    X     	.endc
  252+    X     	.if identical,<flag>,<F>
  253+    X     		.iif true,exp,.mexit 10	; ... etc.
  254+    X     		.mexit
  255+    X     	.endc
  256+    X     	.if identical,<flag>,<D>
  257+    X     		.iif not_defined,exp,.mexit 10
  258+    X     		.mexit
  259+    X     	.endc
  260+    X     	.if identical,<flag>,<N>
  261+    X     		.iif defined,exp,.mexit 10
  262+    X     		.mexit
  263+    X     	.endc
  264+    X     	.endm
  265+          ;	
  266+    X     	.macro boilerplate file_name
  267+    X     /*		file_name
  268+    X      *
  269+    X      *		Copyright 1996 Atari Games Corporation
  270+    X      *	Unauthorized reproduction, adaptation, distribution, performance or 
  271+    X      *	display of this computer program or the associated audiovisual work
  272+    X      *	is strictly prohibited.
  273+    X      *
  274+    X      * ++++++ WARNING WARNING WARNING WARNING WARNING +++++
  275+    X      * This file is machine generated. Any changes you put in here will be lost
dispatch.c                               Atari Games Corp. macpp v9.12   "Oct 16 1997 13:26:41"


  276+    X      * the next time phx_vecs.mac is touched. You need to make your changes to
  277+    X      * phx_vecs.mac instead of this file.
  278+    X      */
  279+    X     	.endm
  280+    X     	boilerplate dispatch.c
  281+    X     	.outfile	1		;The externs go into the .h file
  282+    X     	boilerplate intvecs.h
  283+    X     #if !defined(_INTVECS_H_)
  284+    X     #define _INTVECS_H_
  285+          
  286+    X     struct irq_tab {
  287+    X     	void 	(**softvec)();
  288+    X     	void    (*(*installer)(const struct irq_tab *, void(*new)()))();
  289+    X     	int	notes;
  290+    X     };
  291+          ;
  292+    X     	.macro VDF cond, name, softvec, intern, installer, notes, physical, default, comments
  293+    X     	.condit cond	
  294+    X      .if dif,<softvec>,<0>
  295+    X       ...1 == 0
  296+    X       .iif idn,<intern>,<VINT>,...1 == 1
  297+    X       .iif idn,<intern>,<VEXT>,...1 == 1
  298+    X       .if true, ...1
  299+    X     extern	void (* volatile softvec)();	/* comments */
  300+    X       .iff
  301+    X     extern  void (*softvec)();	/* comments */
  302+    X       .endc
  303+    X      .endc
  304+    X     	.endm
  305+          ;
  306+    X     	_DISPATCH_MAC_ == 1		;next time we process the IRQ table
  307+    X     	.include phx_vecs.mac		;Make the externs
  308+          
  309+    X     enum vecs {
  310+    X     	.macro VDF cond, name, softvec, intern, installer, notes, physical, default, comments
  311+    X     	.condit cond	
  312+    X         name'_INTVEC,
  313+    X     	.endm
  314+    X     	.include phx_vecs.mac		;Make the enums
  315+    X         N_INTVECS
  316+    X     };
  317+          
  318+    X     void (*prc_set_vec (unsigned int vecnum, void (*routine)() ))();
  319+    X     void prc_init_vecs(void);		/* set the default vectors */
  320+          ;
  321+          ; Add a prototype for an as yet unused function
  322+    X     .if true, 0
  323+          
  324+    X     /*		prc_set_vecp(which, what)
  325+    X      *	Sets a special vector for the interrupt identified by <which>
  326+    X      *	to call the routine specified by <what>. <what> is
  327+    X      *	a struct that contains both a pointer to the code
  328+    X      *	to execute and an optional pointer to the private
  329+    X      *	variables for that routine. This is a change from the
  330+    X      *	behavior of prc_set_vec, and is intended to allow
  331+    X      *	multiple incarnations of a given device to share code.
  332+    X      */
dispatch.c                               Atari Games Corp. macpp v9.12   "Oct 16 1997 13:26:41"


  333+          
  334+    X     struct opaque;
  335+    X     extern struct VECP_vector {
  336+    X         void (*function)(struct opaque *);	/* Who you gonna call */
  337+    X         struct opaque *cookie;		/* a magic cookie to hand him */
  338+    X     } prc_set_vecp (
  339+    X         int __which,			/* one of xxx_INTVEC */
  340+    X         struct IRQ_vector __what		/* BY VALUE!!! */
  341+    X     );
  342+    X     .endc
  343+    X     #endif		/* _INTVECS_H_ */
  344+          ;
  345+          ; At this point, we have completed all processing of the .h file
  346+          ; so switch back to the .c file
  347+          ;
  348+    X     	.outfile	0		;switch back to dispatch.c
  349+          ;
  350+    X     #include <config.h>			/* begining of dispatch.c */
  351+    X     #include <os_proto.h>
  352+    X     #include <intvecs.h>
  353+          
  354+    X     #ifndef BLABF
  355+    X     # define BLABF(x)
  356+    X     #endif
  357+          
  358+    X     #ifndef BLAB
  359+    X     # define BLAB(x)
  360+    X     #endif
  361+          
  362+    X      .if true, 1
  363+    X     	.macro VDF cond, name, softvec, intern, installer, notes, physical, default, comments
  364+    X     	.condit cond	
  365+    X       .iif idn,<name>,<XBUS0>,.mexit
  366+    X       .iif idn,<name>,<XBUS1>,.mexit
  367+    X       .iif idn,<name>,<XBUS2>,.mexit
  368+    X       .iif idn,<name>,<XBUS3>,.mexit
  369+    X       .iif idn,<name>,<INT0>,.mexit
  370+    X       .iif idn,<name>,<INT1>,.mexit
  371+    X       .iif idn,<name>,<INT2>,.mexit
  372+    X       .iif idn,<name>,<INT3>,.mexit
  373+    X       .iif idn,<name>,<INT4>,.mexit
  374+    X       .iif idn,<name>,<INT5>,.mexit
  375+    X       .if true, PHX
  376+    X         .if true, physical == XBUS0_LVL
  377+    X     	  ...XBUS0 == ...XBUS0 + 1
  378+    X     	  .mexit
  379+    X         .endc
  380+    X         .if true, physical == XBUS1_LVL
  381+    X     	  ...XBUS1 == ...XBUS1 + 1
  382+    X     	  .mexit
  383+    X         .endc
  384+    X         .if true, physical == XBUS2_LVL
  385+    X     	  ...XBUS2 == ...XBUS2 + 1
  386+    X     	  .mexit
  387+    X         .endc
  388+    X         .if true, physical == XBUS3_LVL
  389+    X     	  ...XBUS3 == ...XBUS3 + 1
dispatch.c                               Atari Games Corp. macpp v9.12   "Oct 16 1997 13:26:41"


  390+    X     	  .mexit
  391+    X         .endc
  392+    X       .endc
  393+    X       .if true, physical == INT0_LVL
  394+    X         	...INT0 == ...INT0 + 1
  395+    X     	.mexit
  396+    X       .endc
  397+    X       .if true, physical == INT1_LVL
  398+    X         	...INT1 == ...INT1 + 1
  399+    X        .if true, PAD || FLG || SEA || VEG
  400+    X     	...IOA == ...IOA + 1
  401+    X         .if ndf, notes
  402+    X     #define notes IO_MAIN_GLOBAL_INT
  403+    X         .endc
  404+    X        .endc
  405+    X     	.mexit
  406+    X       .endc
  407+    X       .if true, physical == INT2_LVL
  408+    X         	...INT2 == ...INT2 + 1
  409+    X     	.mexit
  410+    X       .endc
  411+    X       .if true, physical == INT3_LVL
  412+    X         	...INT3 == ...INT3 + 1
  413+    X     	.mexit
  414+    X       .endc
  415+    X       .if true, physical == INT4_LVL
  416+    X         	...INT4 == ...INT4 + 1
  417+    X     	.mexit
  418+    X       .endc
  419+    X       .if true, physical == INT5_LVL
  420+    X         	...INT5 == ...INT5 + 1
  421+    X     	.mexit
  422+    X       .endc
  423+    X       .if true, physical == IOASIC_LVL
  424+    X         	...IOA == ...IOA + 1
  425+    X        .if ndf, notes
  426+    X     #define notes IO_MAIN_GLOBAL_INT
  427+    X        .endc
  428+    X     	.mexit
  429+    X       .endc
  430+    X     	.endm
  431+    X     ...XBUS0 == 0
  432+    X     ...XBUS1 == 0
  433+    X     ...XBUS2 == 0
  434+    X     ...XBUS3 == 0
  435+    X     ...INT0 == 0
  436+    X     ...INT1 == 0
  437+    X     ...INT2 == 0
  438+    X     ...INT3 == 0
  439+    X     ...INT4 == 0
  440+    X     ...INT5 == 0
  441+    X     ...IOA == 0
  442+    X     	.include phx_vecs.mac	; count vectors requiring dispatch
  443+    X      .endc
  444+          ; 
  445+    X     .macro VDF cond, name, softvec, intern, installer, notes, physical, default, comments
  446+    X      .condit cond	
dispatch.c                               Atari Games Corp. macpp v9.12   "Oct 16 1997 13:26:41"


  447+    X      .if dif,<softvec>,<0>
  448+    X       .if idn,<intern>,<INT>
  449+    X     void (*softvec)();	/* comments */
  450+    X       .endc
  451+    X       .if idn,<intern>,<VINT>
  452+    X     void (* volatile softvec)();	/* comments */
  453+    X       .endc
  454+    X      .endc
  455+    X      .if dif,<default>,<0>
  456+    X       .if idn,<name>,<INT0>
  457+    X        .if true, ...INT0
  458+    X     static void 'default'(void);	/* comments */
  459+    X        .endc
  460+    X        .mexit
  461+    X       .endc
  462+    X       .if idn,<name>,<INT1>
  463+    X        .if true, ...INT1
  464+    X     static void 'default'(void);	/* comments */
  465+    X        .endc
  466+    X        .mexit
  467+    X       .endc
  468+    X       .if idn,<name>,<INT2>
  469+    X        .if true, ...INT2
  470+    X     static void 'default'(void);	/* comments */
  471+    X        .endc
  472+    X        .mexit
  473+    X       .endc
  474+    X       .if idn,<name>,<INT3>
  475+    X        .if true, ...INT3
  476+    X     static void 'default'(void);	/* comments */
  477+    X        .endc
  478+    X        .mexit
  479+    X       .endc
  480+    X       .if idn,<name>,<INT4>
  481+    X        .if true, ...INT4
  482+    X     static void 'default'(void);	/* comments */
  483+    X        .endc
  484+    X        .mexit
  485+    X       .endc
  486+    X       .if idn,<name>,<INT5>
  487+    X        .if true, ...INT5
  488+    X     static void 'default'(void);	/* comments */
  489+    X        .endc
  490+    X        .mexit
  491+    X       .endc
  492+    X       .if idn,<name>,<INT6>
  493+    X        .if true, ...INT6
  494+    X     static void 'default'(void);	/* comments */
  495+    X        .endc
  496+    X        .mexit
  497+    X       .endc
  498+    X       .if idn,<name>,<INT7>
  499+    X        .if true, ...INT7
  500+    X     static void 'default'(void);	/* comments */
  501+    X        .endc
  502+    X        .mexit
  503+    X       .endc
dispatch.c                               Atari Games Corp. macpp v9.12   "Oct 16 1997 13:26:41"


  504+    X       .if true, PHX
  505+    X        .if idn,<name>,<XBUS>
  506+    X         .if true, ...XBUS0|...XBUS1|...XBUS2|...XBUS3
  507+    X     static void 'default'(void);
  508+    X         .endc
  509+    X         .mexit
  510+    X        .endc
  511+    X        .if idn,<name>,<XBUS0>
  512+    X         .if true, ...XBUS0
  513+    X     static void 'default'(void);
  514+    X         .endc
  515+    X         .mexit
  516+    X        .endc
  517+    X        .if idn,<name>,<XBUS1>
  518+    X         .if true, ...XBUS1
  519+    X     static void 'default'(void);
  520+    X         .endc
  521+    X         .mexit
  522+    X        .endc
  523+    X        .if idn,<name>,<XBUS2>
  524+    X         .if true, ...XBUS2
  525+    X     static void 'default'(void);
  526+    X         .endc
  527+    X         .mexit
  528+    X        .endc
  529+    X        .if idn,<name>,<XBUS3>
  530+    X         .if true, ...XBUS3
  531+    X     static void 'default'(void);
  532+    X         .endc
  533+    X         .mexit
  534+    X        .endc
  535+    X       .endc			; PHX
  536+    X       .if idn,<name>,<IOA>
  537+    X        .if true, ...IOA
  538+    X     static void 'default'(void);
  539+    X        .endc
  540+    X        .mexit
  541+    X       .endc
  542+    X     extern void 'default'(void);
  543+    X      .endc
  544+    X     .endm
  545+    X     	.include phx_vecs.mac		;Declare the non-extern vectors
  546+          ;
  547+    X      .if true, ((PROCESSOR&-16) == MIPS3000) || ((PROCESSOR&-16) == MIPS4000)
  548+    X     static void (*hwvinst(const struct irq_tab *, void (*)()))();
  549+    X      .endc
  550+          ;
  551+    X     .if df, PHOENIX_INTCTL_MASK
  552+    X     static void (*pvinst(const struct irq_tab *, void (*)()))();
  553+    X     .endc
  554+          ;
  555+    X     .if df, GALILEO_INTCTL_MASK
  556+    X     static void (*gvinst(const struct irq_tab *, void (*)()))();
  557+    X     .endc
  558+          ;
  559+    X     .if true, ...IOA
  560+    X     static void (*ioainst(const struct irq_tab *, void (*)()))();
dispatch.c                               Atari Games Corp. macpp v9.12   "Oct 16 1997 13:26:41"


  561+    X     .endc
  562+          ;
  563+    X     static const struct irq_tab irq_inits[] = {
  564+    X     	.macro VDF cond, name, softvec, intern, installer, notes, physical, default, comments
  565+    X     	.condit cond	
  566+    X      .if dif,<softvec>,<0>
  567+    X      { (void (**)())&softvec, installer, notes },	/* comments */
  568+    X      .iff
  569+    X      { 0, installer, notes },	/* comments */
  570+    X      .endc
  571+    X     	.endm
  572+    X     	.include phx_vecs.mac		;Build the irq_inits array
  573+    X      { 0, 0, 0} };
  574+          ;
  575+    X     .if true, ((PROCESSOR&-16) == MIPS3000) || ((PROCESSOR&-16) == MIPS4000)
  576+          
  577+    X     extern void (*ramv_tbl[])();
  578+          
  579+    X     static void (*hwvinst(const struct irq_tab *it, void (*new)()))() {
  580+    X         int indx;
  581+    X         void (*old_rtn)();
  582+          
  583+    X         indx = it->notes;
  584+    X         if (indx >= VN_MAX) return 0;
  585+    X         old_rtn = ramv_tbl[indx];
  586+    X         ramv_tbl[indx] = new;
  587+    X         return old_rtn;
  588+    X     }
  589+          
  590+    X      .if df, PHOENIX_INTCTL_MASK
  591+    X     static void (*pvinst(const struct irq_tab *it, void (*new)()))() {
  592+          
  593+    X         if (it->notes) {
  594+    X     	BLABF(("\ndispatch: Adding 0x%08lX to main INTCTL (0x%08lX)...", it->notes, *(VU32*)INTCTL_IE));
  595+    X     	*((VU32 *)(INTCTL_IE)) |= it->notes;
  596+    X         }
  597+    X         return 0;
  598+    X     }
  599+    X      .endc
  600+          
  601+    X      .if df, GALILEO_INTCTL_MASK
  602+    X     static void (*gvinst(const struct irq_tab *it, void (*new)()))() {
  603+          
  604+    X         if (it->notes) {
  605+    X     	BLABF(("\ndispatch: Adding 0x%08lX to Galileo INTCTL (0x%08lX)...", it->notes, \
  606+    X     			*(VU32*)GALILEO_CPU_I_ENA));
  607+    X     	*((VU32 *)(GALILEO_CPU_I_ENA)) |= it->notes;
  608+    X         }
  609+    X         return 0;
  610+    X     }
  611+    X      .endc
  612+          
  613+    X      .if true, ...IOA
  614+    X     static void (*ioainst(const struct irq_tab *it, void (*new)()))() {
  615+    X     extern void prc_wait_n_usecs( int );
  616+    X         if (it->notes)
  617+    X         {
dispatch.c                               Atari Games Corp. macpp v9.12   "Oct 16 1997 13:26:41"


  618+    X          BLABF(("\ndispatch: Adding 0x%04X to IOASIC INTCTL: (0x%04X)...", (int)it->notes, \
  619+    X     		*(VU32*)IO_MAIN_CTL&0xFFFF));
  620+    X          while ( ( *((VU32 *)IO_MAIN_CTL) & it->notes ) != it->notes )
  621+    X          {
  622+    X     #ifdef LED_OUT
  623+    X           *(VU32 *)LED_OUT = ~( 1 << B_LED_RED );
  624+    X     #endif
  625+    X           do
  626+    X           {
  627+    X            *((VU32 *)IO_MAIN_CTL) |= it->notes;
  628+    X            prc_wait_n_usecs( 1000 );
  629+    X           } while ( ( *((VU32 *)IO_MAIN_CTL) & it->notes ) != it->notes );
  630+    X           prc_wait_n_usecs( 1000 );
  631+    X     #ifdef LED_OUT
  632+    X           *(VU32 *)LED_OUT |= ( 1 << B_LED_RED );
  633+    X     #endif
  634+    X          }
  635+    X         }
  636+    X         return 0;
  637+    X     }
  638+    X      .endc
  639+    X     .endc
  640+          
  641+    X     void (*prc_set_vec (unsigned int vecnum, void (*routine)() ))()
  642+    X     {
  643+    X         void (*old_rtn)();
  644+    X         void (**softvec)();
  645+    X         const struct irq_tab *tbp;
  646+    X         int old_ipl;
  647+          
  648+    X         if ( vecnum >= N_INTVECS ) return 0;
  649+    X         tbp = irq_inits+vecnum;
  650+    X         softvec = tbp->softvec;
  651+    X         old_rtn = 0;
  652+    X         old_ipl = prc_set_ipl(INTS_OFF);
  653+    X         if ( tbp->installer ) old_rtn = tbp->installer(tbp, routine);
  654+    X         if ( softvec ) {
  655+    X     	if (!old_rtn) old_rtn = *softvec;
  656+    X     	*softvec = routine;
  657+    X         }
  658+    X         prc_set_ipl(old_ipl);
  659+    X         return old_rtn;
  660+    X     }
  661+          
  662+    X      .if true, PHX
  663+    X       .if true, ...XBUS0
  664+    X     static void xbus0_irq(void) {
  665+    X     	.macro VDF cond, name, softvec, intern, installer, notes, physical, default, comments
  666+    X     	.condit cond	
  667+    X       .iif idn,<name>,<XBUS0>,.mexit
  668+    X       .iif idn,<softvec>,<0>,.mexit
  669+    X       .if true, physical == XBUS0_LVL
  670+    X         if (softvec) softvec();
  671+    X       .endc
  672+    X     	.endm
  673+    X     	.include phx_vecs.mac		; pickup all vectors assigned to XBUS0_LVL
  674+    X         return;
dispatch.c                               Atari Games Corp. macpp v9.12   "Oct 16 1997 13:26:41"


  675+    X     }
  676+          
  677+    X       .endc		; ...XBUS0
  678+    X       .if true, ...XBUS1
  679+    X     static void xbus1_irq(void) {
  680+    X     	.macro VDF cond, name, softvec, intern, installer, notes, physical, default, comments
  681+    X     	.condit cond	
  682+    X       .iif idn,<name>,<XBUS1>,.mexit
  683+    X       .iif idn,<softvec>,<0>,.mexit
  684+    X       .if true, physical == XBUS1_LVL
  685+    X         if (softvec) softvec();
  686+    X       .endc
  687+    X     	.endm
  688+    X     	.include phx_vecs.mac		; pickup all vectors assigned to XBUS1_LVL
  689+    X         return;
  690+    X     }
  691+          
  692+    X       .endc		; ...XBUS1
  693+    X       .if true, ...XBUS2
  694+    X     static void xbus2_irq(void) {
  695+    X     	.macro VDF cond, name, softvec, intern, installer, notes, physical, default, comments
  696+    X     	.condit cond	
  697+    X       .iif idn,<name>,<XBUS2>,.mexit
  698+    X       .iif idn,<softvec>,<0>,.mexit
  699+    X       .if true, physical == XBUS2_LVL
  700+    X         if (softvec) softvec();
  701+    X       .endc
  702+    X     	.endm
  703+    X     	.include phx_vecs.mac		; pickup all vectors assigned to XBUS2_LVL
  704+    X         return;
  705+    X     }
  706+          
  707+    X       .endc		; ...XBUS2
  708+    X       .if true, ...XBUS3
  709+    X     static void xbus3_irq(void) {
  710+    X     	.macro VDF cond, name, softvec, intern, installer, notes, physical, default, comments
  711+    X     	.condit cond	
  712+    X       .iif idn,<name>,<XBUS3>,.mexit
  713+    X       .iif idn,<softvec>,<0>,.mexit
  714+    X       .if true, physical == XBUS3_LVL
  715+    X         if (softvec) softvec();
  716+    X       .endc
  717+    X     	.endm
  718+    X     	.include phx_vecs.mac		; pickup all vectors assigned to XBUS3_LVL
  719+    X         return;
  720+    X     }
  721+          
  722+    X       .endc		; ...XBUS3
  723+    X      .endc		; PHX
  724+    X      .if true, ...INT0
  725+    X     static void int0_irq(void) {
  726+    X     	.macro VDF cond, name, softvec, intern, installer, notes, physical, default, comments
  727+    X     	.condit cond	
  728+    X       .iif idn,<name>,<INT0>,.mexit
  729+    X       .iif idn,<softvec>,<0>,.mexit
  730+    X       .if true, physical == INT0_LVL
  731+    X         if (softvec) softvec();
dispatch.c                               Atari Games Corp. macpp v9.12   "Oct 16 1997 13:26:41"


  732+    X       .endc
  733+    X     	.endm
  734+    X     	.include phx_vecs.mac		; pickup all vectors assigned to IRQ 0
  735+    X         return;
  736+    X     }
  737+          
  738+    X      .endc		; ...INT0
  739+    X      .if true, ...INT1
  740+    X     static void int1_irq(void) {
  741+    X     	.macro VDF cond, name, softvec, intern, installer, notes, physical, default, comments
  742+    X     	.condit cond	
  743+    X       .iif idn,<name>,<INT1>,.mexit
  744+    X       .iif idn,<softvec>,<0>,.mexit
  745+    X       .if true, physical == INT1_LVL
  746+    X         if (softvec) softvec();
  747+    X       .endc
  748+    X     	.endm
  749+    X     	.include phx_vecs.mac		; pickup all vectors assigned to IRQ 1
  750+    X         return;
  751+    X     }
  752+          
  753+    X      .endc		; ...INT1
  754+    X      .if true, ...INT2
  755+    X     static void int2_irq(void) {
  756+    X     	.macro VDF cond, name, softvec, intern, installer, notes, physical, default, comments
  757+    X     	.condit cond	
  758+    X       .iif idn,<name>,<INT2>,.mexit
  759+    X       .iif idn,<softvec>,<0>,.mexit
  760+    X       .if true, physical == INT2_LVL
  761+    X         if (softvec) softvec();
  762+    X       .endc
  763+    X     	.endm
  764+    X     	.include phx_vecs.mac		; pickup all vectors assigned to IRQ 2
  765+    X         return;
  766+    X     }
  767+          
  768+    X      .endc		; ...INT2
  769+    X      .if true, ...INT3
  770+    X     static void int3_irq(void) {
  771+    X     	.macro VDF cond, name, softvec, intern, installer, notes, physical, default, comments
  772+    X     	.condit cond	
  773+    X       .iif idn,<name>,<INT3>,.mexit
  774+    X       .iif idn,<softvec>,<0>,.mexit
  775+    X       .if true, physical == INT3_LVL
  776+    X         if (softvec) softvec();
  777+    X       .endc
  778+    X     	.endm
  779+    X     	.include phx_vecs.mac		; pickup all vectors assigned to IRQ 3
  780+    X         return;
  781+    X     }
  782+          
  783+    X      .endc		; ...INT3
  784+    X      .if true, ...INT4
  785+    X     static void int4_irq(void) {
  786+    X     	.macro VDF cond, name, softvec, intern, installer, notes, physical, default, comments
  787+    X     	.condit cond	
  788+    X       .iif idn,<name>,<INT4>,.mexit
dispatch.c                               Atari Games Corp. macpp v9.12   "Oct 16 1997 13:26:41"


  789+    X       .iif idn,<softvec>,<0>,.mexit
  790+    X       .if true, physical == INT4_LVL
  791+    X         if (softvec) softvec();
  792+    X       .endc
  793+    X     	.endm
  794+    X     	.include phx_vecs.mac		; pickup all vectors assigned to IRQ 4
  795+    X         return;
  796+    X     }
  797+          
  798+    X      .endc		; ...INT4
  799+    X      .if true, ...INT5
  800+    X     static void int5_irq(void) {
  801+    X     	.macro VDF cond, name, softvec, intern, installer, notes, physical, default, comments
  802+    X     	.condit cond	
  803+    X       .iif idn,<name>,<INT5>,.mexit
  804+    X       .iif idn,<softvec>,<0>,.mexit
  805+    X       .if true, physical == INT5_LVL
  806+    X         if (softvec) softvec();
  807+    X       .endc
  808+    X     	.endm
  809+    X     	.include phx_vecs.mac		; pickup all vectors assigned to IRQ 5
  810+    X         return;
  811+    X     }
  812+          
  813+    X      .endc		; ...INT5
  814+    X      .if true, ...IOA && PHX
  815+    X     static void ioa_irq(void) {
  816+    X     	.macro VDF cond, name, softvec, intern, installer, notes, physical, default, comments
  817+    X     	.condit cond	
  818+    X       .iif idn,<name>,<IOA>,.mexit
  819+    X       .iif idn,<softvec>,<0>,.mexit
  820+    X       .if true, physical == IOASIC_LVL
  821+    X         if (softvec) softvec();
  822+    X       .endc
  823+    X     	.endm
  824+    X     	.include phx_vecs.mac		; pickup all vectors assigned to IRQ 5
  825+    X         return;
  826+    X     }
  827+          
  828+    X      .endc		; ...IOA
  829+    X      .if true, PHX
  830+    X       .if true, ...XBUS0|...XBUS1|...XBUS2|...XBUS3
  831+    X     static void xbus_irq(void) {
  832+    X         int which;
  833+    X         which = *(VU32 *)(XBUS_SLOT0+4);
  834+    X       .if true, ...XBUS0
  835+    X         if (!(which&1)) xbus0_irq();
  836+    X       .endc
  837+    X       .if true, ...XBUS1
  838+    X         if (!(which&2)) xbus1_irq();
  839+    X       .endc
  840+    X       .if true, ...XBUS2
  841+    X         if (!(which&4)) xbus2_irq();
  842+    X       .endc
  843+    X       .if true, ...XBUS3
  844+    X         if (!(which&8)) xbus3_irq();
  845+    X       .endc
dispatch.c                               Atari Games Corp. macpp v9.12   "Oct 16 1997 13:26:41"


  846+    X         return;
  847+    X     }
  848+    X       .endc
  849+    X      .endc		; PHX
  850+    X     void prc_init_vecs(void) {
  851+    X     	.macro VDF cond, name, softvec, intern, installer, notes, physical, default, comments
  852+    X     	.condit cond	
  853+    X     .if dif,<default>,<0>
  854+    X      .if true, PHX
  855+    X       .if idn,<name>,<XBUS0>
  856+    X        .iif true, ...XBUS0 == 0, .mexit
  857+    X       .endc
  858+    X       .if idn,<name>,<XBUS1>
  859+    X        .iif true, ...XBUS1 == 0, .mexit
  860+    X       .endc
  861+    X       .if idn,<name>,<XBUS2>
  862+    X        .iif true, ...XBUS2 == 0, .mexit
  863+    X       .endc
  864+    X       .if idn,<name>,<XBUS3>
  865+    X        .iif true, ...XBUS3 == 0, .mexit
  866+    X       .endc
  867+    X       .if idn,<name>,<XBUS>
  868+    X        .iif true, (...XBUS0|...XBUS1|...XBUS2|...XBUS3) == 0, .mexit
  869+    X       .endc
  870+    X      .endc	; PHX
  871+    X      .if idn,<name>,<INT0>
  872+    X       .iif true, ...INT0 == 0, .mexit
  873+    X      .endc
  874+    X      .if idn,<name>,<INT1>
  875+    X       .iif true, ...INT1 == 0, .mexit
  876+    X      .endc
  877+    X      .if idn,<name>,<INT2>
  878+    X       .iif true, ...INT2 == 0, .mexit
  879+    X      .endc
  880+    X      .if idn,<name>,<INT3>
  881+    X       .iif true, ...INT3 == 0, .mexit
  882+    X      .endc
  883+    X      .if idn,<name>,<INT4>
  884+    X       .iif true, ...INT4 == 0, .mexit
  885+    X      .endc
  886+    X      .if idn,<name>,<INT5>
  887+    X       .iif true, ...INT5 == 0, .mexit
  888+    X      .endc
  889+    X      .if idn,<name>,<IOA>
  890+    X       .iif true, ...IOA == 0, .mexit
  891+    X      .endc
  892+    X         prc_set_vec('name'_INTVEC, default);
  893+    X     .endc
  894+    X     	.endm
  895+    X     	.include phx_vecs.mac
  896+          
  897+    X     /* Map the Phoenix interrupts */
  898+          
  899+    X     .if df, INTCTL_MAPA_INIT
  900+    X         BLABF(("\ndispatch: Mapping the A interrupts: 0x%08lX...", INTCTL_MAPA_INIT));
  901+    X         *((VU32 *)(INTCTL_MAPA)) = INTCTL_MAPA_INIT;
  902+    X     .endc
dispatch.c                               Atari Games Corp. macpp v9.12   "Oct 16 1997 13:26:41"


  903+    X     .if df, INTCTL_MAPB_INIT
  904+    X         BLABF(("\ndispatch: Mapping the B interrupts: 0x%08lX...", INTCTL_MAPB_INIT));
  905+    X         *((VU32 *)(INTCTL_MAPB)) = INTCTL_MAPB_INIT;
  906+    X     .endc
  907+          
  908+    X     .if defined, ANNOUNCE_BOOT_ACTIONS
  909+    X      .if true, ANNOUNCE_BOOT_ACTIONS
  910+    X         {
  911+    X     	int jj;
  912+    X     	extern int prc_get_cause(void), prc_get_ipl(void);
  913+    X     	jj = prc_get_cause();
  914+    X     	if (jj&0xFF00) BLABF(("\ndispatch: CPU cause reg: %08lX, CPU SR reg: %08lX", jj, prc_get_ipl()));
  915+    X     	if (jj&0x0400) {
  916+    X       .if true, ...INT0
  917+    X     	.macro VDF cond, name, softvec, intern, installer, notes, physical, default, comments
  918+    X     	.condit cond	
  919+    X        .iif idn,<name>,<INT0>,.mexit
  920+    X        .iif idn,<softvec>,<0>,.mexit
  921+    X        .if true, physical == INT0_LVL
  922+    X     	    if (!softvec) BLAB("\ndispatch: Warning, IRQ 0 pending \"'comments'\"");
  923+    X        .endc
  924+    X     	.endm
  925+    X     	.include phx_vecs.mac		; pickup all vectors assigned to IRQ 0
  926+    X       .iff
  927+    X     	    BLAB("\ndispatch: Warning, IRQ 0 pending with no vector assigned");
  928+    X       .endc		; ...INT0
  929+    X     	}
  930+    X     	if (jj&0x0800) {
  931+    X       .if true, ...INT1
  932+    X     	.macro VDF cond, name, softvec, intern, installer, notes, physical, default, comments
  933+    X     	.condit cond	
  934+    X        .iif idn,<name>,<INT1>,.mexit
  935+    X        .iif idn,<softvec>,<0>,.mexit
  936+    X        .if true, physical == INT1_LVL
  937+    X     	    if (!softvec) BLAB("\ndispatch: Warning, IRQ 1 pending \"'comments'\"");
  938+    X        .endc
  939+    X     	.endm
  940+    X     	.include phx_vecs.mac		; pickup all vectors assigned to IRQ 1
  941+    X       .iff
  942+    X     	    BLAB("\ndispatch: Warning, IRQ 1 pending with no vector assigned");
  943+    X       .endc		; ...INT1
  944+    X     	}
  945+    X     	if (jj&0x1000) {
  946+    X       .if true, ...INT2
  947+    X     	.macro VDF cond, name, softvec, intern, installer, notes, physical, default, comments
  948+    X     	.condit cond	
  949+    X        .iif idn,<name>,<INT2>,.mexit
  950+    X        .iif idn,<softvec>,<0>,.mexit
  951+    X        .if true, physical == INT2_LVL
  952+    X     	    if (!softvec) BLAB("\ndispatch: Warning, IRQ 2 pending \"'comments'\"");
  953+    X        .endc
  954+    X     	.endm
  955+    X     	.include phx_vecs.mac		; pickup all vectors assigned to IRQ 2
  956+    X       .iff
  957+    X     	    BLAB("\ndispatch: Warning, IRQ 2 pending with no vector assigned");
  958+    X       .endc		; ...INT2
  959+    X     	}
dispatch.c                               Atari Games Corp. macpp v9.12   "Oct 16 1997 13:26:41"


  960+    X     	if (jj&0x2000) {
  961+    X       .if true, ...INT3
  962+    X     	.macro VDF cond, name, softvec, intern, installer, notes, physical, default, comments
  963+    X     	.condit cond	
  964+    X        .iif idn,<name>,<INT3>,.mexit
  965+    X        .iif idn,<softvec>,<0>,.mexit
  966+    X        .if true, physical == INT3_LVL
  967+    X     	    if (!softvec) BLAB("\ndispatch: Warning, IRQ 3 pending \"'comments'\"");
  968+    X        .endc
  969+    X     	.endm
  970+    X     	.include phx_vecs.mac		; pickup all vectors assigned to IRQ 3
  971+    X       .iff
  972+    X     	    BLAB("\ndispatch: Warning, IRQ 3 pending with no vector assigned");
  973+    X       .endc		; ...INT3
  974+    X     	}
  975+    X     	if (jj&0x4000) {
  976+    X       .if true, ...INT4
  977+    X     	.macro VDF cond, name, softvec, intern, installer, notes, physical, default, comments
  978+    X     	.condit cond	
  979+    X        .iif idn,<name>,<INT4>,.mexit
  980+    X        .iif idn,<softvec>,<0>,.mexit
  981+    X        .if true, physical == INT4_LVL
  982+    X     	    if (!softvec) BLAB("\ndispatch: Warning, IRQ 4 pending \"'comments'\"");
  983+    X        .endc
  984+    X     	.endm
  985+    X     	.include phx_vecs.mac		; pickup all vectors assigned to IRQ 4
  986+    X       .iff
  987+    X     	    BLAB("\ndispatch: Warning, IRQ 4 pending with no vector assigned");
  988+    X       .endc		; ...INT4
  989+    X     	}
  990+    X     	if (jj&0x8000) {
  991+    X       .if true, ...INT5
  992+    X     	.macro VDF cond, name, softvec, intern, installer, notes, physical, default, comments
  993+    X     	.condit cond	
  994+    X        .iif idn,<name>,<INT5>,.mexit
  995+    X        .iif idn,<softvec>,<0>,.mexit
  996+    X        .if true, physical == INT5_LVL
  997+    X     	    if (!softvec) BLAB("\ndispatch: Warning, IRQ 5 pending \"'comments'\"");
  998+    X        .endc
  999+    X     	.endm
 1000+    X     	.include phx_vecs.mac		; pickup all vectors assigned to IRQ 5
 1001+    X       .iff
 1002+    X     	    BLAB("\ndispatch: Warning, IRQ 5 pending with no vector assigned");
 1003+    X       .endc		; ...INT5
 1004+    X     	}
 1005+    X         }
 1006+    X      .endc		; true, ANNOUNCE_BOOT_ACTIONS
 1007+    X     .endc		; defined, ANNOUNCE_BOOT_ACTIONS
 1008+    X         return;
 1009+    X     }
 1010+   (1)    .endc		; _DISPATCH_MAC_ == 0
  315               N_INTVECS
  316           };
  317           
  318           void (*prc_set_vec (unsigned int vecnum, void (*routine)() ))();
  319           void prc_init_vecs(void);		/* set the default vectors */
  320           ;
dispatch.c                               Atari Games Corp. macpp v9.12   "Oct 16 1997 13:26:41"


  321           ; Add a prototype for an as yet unused function
  322    (1)    .if true, 0
  323           
  324     X     /*		prc_set_vecp(which, what)
  325     X      *	Sets a special vector for the interrupt identified by <which>
  326     X      *	to call the routine specified by <what>. <what> is
  327     X      *	a struct that contains both a pointer to the code
  328     X      *	to execute and an optional pointer to the private
  329     X      *	variables for that routine. This is a change from the
  330     X      *	behavior of prc_set_vec, and is intended to allow
  331     X      *	multiple incarnations of a given device to share code.
  332     X      */
  333           
  334     X     struct opaque;
  335     X     extern struct VECP_vector {
  336     X         void (*function)(struct opaque *);	/* Who you gonna call */
  337     X         struct opaque *cookie;		/* a magic cookie to hand him */
  338     X     } prc_set_vecp (
  339     X         int __which,			/* one of xxx_INTVEC */
  340     X         struct IRQ_vector __what		/* BY VALUE!!! */
  341     X     );
  342    (1)    .endc
  343           #endif		/* _INTVECS_H_ */
  344           ;
  345           ; At this point, we have completed all processing of the .h file
  346           ; so switch back to the .c file
  347           ;
  348  00000000 	.outfile	0		;switch back to dispatch.c
  349           ;
  350           #include <config.h>			/* begining of dispatch.c */
  351           #include <os_proto.h>
  352           #include <intvecs.h>
  353           
  354           #ifndef BLABF
  355           # define BLABF(x)
  356           #endif
  357           
  358           #ifndef BLAB
  359           # define BLAB(x)
  360           #endif
  361           
  362    (1)     .if true, 1
  363           	.macro VDF cond, name, softvec, intern, installer, notes, physical, default, comments
  364           	.condit cond	
  365             .iif idn,<name>,<XBUS0>,.mexit
  366             .iif idn,<name>,<XBUS1>,.mexit
  367             .iif idn,<name>,<XBUS2>,.mexit
  368             .iif idn,<name>,<XBUS3>,.mexit
  369             .iif idn,<name>,<INT0>,.mexit
  370             .iif idn,<name>,<INT1>,.mexit
  371             .iif idn,<name>,<INT2>,.mexit
  372             .iif idn,<name>,<INT3>,.mexit
  373             .iif idn,<name>,<INT4>,.mexit
  374             .iif idn,<name>,<INT5>,.mexit
  375             .if true, PHX
  376               .if true, physical == XBUS0_LVL
  377           	  ...XBUS0 == ...XBUS0 + 1
dispatch.c                               Atari Games Corp. macpp v9.12   "Oct 16 1997 13:26:41"


  378           	  .mexit
  379               .endc
  380               .if true, physical == XBUS1_LVL
  381           	  ...XBUS1 == ...XBUS1 + 1
  382           	  .mexit
  383               .endc
  384               .if true, physical == XBUS2_LVL
  385           	  ...XBUS2 == ...XBUS2 + 1
  386           	  .mexit
  387               .endc
  388               .if true, physical == XBUS3_LVL
  389           	  ...XBUS3 == ...XBUS3 + 1
  390           	  .mexit
  391               .endc
  392             .endc
  393             .if true, physical == INT0_LVL
  394               	...INT0 == ...INT0 + 1
  395           	.mexit
  396             .endc
  397             .if true, physical == INT1_LVL
  398               	...INT1 == ...INT1 + 1
  399              .if true, PAD || FLG || SEA || VEG
  400           	...IOA == ...IOA + 1
  401               .if ndf, notes
  402           #define notes IO_MAIN_GLOBAL_INT
  403               .endc
  404              .endc
  405           	.mexit
  406             .endc
  407             .if true, physical == INT2_LVL
  408               	...INT2 == ...INT2 + 1
  409           	.mexit
  410             .endc
  411             .if true, physical == INT3_LVL
  412               	...INT3 == ...INT3 + 1
  413           	.mexit
  414             .endc
  415             .if true, physical == INT4_LVL
  416               	...INT4 == ...INT4 + 1
  417           	.mexit
  418             .endc
  419             .if true, physical == INT5_LVL
  420               	...INT5 == ...INT5 + 1
  421           	.mexit
  422             .endc
  423             .if true, physical == IOASIC_LVL
  424               	...IOA == ...IOA + 1
  425              .if ndf, notes
  426           #define notes IO_MAIN_GLOBAL_INT
  427              .endc
  428           	.mexit
  429             .endc
  430           	.endm
  431  00000000 ...XBUS0 == 0
  432  00000000 ...XBUS1 == 0
  433  00000000 ...XBUS2 == 0
  434  00000000 ...XBUS3 == 0
dispatch.c                               Atari Games Corp. macpp v9.12   "Oct 16 1997 13:26:41"


  435  00000000 ...INT0 == 0
  436  00000000 ...INT1 == 0
  437  00000000 ...INT2 == 0
  438  00000000 ...INT3 == 0
  439  00000000 ...INT4 == 0
  440  00000000 ...INT5 == 0
  441  00000000 ...IOA == 0
  442           	.include phx_vecs.mac	; count vectors requiring dispatch
    1+          ;/*		phx_vecs.mac
    2+          ; *
    3+          ; *		Copyright 1996 Atari Games Corporation
    4+          ; *	Unauthorized reproduction, adaptation, distribution, performance or 
    5+          ; *	display of this computer program or the associated audiovisual work
    6+          ; *	is strictly prohibited.
    7+          ; *
    8+          ; *	This file is processed by MACPP to produce dispatch.c and intvecs.h.
    9+          ; *
   10+          ; *	The definitions placed in intvecs.h declare virtual vector numbers
   11+          ; *	in the form of xxx_INTVEC and a cross reference table(s) so the
   12+          ; *	dispatcher can call the appropriate functions.
   13+          ; *
   14+          ; *	intvecs.h should be #include'd by any module that uses prc_set_vec().
   15+          ; */
   16+          ;
   17+          ; This file recursivley '.includes' itself to succesively build up the approprate
   18+          ; tables and functions in C and places the results in one of two files (the
   19+          ; first -out=file supplied on the MACPP command line is expected to be dispatch.c
   20+          ; and the second -out=file is expected to be intvecs.h and the third is expected to
   21+          ; be /dev/null). If you don't speak fluent MACPP, then you probably shouldn't be
   22+          ; changing anything in this file other than the VDF table listed below.
   23+          ;
   24+   (2)    .if not_defined, _DISPATCH_MAC_		;1 +++++
   25+    X     _DISPATCH_MAC_ == 0			;2 Don't move ...
   26+    X     OUTPUT_LANG == 5 ;LANG_NONE		;3 ... or change ... 
   27+    X     	.outfile 2			;4 ... anything on ...
   28+    X     	.include config.mac		;5 ... these ...
   29+    X     	.outfile 0			;6 ... nine  ...
   30+   (2)    .endc					;7 ... lines ...
   31+   (2)    .if true, (_DISPATCH_MAC_&1) != 0	;8
   32+   (3)     .if true, 0				;9 -----
   33+          
   34+    X     You are free to add or remove entries from this table according to your
   35+    X     requirements. There are 10 fields used on each line in this table. The
   36+    X     description of each field follows:
   37+          
   38+    X     Field 1 = macro call
   39+          
   40+    X     It must always be the keyword VDF (case is not significant).
   41+          
   42+    X     Field 2 = condition
   43+          
   44+    X     This is a dual operand field, so the two operands together must be enclosed in
   45+    X     <>'s. The first operand is one of T, F, D or N representing True, False,
   46+    X     Defined or Not_defined respectively. Case is significant, use uppercase only
   47+    X     please. For the conditions T or F the second operand must be an expression
   48+    X     which must resolve to non-$0 (True) or $0 (False) in order for the macro
   49+    X     to be processed (else it is ignored). The expression can contain no embedded
dispatch.c                               Atari Games Corp. macpp v9.12   "Oct 16 1997 13:26:41"


   50+    X     spaces. For the conditions D and N, the second operand must only be a symbol
   51+    X     which must be Defined or Not-defined respectively in order for the macro to be
   52+    X     processed. Some short cut expressions have been preprocessed to make using the
   53+    X     expressions a little more concise. These are:
   54+          
   55+    X     	PHX = not $0 if HOST_BOARD == PHOENIX
   56+    X     	PAD = not $0 if HOST_BOARD == PHOENIX_AD
   57+    X     	FLG = not $0 if HOST_BOARD == FLAGSTAFF
   58+    X     	SEA = not $0 if HOST_BOARD == SEATTLE
   59+    X     	VEG = not $0 if HOST_BOARD == VEGAS
   60+          
   61+    X     Field 3 = vector name
   62+          
   63+    X     The NAME field is the name of the virtual vector. An _INTVEC will be appended
   64+    X     to it in the C definitions in intvecs.h, but otherwise the name is unmolested.
   65+    X     Case is significant only if you want it to be. The R3K/R4K has an option where
   66+    X     a number of vectors are maintained in an array of pointers rather than each
   67+    X     one having its own name. The index into the array is same as the number
   68+    X     returned in the processor's CAUSE register for that particluar interrupt. This
   69+    X     procedure is done simply for performance reasons. The option is selected by
   70+    X     using a 0 for this field and using an installer function with the vector index
   71+    X     as the parameter to the installer.
   72+          
   73+    X     Field 4 = Vector pointer
   74+          
   75+    X     This field identifies the name of a variable in BSS that contains a pointer
   76+    X     to the function to call at interrupt (or will be set by the prc_set_vec()
   77+    X     function). This is the name of the "soft" or logical vector and is either
   78+    X     declared in dispatch.c or externally according to the INT/EXT field described
   79+    X     next.
   80+          
   81+    X     Field 5 = INTernal or EXTernal vector
   82+          
   83+    X     This field contains the keywords INT, EXT, VINT or VEXT identifying the vector
   84+    X     in field 4 as being defined INTernally, EXTernally, Volatile INTernally or
   85+    X     Volatile Externally to dispatch.c respectively.
   86+          
   87+    X     Field 6 = name of vector installer
   88+          
   89+    X     This field identifies the name of a function that prc_set_vec() will call to
   90+    X     actually install the vector or 0 if there is no special stuff that needs to
   91+    X     be performed during vector installation.
   92+          
   93+    X     Field 7 = Notes for the installer.
   94+          
   95+    X     The Notes field is a parameter that is passed to the installer if there is one.
   96+          
   97+    X     Field 8 = Physical vector attachment.
   98+          
   99+    X     A dispatch routine is constructed for each of the 4 XBUS interrupts and for each of
  100+    X     the 6 CPU interrupts.  This field instructs phx_vecs.mac into which of the XBUS or
  101+    X     INTx dispatchers a caller to this vector belongs.  If this vector is not associated
  102+    X     with an XBUS or an INTx interrupt, it needs to be -1.  Place the interrupt routines
  103+    X     in this table in the order in which you want them executed.
  104+          
  105+    X     Field 9 = Default function.
  106+          
dispatch.c                               Atari Games Corp. macpp v9.12   "Oct 16 1997 13:26:41"


  107+    X     Name of default routine to install in the vector, or 0 if none.  phx_vecs.mac builds
  108+    X     a function called prc_init_vecs(void) which, when called, will perform a string of
  109+    X     prc_set_vec()'s for all the vectors having this field non-zero.  After the vectors
  110+    X     have been loaded, prc_init_vecs(void) will map the phoenix and galileo interrupts as
  111+    X     specified in phoenix.mac.
  112+          
  113+    X     Field 10 = Comments.
  114+          
  115+    X     The Comments field is placed on selected lines in intvecs.h and/or dispatch.c
  116+    X     as simple 'C' comments.
  117+          
  118+   (3)     .endc				; Don't move this line
  119+          ;
  120+          ;   Condit	Name	   Vector   I/E	Installer   Notes      Phys	Default	Comments
  121+          ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  122+          VDF <T,1>	GAMEVB,	   gameint, EXT	0,          0,		-1,	0,	< post-wierdness Vblank >
  123+          VDF <T,1>	MS4,       ms4vec,  EXT	0,          0,		-1,	0,	< 4 Millisecond timer >
  124+          VDF <T,1>	PRC_DELAY, prc_delay_vec, EXT 0,    0,		-1,	sst_prc_delay, < prc_delay soft vector >
  125+          VDF <T,1>	PRC_SET_IPL, set_ipl_vec, INT 0,    0,		-1,	0,	< prc_set_ipl soft vector >
  126+          VDF <T,1>	SAVE,      savintp, EXT 0,          0,		-1,	0,	< context save soft vector >
  127+          VDF <T,1>	RESTORE,   restintp,EXT 0,          0,		-1,	0,	< context restore soft vector >
  128+          VDF <T,1>	SW0,	   0,	    INT hwvinst,    VN_IRQ0,    -1,	0,	< Software interrupt 0 >
  129+          VDF <T,1>	SW1,	   0,       INT hwvinst,    VN_IRQ1,    -1,	0,	< Software interrupt 0 >
  130+          VDF <T,1>	INT0,	   0,       INT hwvinst,    VN_IRQ2,    -1,	int0_irq, < Hardware interrupt 0 >
  131+          VDF <T,1>	INT1,	   0,	    INT hwvinst,    VN_IRQ3,    -1,	int1_irq, < Hardware interrupt 1 >
  132+          VDF <T,PHX>	INT2,	   0,	    INT hwvinst,    VN_IRQ4,    -1,	int2_irq, < Hardware interrupt 2 >
  133+          VDF <T,1>	INT3,	   0,       INT hwvinst,    VN_IRQ5,    -1,	int3_irq, < Hardware interrupt 3 >
  134+          VDF <T,1>	INT4,	   0,	    INT hwvinst,    VN_IRQ6,    -1,	int4_irq, < Hardware interrupt 4 >
  135+          VDF <T,1>	INT5,	   0,	    INT hwvinst,    VN_IRQ7,    -1,	int5_irq, < Hardware interrupt 5 >
  136+          VDF <T,1>	TLBMOD,	   0,	    INT hwvinst,    VN_TLBM,    -1,	0,	< TLB modification >
  137+          VDF <T,1>	TLBLOAD,   0,	    INT hwvinst,    VN_TLBL,    -1,	0,	< TLB miss on I or D fetch >
  138+          VDF <T,1>	TLBSTORE,  0,	    INT hwvinst,    VN_TLBS,    -1,	0,	< TLB miss on store >
  139+          VDF <T,1>	ADDRERRL,  0,	    INT hwvinst,    VN_ADDRL,   -1,	0,	< Address error on I or D fetch >
  140+          VDF <T,1>	ADDRERRS,  0,	    INT hwvinst,    VN_ADDRS,   -1,	0,	< Address error on store >
  141+          VDF <T,1>	BUSERRI,   0,	    INT hwvinst,    VN_BUSERRI, -1,	0,	< Bus error on I-fetch >
  142+          VDF <T,1>	BUSERRD,   0,	    INT hwvinst,    VN_BUSERRD, -1,	0,	< Bus error on D-fetch >
  143+          VDF <T,1>	SYSCALL,   0,       INT hwvinst,    VN_SYSCALL, -1,	0,	< SYSCALL instruction >
  144+          VDF <T,1>	BREAK,     0,       INT hwvinst,    VN_BREAK,   -1,	0,	< Breakpoint instruction >
  145+          VDF <T,1>	RESERV,    0,       INT hwvinst,    VN_RESERV,  -1,	0,	< Reserved instruction >
  146+          VDF <T,1>	COPROC,    0,       INT hwvinst,    VN_COPROC,  -1,	0,	< Coprocessor unusable >
  147+          VDF <T,1>	OVRFLOW,   0,       INT hwvinst,    VN_OVERFL,  -1,	0,	< Integer Arithmetic Overflow >
  148+          VDF <T,1>	TRAP,      0,       INT hwvinst,    VN_TRAPV,   -1,	0,	< TRAP exception >
  149+          VDF <T,1>	FLOAT,     0,       INT hwvinst,    VN_FPE,     -1,	0,	< FLoating point exception >
  150+          VDF <T,1>	TIMER,	   timervec, INT 0,	    0,          -1,	0,	< Soft Timer interrupt >
  151+          VDF <T,1>	TIMERPLL,  tpllvec, VEXT 0,	    0,		-1,	0,	<Adjust 1MS timer>
  152+          VDF <T,1>	GAMEFRAME, framevec,INT 0,	    0,		-1,	0,	< Frame complete >
  153+   (3)    .if true, PHX
  154+    X     VDF <D,NET_LVL>	NET,       netintp, INT 0,          0,		NET_LVL,0,	< network int soft vector >
  155+    X     VDF <D,XBUS>	XBUS,	   xbusintp, INT pvinst,    XBUS_NOTES,	XBUS_LVL,xbus_irq, < Any XBUS interrupt >
  156+    X     VDF <T,XS0>	XS0,       xs0intp, INT pvinst,	    XS0_NOTES,	XS0_LVL,0,	< Expansion Slot 0 interrupt >
  157+    X     VDF <T,XS1>	XS1,       xs1intp, INT pvinst,	    XS1_NOTES,	XS1_LVL,0,	< Expansion Slot 1 interrupt >
  158+    X     VDF <T,XS2>	XS2,       xs2intp, INT pvinst,	    XS2_NOTES,	XS2_LVL,0,	< Expansion Slot 2 interrupt >
  159+    X     VDF <T,XS3>	XS3,       xs3intp, INT pvinst,	    XS3_NOTES,	XS3_LVL,0,	< Expansion Slot 3 interrupt >
  160+    X     VDF <T,MIO>	MIO,       miointp, INT pvinst,	    MIO_NOTES,	MIO_LVL,0,	< Miscellaneous I/O interrupt >
  161+    X     VDF <T,CU1>	CU1,       cu1intp, INT pvinst,	    CU1_NOTES,	CU1_LVL,0,	< Combo UART 1 interrupt >
  162+    X     VDF <T,CU2>	CU2,       cu2intp, INT pvinst,	    CU2_NOTES,	CU2_LVL,0,	< Combo UART 2 interrupt >
  163+    X     VDF <T,CPP>	CPP,       cppintp, INT pvinst,	    CPP_NOTES,	CPP_LVL,0,	< Combo Parallel Port interrupt >
dispatch.c                               Atari Games Corp. macpp v9.12   "Oct 16 1997 13:26:41"


  164+    X     VDF <T,PCA>	PCA,       pcaintp, INT pvinst,	    PCA_NOTES,	PCA_LVL,0,	< PCI A interrupt >
  165+    X     VDF <T,PCB>	PCB,       pcbintp, INT pvinst,	    PCB_NOTES,	PCB_LVL,0,	< PCI B interrupt >
  166+    X     VDF <T,PCC>	PCC,       pccintp, INT pvinst,	    PCC_NOTES,	PCC_LVL,0,	< PCI C interrupt >
  167+    X     VDF <T,VSY>	VSY,       vsyintp, INT pvinst,	    VSY_NOTES,	VSY_LVL,0,	< PCI D (VSYNC) interrupt >
  168+    X     VDF <T,IDE>	IDE,	   ideintp, INT pvinst,	    IDE_NOTES,	IDE_LVL,0,	< IDE interrupt >
  169+    X     VDF <T,IOA>	IOA,	   ioaintp, INT pvinst,	    IOA_NOTES,	IOA_LVL,ioa_irq,< I/O Asic interrupt >
  170+    X     VDF <T,ADC>	ADC,	   adcintp, INT pvinst,	    ADC_NOTES,	ADC_LVL,0,	< A/D Converter interrupt >
  171+    X     VDF <D,SND_I>	CAGE,      cagevec, INT 0,          0,		CAGE_LVL,aud_irq, < CAGE interrupt >
  172+   (3)    .endc
  173+   (3)    .if true, PAD || FLG || SEA || VEG
  174+          ;VDF <T,1>	IOA,	   0,	    INT hwvinst,    VN_IRQ3,	-1,	0,	< I/O Asic interrupt >
  175+          VDF <T,1>	IDE,	   0,	    INT hwvinst,    VN_IRQ4,    -1,	0,	< IDE interrupt >
  176+          VDF <T,EXP>	EXP,       expintp, INT pvinst,	    EXP_NOTES,	EXP_LVL,0,	< Expansion Slot interrupt >
  177+   (4)     .if true, PAD || SEA
  178+          VDF <T,NSS>	NSS,	   nssintp, INT pvinst,	    NSS_NOTES,  NSS_LVL,0,	< NSS/Hi-Link interrupt>
  179+   (4)     .endc
  180+   (4)     .if true, FLG
  181+    X     VDF <T,ETH>	ETH,	   ethintp, INT pvinst,     ETH_NOTES,  ETH_LVL,0,	< ethernet interrupt >
  182+    X     VDF <D,SND_I>	CAGE,	   cagevec, INT ioainst,    CAGE_NOTES, CAGE_LVL,aud_irq, < CAGE interrupt >
  183+   (4)     .endc
  184+          VDF <T,WD1>	WD1,	   wd1intp, INT pvinst,	    WD1_NOTES,  WD1_LVL,0,	< Widget interrupt 1>
  185+          VDF <T,PCI>	PCI,       pciintp, INT pvinst,	    PCI_NOTES,	PCI_LVL,0,	< PCI interrupt >
  186+          VDF <T,ADC>	ADC,	   adcintp, INT pvinst,	    ADC_NOTES,	ADC_LVL,0,	< A/D Converter interrupt >
  187+          VDF <T,WD2>	WD2,	   wd2intp, INT pvinst,	    WD2_NOTES,  WD2_LVL,0,	< Widget interrupt 2>
  188+          VDF <T,DBG>	DBG,	   dbgintp, INT pvinst,	    DBG_NOTES,	DBG_LVL,0,	< Debug switch interrupt >
  189+          VDF <T,VSY>	VSY,	   vsyintp, INT pvinst,	    VSY_NOTES,	VSY_LVL,0,	< VSYNC interrupt >
  190+   (3)    .endc
  191+          VDF <T,GAL>	GAL,	   0,       INT gvinst,	    GAL_NOTES,  GAL_LVL,galileoint, < Any Galileo Error Interrupt >
  192+          VDF <T,MOE>	MOE,	   moeintp, INT gvinst,	    MOE_NOTES,	MOE_LVL,0,	< Galileo MemOut >
  193+          VDF <T,DOE>	DOE,	   doeintp, INT gvinst,	    DOE_NOTES,	DOE_LVL,0,	< Galileo DMAOut >
  194+          VDF <T,COE>	COE,	   coeintp, INT gvinst,	    COE_NOTES,	COE_LVL,0,	< Galileo CPUOut >
  195+          VDF <T,DM0>	DM0,	   dm0intp, INT gvinst,	    DM0_NOTES,	DM0_LVL,0,	< Galileo DMA0Comp >
  196+          VDF <T,DM1>	DM1,	   dm1intp, INT gvinst,	    DM1_NOTES,	DM1_LVL,0,	< Galileo DMA1Comp >
  197+          VDF <T,DM2>	DM2,	   dm2intp, INT gvinst,	    DM2_NOTES,	DM2_LVL,0,	< Galileo DMA2Comp >
  198+          VDF <T,DM3>	DM3,	   dm3intp, INT gvinst,	    DM3_NOTES,	DM3_LVL,0,	< Galileo DMA3Comp >
  199+          VDF <T,TM0>	TM0,	   tm0intp, INT gvinst,	    TM0_NOTES,	TM0_LVL,0,	< Galileo T0Exp >
  200+          VDF <T,TM1>	TM1,	   tm1intp, INT gvinst,	    TM1_NOTES,	TM1_LVL,0,	< Galileo T1Exp >
  201+          VDF <T,TM2>	TM2,	   tm2intp, INT gvinst,	    TM2_NOTES,	TM2_LVL,0,	< Galileo T2Exp >
  202+          VDF <T,TM3>	TM3,	   tm3intp, INT gvinst,	    TM3_NOTES,	TM3_LVL,cputimerint, < Galileo T3EXP timer interrupt >
  203+          VDF <T,MRE>	MRE,	   mreintp, INT gvinst,	    MRE_NOTES,	MRE_LVL,0,	< Galileo MasRdErr >
  204+          VDF <T,SWE>	SWE,	   sweintp, INT gvinst,	    SWE_NOTES,	SWE_LVL,0,	< Galileo SlvWrErr >
  205+          VDF <T,MWE>	MWE,	   mweintp, INT gvinst,	    MWE_NOTES,	MWE_LVL,0,	< Galileo MasWrErr >
  206+          VDF <T,SRE>	SRE,	   sreintp, INT gvinst,	    SRE_NOTES,	SRE_LVL,0,	< Galileo SlvRdErr >
  207+          VDF <T,AEP>	AEP,	   aepintp, INT gvinst,	    AEP_NOTES,	AEP_LVL,0,	< Galileo AddrErr >
  208+          VDF <T,MEP>	MEP,	   mepintp, INT gvinst,	    MEP_NOTES,	MEP_LVL,0,	< Galileo MemErr >
  209+          VDF <T,MAS>	MAS,	   masintp, INT gvinst,	    MAS_NOTES,	MAS_LVL,0,	< Galileo MasAbort >
  210+          VDF <T,TAR>	TAR,	   tarintp, INT gvinst,	    TAR_NOTES,	TAR_LVL,0,	< Galileo TarAbort >
  211+          VDF <T,RTY>	RTY,	   rtyintp, INT gvinst,	    RTY_NOTES,	RTY_LVL,0,	< Galileo RetryCtr >
  212+          VDF <T,PC0>	PC0,	   pc0intp, INT gvinst,	    PC0_NOTES,	PC0_LVL,0,	< Galileo PCI Interrupt >
  213+          VDF <T,PC1>	PC1,	   pc1intp, INT gvinst,	    PC1_NOTES,	PC1_LVL,0,	< Galileo PCI Interrupt >
  214+          VDF <T,PC2>	PC2,	   pc2intp, INT gvinst,	    PC2_NOTES,	PC2_LVL,0,	< Galileo PCI Interrupt >
  215+          VDF <T,PC3>	PC3,	   pc3intp, INT gvinst,	    PC3_NOTES,	PC3_LVL,0,	< Galileo PCI Interrupt >
  216+          VDF <D,UART_LVL> UART,	   uartintp,INT ioainst,    UART_NOTES,	UART_LVL,0,	< I/O ASIC UART interrupts >
  217+          VDF <D,SND_LVL>	SND,	   sndintp, INT ioainst,    SND_NOTES,	SND_LVL, 0,	< I/O ASIC Sound interrupts >
  218+          VDF <D,MC_LVL>	MC,	   mcintp,  INT ioainst,    MC_NOTES,	MC_LVL,	0,	< I/O ASIC Microcontroller interrupt >
  219+          ;
  220+   (2)    .endc			; (_DISPATCH_MAC_&1) != 0 *** DON'T MOVE THIS LINE EITHER ***
dispatch.c                               Atari Games Corp. macpp v9.12   "Oct 16 1997 13:26:41"


  221+          ;
  222+          ;+++++++ From here on, there are few user servicable parts inside. ++++
  223+          ;
  224+          ; This is sortof how it works:
  225+          ; The first pass through, _DISPATCH_MAC_ will be 0 (set above by the .if not_defined).
  226+          ; First the copyright boilerplate is inserted into both output files and the macro VDF
  227+          ; is defined to create externs. Some struct definitions and unique externs are depositied
  228+          ; into the .h file. Next _DISPATCH_MAC_ is set to 1 and this file is .included
  229+          ; again. This will cause MACPP to read the VDF table above and output the appropriate
  230+          ; information in the .h file but ignore the rest of the file. The VDF macro is redefined,
  231+          ; and the procedure is repeated causing the creation of different items according to what
  232+          ; is needed. Once the whole .h file is built, the procedure repeats for the building of the
  233+          ; .c file.
  234+          ;
  235+   (2)    .if true, _DISPATCH_MAC_ == 0		; First (main) pass
  236+    X      PHX == 0
  237+    X      PAD == 0
  238+    X      FLG == 0
  239+    X      SEA == 0
  240+    X      VEG == 0
  241+    X      .iif true, HOST_BOARD == PHOENIX, PHX == 1 ;set the appropriate ones true as desired
  242+    X      .iif true, HOST_BOARD == PHOENIX_AD, PAD == 1 ;set the appropriate ones true as desired
  243+    X      .iif true, HOST_BOARD == FLAGSTAFF, FLG == 1 ;set the appropriate ones true as desired
  244+    X      .iif true, HOST_BOARD == SEATTLE, SEA == 1 ;set the appropriate ones true as desired
  245+    X      .iif true, HOST_BOARD == VEGAS, VEG == 1 ;set the appropriate ones true as desired
  246+          ;
  247+    X     	.macro .condit flag,exp		; The .condit macro does an expression test ...
  248+    X     	.if identical,<flag>,<T>
  249+    X     		.iif false,exp,.mexit 10 ; ... and aborts higher level macros if false
  250+    X     		.mexit
  251+    X     	.endc
  252+    X     	.if identical,<flag>,<F>
  253+    X     		.iif true,exp,.mexit 10	; ... etc.
  254+    X     		.mexit
  255+    X     	.endc
  256+    X     	.if identical,<flag>,<D>
  257+    X     		.iif not_defined,exp,.mexit 10
  258+    X     		.mexit
  259+    X     	.endc
  260+    X     	.if identical,<flag>,<N>
  261+    X     		.iif defined,exp,.mexit 10
  262+    X     		.mexit
  263+    X     	.endc
  264+    X     	.endm
  265+          ;	
  266+    X     	.macro boilerplate file_name
  267+    X     /*		file_name
  268+    X      *
  269+    X      *		Copyright 1996 Atari Games Corporation
  270+    X      *	Unauthorized reproduction, adaptation, distribution, performance or 
  271+    X      *	display of this computer program or the associated audiovisual work
  272+    X      *	is strictly prohibited.
  273+    X      *
  274+    X      * ++++++ WARNING WARNING WARNING WARNING WARNING +++++
  275+    X      * This file is machine generated. Any changes you put in here will be lost
  276+    X      * the next time phx_vecs.mac is touched. You need to make your changes to
  277+    X      * phx_vecs.mac instead of this file.
dispatch.c                               Atari Games Corp. macpp v9.12   "Oct 16 1997 13:26:41"


  278+    X      */
  279+    X     	.endm
  280+    X     	boilerplate dispatch.c
  281+    X     	.outfile	1		;The externs go into the .h file
  282+    X     	boilerplate intvecs.h
  283+    X     #if !defined(_INTVECS_H_)
  284+    X     #define _INTVECS_H_
  285+          
  286+    X     struct irq_tab {
  287+    X     	void 	(**softvec)();
  288+    X     	void    (*(*installer)(const struct irq_tab *, void(*new)()))();
  289+    X     	int	notes;
  290+    X     };
  291+          ;
  292+    X     	.macro VDF cond, name, softvec, intern, installer, notes, physical, default, comments
  293+    X     	.condit cond	
  294+    X      .if dif,<softvec>,<0>
  295+    X       ...1 == 0
  296+    X       .iif idn,<intern>,<VINT>,...1 == 1
  297+    X       .iif idn,<intern>,<VEXT>,...1 == 1
  298+    X       .if true, ...1
  299+    X     extern	void (* volatile softvec)();	/* comments */
  300+    X       .iff
  301+    X     extern  void (*softvec)();	/* comments */
  302+    X       .endc
  303+    X      .endc
  304+    X     	.endm
  305+          ;
  306+    X     	_DISPATCH_MAC_ == 1		;next time we process the IRQ table
  307+    X     	.include phx_vecs.mac		;Make the externs
  308+          
  309+    X     enum vecs {
  310+    X     	.macro VDF cond, name, softvec, intern, installer, notes, physical, default, comments
  311+    X     	.condit cond	
  312+    X         name'_INTVEC,
  313+    X     	.endm
  314+    X     	.include phx_vecs.mac		;Make the enums
  315+    X         N_INTVECS
  316+    X     };
  317+          
  318+    X     void (*prc_set_vec (unsigned int vecnum, void (*routine)() ))();
  319+    X     void prc_init_vecs(void);		/* set the default vectors */
  320+          ;
  321+          ; Add a prototype for an as yet unused function
  322+    X     .if true, 0
  323+          
  324+    X     /*		prc_set_vecp(which, what)
  325+    X      *	Sets a special vector for the interrupt identified by <which>
  326+    X      *	to call the routine specified by <what>. <what> is
  327+    X      *	a struct that contains both a pointer to the code
  328+    X      *	to execute and an optional pointer to the private
  329+    X      *	variables for that routine. This is a change from the
  330+    X      *	behavior of prc_set_vec, and is intended to allow
  331+    X      *	multiple incarnations of a given device to share code.
  332+    X      */
  333+          
  334+    X     struct opaque;
dispatch.c                               Atari Games Corp. macpp v9.12   "Oct 16 1997 13:26:41"


  335+    X     extern struct VECP_vector {
  336+    X         void (*function)(struct opaque *);	/* Who you gonna call */
  337+    X         struct opaque *cookie;		/* a magic cookie to hand him */
  338+    X     } prc_set_vecp (
  339+    X         int __which,			/* one of xxx_INTVEC */
  340+    X         struct IRQ_vector __what		/* BY VALUE!!! */
  341+    X     );
  342+    X     .endc
  343+    X     #endif		/* _INTVECS_H_ */
  344+          ;
  345+          ; At this point, we have completed all processing of the .h file
  346+          ; so switch back to the .c file
  347+          ;
  348+    X     	.outfile	0		;switch back to dispatch.c
  349+          ;
  350+    X     #include <config.h>			/* begining of dispatch.c */
  351+    X     #include <os_proto.h>
  352+    X     #include <intvecs.h>
  353+          
  354+    X     #ifndef BLABF
  355+    X     # define BLABF(x)
  356+    X     #endif
  357+          
  358+    X     #ifndef BLAB
  359+    X     # define BLAB(x)
  360+    X     #endif
  361+          
  362+    X      .if true, 1
  363+    X     	.macro VDF cond, name, softvec, intern, installer, notes, physical, default, comments
  364+    X     	.condit cond	
  365+    X       .iif idn,<name>,<XBUS0>,.mexit
  366+    X       .iif idn,<name>,<XBUS1>,.mexit
  367+    X       .iif idn,<name>,<XBUS2>,.mexit
  368+    X       .iif idn,<name>,<XBUS3>,.mexit
  369+    X       .iif idn,<name>,<INT0>,.mexit
  370+    X       .iif idn,<name>,<INT1>,.mexit
  371+    X       .iif idn,<name>,<INT2>,.mexit
  372+    X       .iif idn,<name>,<INT3>,.mexit
  373+    X       .iif idn,<name>,<INT4>,.mexit
  374+    X       .iif idn,<name>,<INT5>,.mexit
  375+    X       .if true, PHX
  376+    X         .if true, physical == XBUS0_LVL
  377+    X     	  ...XBUS0 == ...XBUS0 + 1
  378+    X     	  .mexit
  379+    X         .endc
  380+    X         .if true, physical == XBUS1_LVL
  381+    X     	  ...XBUS1 == ...XBUS1 + 1
  382+    X     	  .mexit
  383+    X         .endc
  384+    X         .if true, physical == XBUS2_LVL
  385+    X     	  ...XBUS2 == ...XBUS2 + 1
  386+    X     	  .mexit
  387+    X         .endc
  388+    X         .if true, physical == XBUS3_LVL
  389+    X     	  ...XBUS3 == ...XBUS3 + 1
  390+    X     	  .mexit
  391+    X         .endc
dispatch.c                               Atari Games Corp. macpp v9.12   "Oct 16 1997 13:26:41"


  392+    X       .endc
  393+    X       .if true, physical == INT0_LVL
  394+    X         	...INT0 == ...INT0 + 1
  395+    X     	.mexit
  396+    X       .endc
  397+    X       .if true, physical == INT1_LVL
  398+    X         	...INT1 == ...INT1 + 1
  399+    X        .if true, PAD || FLG || SEA || VEG
  400+    X     	...IOA == ...IOA + 1
  401+    X         .if ndf, notes
  402+    X     #define notes IO_MAIN_GLOBAL_INT
  403+    X         .endc
  404+    X        .endc
  405+    X     	.mexit
  406+    X       .endc
  407+    X       .if true, physical == INT2_LVL
  408+    X         	...INT2 == ...INT2 + 1
  409+    X     	.mexit
  410+    X       .endc
  411+    X       .if true, physical == INT3_LVL
  412+    X         	...INT3 == ...INT3 + 1
  413+    X     	.mexit
  414+    X       .endc
  415+    X       .if true, physical == INT4_LVL
  416+    X         	...INT4 == ...INT4 + 1
  417+    X     	.mexit
  418+    X       .endc
  419+    X       .if true, physical == INT5_LVL
  420+    X         	...INT5 == ...INT5 + 1
  421+    X     	.mexit
  422+    X       .endc
  423+    X       .if true, physical == IOASIC_LVL
  424+    X         	...IOA == ...IOA + 1
  425+    X        .if ndf, notes
  426+    X     #define notes IO_MAIN_GLOBAL_INT
  427+    X        .endc
  428+    X     	.mexit
  429+    X       .endc
  430+    X     	.endm
  431+    X     ...XBUS0 == 0
  432+    X     ...XBUS1 == 0
  433+    X     ...XBUS2 == 0
  434+    X     ...XBUS3 == 0
  435+    X     ...INT0 == 0
  436+    X     ...INT1 == 0
  437+    X     ...INT2 == 0
  438+    X     ...INT3 == 0
  439+    X     ...INT4 == 0
  440+    X     ...INT5 == 0
  441+    X     ...IOA == 0
  442+    X     	.include phx_vecs.mac	; count vectors requiring dispatch
  443+    X      .endc
  444+          ; 
  445+    X     .macro VDF cond, name, softvec, intern, installer, notes, physical, default, comments
  446+    X      .condit cond	
  447+    X      .if dif,<softvec>,<0>
  448+    X       .if idn,<intern>,<INT>
dispatch.c                               Atari Games Corp. macpp v9.12   "Oct 16 1997 13:26:41"


  449+    X     void (*softvec)();	/* comments */
  450+    X       .endc
  451+    X       .if idn,<intern>,<VINT>
  452+    X     void (* volatile softvec)();	/* comments */
  453+    X       .endc
  454+    X      .endc
  455+    X      .if dif,<default>,<0>
  456+    X       .if idn,<name>,<INT0>
  457+    X        .if true, ...INT0
  458+    X     static void 'default'(void);	/* comments */
  459+    X        .endc
  460+    X        .mexit
  461+    X       .endc
  462+    X       .if idn,<name>,<INT1>
  463+    X        .if true, ...INT1
  464+    X     static void 'default'(void);	/* comments */
  465+    X        .endc
  466+    X        .mexit
  467+    X       .endc
  468+    X       .if idn,<name>,<INT2>
  469+    X        .if true, ...INT2
  470+    X     static void 'default'(void);	/* comments */
  471+    X        .endc
  472+    X        .mexit
  473+    X       .endc
  474+    X       .if idn,<name>,<INT3>
  475+    X        .if true, ...INT3
  476+    X     static void 'default'(void);	/* comments */
  477+    X        .endc
  478+    X        .mexit
  479+    X       .endc
  480+    X       .if idn,<name>,<INT4>
  481+    X        .if true, ...INT4
  482+    X     static void 'default'(void);	/* comments */
  483+    X        .endc
  484+    X        .mexit
  485+    X       .endc
  486+    X       .if idn,<name>,<INT5>
  487+    X        .if true, ...INT5
  488+    X     static void 'default'(void);	/* comments */
  489+    X        .endc
  490+    X        .mexit
  491+    X       .endc
  492+    X       .if idn,<name>,<INT6>
  493+    X        .if true, ...INT6
  494+    X     static void 'default'(void);	/* comments */
  495+    X        .endc
  496+    X        .mexit
  497+    X       .endc
  498+    X       .if idn,<name>,<INT7>
  499+    X        .if true, ...INT7
  500+    X     static void 'default'(void);	/* comments */
  501+    X        .endc
  502+    X        .mexit
  503+    X       .endc
  504+    X       .if true, PHX
  505+    X        .if idn,<name>,<XBUS>
dispatch.c                               Atari Games Corp. macpp v9.12   "Oct 16 1997 13:26:41"


  506+    X         .if true, ...XBUS0|...XBUS1|...XBUS2|...XBUS3
  507+    X     static void 'default'(void);
  508+    X         .endc
  509+    X         .mexit
  510+    X        .endc
  511+    X        .if idn,<name>,<XBUS0>
  512+    X         .if true, ...XBUS0
  513+    X     static void 'default'(void);
  514+    X         .endc
  515+    X         .mexit
  516+    X        .endc
  517+    X        .if idn,<name>,<XBUS1>
  518+    X         .if true, ...XBUS1
  519+    X     static void 'default'(void);
  520+    X         .endc
  521+    X         .mexit
  522+    X        .endc
  523+    X        .if idn,<name>,<XBUS2>
  524+    X         .if true, ...XBUS2
  525+    X     static void 'default'(void);
  526+    X         .endc
  527+    X         .mexit
  528+    X        .endc
  529+    X        .if idn,<name>,<XBUS3>
  530+    X         .if true, ...XBUS3
  531+    X     static void 'default'(void);
  532+    X         .endc
  533+    X         .mexit
  534+    X        .endc
  535+    X       .endc			; PHX
  536+    X       .if idn,<name>,<IOA>
  537+    X        .if true, ...IOA
  538+    X     static void 'default'(void);
  539+    X        .endc
  540+    X        .mexit
  541+    X       .endc
  542+    X     extern void 'default'(void);
  543+    X      .endc
  544+    X     .endm
  545+    X     	.include phx_vecs.mac		;Declare the non-extern vectors
  546+          ;
  547+    X      .if true, ((PROCESSOR&-16) == MIPS3000) || ((PROCESSOR&-16) == MIPS4000)
  548+    X     static void (*hwvinst(const struct irq_tab *, void (*)()))();
  549+    X      .endc
  550+          ;
  551+    X     .if df, PHOENIX_INTCTL_MASK
  552+    X     static void (*pvinst(const struct irq_tab *, void (*)()))();
  553+    X     .endc
  554+          ;
  555+    X     .if df, GALILEO_INTCTL_MASK
  556+    X     static void (*gvinst(const struct irq_tab *, void (*)()))();
  557+    X     .endc
  558+          ;
  559+    X     .if true, ...IOA
  560+    X     static void (*ioainst(const struct irq_tab *, void (*)()))();
  561+    X     .endc
  562+          ;
dispatch.c                               Atari Games Corp. macpp v9.12   "Oct 16 1997 13:26:41"


  563+    X     static const struct irq_tab irq_inits[] = {
  564+    X     	.macro VDF cond, name, softvec, intern, installer, notes, physical, default, comments
  565+    X     	.condit cond	
  566+    X      .if dif,<softvec>,<0>
  567+    X      { (void (**)())&softvec, installer, notes },	/* comments */
  568+    X      .iff
  569+    X      { 0, installer, notes },	/* comments */
  570+    X      .endc
  571+    X     	.endm
  572+    X     	.include phx_vecs.mac		;Build the irq_inits array
  573+    X      { 0, 0, 0} };
  574+          ;
  575+    X     .if true, ((PROCESSOR&-16) == MIPS3000) || ((PROCESSOR&-16) == MIPS4000)
  576+          
  577+    X     extern void (*ramv_tbl[])();
  578+          
  579+    X     static void (*hwvinst(const struct irq_tab *it, void (*new)()))() {
  580+    X         int indx;
  581+    X         void (*old_rtn)();
  582+          
  583+    X         indx = it->notes;
  584+    X         if (indx >= VN_MAX) return 0;
  585+    X         old_rtn = ramv_tbl[indx];
  586+    X         ramv_tbl[indx] = new;
  587+    X         return old_rtn;
  588+    X     }
  589+          
  590+    X      .if df, PHOENIX_INTCTL_MASK
  591+    X     static void (*pvinst(const struct irq_tab *it, void (*new)()))() {
  592+          
  593+    X         if (it->notes) {
  594+    X     	BLABF(("\ndispatch: Adding 0x%08lX to main INTCTL (0x%08lX)...", it->notes, *(VU32*)INTCTL_IE));
  595+    X     	*((VU32 *)(INTCTL_IE)) |= it->notes;
  596+    X         }
  597+    X         return 0;
  598+    X     }
  599+    X      .endc
  600+          
  601+    X      .if df, GALILEO_INTCTL_MASK
  602+    X     static void (*gvinst(const struct irq_tab *it, void (*new)()))() {
  603+          
  604+    X         if (it->notes) {
  605+    X     	BLABF(("\ndispatch: Adding 0x%08lX to Galileo INTCTL (0x%08lX)...", it->notes, \
  606+    X     			*(VU32*)GALILEO_CPU_I_ENA));
  607+    X     	*((VU32 *)(GALILEO_CPU_I_ENA)) |= it->notes;
  608+    X         }
  609+    X         return 0;
  610+    X     }
  611+    X      .endc
  612+          
  613+    X      .if true, ...IOA
  614+    X     static void (*ioainst(const struct irq_tab *it, void (*new)()))() {
  615+    X     extern void prc_wait_n_usecs( int );
  616+    X         if (it->notes)
  617+    X         {
  618+    X          BLABF(("\ndispatch: Adding 0x%04X to IOASIC INTCTL: (0x%04X)...", (int)it->notes, \
  619+    X     		*(VU32*)IO_MAIN_CTL&0xFFFF));
dispatch.c                               Atari Games Corp. macpp v9.12   "Oct 16 1997 13:26:41"


  620+    X          while ( ( *((VU32 *)IO_MAIN_CTL) & it->notes ) != it->notes )
  621+    X          {
  622+    X     #ifdef LED_OUT
  623+    X           *(VU32 *)LED_OUT = ~( 1 << B_LED_RED );
  624+    X     #endif
  625+    X           do
  626+    X           {
  627+    X            *((VU32 *)IO_MAIN_CTL) |= it->notes;
  628+    X            prc_wait_n_usecs( 1000 );
  629+    X           } while ( ( *((VU32 *)IO_MAIN_CTL) & it->notes ) != it->notes );
  630+    X           prc_wait_n_usecs( 1000 );
  631+    X     #ifdef LED_OUT
  632+    X           *(VU32 *)LED_OUT |= ( 1 << B_LED_RED );
  633+    X     #endif
  634+    X          }
  635+    X         }
  636+    X         return 0;
  637+    X     }
  638+    X      .endc
  639+    X     .endc
  640+          
  641+    X     void (*prc_set_vec (unsigned int vecnum, void (*routine)() ))()
  642+    X     {
  643+    X         void (*old_rtn)();
  644+    X         void (**softvec)();
  645+    X         const struct irq_tab *tbp;
  646+    X         int old_ipl;
  647+          
  648+    X         if ( vecnum >= N_INTVECS ) return 0;
  649+    X         tbp = irq_inits+vecnum;
  650+    X         softvec = tbp->softvec;
  651+    X         old_rtn = 0;
  652+    X         old_ipl = prc_set_ipl(INTS_OFF);
  653+    X         if ( tbp->installer ) old_rtn = tbp->installer(tbp, routine);
  654+    X         if ( softvec ) {
  655+    X     	if (!old_rtn) old_rtn = *softvec;
  656+    X     	*softvec = routine;
  657+    X         }
  658+    X         prc_set_ipl(old_ipl);
  659+    X         return old_rtn;
  660+    X     }
  661+          
  662+    X      .if true, PHX
  663+    X       .if true, ...XBUS0
  664+    X     static void xbus0_irq(void) {
  665+    X     	.macro VDF cond, name, softvec, intern, installer, notes, physical, default, comments
  666+    X     	.condit cond	
  667+    X       .iif idn,<name>,<XBUS0>,.mexit
  668+    X       .iif idn,<softvec>,<0>,.mexit
  669+    X       .if true, physical == XBUS0_LVL
  670+    X         if (softvec) softvec();
  671+    X       .endc
  672+    X     	.endm
  673+    X     	.include phx_vecs.mac		; pickup all vectors assigned to XBUS0_LVL
  674+    X         return;
  675+    X     }
  676+          
dispatch.c                               Atari Games Corp. macpp v9.12   "Oct 16 1997 13:26:41"


  677+    X       .endc		; ...XBUS0
  678+    X       .if true, ...XBUS1
  679+    X     static void xbus1_irq(void) {
  680+    X     	.macro VDF cond, name, softvec, intern, installer, notes, physical, default, comments
  681+    X     	.condit cond	
  682+    X       .iif idn,<name>,<XBUS1>,.mexit
  683+    X       .iif idn,<softvec>,<0>,.mexit
  684+    X       .if true, physical == XBUS1_LVL
  685+    X         if (softvec) softvec();
  686+    X       .endc
  687+    X     	.endm
  688+    X     	.include phx_vecs.mac		; pickup all vectors assigned to XBUS1_LVL
  689+    X         return;
  690+    X     }
  691+          
  692+    X       .endc		; ...XBUS1
  693+    X       .if true, ...XBUS2
  694+    X     static void xbus2_irq(void) {
  695+    X     	.macro VDF cond, name, softvec, intern, installer, notes, physical, default, comments
  696+    X     	.condit cond	
  697+    X       .iif idn,<name>,<XBUS2>,.mexit
  698+    X       .iif idn,<softvec>,<0>,.mexit
  699+    X       .if true, physical == XBUS2_LVL
  700+    X         if (softvec) softvec();
  701+    X       .endc
  702+    X     	.endm
  703+    X     	.include phx_vecs.mac		; pickup all vectors assigned to XBUS2_LVL
  704+    X         return;
  705+    X     }
  706+          
  707+    X       .endc		; ...XBUS2
  708+    X       .if true, ...XBUS3
  709+    X     static void xbus3_irq(void) {
  710+    X     	.macro VDF cond, name, softvec, intern, installer, notes, physical, default, comments
  711+    X     	.condit cond	
  712+    X       .iif idn,<name>,<XBUS3>,.mexit
  713+    X       .iif idn,<softvec>,<0>,.mexit
  714+    X       .if true, physical == XBUS3_LVL
  715+    X         if (softvec) softvec();
  716+    X       .endc
  717+    X     	.endm
  718+    X     	.include phx_vecs.mac		; pickup all vectors assigned to XBUS3_LVL
  719+    X         return;
  720+    X     }
  721+          
  722+    X       .endc		; ...XBUS3
  723+    X      .endc		; PHX
  724+    X      .if true, ...INT0
  725+    X     static void int0_irq(void) {
  726+    X     	.macro VDF cond, name, softvec, intern, installer, notes, physical, default, comments
  727+    X     	.condit cond	
  728+    X       .iif idn,<name>,<INT0>,.mexit
  729+    X       .iif idn,<softvec>,<0>,.mexit
  730+    X       .if true, physical == INT0_LVL
  731+    X         if (softvec) softvec();
  732+    X       .endc
  733+    X     	.endm
dispatch.c                               Atari Games Corp. macpp v9.12   "Oct 16 1997 13:26:41"


  734+    X     	.include phx_vecs.mac		; pickup all vectors assigned to IRQ 0
  735+    X         return;
  736+    X     }
  737+          
  738+    X      .endc		; ...INT0
  739+    X      .if true, ...INT1
  740+    X     static void int1_irq(void) {
  741+    X     	.macro VDF cond, name, softvec, intern, installer, notes, physical, default, comments
  742+    X     	.condit cond	
  743+    X       .iif idn,<name>,<INT1>,.mexit
  744+    X       .iif idn,<softvec>,<0>,.mexit
  745+    X       .if true, physical == INT1_LVL
  746+    X         if (softvec) softvec();
  747+    X       .endc
  748+    X     	.endm
  749+    X     	.include phx_vecs.mac		; pickup all vectors assigned to IRQ 1
  750+    X         return;
  751+    X     }
  752+          
  753+    X      .endc		; ...INT1
  754+    X      .if true, ...INT2
  755+    X     static void int2_irq(void) {
  756+    X     	.macro VDF cond, name, softvec, intern, installer, notes, physical, default, comments
  757+    X     	.condit cond	
  758+    X       .iif idn,<name>,<INT2>,.mexit
  759+    X       .iif idn,<softvec>,<0>,.mexit
  760+    X       .if true, physical == INT2_LVL
  761+    X         if (softvec) softvec();
  762+    X       .endc
  763+    X     	.endm
  764+    X     	.include phx_vecs.mac		; pickup all vectors assigned to IRQ 2
  765+    X         return;
  766+    X     }
  767+          
  768+    X      .endc		; ...INT2
  769+    X      .if true, ...INT3
  770+    X     static void int3_irq(void) {
  771+    X     	.macro VDF cond, name, softvec, intern, installer, notes, physical, default, comments
  772+    X     	.condit cond	
  773+    X       .iif idn,<name>,<INT3>,.mexit
  774+    X       .iif idn,<softvec>,<0>,.mexit
  775+    X       .if true, physical == INT3_LVL
  776+    X         if (softvec) softvec();
  777+    X       .endc
  778+    X     	.endm
  779+    X     	.include phx_vecs.mac		; pickup all vectors assigned to IRQ 3
  780+    X         return;
  781+    X     }
  782+          
  783+    X      .endc		; ...INT3
  784+    X      .if true, ...INT4
  785+    X     static void int4_irq(void) {
  786+    X     	.macro VDF cond, name, softvec, intern, installer, notes, physical, default, comments
  787+    X     	.condit cond	
  788+    X       .iif idn,<name>,<INT4>,.mexit
  789+    X       .iif idn,<softvec>,<0>,.mexit
  790+    X       .if true, physical == INT4_LVL
dispatch.c                               Atari Games Corp. macpp v9.12   "Oct 16 1997 13:26:41"


  791+    X         if (softvec) softvec();
  792+    X       .endc
  793+    X     	.endm
  794+    X     	.include phx_vecs.mac		; pickup all vectors assigned to IRQ 4
  795+    X         return;
  796+    X     }
  797+          
  798+    X      .endc		; ...INT4
  799+    X      .if true, ...INT5
  800+    X     static void int5_irq(void) {
  801+    X     	.macro VDF cond, name, softvec, intern, installer, notes, physical, default, comments
  802+    X     	.condit cond	
  803+    X       .iif idn,<name>,<INT5>,.mexit
  804+    X       .iif idn,<softvec>,<0>,.mexit
  805+    X       .if true, physical == INT5_LVL
  806+    X         if (softvec) softvec();
  807+    X       .endc
  808+    X     	.endm
  809+    X     	.include phx_vecs.mac		; pickup all vectors assigned to IRQ 5
  810+    X         return;
  811+    X     }
  812+          
  813+    X      .endc		; ...INT5
  814+    X      .if true, ...IOA && PHX
  815+    X     static void ioa_irq(void) {
  816+    X     	.macro VDF cond, name, softvec, intern, installer, notes, physical, default, comments
  817+    X     	.condit cond	
  818+    X       .iif idn,<name>,<IOA>,.mexit
  819+    X       .iif idn,<softvec>,<0>,.mexit
  820+    X       .if true, physical == IOASIC_LVL
  821+    X         if (softvec) softvec();
  822+    X       .endc
  823+    X     	.endm
  824+    X     	.include phx_vecs.mac		; pickup all vectors assigned to IRQ 5
  825+    X         return;
  826+    X     }
  827+          
  828+    X      .endc		; ...IOA
  829+    X      .if true, PHX
  830+    X       .if true, ...XBUS0|...XBUS1|...XBUS2|...XBUS3
  831+    X     static void xbus_irq(void) {
  832+    X         int which;
  833+    X         which = *(VU32 *)(XBUS_SLOT0+4);
  834+    X       .if true, ...XBUS0
  835+    X         if (!(which&1)) xbus0_irq();
  836+    X       .endc
  837+    X       .if true, ...XBUS1
  838+    X         if (!(which&2)) xbus1_irq();
  839+    X       .endc
  840+    X       .if true, ...XBUS2
  841+    X         if (!(which&4)) xbus2_irq();
  842+    X       .endc
  843+    X       .if true, ...XBUS3
  844+    X         if (!(which&8)) xbus3_irq();
  845+    X       .endc
  846+    X         return;
  847+    X     }
dispatch.c                               Atari Games Corp. macpp v9.12   "Oct 16 1997 13:26:41"


  848+    X       .endc
  849+    X      .endc		; PHX
  850+    X     void prc_init_vecs(void) {
  851+    X     	.macro VDF cond, name, softvec, intern, installer, notes, physical, default, comments
  852+    X     	.condit cond	
  853+    X     .if dif,<default>,<0>
  854+    X      .if true, PHX
  855+    X       .if idn,<name>,<XBUS0>
  856+    X        .iif true, ...XBUS0 == 0, .mexit
  857+    X       .endc
  858+    X       .if idn,<name>,<XBUS1>
  859+    X        .iif true, ...XBUS1 == 0, .mexit
  860+    X       .endc
  861+    X       .if idn,<name>,<XBUS2>
  862+    X        .iif true, ...XBUS2 == 0, .mexit
  863+    X       .endc
  864+    X       .if idn,<name>,<XBUS3>
  865+    X        .iif true, ...XBUS3 == 0, .mexit
  866+    X       .endc
  867+    X       .if idn,<name>,<XBUS>
  868+    X        .iif true, (...XBUS0|...XBUS1|...XBUS2|...XBUS3) == 0, .mexit
  869+    X       .endc
  870+    X      .endc	; PHX
  871+    X      .if idn,<name>,<INT0>
  872+    X       .iif true, ...INT0 == 0, .mexit
  873+    X      .endc
  874+    X      .if idn,<name>,<INT1>
  875+    X       .iif true, ...INT1 == 0, .mexit
  876+    X      .endc
  877+    X      .if idn,<name>,<INT2>
  878+    X       .iif true, ...INT2 == 0, .mexit
  879+    X      .endc
  880+    X      .if idn,<name>,<INT3>
  881+    X       .iif true, ...INT3 == 0, .mexit
  882+    X      .endc
  883+    X      .if idn,<name>,<INT4>
  884+    X       .iif true, ...INT4 == 0, .mexit
  885+    X      .endc
  886+    X      .if idn,<name>,<INT5>
  887+    X       .iif true, ...INT5 == 0, .mexit
  888+    X      .endc
  889+    X      .if idn,<name>,<IOA>
  890+    X       .iif true, ...IOA == 0, .mexit
  891+    X      .endc
  892+    X         prc_set_vec('name'_INTVEC, default);
  893+    X     .endc
  894+    X     	.endm
  895+    X     	.include phx_vecs.mac
  896+          
  897+    X     /* Map the Phoenix interrupts */
  898+          
  899+    X     .if df, INTCTL_MAPA_INIT
  900+    X         BLABF(("\ndispatch: Mapping the A interrupts: 0x%08lX...", INTCTL_MAPA_INIT));
  901+    X         *((VU32 *)(INTCTL_MAPA)) = INTCTL_MAPA_INIT;
  902+    X     .endc
  903+    X     .if df, INTCTL_MAPB_INIT
  904+    X         BLABF(("\ndispatch: Mapping the B interrupts: 0x%08lX...", INTCTL_MAPB_INIT));
dispatch.c                               Atari Games Corp. macpp v9.12   "Oct 16 1997 13:26:41"


  905+    X         *((VU32 *)(INTCTL_MAPB)) = INTCTL_MAPB_INIT;
  906+    X     .endc
  907+          
  908+    X     .if defined, ANNOUNCE_BOOT_ACTIONS
  909+    X      .if true, ANNOUNCE_BOOT_ACTIONS
  910+    X         {
  911+    X     	int jj;
  912+    X     	extern int prc_get_cause(void), prc_get_ipl(void);
  913+    X     	jj = prc_get_cause();
  914+    X     	if (jj&0xFF00) BLABF(("\ndispatch: CPU cause reg: %08lX, CPU SR reg: %08lX", jj, prc_get_ipl()));
  915+    X     	if (jj&0x0400) {
  916+    X       .if true, ...INT0
  917+    X     	.macro VDF cond, name, softvec, intern, installer, notes, physical, default, comments
  918+    X     	.condit cond	
  919+    X        .iif idn,<name>,<INT0>,.mexit
  920+    X        .iif idn,<softvec>,<0>,.mexit
  921+    X        .if true, physical == INT0_LVL
  922+    X     	    if (!softvec) BLAB("\ndispatch: Warning, IRQ 0 pending \"'comments'\"");
  923+    X        .endc
  924+    X     	.endm
  925+    X     	.include phx_vecs.mac		; pickup all vectors assigned to IRQ 0
  926+    X       .iff
  927+    X     	    BLAB("\ndispatch: Warning, IRQ 0 pending with no vector assigned");
  928+    X       .endc		; ...INT0
  929+    X     	}
  930+    X     	if (jj&0x0800) {
  931+    X       .if true, ...INT1
  932+    X     	.macro VDF cond, name, softvec, intern, installer, notes, physical, default, comments
  933+    X     	.condit cond	
  934+    X        .iif idn,<name>,<INT1>,.mexit
  935+    X        .iif idn,<softvec>,<0>,.mexit
  936+    X        .if true, physical == INT1_LVL
  937+    X     	    if (!softvec) BLAB("\ndispatch: Warning, IRQ 1 pending \"'comments'\"");
  938+    X        .endc
  939+    X     	.endm
  940+    X     	.include phx_vecs.mac		; pickup all vectors assigned to IRQ 1
  941+    X       .iff
  942+    X     	    BLAB("\ndispatch: Warning, IRQ 1 pending with no vector assigned");
  943+    X       .endc		; ...INT1
  944+    X     	}
  945+    X     	if (jj&0x1000) {
  946+    X       .if true, ...INT2
  947+    X     	.macro VDF cond, name, softvec, intern, installer, notes, physical, default, comments
  948+    X     	.condit cond	
  949+    X        .iif idn,<name>,<INT2>,.mexit
  950+    X        .iif idn,<softvec>,<0>,.mexit
  951+    X        .if true, physical == INT2_LVL
  952+    X     	    if (!softvec) BLAB("\ndispatch: Warning, IRQ 2 pending \"'comments'\"");
  953+    X        .endc
  954+    X     	.endm
  955+    X     	.include phx_vecs.mac		; pickup all vectors assigned to IRQ 2
  956+    X       .iff
  957+    X     	    BLAB("\ndispatch: Warning, IRQ 2 pending with no vector assigned");
  958+    X       .endc		; ...INT2
  959+    X     	}
  960+    X     	if (jj&0x2000) {
  961+    X       .if true, ...INT3
dispatch.c                               Atari Games Corp. macpp v9.12   "Oct 16 1997 13:26:41"


  962+    X     	.macro VDF cond, name, softvec, intern, installer, notes, physical, default, comments
  963+    X     	.condit cond	
  964+    X        .iif idn,<name>,<INT3>,.mexit
  965+    X        .iif idn,<softvec>,<0>,.mexit
  966+    X        .if true, physical == INT3_LVL
  967+    X     	    if (!softvec) BLAB("\ndispatch: Warning, IRQ 3 pending \"'comments'\"");
  968+    X        .endc
  969+    X     	.endm
  970+    X     	.include phx_vecs.mac		; pickup all vectors assigned to IRQ 3
  971+    X       .iff
  972+    X     	    BLAB("\ndispatch: Warning, IRQ 3 pending with no vector assigned");
  973+    X       .endc		; ...INT3
  974+    X     	}
  975+    X     	if (jj&0x4000) {
  976+    X       .if true, ...INT4
  977+    X     	.macro VDF cond, name, softvec, intern, installer, notes, physical, default, comments
  978+    X     	.condit cond	
  979+    X        .iif idn,<name>,<INT4>,.mexit
  980+    X        .iif idn,<softvec>,<0>,.mexit
  981+    X        .if true, physical == INT4_LVL
  982+    X     	    if (!softvec) BLAB("\ndispatch: Warning, IRQ 4 pending \"'comments'\"");
  983+    X        .endc
  984+    X     	.endm
  985+    X     	.include phx_vecs.mac		; pickup all vectors assigned to IRQ 4
  986+    X       .iff
  987+    X     	    BLAB("\ndispatch: Warning, IRQ 4 pending with no vector assigned");
  988+    X       .endc		; ...INT4
  989+    X     	}
  990+    X     	if (jj&0x8000) {
  991+    X       .if true, ...INT5
  992+    X     	.macro VDF cond, name, softvec, intern, installer, notes, physical, default, comments
  993+    X     	.condit cond	
  994+    X        .iif idn,<name>,<INT5>,.mexit
  995+    X        .iif idn,<softvec>,<0>,.mexit
  996+    X        .if true, physical == INT5_LVL
  997+    X     	    if (!softvec) BLAB("\ndispatch: Warning, IRQ 5 pending \"'comments'\"");
  998+    X        .endc
  999+    X     	.endm
 1000+    X     	.include phx_vecs.mac		; pickup all vectors assigned to IRQ 5
 1001+    X       .iff
 1002+    X     	    BLAB("\ndispatch: Warning, IRQ 5 pending with no vector assigned");
 1003+    X       .endc		; ...INT5
 1004+    X     	}
 1005+    X         }
 1006+    X      .endc		; true, ANNOUNCE_BOOT_ACTIONS
 1007+    X     .endc		; defined, ANNOUNCE_BOOT_ACTIONS
 1008+    X         return;
 1009+    X     }
 1010+   (2)    .endc		; _DISPATCH_MAC_ == 0
  443    (1)     .endc
  444           ; 
  445           .macro VDF cond, name, softvec, intern, installer, notes, physical, default, comments
  446            .condit cond	
  447            .if dif,<softvec>,<0>
  448             .if idn,<intern>,<INT>
  449           void (*softvec)();	/* comments */
  450             .endc
dispatch.c                               Atari Games Corp. macpp v9.12   "Oct 16 1997 13:26:41"


  451             .if idn,<intern>,<VINT>
  452           void (* volatile softvec)();	/* comments */
  453             .endc
  454            .endc
  455            .if dif,<default>,<0>
  456             .if idn,<name>,<INT0>
  457              .if true, ...INT0
  458           static void 'default'(void);	/* comments */
  459              .endc
  460              .mexit
  461             .endc
  462             .if idn,<name>,<INT1>
  463              .if true, ...INT1
  464           static void 'default'(void);	/* comments */
  465              .endc
  466              .mexit
  467             .endc
  468             .if idn,<name>,<INT2>
  469              .if true, ...INT2
  470           static void 'default'(void);	/* comments */
  471              .endc
  472              .mexit
  473             .endc
  474             .if idn,<name>,<INT3>
  475              .if true, ...INT3
  476           static void 'default'(void);	/* comments */
  477              .endc
  478              .mexit
  479             .endc
  480             .if idn,<name>,<INT4>
  481              .if true, ...INT4
  482           static void 'default'(void);	/* comments */
  483              .endc
  484              .mexit
  485             .endc
  486             .if idn,<name>,<INT5>
  487              .if true, ...INT5
  488           static void 'default'(void);	/* comments */
  489              .endc
  490              .mexit
  491             .endc
  492             .if idn,<name>,<INT6>
  493              .if true, ...INT6
  494           static void 'default'(void);	/* comments */
  495              .endc
  496              .mexit
  497             .endc
  498             .if idn,<name>,<INT7>
  499              .if true, ...INT7
  500           static void 'default'(void);	/* comments */
  501              .endc
  502              .mexit
  503             .endc
  504             .if true, PHX
  505              .if idn,<name>,<XBUS>
  506               .if true, ...XBUS0|...XBUS1|...XBUS2|...XBUS3
  507           static void 'default'(void);
dispatch.c                               Atari Games Corp. macpp v9.12   "Oct 16 1997 13:26:41"


  508               .endc
  509               .mexit
  510              .endc
  511              .if idn,<name>,<XBUS0>
  512               .if true, ...XBUS0
  513           static void 'default'(void);
  514               .endc
  515               .mexit
  516              .endc
  517              .if idn,<name>,<XBUS1>
  518               .if true, ...XBUS1
  519           static void 'default'(void);
  520               .endc
  521               .mexit
  522              .endc
  523              .if idn,<name>,<XBUS2>
  524               .if true, ...XBUS2
  525           static void 'default'(void);
  526               .endc
  527               .mexit
  528              .endc
  529              .if idn,<name>,<XBUS3>
  530               .if true, ...XBUS3
  531           static void 'default'(void);
  532               .endc
  533               .mexit
  534              .endc
  535             .endc			; PHX
  536             .if idn,<name>,<IOA>
  537              .if true, ...IOA
  538           static void 'default'(void);
  539              .endc
  540              .mexit
  541             .endc
  542           extern void 'default'(void);
  543            .endc
  544           .endm
  545           	.include phx_vecs.mac		;Declare the non-extern vectors
    1+          ;/*		phx_vecs.mac
    2+          ; *
    3+          ; *		Copyright 1996 Atari Games Corporation
    4+          ; *	Unauthorized reproduction, adaptation, distribution, performance or 
    5+          ; *	display of this computer program or the associated audiovisual work
    6+          ; *	is strictly prohibited.
    7+          ; *
    8+          ; *	This file is processed by MACPP to produce dispatch.c and intvecs.h.
    9+          ; *
   10+          ; *	The definitions placed in intvecs.h declare virtual vector numbers
   11+          ; *	in the form of xxx_INTVEC and a cross reference table(s) so the
   12+          ; *	dispatcher can call the appropriate functions.
   13+          ; *
   14+          ; *	intvecs.h should be #include'd by any module that uses prc_set_vec().
   15+          ; */
   16+          ;
   17+          ; This file recursivley '.includes' itself to succesively build up the approprate
   18+          ; tables and functions in C and places the results in one of two files (the
   19+          ; first -out=file supplied on the MACPP command line is expected to be dispatch.c
dispatch.c                               Atari Games Corp. macpp v9.12   "Oct 16 1997 13:26:41"


   20+          ; and the second -out=file is expected to be intvecs.h and the third is expected to
   21+          ; be /dev/null). If you don't speak fluent MACPP, then you probably shouldn't be
   22+          ; changing anything in this file other than the VDF table listed below.
   23+          ;
   24+   (1)    .if not_defined, _DISPATCH_MAC_		;1 +++++
   25+    X     _DISPATCH_MAC_ == 0			;2 Don't move ...
   26+    X     OUTPUT_LANG == 5 ;LANG_NONE		;3 ... or change ... 
   27+    X     	.outfile 2			;4 ... anything on ...
   28+    X     	.include config.mac		;5 ... these ...
   29+    X     	.outfile 0			;6 ... nine  ...
   30+   (1)    .endc					;7 ... lines ...
   31+   (1)    .if true, (_DISPATCH_MAC_&1) != 0	;8
   32+   (2)     .if true, 0				;9 -----
   33+          
   34+    X     You are free to add or remove entries from this table according to your
   35+    X     requirements. There are 10 fields used on each line in this table. The
   36+    X     description of each field follows:
   37+          
   38+    X     Field 1 = macro call
   39+          
   40+    X     It must always be the keyword VDF (case is not significant).
   41+          
   42+    X     Field 2 = condition
   43+          
   44+    X     This is a dual operand field, so the two operands together must be enclosed in
   45+    X     <>'s. The first operand is one of T, F, D or N representing True, False,
   46+    X     Defined or Not_defined respectively. Case is significant, use uppercase only
   47+    X     please. For the conditions T or F the second operand must be an expression
   48+    X     which must resolve to non-$0 (True) or $0 (False) in order for the macro
   49+    X     to be processed (else it is ignored). The expression can contain no embedded
   50+    X     spaces. For the conditions D and N, the second operand must only be a symbol
   51+    X     which must be Defined or Not-defined respectively in order for the macro to be
   52+    X     processed. Some short cut expressions have been preprocessed to make using the
   53+    X     expressions a little more concise. These are:
   54+          
   55+    X     	PHX = not $0 if HOST_BOARD == PHOENIX
   56+    X     	PAD = not $0 if HOST_BOARD == PHOENIX_AD
   57+    X     	FLG = not $0 if HOST_BOARD == FLAGSTAFF
   58+    X     	SEA = not $0 if HOST_BOARD == SEATTLE
   59+    X     	VEG = not $0 if HOST_BOARD == VEGAS
   60+          
   61+    X     Field 3 = vector name
   62+          
   63+    X     The NAME field is the name of the virtual vector. An _INTVEC will be appended
   64+    X     to it in the C definitions in intvecs.h, but otherwise the name is unmolested.
   65+    X     Case is significant only if you want it to be. The R3K/R4K has an option where
   66+    X     a number of vectors are maintained in an array of pointers rather than each
   67+    X     one having its own name. The index into the array is same as the number
   68+    X     returned in the processor's CAUSE register for that particluar interrupt. This
   69+    X     procedure is done simply for performance reasons. The option is selected by
   70+    X     using a 0 for this field and using an installer function with the vector index
   71+    X     as the parameter to the installer.
   72+          
   73+    X     Field 4 = Vector pointer
   74+          
   75+    X     This field identifies the name of a variable in BSS that contains a pointer
   76+    X     to the function to call at interrupt (or will be set by the prc_set_vec()
dispatch.c                               Atari Games Corp. macpp v9.12   "Oct 16 1997 13:26:41"


   77+    X     function). This is the name of the "soft" or logical vector and is either
   78+    X     declared in dispatch.c or externally according to the INT/EXT field described
   79+    X     next.
   80+          
   81+    X     Field 5 = INTernal or EXTernal vector
   82+          
   83+    X     This field contains the keywords INT, EXT, VINT or VEXT identifying the vector
   84+    X     in field 4 as being defined INTernally, EXTernally, Volatile INTernally or
   85+    X     Volatile Externally to dispatch.c respectively.
   86+          
   87+    X     Field 6 = name of vector installer
   88+          
   89+    X     This field identifies the name of a function that prc_set_vec() will call to
   90+    X     actually install the vector or 0 if there is no special stuff that needs to
   91+    X     be performed during vector installation.
   92+          
   93+    X     Field 7 = Notes for the installer.
   94+          
   95+    X     The Notes field is a parameter that is passed to the installer if there is one.
   96+          
   97+    X     Field 8 = Physical vector attachment.
   98+          
   99+    X     A dispatch routine is constructed for each of the 4 XBUS interrupts and for each of
  100+    X     the 6 CPU interrupts.  This field instructs phx_vecs.mac into which of the XBUS or
  101+    X     INTx dispatchers a caller to this vector belongs.  If this vector is not associated
  102+    X     with an XBUS or an INTx interrupt, it needs to be -1.  Place the interrupt routines
  103+    X     in this table in the order in which you want them executed.
  104+          
  105+    X     Field 9 = Default function.
  106+          
  107+    X     Name of default routine to install in the vector, or 0 if none.  phx_vecs.mac builds
  108+    X     a function called prc_init_vecs(void) which, when called, will perform a string of
  109+    X     prc_set_vec()'s for all the vectors having this field non-zero.  After the vectors
  110+    X     have been loaded, prc_init_vecs(void) will map the phoenix and galileo interrupts as
  111+    X     specified in phoenix.mac.
  112+          
  113+    X     Field 10 = Comments.
  114+          
  115+    X     The Comments field is placed on selected lines in intvecs.h and/or dispatch.c
  116+    X     as simple 'C' comments.
  117+          
  118+   (2)     .endc				; Don't move this line
  119+          ;
  120+          ;   Condit	Name	   Vector   I/E	Installer   Notes      Phys	Default	Comments
  121+          ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  122+          VDF <T,1>	GAMEVB,	   gameint, EXT	0,          0,		-1,	0,	< post-wierdness Vblank >
  123+          VDF <T,1>	MS4,       ms4vec,  EXT	0,          0,		-1,	0,	< 4 Millisecond timer >
  124+          VDF <T,1>	PRC_DELAY, prc_delay_vec, EXT 0,    0,		-1,	sst_prc_delay, < prc_delay soft vector >
  125+          VDF <T,1>	PRC_SET_IPL, set_ipl_vec, INT 0,    0,		-1,	0,	< prc_set_ipl soft vector >
  126+          VDF <T,1>	SAVE,      savintp, EXT 0,          0,		-1,	0,	< context save soft vector >
  127+          VDF <T,1>	RESTORE,   restintp,EXT 0,          0,		-1,	0,	< context restore soft vector >
  128+          VDF <T,1>	SW0,	   0,	    INT hwvinst,    VN_IRQ0,    -1,	0,	< Software interrupt 0 >
  129+          VDF <T,1>	SW1,	   0,       INT hwvinst,    VN_IRQ1,    -1,	0,	< Software interrupt 0 >
  130+          VDF <T,1>	INT0,	   0,       INT hwvinst,    VN_IRQ2,    -1,	int0_irq, < Hardware interrupt 0 >
  131+          VDF <T,1>	INT1,	   0,	    INT hwvinst,    VN_IRQ3,    -1,	int1_irq, < Hardware interrupt 1 >
  132+          VDF <T,PHX>	INT2,	   0,	    INT hwvinst,    VN_IRQ4,    -1,	int2_irq, < Hardware interrupt 2 >
  133+          VDF <T,1>	INT3,	   0,       INT hwvinst,    VN_IRQ5,    -1,	int3_irq, < Hardware interrupt 3 >
dispatch.c                               Atari Games Corp. macpp v9.12   "Oct 16 1997 13:26:41"


  134+          VDF <T,1>	INT4,	   0,	    INT hwvinst,    VN_IRQ6,    -1,	int4_irq, < Hardware interrupt 4 >
  135+          VDF <T,1>	INT5,	   0,	    INT hwvinst,    VN_IRQ7,    -1,	int5_irq, < Hardware interrupt 5 >
  136+          VDF <T,1>	TLBMOD,	   0,	    INT hwvinst,    VN_TLBM,    -1,	0,	< TLB modification >
  137+          VDF <T,1>	TLBLOAD,   0,	    INT hwvinst,    VN_TLBL,    -1,	0,	< TLB miss on I or D fetch >
  138+          VDF <T,1>	TLBSTORE,  0,	    INT hwvinst,    VN_TLBS,    -1,	0,	< TLB miss on store >
  139+          VDF <T,1>	ADDRERRL,  0,	    INT hwvinst,    VN_ADDRL,   -1,	0,	< Address error on I or D fetch >
  140+          VDF <T,1>	ADDRERRS,  0,	    INT hwvinst,    VN_ADDRS,   -1,	0,	< Address error on store >
  141+          VDF <T,1>	BUSERRI,   0,	    INT hwvinst,    VN_BUSERRI, -1,	0,	< Bus error on I-fetch >
  142+          VDF <T,1>	BUSERRD,   0,	    INT hwvinst,    VN_BUSERRD, -1,	0,	< Bus error on D-fetch >
  143+          VDF <T,1>	SYSCALL,   0,       INT hwvinst,    VN_SYSCALL, -1,	0,	< SYSCALL instruction >
  144+          VDF <T,1>	BREAK,     0,       INT hwvinst,    VN_BREAK,   -1,	0,	< Breakpoint instruction >
  145+          VDF <T,1>	RESERV,    0,       INT hwvinst,    VN_RESERV,  -1,	0,	< Reserved instruction >
  146+          VDF <T,1>	COPROC,    0,       INT hwvinst,    VN_COPROC,  -1,	0,	< Coprocessor unusable >
  147+          VDF <T,1>	OVRFLOW,   0,       INT hwvinst,    VN_OVERFL,  -1,	0,	< Integer Arithmetic Overflow >
  148+          VDF <T,1>	TRAP,      0,       INT hwvinst,    VN_TRAPV,   -1,	0,	< TRAP exception >
  149+          VDF <T,1>	FLOAT,     0,       INT hwvinst,    VN_FPE,     -1,	0,	< FLoating point exception >
  150+          VDF <T,1>	TIMER,	   timervec, INT 0,	    0,          -1,	0,	< Soft Timer interrupt >
  151+          VDF <T,1>	TIMERPLL,  tpllvec, VEXT 0,	    0,		-1,	0,	<Adjust 1MS timer>
  152+          VDF <T,1>	GAMEFRAME, framevec,INT 0,	    0,		-1,	0,	< Frame complete >
  153+   (2)    .if true, PHX
  154+    X     VDF <D,NET_LVL>	NET,       netintp, INT 0,          0,		NET_LVL,0,	< network int soft vector >
  155+    X     VDF <D,XBUS>	XBUS,	   xbusintp, INT pvinst,    XBUS_NOTES,	XBUS_LVL,xbus_irq, < Any XBUS interrupt >
  156+    X     VDF <T,XS0>	XS0,       xs0intp, INT pvinst,	    XS0_NOTES,	XS0_LVL,0,	< Expansion Slot 0 interrupt >
  157+    X     VDF <T,XS1>	XS1,       xs1intp, INT pvinst,	    XS1_NOTES,	XS1_LVL,0,	< Expansion Slot 1 interrupt >
  158+    X     VDF <T,XS2>	XS2,       xs2intp, INT pvinst,	    XS2_NOTES,	XS2_LVL,0,	< Expansion Slot 2 interrupt >
  159+    X     VDF <T,XS3>	XS3,       xs3intp, INT pvinst,	    XS3_NOTES,	XS3_LVL,0,	< Expansion Slot 3 interrupt >
  160+    X     VDF <T,MIO>	MIO,       miointp, INT pvinst,	    MIO_NOTES,	MIO_LVL,0,	< Miscellaneous I/O interrupt >
  161+    X     VDF <T,CU1>	CU1,       cu1intp, INT pvinst,	    CU1_NOTES,	CU1_LVL,0,	< Combo UART 1 interrupt >
  162+    X     VDF <T,CU2>	CU2,       cu2intp, INT pvinst,	    CU2_NOTES,	CU2_LVL,0,	< Combo UART 2 interrupt >
  163+    X     VDF <T,CPP>	CPP,       cppintp, INT pvinst,	    CPP_NOTES,	CPP_LVL,0,	< Combo Parallel Port interrupt >
  164+    X     VDF <T,PCA>	PCA,       pcaintp, INT pvinst,	    PCA_NOTES,	PCA_LVL,0,	< PCI A interrupt >
  165+    X     VDF <T,PCB>	PCB,       pcbintp, INT pvinst,	    PCB_NOTES,	PCB_LVL,0,	< PCI B interrupt >
  166+    X     VDF <T,PCC>	PCC,       pccintp, INT pvinst,	    PCC_NOTES,	PCC_LVL,0,	< PCI C interrupt >
  167+    X     VDF <T,VSY>	VSY,       vsyintp, INT pvinst,	    VSY_NOTES,	VSY_LVL,0,	< PCI D (VSYNC) interrupt >
  168+    X     VDF <T,IDE>	IDE,	   ideintp, INT pvinst,	    IDE_NOTES,	IDE_LVL,0,	< IDE interrupt >
  169+    X     VDF <T,IOA>	IOA,	   ioaintp, INT pvinst,	    IOA_NOTES,	IOA_LVL,ioa_irq,< I/O Asic interrupt >
  170+    X     VDF <T,ADC>	ADC,	   adcintp, INT pvinst,	    ADC_NOTES,	ADC_LVL,0,	< A/D Converter interrupt >
  171+    X     VDF <D,SND_I>	CAGE,      cagevec, INT 0,          0,		CAGE_LVL,aud_irq, < CAGE interrupt >
  172+   (2)    .endc
  173+   (2)    .if true, PAD || FLG || SEA || VEG
  174+          ;VDF <T,1>	IOA,	   0,	    INT hwvinst,    VN_IRQ3,	-1,	0,	< I/O Asic interrupt >
  175+          VDF <T,1>	IDE,	   0,	    INT hwvinst,    VN_IRQ4,    -1,	0,	< IDE interrupt >
  176+          VDF <T,EXP>	EXP,       expintp, INT pvinst,	    EXP_NOTES,	EXP_LVL,0,	< Expansion Slot interrupt >
  177+   (3)     .if true, PAD || SEA
  178+          VDF <T,NSS>	NSS,	   nssintp, INT pvinst,	    NSS_NOTES,  NSS_LVL,0,	< NSS/Hi-Link interrupt>
  179+   (3)     .endc
  180+   (3)     .if true, FLG
  181+    X     VDF <T,ETH>	ETH,	   ethintp, INT pvinst,     ETH_NOTES,  ETH_LVL,0,	< ethernet interrupt >
  182+    X     VDF <D,SND_I>	CAGE,	   cagevec, INT ioainst,    CAGE_NOTES, CAGE_LVL,aud_irq, < CAGE interrupt >
  183+   (3)     .endc
  184+          VDF <T,WD1>	WD1,	   wd1intp, INT pvinst,	    WD1_NOTES,  WD1_LVL,0,	< Widget interrupt 1>
  185+          VDF <T,PCI>	PCI,       pciintp, INT pvinst,	    PCI_NOTES,	PCI_LVL,0,	< PCI interrupt >
  186+          VDF <T,ADC>	ADC,	   adcintp, INT pvinst,	    ADC_NOTES,	ADC_LVL,0,	< A/D Converter interrupt >
  187+          VDF <T,WD2>	WD2,	   wd2intp, INT pvinst,	    WD2_NOTES,  WD2_LVL,0,	< Widget interrupt 2>
  188+          VDF <T,DBG>	DBG,	   dbgintp, INT pvinst,	    DBG_NOTES,	DBG_LVL,0,	< Debug switch interrupt >
  189+          VDF <T,VSY>	VSY,	   vsyintp, INT pvinst,	    VSY_NOTES,	VSY_LVL,0,	< VSYNC interrupt >
  190+   (2)    .endc
dispatch.c                               Atari Games Corp. macpp v9.12   "Oct 16 1997 13:26:41"


  191+          VDF <T,GAL>	GAL,	   0,       INT gvinst,	    GAL_NOTES,  GAL_LVL,galileoint, < Any Galileo Error Interrupt >
  192+          VDF <T,MOE>	MOE,	   moeintp, INT gvinst,	    MOE_NOTES,	MOE_LVL,0,	< Galileo MemOut >
  193+          VDF <T,DOE>	DOE,	   doeintp, INT gvinst,	    DOE_NOTES,	DOE_LVL,0,	< Galileo DMAOut >
  194+          VDF <T,COE>	COE,	   coeintp, INT gvinst,	    COE_NOTES,	COE_LVL,0,	< Galileo CPUOut >
  195+          VDF <T,DM0>	DM0,	   dm0intp, INT gvinst,	    DM0_NOTES,	DM0_LVL,0,	< Galileo DMA0Comp >
  196+          VDF <T,DM1>	DM1,	   dm1intp, INT gvinst,	    DM1_NOTES,	DM1_LVL,0,	< Galileo DMA1Comp >
  197+          VDF <T,DM2>	DM2,	   dm2intp, INT gvinst,	    DM2_NOTES,	DM2_LVL,0,	< Galileo DMA2Comp >
  198+          VDF <T,DM3>	DM3,	   dm3intp, INT gvinst,	    DM3_NOTES,	DM3_LVL,0,	< Galileo DMA3Comp >
  199+          VDF <T,TM0>	TM0,	   tm0intp, INT gvinst,	    TM0_NOTES,	TM0_LVL,0,	< Galileo T0Exp >
  200+          VDF <T,TM1>	TM1,	   tm1intp, INT gvinst,	    TM1_NOTES,	TM1_LVL,0,	< Galileo T1Exp >
  201+          VDF <T,TM2>	TM2,	   tm2intp, INT gvinst,	    TM2_NOTES,	TM2_LVL,0,	< Galileo T2Exp >
  202+          VDF <T,TM3>	TM3,	   tm3intp, INT gvinst,	    TM3_NOTES,	TM3_LVL,cputimerint, < Galileo T3EXP timer interrupt >
  203+          VDF <T,MRE>	MRE,	   mreintp, INT gvinst,	    MRE_NOTES,	MRE_LVL,0,	< Galileo MasRdErr >
  204+          VDF <T,SWE>	SWE,	   sweintp, INT gvinst,	    SWE_NOTES,	SWE_LVL,0,	< Galileo SlvWrErr >
  205+          VDF <T,MWE>	MWE,	   mweintp, INT gvinst,	    MWE_NOTES,	MWE_LVL,0,	< Galileo MasWrErr >
  206+          VDF <T,SRE>	SRE,	   sreintp, INT gvinst,	    SRE_NOTES,	SRE_LVL,0,	< Galileo SlvRdErr >
  207+          VDF <T,AEP>	AEP,	   aepintp, INT gvinst,	    AEP_NOTES,	AEP_LVL,0,	< Galileo AddrErr >
  208+          VDF <T,MEP>	MEP,	   mepintp, INT gvinst,	    MEP_NOTES,	MEP_LVL,0,	< Galileo MemErr >
  209+          VDF <T,MAS>	MAS,	   masintp, INT gvinst,	    MAS_NOTES,	MAS_LVL,0,	< Galileo MasAbort >
  210+          VDF <T,TAR>	TAR,	   tarintp, INT gvinst,	    TAR_NOTES,	TAR_LVL,0,	< Galileo TarAbort >
  211+          VDF <T,RTY>	RTY,	   rtyintp, INT gvinst,	    RTY_NOTES,	RTY_LVL,0,	< Galileo RetryCtr >
  212+          VDF <T,PC0>	PC0,	   pc0intp, INT gvinst,	    PC0_NOTES,	PC0_LVL,0,	< Galileo PCI Interrupt >
  213+          VDF <T,PC1>	PC1,	   pc1intp, INT gvinst,	    PC1_NOTES,	PC1_LVL,0,	< Galileo PCI Interrupt >
  214+          VDF <T,PC2>	PC2,	   pc2intp, INT gvinst,	    PC2_NOTES,	PC2_LVL,0,	< Galileo PCI Interrupt >
  215+          VDF <T,PC3>	PC3,	   pc3intp, INT gvinst,	    PC3_NOTES,	PC3_LVL,0,	< Galileo PCI Interrupt >
  216+          VDF <D,UART_LVL> UART,	   uartintp,INT ioainst,    UART_NOTES,	UART_LVL,0,	< I/O ASIC UART interrupts >
  217+          VDF <D,SND_LVL>	SND,	   sndintp, INT ioainst,    SND_NOTES,	SND_LVL, 0,	< I/O ASIC Sound interrupts >
  218+          VDF <D,MC_LVL>	MC,	   mcintp,  INT ioainst,    MC_NOTES,	MC_LVL,	0,	< I/O ASIC Microcontroller interrupt >
  219+          ;
  220+   (1)    .endc			; (_DISPATCH_MAC_&1) != 0 *** DON'T MOVE THIS LINE EITHER ***
  221+          ;
  222+          ;+++++++ From here on, there are few user servicable parts inside. ++++
  223+          ;
  224+          ; This is sortof how it works:
  225+          ; The first pass through, _DISPATCH_MAC_ will be 0 (set above by the .if not_defined).
  226+          ; First the copyright boilerplate is inserted into both output files and the macro VDF
  227+          ; is defined to create externs. Some struct definitions and unique externs are depositied
  228+          ; into the .h file. Next _DISPATCH_MAC_ is set to 1 and this file is .included
  229+          ; again. This will cause MACPP to read the VDF table above and output the appropriate
  230+          ; information in the .h file but ignore the rest of the file. The VDF macro is redefined,
  231+          ; and the procedure is repeated causing the creation of different items according to what
  232+          ; is needed. Once the whole .h file is built, the procedure repeats for the building of the
  233+          ; .c file.
  234+          ;
  235+   (1)    .if true, _DISPATCH_MAC_ == 0		; First (main) pass
  236+    X      PHX == 0
  237+    X      PAD == 0
  238+    X      FLG == 0
  239+    X      SEA == 0
  240+    X      VEG == 0
  241+    X      .iif true, HOST_BOARD == PHOENIX, PHX == 1 ;set the appropriate ones true as desired
  242+    X      .iif true, HOST_BOARD == PHOENIX_AD, PAD == 1 ;set the appropriate ones true as desired
  243+    X      .iif true, HOST_BOARD == FLAGSTAFF, FLG == 1 ;set the appropriate ones true as desired
  244+    X      .iif true, HOST_BOARD == SEATTLE, SEA == 1 ;set the appropriate ones true as desired
  245+    X      .iif true, HOST_BOARD == VEGAS, VEG == 1 ;set the appropriate ones true as desired
  246+          ;
  247+    X     	.macro .condit flag,exp		; The .condit macro does an expression test ...
dispatch.c                               Atari Games Corp. macpp v9.12   "Oct 16 1997 13:26:41"


  248+    X     	.if identical,<flag>,<T>
  249+    X     		.iif false,exp,.mexit 10 ; ... and aborts higher level macros if false
  250+    X     		.mexit
  251+    X     	.endc
  252+    X     	.if identical,<flag>,<F>
  253+    X     		.iif true,exp,.mexit 10	; ... etc.
  254+    X     		.mexit
  255+    X     	.endc
  256+    X     	.if identical,<flag>,<D>
  257+    X     		.iif not_defined,exp,.mexit 10
  258+    X     		.mexit
  259+    X     	.endc
  260+    X     	.if identical,<flag>,<N>
  261+    X     		.iif defined,exp,.mexit 10
  262+    X     		.mexit
  263+    X     	.endc
  264+    X     	.endm
  265+          ;	
  266+    X     	.macro boilerplate file_name
  267+    X     /*		file_name
  268+    X      *
  269+    X      *		Copyright 1996 Atari Games Corporation
  270+    X      *	Unauthorized reproduction, adaptation, distribution, performance or 
  271+    X      *	display of this computer program or the associated audiovisual work
  272+    X      *	is strictly prohibited.
  273+    X      *
  274+    X      * ++++++ WARNING WARNING WARNING WARNING WARNING +++++
  275+    X      * This file is machine generated. Any changes you put in here will be lost
  276+    X      * the next time phx_vecs.mac is touched. You need to make your changes to
  277+    X      * phx_vecs.mac instead of this file.
  278+    X      */
  279+    X     	.endm
  280+    X     	boilerplate dispatch.c
  281+    X     	.outfile	1		;The externs go into the .h file
  282+    X     	boilerplate intvecs.h
  283+    X     #if !defined(_INTVECS_H_)
  284+    X     #define _INTVECS_H_
  285+          
  286+    X     struct irq_tab {
  287+    X     	void 	(**softvec)();
  288+    X     	void    (*(*installer)(const struct irq_tab *, void(*new)()))();
  289+    X     	int	notes;
  290+    X     };
  291+          ;
  292+    X     	.macro VDF cond, name, softvec, intern, installer, notes, physical, default, comments
  293+    X     	.condit cond	
  294+    X      .if dif,<softvec>,<0>
  295+    X       ...1 == 0
  296+    X       .iif idn,<intern>,<VINT>,...1 == 1
  297+    X       .iif idn,<intern>,<VEXT>,...1 == 1
  298+    X       .if true, ...1
  299+    X     extern	void (* volatile softvec)();	/* comments */
  300+    X       .iff
  301+    X     extern  void (*softvec)();	/* comments */
  302+    X       .endc
  303+    X      .endc
  304+    X     	.endm
dispatch.c                               Atari Games Corp. macpp v9.12   "Oct 16 1997 13:26:41"


  305+          ;
  306+    X     	_DISPATCH_MAC_ == 1		;next time we process the IRQ table
  307+    X     	.include phx_vecs.mac		;Make the externs
  308+          
  309+    X     enum vecs {
  310+    X     	.macro VDF cond, name, softvec, intern, installer, notes, physical, default, comments
  311+    X     	.condit cond	
  312+    X         name'_INTVEC,
  313+    X     	.endm
  314+    X     	.include phx_vecs.mac		;Make the enums
  315+    X         N_INTVECS
  316+    X     };
  317+          
  318+    X     void (*prc_set_vec (unsigned int vecnum, void (*routine)() ))();
  319+    X     void prc_init_vecs(void);		/* set the default vectors */
  320+          ;
  321+          ; Add a prototype for an as yet unused function
  322+    X     .if true, 0
  323+          
  324+    X     /*		prc_set_vecp(which, what)
  325+    X      *	Sets a special vector for the interrupt identified by <which>
  326+    X      *	to call the routine specified by <what>. <what> is
  327+    X      *	a struct that contains both a pointer to the code
  328+    X      *	to execute and an optional pointer to the private
  329+    X      *	variables for that routine. This is a change from the
  330+    X      *	behavior of prc_set_vec, and is intended to allow
  331+    X      *	multiple incarnations of a given device to share code.
  332+    X      */
  333+          
  334+    X     struct opaque;
  335+    X     extern struct VECP_vector {
  336+    X         void (*function)(struct opaque *);	/* Who you gonna call */
  337+    X         struct opaque *cookie;		/* a magic cookie to hand him */
  338+    X     } prc_set_vecp (
  339+    X         int __which,			/* one of xxx_INTVEC */
  340+    X         struct IRQ_vector __what		/* BY VALUE!!! */
  341+    X     );
  342+    X     .endc
  343+    X     #endif		/* _INTVECS_H_ */
  344+          ;
  345+          ; At this point, we have completed all processing of the .h file
  346+          ; so switch back to the .c file
  347+          ;
  348+    X     	.outfile	0		;switch back to dispatch.c
  349+          ;
  350+    X     #include <config.h>			/* begining of dispatch.c */
  351+    X     #include <os_proto.h>
  352+    X     #include <intvecs.h>
  353+          
  354+    X     #ifndef BLABF
  355+    X     # define BLABF(x)
  356+    X     #endif
  357+          
  358+    X     #ifndef BLAB
  359+    X     # define BLAB(x)
  360+    X     #endif
  361+          
dispatch.c                               Atari Games Corp. macpp v9.12   "Oct 16 1997 13:26:41"


  362+    X      .if true, 1
  363+    X     	.macro VDF cond, name, softvec, intern, installer, notes, physical, default, comments
  364+    X     	.condit cond	
  365+    X       .iif idn,<name>,<XBUS0>,.mexit
  366+    X       .iif idn,<name>,<XBUS1>,.mexit
  367+    X       .iif idn,<name>,<XBUS2>,.mexit
  368+    X       .iif idn,<name>,<XBUS3>,.mexit
  369+    X       .iif idn,<name>,<INT0>,.mexit
  370+    X       .iif idn,<name>,<INT1>,.mexit
  371+    X       .iif idn,<name>,<INT2>,.mexit
  372+    X       .iif idn,<name>,<INT3>,.mexit
  373+    X       .iif idn,<name>,<INT4>,.mexit
  374+    X       .iif idn,<name>,<INT5>,.mexit
  375+    X       .if true, PHX
  376+    X         .if true, physical == XBUS0_LVL
  377+    X     	  ...XBUS0 == ...XBUS0 + 1
  378+    X     	  .mexit
  379+    X         .endc
  380+    X         .if true, physical == XBUS1_LVL
  381+    X     	  ...XBUS1 == ...XBUS1 + 1
  382+    X     	  .mexit
  383+    X         .endc
  384+    X         .if true, physical == XBUS2_LVL
  385+    X     	  ...XBUS2 == ...XBUS2 + 1
  386+    X     	  .mexit
  387+    X         .endc
  388+    X         .if true, physical == XBUS3_LVL
  389+    X     	  ...XBUS3 == ...XBUS3 + 1
  390+    X     	  .mexit
  391+    X         .endc
  392+    X       .endc
  393+    X       .if true, physical == INT0_LVL
  394+    X         	...INT0 == ...INT0 + 1
  395+    X     	.mexit
  396+    X       .endc
  397+    X       .if true, physical == INT1_LVL
  398+    X         	...INT1 == ...INT1 + 1
  399+    X        .if true, PAD || FLG || SEA || VEG
  400+    X     	...IOA == ...IOA + 1
  401+    X         .if ndf, notes
  402+    X     #define notes IO_MAIN_GLOBAL_INT
  403+    X         .endc
  404+    X        .endc
  405+    X     	.mexit
  406+    X       .endc
  407+    X       .if true, physical == INT2_LVL
  408+    X         	...INT2 == ...INT2 + 1
  409+    X     	.mexit
  410+    X       .endc
  411+    X       .if true, physical == INT3_LVL
  412+    X         	...INT3 == ...INT3 + 1
  413+    X     	.mexit
  414+    X       .endc
  415+    X       .if true, physical == INT4_LVL
  416+    X         	...INT4 == ...INT4 + 1
  417+    X     	.mexit
  418+    X       .endc
dispatch.c                               Atari Games Corp. macpp v9.12   "Oct 16 1997 13:26:41"


  419+    X       .if true, physical == INT5_LVL
  420+    X         	...INT5 == ...INT5 + 1
  421+    X     	.mexit
  422+    X       .endc
  423+    X       .if true, physical == IOASIC_LVL
  424+    X         	...IOA == ...IOA + 1
  425+    X        .if ndf, notes
  426+    X     #define notes IO_MAIN_GLOBAL_INT
  427+    X        .endc
  428+    X     	.mexit
  429+    X       .endc
  430+    X     	.endm
  431+    X     ...XBUS0 == 0
  432+    X     ...XBUS1 == 0
  433+    X     ...XBUS2 == 0
  434+    X     ...XBUS3 == 0
  435+    X     ...INT0 == 0
  436+    X     ...INT1 == 0
  437+    X     ...INT2 == 0
  438+    X     ...INT3 == 0
  439+    X     ...INT4 == 0
  440+    X     ...INT5 == 0
  441+    X     ...IOA == 0
  442+    X     	.include phx_vecs.mac	; count vectors requiring dispatch
  443+    X      .endc
  444+          ; 
  445+    X     .macro VDF cond, name, softvec, intern, installer, notes, physical, default, comments
  446+    X      .condit cond	
  447+    X      .if dif,<softvec>,<0>
  448+    X       .if idn,<intern>,<INT>
  449+    X     void (*softvec)();	/* comments */
  450+    X       .endc
  451+    X       .if idn,<intern>,<VINT>
  452+    X     void (* volatile softvec)();	/* comments */
  453+    X       .endc
  454+    X      .endc
  455+    X      .if dif,<default>,<0>
  456+    X       .if idn,<name>,<INT0>
  457+    X        .if true, ...INT0
  458+    X     static void 'default'(void);	/* comments */
  459+    X        .endc
  460+    X        .mexit
  461+    X       .endc
  462+    X       .if idn,<name>,<INT1>
  463+    X        .if true, ...INT1
  464+    X     static void 'default'(void);	/* comments */
  465+    X        .endc
  466+    X        .mexit
  467+    X       .endc
  468+    X       .if idn,<name>,<INT2>
  469+    X        .if true, ...INT2
  470+    X     static void 'default'(void);	/* comments */
  471+    X        .endc
  472+    X        .mexit
  473+    X       .endc
  474+    X       .if idn,<name>,<INT3>
  475+    X        .if true, ...INT3
dispatch.c                               Atari Games Corp. macpp v9.12   "Oct 16 1997 13:26:41"


  476+    X     static void 'default'(void);	/* comments */
  477+    X        .endc
  478+    X        .mexit
  479+    X       .endc
  480+    X       .if idn,<name>,<INT4>
  481+    X        .if true, ...INT4
  482+    X     static void 'default'(void);	/* comments */
  483+    X        .endc
  484+    X        .mexit
  485+    X       .endc
  486+    X       .if idn,<name>,<INT5>
  487+    X        .if true, ...INT5
  488+    X     static void 'default'(void);	/* comments */
  489+    X        .endc
  490+    X        .mexit
  491+    X       .endc
  492+    X       .if idn,<name>,<INT6>
  493+    X        .if true, ...INT6
  494+    X     static void 'default'(void);	/* comments */
  495+    X        .endc
  496+    X        .mexit
  497+    X       .endc
  498+    X       .if idn,<name>,<INT7>
  499+    X        .if true, ...INT7
  500+    X     static void 'default'(void);	/* comments */
  501+    X        .endc
  502+    X        .mexit
  503+    X       .endc
  504+    X       .if true, PHX
  505+    X        .if idn,<name>,<XBUS>
  506+    X         .if true, ...XBUS0|...XBUS1|...XBUS2|...XBUS3
  507+    X     static void 'default'(void);
  508+    X         .endc
  509+    X         .mexit
  510+    X        .endc
  511+    X        .if idn,<name>,<XBUS0>
  512+    X         .if true, ...XBUS0
  513+    X     static void 'default'(void);
  514+    X         .endc
  515+    X         .mexit
  516+    X        .endc
  517+    X        .if idn,<name>,<XBUS1>
  518+    X         .if true, ...XBUS1
  519+    X     static void 'default'(void);
  520+    X         .endc
  521+    X         .mexit
  522+    X        .endc
  523+    X        .if idn,<name>,<XBUS2>
  524+    X         .if true, ...XBUS2
  525+    X     static void 'default'(void);
  526+    X         .endc
  527+    X         .mexit
  528+    X        .endc
  529+    X        .if idn,<name>,<XBUS3>
  530+    X         .if true, ...XBUS3
  531+    X     static void 'default'(void);
  532+    X         .endc
dispatch.c                               Atari Games Corp. macpp v9.12   "Oct 16 1997 13:26:41"


  533+    X         .mexit
  534+    X        .endc
  535+    X       .endc			; PHX
  536+    X       .if idn,<name>,<IOA>
  537+    X        .if true, ...IOA
  538+    X     static void 'default'(void);
  539+    X        .endc
  540+    X        .mexit
  541+    X       .endc
  542+    X     extern void 'default'(void);
  543+    X      .endc
  544+    X     .endm
  545+    X     	.include phx_vecs.mac		;Declare the non-extern vectors
  546+          ;
  547+    X      .if true, ((PROCESSOR&-16) == MIPS3000) || ((PROCESSOR&-16) == MIPS4000)
  548+    X     static void (*hwvinst(const struct irq_tab *, void (*)()))();
  549+    X      .endc
  550+          ;
  551+    X     .if df, PHOENIX_INTCTL_MASK
  552+    X     static void (*pvinst(const struct irq_tab *, void (*)()))();
  553+    X     .endc
  554+          ;
  555+    X     .if df, GALILEO_INTCTL_MASK
  556+    X     static void (*gvinst(const struct irq_tab *, void (*)()))();
  557+    X     .endc
  558+          ;
  559+    X     .if true, ...IOA
  560+    X     static void (*ioainst(const struct irq_tab *, void (*)()))();
  561+    X     .endc
  562+          ;
  563+    X     static const struct irq_tab irq_inits[] = {
  564+    X     	.macro VDF cond, name, softvec, intern, installer, notes, physical, default, comments
  565+    X     	.condit cond	
  566+    X      .if dif,<softvec>,<0>
  567+    X      { (void (**)())&softvec, installer, notes },	/* comments */
  568+    X      .iff
  569+    X      { 0, installer, notes },	/* comments */
  570+    X      .endc
  571+    X     	.endm
  572+    X     	.include phx_vecs.mac		;Build the irq_inits array
  573+    X      { 0, 0, 0} };
  574+          ;
  575+    X     .if true, ((PROCESSOR&-16) == MIPS3000) || ((PROCESSOR&-16) == MIPS4000)
  576+          
  577+    X     extern void (*ramv_tbl[])();
  578+          
  579+    X     static void (*hwvinst(const struct irq_tab *it, void (*new)()))() {
  580+    X         int indx;
  581+    X         void (*old_rtn)();
  582+          
  583+    X         indx = it->notes;
  584+    X         if (indx >= VN_MAX) return 0;
  585+    X         old_rtn = ramv_tbl[indx];
  586+    X         ramv_tbl[indx] = new;
  587+    X         return old_rtn;
  588+    X     }
  589+          
dispatch.c                               Atari Games Corp. macpp v9.12   "Oct 16 1997 13:26:41"


  590+    X      .if df, PHOENIX_INTCTL_MASK
  591+    X     static void (*pvinst(const struct irq_tab *it, void (*new)()))() {
  592+          
  593+    X         if (it->notes) {
  594+    X     	BLABF(("\ndispatch: Adding 0x%08lX to main INTCTL (0x%08lX)...", it->notes, *(VU32*)INTCTL_IE));
  595+    X     	*((VU32 *)(INTCTL_IE)) |= it->notes;
  596+    X         }
  597+    X         return 0;
  598+    X     }
  599+    X      .endc
  600+          
  601+    X      .if df, GALILEO_INTCTL_MASK
  602+    X     static void (*gvinst(const struct irq_tab *it, void (*new)()))() {
  603+          
  604+    X         if (it->notes) {
  605+    X     	BLABF(("\ndispatch: Adding 0x%08lX to Galileo INTCTL (0x%08lX)...", it->notes, \
  606+    X     			*(VU32*)GALILEO_CPU_I_ENA));
  607+    X     	*((VU32 *)(GALILEO_CPU_I_ENA)) |= it->notes;
  608+    X         }
  609+    X         return 0;
  610+    X     }
  611+    X      .endc
  612+          
  613+    X      .if true, ...IOA
  614+    X     static void (*ioainst(const struct irq_tab *it, void (*new)()))() {
  615+    X     extern void prc_wait_n_usecs( int );
  616+    X         if (it->notes)
  617+    X         {
  618+    X          BLABF(("\ndispatch: Adding 0x%04X to IOASIC INTCTL: (0x%04X)...", (int)it->notes, \
  619+    X     		*(VU32*)IO_MAIN_CTL&0xFFFF));
  620+    X          while ( ( *((VU32 *)IO_MAIN_CTL) & it->notes ) != it->notes )
  621+    X          {
  622+    X     #ifdef LED_OUT
  623+    X           *(VU32 *)LED_OUT = ~( 1 << B_LED_RED );
  624+    X     #endif
  625+    X           do
  626+    X           {
  627+    X            *((VU32 *)IO_MAIN_CTL) |= it->notes;
  628+    X            prc_wait_n_usecs( 1000 );
  629+    X           } while ( ( *((VU32 *)IO_MAIN_CTL) & it->notes ) != it->notes );
  630+    X           prc_wait_n_usecs( 1000 );
  631+    X     #ifdef LED_OUT
  632+    X           *(VU32 *)LED_OUT |= ( 1 << B_LED_RED );
  633+    X     #endif
  634+    X          }
  635+    X         }
  636+    X         return 0;
  637+    X     }
  638+    X      .endc
  639+    X     .endc
  640+          
  641+    X     void (*prc_set_vec (unsigned int vecnum, void (*routine)() ))()
  642+    X     {
  643+    X         void (*old_rtn)();
  644+    X         void (**softvec)();
  645+    X         const struct irq_tab *tbp;
  646+    X         int old_ipl;
dispatch.c                               Atari Games Corp. macpp v9.12   "Oct 16 1997 13:26:41"


  647+          
  648+    X         if ( vecnum >= N_INTVECS ) return 0;
  649+    X         tbp = irq_inits+vecnum;
  650+    X         softvec = tbp->softvec;
  651+    X         old_rtn = 0;
  652+    X         old_ipl = prc_set_ipl(INTS_OFF);
  653+    X         if ( tbp->installer ) old_rtn = tbp->installer(tbp, routine);
  654+    X         if ( softvec ) {
  655+    X     	if (!old_rtn) old_rtn = *softvec;
  656+    X     	*softvec = routine;
  657+    X         }
  658+    X         prc_set_ipl(old_ipl);
  659+    X         return old_rtn;
  660+    X     }
  661+          
  662+    X      .if true, PHX
  663+    X       .if true, ...XBUS0
  664+    X     static void xbus0_irq(void) {
  665+    X     	.macro VDF cond, name, softvec, intern, installer, notes, physical, default, comments
  666+    X     	.condit cond	
  667+    X       .iif idn,<name>,<XBUS0>,.mexit
  668+    X       .iif idn,<softvec>,<0>,.mexit
  669+    X       .if true, physical == XBUS0_LVL
  670+    X         if (softvec) softvec();
  671+    X       .endc
  672+    X     	.endm
  673+    X     	.include phx_vecs.mac		; pickup all vectors assigned to XBUS0_LVL
  674+    X         return;
  675+    X     }
  676+          
  677+    X       .endc		; ...XBUS0
  678+    X       .if true, ...XBUS1
  679+    X     static void xbus1_irq(void) {
  680+    X     	.macro VDF cond, name, softvec, intern, installer, notes, physical, default, comments
  681+    X     	.condit cond	
  682+    X       .iif idn,<name>,<XBUS1>,.mexit
  683+    X       .iif idn,<softvec>,<0>,.mexit
  684+    X       .if true, physical == XBUS1_LVL
  685+    X         if (softvec) softvec();
  686+    X       .endc
  687+    X     	.endm
  688+    X     	.include phx_vecs.mac		; pickup all vectors assigned to XBUS1_LVL
  689+    X         return;
  690+    X     }
  691+          
  692+    X       .endc		; ...XBUS1
  693+    X       .if true, ...XBUS2
  694+    X     static void xbus2_irq(void) {
  695+    X     	.macro VDF cond, name, softvec, intern, installer, notes, physical, default, comments
  696+    X     	.condit cond	
  697+    X       .iif idn,<name>,<XBUS2>,.mexit
  698+    X       .iif idn,<softvec>,<0>,.mexit
  699+    X       .if true, physical == XBUS2_LVL
  700+    X         if (softvec) softvec();
  701+    X       .endc
  702+    X     	.endm
  703+    X     	.include phx_vecs.mac		; pickup all vectors assigned to XBUS2_LVL
dispatch.c                               Atari Games Corp. macpp v9.12   "Oct 16 1997 13:26:41"


  704+    X         return;
  705+    X     }
  706+          
  707+    X       .endc		; ...XBUS2
  708+    X       .if true, ...XBUS3
  709+    X     static void xbus3_irq(void) {
  710+    X     	.macro VDF cond, name, softvec, intern, installer, notes, physical, default, comments
  711+    X     	.condit cond	
  712+    X       .iif idn,<name>,<XBUS3>,.mexit
  713+    X       .iif idn,<softvec>,<0>,.mexit
  714+    X       .if true, physical == XBUS3_LVL
  715+    X         if (softvec) softvec();
  716+    X       .endc
  717+    X     	.endm
  718+    X     	.include phx_vecs.mac		; pickup all vectors assigned to XBUS3_LVL
  719+    X         return;
  720+    X     }
  721+          
  722+    X       .endc		; ...XBUS3
  723+    X      .endc		; PHX
  724+    X      .if true, ...INT0
  725+    X     static void int0_irq(void) {
  726+    X     	.macro VDF cond, name, softvec, intern, installer, notes, physical, default, comments
  727+    X     	.condit cond	
  728+    X       .iif idn,<name>,<INT0>,.mexit
  729+    X       .iif idn,<softvec>,<0>,.mexit
  730+    X       .if true, physical == INT0_LVL
  731+    X         if (softvec) softvec();
  732+    X       .endc
  733+    X     	.endm
  734+    X     	.include phx_vecs.mac		; pickup all vectors assigned to IRQ 0
  735+    X         return;
  736+    X     }
  737+          
  738+    X      .endc		; ...INT0
  739+    X      .if true, ...INT1
  740+    X     static void int1_irq(void) {
  741+    X     	.macro VDF cond, name, softvec, intern, installer, notes, physical, default, comments
  742+    X     	.condit cond	
  743+    X       .iif idn,<name>,<INT1>,.mexit
  744+    X       .iif idn,<softvec>,<0>,.mexit
  745+    X       .if true, physical == INT1_LVL
  746+    X         if (softvec) softvec();
  747+    X       .endc
  748+    X     	.endm
  749+    X     	.include phx_vecs.mac		; pickup all vectors assigned to IRQ 1
  750+    X         return;
  751+    X     }
  752+          
  753+    X      .endc		; ...INT1
  754+    X      .if true, ...INT2
  755+    X     static void int2_irq(void) {
  756+    X     	.macro VDF cond, name, softvec, intern, installer, notes, physical, default, comments
  757+    X     	.condit cond	
  758+    X       .iif idn,<name>,<INT2>,.mexit
  759+    X       .iif idn,<softvec>,<0>,.mexit
  760+    X       .if true, physical == INT2_LVL
dispatch.c                               Atari Games Corp. macpp v9.12   "Oct 16 1997 13:26:41"


  761+    X         if (softvec) softvec();
  762+    X       .endc
  763+    X     	.endm
  764+    X     	.include phx_vecs.mac		; pickup all vectors assigned to IRQ 2
  765+    X         return;
  766+    X     }
  767+          
  768+    X      .endc		; ...INT2
  769+    X      .if true, ...INT3
  770+    X     static void int3_irq(void) {
  771+    X     	.macro VDF cond, name, softvec, intern, installer, notes, physical, default, comments
  772+    X     	.condit cond	
  773+    X       .iif idn,<name>,<INT3>,.mexit
  774+    X       .iif idn,<softvec>,<0>,.mexit
  775+    X       .if true, physical == INT3_LVL
  776+    X         if (softvec) softvec();
  777+    X       .endc
  778+    X     	.endm
  779+    X     	.include phx_vecs.mac		; pickup all vectors assigned to IRQ 3
  780+    X         return;
  781+    X     }
  782+          
  783+    X      .endc		; ...INT3
  784+    X      .if true, ...INT4
  785+    X     static void int4_irq(void) {
  786+    X     	.macro VDF cond, name, softvec, intern, installer, notes, physical, default, comments
  787+    X     	.condit cond	
  788+    X       .iif idn,<name>,<INT4>,.mexit
  789+    X       .iif idn,<softvec>,<0>,.mexit
  790+    X       .if true, physical == INT4_LVL
  791+    X         if (softvec) softvec();
  792+    X       .endc
  793+    X     	.endm
  794+    X     	.include phx_vecs.mac		; pickup all vectors assigned to IRQ 4
  795+    X         return;
  796+    X     }
  797+          
  798+    X      .endc		; ...INT4
  799+    X      .if true, ...INT5
  800+    X     static void int5_irq(void) {
  801+    X     	.macro VDF cond, name, softvec, intern, installer, notes, physical, default, comments
  802+    X     	.condit cond	
  803+    X       .iif idn,<name>,<INT5>,.mexit
  804+    X       .iif idn,<softvec>,<0>,.mexit
  805+    X       .if true, physical == INT5_LVL
  806+    X         if (softvec) softvec();
  807+    X       .endc
  808+    X     	.endm
  809+    X     	.include phx_vecs.mac		; pickup all vectors assigned to IRQ 5
  810+    X         return;
  811+    X     }
  812+          
  813+    X      .endc		; ...INT5
  814+    X      .if true, ...IOA && PHX
  815+    X     static void ioa_irq(void) {
  816+    X     	.macro VDF cond, name, softvec, intern, installer, notes, physical, default, comments
  817+    X     	.condit cond	
dispatch.c                               Atari Games Corp. macpp v9.12   "Oct 16 1997 13:26:41"


  818+    X       .iif idn,<name>,<IOA>,.mexit
  819+    X       .iif idn,<softvec>,<0>,.mexit
  820+    X       .if true, physical == IOASIC_LVL
  821+    X         if (softvec) softvec();
  822+    X       .endc
  823+    X     	.endm
  824+    X     	.include phx_vecs.mac		; pickup all vectors assigned to IRQ 5
  825+    X         return;
  826+    X     }
  827+          
  828+    X      .endc		; ...IOA
  829+    X      .if true, PHX
  830+    X       .if true, ...XBUS0|...XBUS1|...XBUS2|...XBUS3
  831+    X     static void xbus_irq(void) {
  832+    X         int which;
  833+    X         which = *(VU32 *)(XBUS_SLOT0+4);
  834+    X       .if true, ...XBUS0
  835+    X         if (!(which&1)) xbus0_irq();
  836+    X       .endc
  837+    X       .if true, ...XBUS1
  838+    X         if (!(which&2)) xbus1_irq();
  839+    X       .endc
  840+    X       .if true, ...XBUS2
  841+    X         if (!(which&4)) xbus2_irq();
  842+    X       .endc
  843+    X       .if true, ...XBUS3
  844+    X         if (!(which&8)) xbus3_irq();
  845+    X       .endc
  846+    X         return;
  847+    X     }
  848+    X       .endc
  849+    X      .endc		; PHX
  850+    X     void prc_init_vecs(void) {
  851+    X     	.macro VDF cond, name, softvec, intern, installer, notes, physical, default, comments
  852+    X     	.condit cond	
  853+    X     .if dif,<default>,<0>
  854+    X      .if true, PHX
  855+    X       .if idn,<name>,<XBUS0>
  856+    X        .iif true, ...XBUS0 == 0, .mexit
  857+    X       .endc
  858+    X       .if idn,<name>,<XBUS1>
  859+    X        .iif true, ...XBUS1 == 0, .mexit
  860+    X       .endc
  861+    X       .if idn,<name>,<XBUS2>
  862+    X        .iif true, ...XBUS2 == 0, .mexit
  863+    X       .endc
  864+    X       .if idn,<name>,<XBUS3>
  865+    X        .iif true, ...XBUS3 == 0, .mexit
  866+    X       .endc
  867+    X       .if idn,<name>,<XBUS>
  868+    X        .iif true, (...XBUS0|...XBUS1|...XBUS2|...XBUS3) == 0, .mexit
  869+    X       .endc
  870+    X      .endc	; PHX
  871+    X      .if idn,<name>,<INT0>
  872+    X       .iif true, ...INT0 == 0, .mexit
  873+    X      .endc
  874+    X      .if idn,<name>,<INT1>
dispatch.c                               Atari Games Corp. macpp v9.12   "Oct 16 1997 13:26:41"


  875+    X       .iif true, ...INT1 == 0, .mexit
  876+    X      .endc
  877+    X      .if idn,<name>,<INT2>
  878+    X       .iif true, ...INT2 == 0, .mexit
  879+    X      .endc
  880+    X      .if idn,<name>,<INT3>
  881+    X       .iif true, ...INT3 == 0, .mexit
  882+    X      .endc
  883+    X      .if idn,<name>,<INT4>
  884+    X       .iif true, ...INT4 == 0, .mexit
  885+    X      .endc
  886+    X      .if idn,<name>,<INT5>
  887+    X       .iif true, ...INT5 == 0, .mexit
  888+    X      .endc
  889+    X      .if idn,<name>,<IOA>
  890+    X       .iif true, ...IOA == 0, .mexit
  891+    X      .endc
  892+    X         prc_set_vec('name'_INTVEC, default);
  893+    X     .endc
  894+    X     	.endm
  895+    X     	.include phx_vecs.mac
  896+          
  897+    X     /* Map the Phoenix interrupts */
  898+          
  899+    X     .if df, INTCTL_MAPA_INIT
  900+    X         BLABF(("\ndispatch: Mapping the A interrupts: 0x%08lX...", INTCTL_MAPA_INIT));
  901+    X         *((VU32 *)(INTCTL_MAPA)) = INTCTL_MAPA_INIT;
  902+    X     .endc
  903+    X     .if df, INTCTL_MAPB_INIT
  904+    X         BLABF(("\ndispatch: Mapping the B interrupts: 0x%08lX...", INTCTL_MAPB_INIT));
  905+    X         *((VU32 *)(INTCTL_MAPB)) = INTCTL_MAPB_INIT;
  906+    X     .endc
  907+          
  908+    X     .if defined, ANNOUNCE_BOOT_ACTIONS
  909+    X      .if true, ANNOUNCE_BOOT_ACTIONS
  910+    X         {
  911+    X     	int jj;
  912+    X     	extern int prc_get_cause(void), prc_get_ipl(void);
  913+    X     	jj = prc_get_cause();
  914+    X     	if (jj&0xFF00) BLABF(("\ndispatch: CPU cause reg: %08lX, CPU SR reg: %08lX", jj, prc_get_ipl()));
  915+    X     	if (jj&0x0400) {
  916+    X       .if true, ...INT0
  917+    X     	.macro VDF cond, name, softvec, intern, installer, notes, physical, default, comments
  918+    X     	.condit cond	
  919+    X        .iif idn,<name>,<INT0>,.mexit
  920+    X        .iif idn,<softvec>,<0>,.mexit
  921+    X        .if true, physical == INT0_LVL
  922+    X     	    if (!softvec) BLAB("\ndispatch: Warning, IRQ 0 pending \"'comments'\"");
  923+    X        .endc
  924+    X     	.endm
  925+    X     	.include phx_vecs.mac		; pickup all vectors assigned to IRQ 0
  926+    X       .iff
  927+    X     	    BLAB("\ndispatch: Warning, IRQ 0 pending with no vector assigned");
  928+    X       .endc		; ...INT0
  929+    X     	}
  930+    X     	if (jj&0x0800) {
  931+    X       .if true, ...INT1
dispatch.c                               Atari Games Corp. macpp v9.12   "Oct 16 1997 13:26:41"


  932+    X     	.macro VDF cond, name, softvec, intern, installer, notes, physical, default, comments
  933+    X     	.condit cond	
  934+    X        .iif idn,<name>,<INT1>,.mexit
  935+    X        .iif idn,<softvec>,<0>,.mexit
  936+    X        .if true, physical == INT1_LVL
  937+    X     	    if (!softvec) BLAB("\ndispatch: Warning, IRQ 1 pending \"'comments'\"");
  938+    X        .endc
  939+    X     	.endm
  940+    X     	.include phx_vecs.mac		; pickup all vectors assigned to IRQ 1
  941+    X       .iff
  942+    X     	    BLAB("\ndispatch: Warning, IRQ 1 pending with no vector assigned");
  943+    X       .endc		; ...INT1
  944+    X     	}
  945+    X     	if (jj&0x1000) {
  946+    X       .if true, ...INT2
  947+    X     	.macro VDF cond, name, softvec, intern, installer, notes, physical, default, comments
  948+    X     	.condit cond	
  949+    X        .iif idn,<name>,<INT2>,.mexit
  950+    X        .iif idn,<softvec>,<0>,.mexit
  951+    X        .if true, physical == INT2_LVL
  952+    X     	    if (!softvec) BLAB("\ndispatch: Warning, IRQ 2 pending \"'comments'\"");
  953+    X        .endc
  954+    X     	.endm
  955+    X     	.include phx_vecs.mac		; pickup all vectors assigned to IRQ 2
  956+    X       .iff
  957+    X     	    BLAB("\ndispatch: Warning, IRQ 2 pending with no vector assigned");
  958+    X       .endc		; ...INT2
  959+    X     	}
  960+    X     	if (jj&0x2000) {
  961+    X       .if true, ...INT3
  962+    X     	.macro VDF cond, name, softvec, intern, installer, notes, physical, default, comments
  963+    X     	.condit cond	
  964+    X        .iif idn,<name>,<INT3>,.mexit
  965+    X        .iif idn,<softvec>,<0>,.mexit
  966+    X        .if true, physical == INT3_LVL
  967+    X     	    if (!softvec) BLAB("\ndispatch: Warning, IRQ 3 pending \"'comments'\"");
  968+    X        .endc
  969+    X     	.endm
  970+    X     	.include phx_vecs.mac		; pickup all vectors assigned to IRQ 3
  971+    X       .iff
  972+    X     	    BLAB("\ndispatch: Warning, IRQ 3 pending with no vector assigned");
  973+    X       .endc		; ...INT3
  974+    X     	}
  975+    X     	if (jj&0x4000) {
  976+    X       .if true, ...INT4
  977+    X     	.macro VDF cond, name, softvec, intern, installer, notes, physical, default, comments
  978+    X     	.condit cond	
  979+    X        .iif idn,<name>,<INT4>,.mexit
  980+    X        .iif idn,<softvec>,<0>,.mexit
  981+    X        .if true, physical == INT4_LVL
  982+    X     	    if (!softvec) BLAB("\ndispatch: Warning, IRQ 4 pending \"'comments'\"");
  983+    X        .endc
  984+    X     	.endm
  985+    X     	.include phx_vecs.mac		; pickup all vectors assigned to IRQ 4
  986+    X       .iff
  987+    X     	    BLAB("\ndispatch: Warning, IRQ 4 pending with no vector assigned");
  988+    X       .endc		; ...INT4
dispatch.c                               Atari Games Corp. macpp v9.12   "Oct 16 1997 13:26:41"


  989+    X     	}
  990+    X     	if (jj&0x8000) {
  991+    X       .if true, ...INT5
  992+    X     	.macro VDF cond, name, softvec, intern, installer, notes, physical, default, comments
  993+    X     	.condit cond	
  994+    X        .iif idn,<name>,<INT5>,.mexit
  995+    X        .iif idn,<softvec>,<0>,.mexit
  996+    X        .if true, physical == INT5_LVL
  997+    X     	    if (!softvec) BLAB("\ndispatch: Warning, IRQ 5 pending \"'comments'\"");
  998+    X        .endc
  999+    X     	.endm
 1000+    X     	.include phx_vecs.mac		; pickup all vectors assigned to IRQ 5
 1001+    X       .iff
 1002+    X     	    BLAB("\ndispatch: Warning, IRQ 5 pending with no vector assigned");
 1003+    X       .endc		; ...INT5
 1004+    X     	}
 1005+    X         }
 1006+    X      .endc		; true, ANNOUNCE_BOOT_ACTIONS
 1007+    X     .endc		; defined, ANNOUNCE_BOOT_ACTIONS
 1008+    X         return;
 1009+    X     }
 1010+   (1)    .endc		; _DISPATCH_MAC_ == 0
  546           ;
  547    (1)     .if true, ((PROCESSOR&-16) == MIPS3000) || ((PROCESSOR&-16) == MIPS4000)
  548           static void (*hwvinst(const struct irq_tab *, void (*)()))();
  549    (1)     .endc
  550           ;
  551    (1)    .if df, PHOENIX_INTCTL_MASK
  552           static void (*pvinst(const struct irq_tab *, void (*)()))();
  553    (1)    .endc
  554           ;
  555    (1)    .if df, GALILEO_INTCTL_MASK
  556           static void (*gvinst(const struct irq_tab *, void (*)()))();
  557    (1)    .endc
  558           ;
  559    (1)    .if true, ...IOA
  560           static void (*ioainst(const struct irq_tab *, void (*)()))();
  561    (1)    .endc
  562           ;
  563           static const struct irq_tab irq_inits[] = {
  564           	.macro VDF cond, name, softvec, intern, installer, notes, physical, default, comments
  565           	.condit cond	
  566            .if dif,<softvec>,<0>
  567            { (void (**)())&softvec, installer, notes },	/* comments */
  568            .iff
  569            { 0, installer, notes },	/* comments */
  570            .endc
  571           	.endm
  572           	.include phx_vecs.mac		;Build the irq_inits array
    1+          ;/*		phx_vecs.mac
    2+          ; *
    3+          ; *		Copyright 1996 Atari Games Corporation
    4+          ; *	Unauthorized reproduction, adaptation, distribution, performance or 
    5+          ; *	display of this computer program or the associated audiovisual work
    6+          ; *	is strictly prohibited.
    7+          ; *
    8+          ; *	This file is processed by MACPP to produce dispatch.c and intvecs.h.
dispatch.c                               Atari Games Corp. macpp v9.12   "Oct 16 1997 13:26:41"


    9+          ; *
   10+          ; *	The definitions placed in intvecs.h declare virtual vector numbers
   11+          ; *	in the form of xxx_INTVEC and a cross reference table(s) so the
   12+          ; *	dispatcher can call the appropriate functions.
   13+          ; *
   14+          ; *	intvecs.h should be #include'd by any module that uses prc_set_vec().
   15+          ; */
   16+          ;
   17+          ; This file recursivley '.includes' itself to succesively build up the approprate
   18+          ; tables and functions in C and places the results in one of two files (the
   19+          ; first -out=file supplied on the MACPP command line is expected to be dispatch.c
   20+          ; and the second -out=file is expected to be intvecs.h and the third is expected to
   21+          ; be /dev/null). If you don't speak fluent MACPP, then you probably shouldn't be
   22+          ; changing anything in this file other than the VDF table listed below.
   23+          ;
   24+   (1)    .if not_defined, _DISPATCH_MAC_		;1 +++++
   25+    X     _DISPATCH_MAC_ == 0			;2 Don't move ...
   26+    X     OUTPUT_LANG == 5 ;LANG_NONE		;3 ... or change ... 
   27+    X     	.outfile 2			;4 ... anything on ...
   28+    X     	.include config.mac		;5 ... these ...
   29+    X     	.outfile 0			;6 ... nine  ...
   30+   (1)    .endc					;7 ... lines ...
   31+   (1)    .if true, (_DISPATCH_MAC_&1) != 0	;8
   32+   (2)     .if true, 0				;9 -----
   33+          
   34+    X     You are free to add or remove entries from this table according to your
   35+    X     requirements. There are 10 fields used on each line in this table. The
   36+    X     description of each field follows:
   37+          
   38+    X     Field 1 = macro call
   39+          
   40+    X     It must always be the keyword VDF (case is not significant).
   41+          
   42+    X     Field 2 = condition
   43+          
   44+    X     This is a dual operand field, so the two operands together must be enclosed in
   45+    X     <>'s. The first operand is one of T, F, D or N representing True, False,
   46+    X     Defined or Not_defined respectively. Case is significant, use uppercase only
   47+    X     please. For the conditions T or F the second operand must be an expression
   48+    X     which must resolve to non-$0 (True) or $0 (False) in order for the macro
   49+    X     to be processed (else it is ignored). The expression can contain no embedded
   50+    X     spaces. For the conditions D and N, the second operand must only be a symbol
   51+    X     which must be Defined or Not-defined respectively in order for the macro to be
   52+    X     processed. Some short cut expressions have been preprocessed to make using the
   53+    X     expressions a little more concise. These are:
   54+          
   55+    X     	PHX = not $0 if HOST_BOARD == PHOENIX
   56+    X     	PAD = not $0 if HOST_BOARD == PHOENIX_AD
   57+    X     	FLG = not $0 if HOST_BOARD == FLAGSTAFF
   58+    X     	SEA = not $0 if HOST_BOARD == SEATTLE
   59+    X     	VEG = not $0 if HOST_BOARD == VEGAS
   60+          
   61+    X     Field 3 = vector name
   62+          
   63+    X     The NAME field is the name of the virtual vector. An _INTVEC will be appended
   64+    X     to it in the C definitions in intvecs.h, but otherwise the name is unmolested.
   65+    X     Case is significant only if you want it to be. The R3K/R4K has an option where
dispatch.c                               Atari Games Corp. macpp v9.12   "Oct 16 1997 13:26:41"


   66+    X     a number of vectors are maintained in an array of pointers rather than each
   67+    X     one having its own name. The index into the array is same as the number
   68+    X     returned in the processor's CAUSE register for that particluar interrupt. This
   69+    X     procedure is done simply for performance reasons. The option is selected by
   70+    X     using a 0 for this field and using an installer function with the vector index
   71+    X     as the parameter to the installer.
   72+          
   73+    X     Field 4 = Vector pointer
   74+          
   75+    X     This field identifies the name of a variable in BSS that contains a pointer
   76+    X     to the function to call at interrupt (or will be set by the prc_set_vec()
   77+    X     function). This is the name of the "soft" or logical vector and is either
   78+    X     declared in dispatch.c or externally according to the INT/EXT field described
   79+    X     next.
   80+          
   81+    X     Field 5 = INTernal or EXTernal vector
   82+          
   83+    X     This field contains the keywords INT, EXT, VINT or VEXT identifying the vector
   84+    X     in field 4 as being defined INTernally, EXTernally, Volatile INTernally or
   85+    X     Volatile Externally to dispatch.c respectively.
   86+          
   87+    X     Field 6 = name of vector installer
   88+          
   89+    X     This field identifies the name of a function that prc_set_vec() will call to
   90+    X     actually install the vector or 0 if there is no special stuff that needs to
   91+    X     be performed during vector installation.
   92+          
   93+    X     Field 7 = Notes for the installer.
   94+          
   95+    X     The Notes field is a parameter that is passed to the installer if there is one.
   96+          
   97+    X     Field 8 = Physical vector attachment.
   98+          
   99+    X     A dispatch routine is constructed for each of the 4 XBUS interrupts and for each of
  100+    X     the 6 CPU interrupts.  This field instructs phx_vecs.mac into which of the XBUS or
  101+    X     INTx dispatchers a caller to this vector belongs.  If this vector is not associated
  102+    X     with an XBUS or an INTx interrupt, it needs to be -1.  Place the interrupt routines
  103+    X     in this table in the order in which you want them executed.
  104+          
  105+    X     Field 9 = Default function.
  106+          
  107+    X     Name of default routine to install in the vector, or 0 if none.  phx_vecs.mac builds
  108+    X     a function called prc_init_vecs(void) which, when called, will perform a string of
  109+    X     prc_set_vec()'s for all the vectors having this field non-zero.  After the vectors
  110+    X     have been loaded, prc_init_vecs(void) will map the phoenix and galileo interrupts as
  111+    X     specified in phoenix.mac.
  112+          
  113+    X     Field 10 = Comments.
  114+          
  115+    X     The Comments field is placed on selected lines in intvecs.h and/or dispatch.c
  116+    X     as simple 'C' comments.
  117+          
  118+   (2)     .endc				; Don't move this line
  119+          ;
  120+          ;   Condit	Name	   Vector   I/E	Installer   Notes      Phys	Default	Comments
  121+          ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  122+          VDF <T,1>	GAMEVB,	   gameint, EXT	0,          0,		-1,	0,	< post-wierdness Vblank >
dispatch.c                               Atari Games Corp. macpp v9.12   "Oct 16 1997 13:26:41"


  123+          VDF <T,1>	MS4,       ms4vec,  EXT	0,          0,		-1,	0,	< 4 Millisecond timer >
  124+          VDF <T,1>	PRC_DELAY, prc_delay_vec, EXT 0,    0,		-1,	sst_prc_delay, < prc_delay soft vector >
  125+          VDF <T,1>	PRC_SET_IPL, set_ipl_vec, INT 0,    0,		-1,	0,	< prc_set_ipl soft vector >
  126+          VDF <T,1>	SAVE,      savintp, EXT 0,          0,		-1,	0,	< context save soft vector >
  127+          VDF <T,1>	RESTORE,   restintp,EXT 0,          0,		-1,	0,	< context restore soft vector >
  128+          VDF <T,1>	SW0,	   0,	    INT hwvinst,    VN_IRQ0,    -1,	0,	< Software interrupt 0 >
  129+          VDF <T,1>	SW1,	   0,       INT hwvinst,    VN_IRQ1,    -1,	0,	< Software interrupt 0 >
  130+          VDF <T,1>	INT0,	   0,       INT hwvinst,    VN_IRQ2,    -1,	int0_irq, < Hardware interrupt 0 >
  131+          VDF <T,1>	INT1,	   0,	    INT hwvinst,    VN_IRQ3,    -1,	int1_irq, < Hardware interrupt 1 >
  132+          VDF <T,PHX>	INT2,	   0,	    INT hwvinst,    VN_IRQ4,    -1,	int2_irq, < Hardware interrupt 2 >
  133+          VDF <T,1>	INT3,	   0,       INT hwvinst,    VN_IRQ5,    -1,	int3_irq, < Hardware interrupt 3 >
  134+          VDF <T,1>	INT4,	   0,	    INT hwvinst,    VN_IRQ6,    -1,	int4_irq, < Hardware interrupt 4 >
  135+          VDF <T,1>	INT5,	   0,	    INT hwvinst,    VN_IRQ7,    -1,	int5_irq, < Hardware interrupt 5 >
  136+          VDF <T,1>	TLBMOD,	   0,	    INT hwvinst,    VN_TLBM,    -1,	0,	< TLB modification >
  137+          VDF <T,1>	TLBLOAD,   0,	    INT hwvinst,    VN_TLBL,    -1,	0,	< TLB miss on I or D fetch >
  138+          VDF <T,1>	TLBSTORE,  0,	    INT hwvinst,    VN_TLBS,    -1,	0,	< TLB miss on store >
  139+          VDF <T,1>	ADDRERRL,  0,	    INT hwvinst,    VN_ADDRL,   -1,	0,	< Address error on I or D fetch >
  140+          VDF <T,1>	ADDRERRS,  0,	    INT hwvinst,    VN_ADDRS,   -1,	0,	< Address error on store >
  141+          VDF <T,1>	BUSERRI,   0,	    INT hwvinst,    VN_BUSERRI, -1,	0,	< Bus error on I-fetch >
  142+          VDF <T,1>	BUSERRD,   0,	    INT hwvinst,    VN_BUSERRD, -1,	0,	< Bus error on D-fetch >
  143+          VDF <T,1>	SYSCALL,   0,       INT hwvinst,    VN_SYSCALL, -1,	0,	< SYSCALL instruction >
  144+          VDF <T,1>	BREAK,     0,       INT hwvinst,    VN_BREAK,   -1,	0,	< Breakpoint instruction >
  145+          VDF <T,1>	RESERV,    0,       INT hwvinst,    VN_RESERV,  -1,	0,	< Reserved instruction >
  146+          VDF <T,1>	COPROC,    0,       INT hwvinst,    VN_COPROC,  -1,	0,	< Coprocessor unusable >
  147+          VDF <T,1>	OVRFLOW,   0,       INT hwvinst,    VN_OVERFL,  -1,	0,	< Integer Arithmetic Overflow >
  148+          VDF <T,1>	TRAP,      0,       INT hwvinst,    VN_TRAPV,   -1,	0,	< TRAP exception >
  149+          VDF <T,1>	FLOAT,     0,       INT hwvinst,    VN_FPE,     -1,	0,	< FLoating point exception >
  150+          VDF <T,1>	TIMER,	   timervec, INT 0,	    0,          -1,	0,	< Soft Timer interrupt >
  151+          VDF <T,1>	TIMERPLL,  tpllvec, VEXT 0,	    0,		-1,	0,	<Adjust 1MS timer>
  152+          VDF <T,1>	GAMEFRAME, framevec,INT 0,	    0,		-1,	0,	< Frame complete >
  153+   (2)    .if true, PHX
  154+    X     VDF <D,NET_LVL>	NET,       netintp, INT 0,          0,		NET_LVL,0,	< network int soft vector >
  155+    X     VDF <D,XBUS>	XBUS,	   xbusintp, INT pvinst,    XBUS_NOTES,	XBUS_LVL,xbus_irq, < Any XBUS interrupt >
  156+    X     VDF <T,XS0>	XS0,       xs0intp, INT pvinst,	    XS0_NOTES,	XS0_LVL,0,	< Expansion Slot 0 interrupt >
  157+    X     VDF <T,XS1>	XS1,       xs1intp, INT pvinst,	    XS1_NOTES,	XS1_LVL,0,	< Expansion Slot 1 interrupt >
  158+    X     VDF <T,XS2>	XS2,       xs2intp, INT pvinst,	    XS2_NOTES,	XS2_LVL,0,	< Expansion Slot 2 interrupt >
  159+    X     VDF <T,XS3>	XS3,       xs3intp, INT pvinst,	    XS3_NOTES,	XS3_LVL,0,	< Expansion Slot 3 interrupt >
  160+    X     VDF <T,MIO>	MIO,       miointp, INT pvinst,	    MIO_NOTES,	MIO_LVL,0,	< Miscellaneous I/O interrupt >
  161+    X     VDF <T,CU1>	CU1,       cu1intp, INT pvinst,	    CU1_NOTES,	CU1_LVL,0,	< Combo UART 1 interrupt >
  162+    X     VDF <T,CU2>	CU2,       cu2intp, INT pvinst,	    CU2_NOTES,	CU2_LVL,0,	< Combo UART 2 interrupt >
  163+    X     VDF <T,CPP>	CPP,       cppintp, INT pvinst,	    CPP_NOTES,	CPP_LVL,0,	< Combo Parallel Port interrupt >
  164+    X     VDF <T,PCA>	PCA,       pcaintp, INT pvinst,	    PCA_NOTES,	PCA_LVL,0,	< PCI A interrupt >
  165+    X     VDF <T,PCB>	PCB,       pcbintp, INT pvinst,	    PCB_NOTES,	PCB_LVL,0,	< PCI B interrupt >
  166+    X     VDF <T,PCC>	PCC,       pccintp, INT pvinst,	    PCC_NOTES,	PCC_LVL,0,	< PCI C interrupt >
  167+    X     VDF <T,VSY>	VSY,       vsyintp, INT pvinst,	    VSY_NOTES,	VSY_LVL,0,	< PCI D (VSYNC) interrupt >
  168+    X     VDF <T,IDE>	IDE,	   ideintp, INT pvinst,	    IDE_NOTES,	IDE_LVL,0,	< IDE interrupt >
  169+    X     VDF <T,IOA>	IOA,	   ioaintp, INT pvinst,	    IOA_NOTES,	IOA_LVL,ioa_irq,< I/O Asic interrupt >
  170+    X     VDF <T,ADC>	ADC,	   adcintp, INT pvinst,	    ADC_NOTES,	ADC_LVL,0,	< A/D Converter interrupt >
  171+    X     VDF <D,SND_I>	CAGE,      cagevec, INT 0,          0,		CAGE_LVL,aud_irq, < CAGE interrupt >
  172+   (2)    .endc
  173+   (2)    .if true, PAD || FLG || SEA || VEG
  174+          ;VDF <T,1>	IOA,	   0,	    INT hwvinst,    VN_IRQ3,	-1,	0,	< I/O Asic interrupt >
  175+          VDF <T,1>	IDE,	   0,	    INT hwvinst,    VN_IRQ4,    -1,	0,	< IDE interrupt >
  176+          VDF <T,EXP>	EXP,       expintp, INT pvinst,	    EXP_NOTES,	EXP_LVL,0,	< Expansion Slot interrupt >
  177+   (3)     .if true, PAD || SEA
  178+          VDF <T,NSS>	NSS,	   nssintp, INT pvinst,	    NSS_NOTES,  NSS_LVL,0,	< NSS/Hi-Link interrupt>
  179+   (3)     .endc
dispatch.c                               Atari Games Corp. macpp v9.12   "Oct 16 1997 13:26:41"


  180+   (3)     .if true, FLG
  181+    X     VDF <T,ETH>	ETH,	   ethintp, INT pvinst,     ETH_NOTES,  ETH_LVL,0,	< ethernet interrupt >
  182+    X     VDF <D,SND_I>	CAGE,	   cagevec, INT ioainst,    CAGE_NOTES, CAGE_LVL,aud_irq, < CAGE interrupt >
  183+   (3)     .endc
  184+          VDF <T,WD1>	WD1,	   wd1intp, INT pvinst,	    WD1_NOTES,  WD1_LVL,0,	< Widget interrupt 1>
  185+          VDF <T,PCI>	PCI,       pciintp, INT pvinst,	    PCI_NOTES,	PCI_LVL,0,	< PCI interrupt >
  186+          VDF <T,ADC>	ADC,	   adcintp, INT pvinst,	    ADC_NOTES,	ADC_LVL,0,	< A/D Converter interrupt >
  187+          VDF <T,WD2>	WD2,	   wd2intp, INT pvinst,	    WD2_NOTES,  WD2_LVL,0,	< Widget interrupt 2>
  188+          VDF <T,DBG>	DBG,	   dbgintp, INT pvinst,	    DBG_NOTES,	DBG_LVL,0,	< Debug switch interrupt >
  189+          VDF <T,VSY>	VSY,	   vsyintp, INT pvinst,	    VSY_NOTES,	VSY_LVL,0,	< VSYNC interrupt >
  190+   (2)    .endc
  191+          VDF <T,GAL>	GAL,	   0,       INT gvinst,	    GAL_NOTES,  GAL_LVL,galileoint, < Any Galileo Error Interrupt >
  192+          VDF <T,MOE>	MOE,	   moeintp, INT gvinst,	    MOE_NOTES,	MOE_LVL,0,	< Galileo MemOut >
  193+          VDF <T,DOE>	DOE,	   doeintp, INT gvinst,	    DOE_NOTES,	DOE_LVL,0,	< Galileo DMAOut >
  194+          VDF <T,COE>	COE,	   coeintp, INT gvinst,	    COE_NOTES,	COE_LVL,0,	< Galileo CPUOut >
  195+          VDF <T,DM0>	DM0,	   dm0intp, INT gvinst,	    DM0_NOTES,	DM0_LVL,0,	< Galileo DMA0Comp >
  196+          VDF <T,DM1>	DM1,	   dm1intp, INT gvinst,	    DM1_NOTES,	DM1_LVL,0,	< Galileo DMA1Comp >
  197+          VDF <T,DM2>	DM2,	   dm2intp, INT gvinst,	    DM2_NOTES,	DM2_LVL,0,	< Galileo DMA2Comp >
  198+          VDF <T,DM3>	DM3,	   dm3intp, INT gvinst,	    DM3_NOTES,	DM3_LVL,0,	< Galileo DMA3Comp >
  199+          VDF <T,TM0>	TM0,	   tm0intp, INT gvinst,	    TM0_NOTES,	TM0_LVL,0,	< Galileo T0Exp >
  200+          VDF <T,TM1>	TM1,	   tm1intp, INT gvinst,	    TM1_NOTES,	TM1_LVL,0,	< Galileo T1Exp >
  201+          VDF <T,TM2>	TM2,	   tm2intp, INT gvinst,	    TM2_NOTES,	TM2_LVL,0,	< Galileo T2Exp >
  202+          VDF <T,TM3>	TM3,	   tm3intp, INT gvinst,	    TM3_NOTES,	TM3_LVL,cputimerint, < Galileo T3EXP timer interrupt >
  203+          VDF <T,MRE>	MRE,	   mreintp, INT gvinst,	    MRE_NOTES,	MRE_LVL,0,	< Galileo MasRdErr >
  204+          VDF <T,SWE>	SWE,	   sweintp, INT gvinst,	    SWE_NOTES,	SWE_LVL,0,	< Galileo SlvWrErr >
  205+          VDF <T,MWE>	MWE,	   mweintp, INT gvinst,	    MWE_NOTES,	MWE_LVL,0,	< Galileo MasWrErr >
  206+          VDF <T,SRE>	SRE,	   sreintp, INT gvinst,	    SRE_NOTES,	SRE_LVL,0,	< Galileo SlvRdErr >
  207+          VDF <T,AEP>	AEP,	   aepintp, INT gvinst,	    AEP_NOTES,	AEP_LVL,0,	< Galileo AddrErr >
  208+          VDF <T,MEP>	MEP,	   mepintp, INT gvinst,	    MEP_NOTES,	MEP_LVL,0,	< Galileo MemErr >
  209+          VDF <T,MAS>	MAS,	   masintp, INT gvinst,	    MAS_NOTES,	MAS_LVL,0,	< Galileo MasAbort >
  210+          VDF <T,TAR>	TAR,	   tarintp, INT gvinst,	    TAR_NOTES,	TAR_LVL,0,	< Galileo TarAbort >
  211+          VDF <T,RTY>	RTY,	   rtyintp, INT gvinst,	    RTY_NOTES,	RTY_LVL,0,	< Galileo RetryCtr >
  212+          VDF <T,PC0>	PC0,	   pc0intp, INT gvinst,	    PC0_NOTES,	PC0_LVL,0,	< Galileo PCI Interrupt >
  213+          VDF <T,PC1>	PC1,	   pc1intp, INT gvinst,	    PC1_NOTES,	PC1_LVL,0,	< Galileo PCI Interrupt >
  214+          VDF <T,PC2>	PC2,	   pc2intp, INT gvinst,	    PC2_NOTES,	PC2_LVL,0,	< Galileo PCI Interrupt >
  215+          VDF <T,PC3>	PC3,	   pc3intp, INT gvinst,	    PC3_NOTES,	PC3_LVL,0,	< Galileo PCI Interrupt >
  216+          VDF <D,UART_LVL> UART,	   uartintp,INT ioainst,    UART_NOTES,	UART_LVL,0,	< I/O ASIC UART interrupts >
  217+          VDF <D,SND_LVL>	SND,	   sndintp, INT ioainst,    SND_NOTES,	SND_LVL, 0,	< I/O ASIC Sound interrupts >
  218+          VDF <D,MC_LVL>	MC,	   mcintp,  INT ioainst,    MC_NOTES,	MC_LVL,	0,	< I/O ASIC Microcontroller interrupt >
  219+          ;
  220+   (1)    .endc			; (_DISPATCH_MAC_&1) != 0 *** DON'T MOVE THIS LINE EITHER ***
  221+          ;
  222+          ;+++++++ From here on, there are few user servicable parts inside. ++++
  223+          ;
  224+          ; This is sortof how it works:
  225+          ; The first pass through, _DISPATCH_MAC_ will be 0 (set above by the .if not_defined).
  226+          ; First the copyright boilerplate is inserted into both output files and the macro VDF
  227+          ; is defined to create externs. Some struct definitions and unique externs are depositied
  228+          ; into the .h file. Next _DISPATCH_MAC_ is set to 1 and this file is .included
  229+          ; again. This will cause MACPP to read the VDF table above and output the appropriate
  230+          ; information in the .h file but ignore the rest of the file. The VDF macro is redefined,
  231+          ; and the procedure is repeated causing the creation of different items according to what
  232+          ; is needed. Once the whole .h file is built, the procedure repeats for the building of the
  233+          ; .c file.
  234+          ;
  235+   (1)    .if true, _DISPATCH_MAC_ == 0		; First (main) pass
  236+    X      PHX == 0
dispatch.c                               Atari Games Corp. macpp v9.12   "Oct 16 1997 13:26:41"


  237+    X      PAD == 0
  238+    X      FLG == 0
  239+    X      SEA == 0
  240+    X      VEG == 0
  241+    X      .iif true, HOST_BOARD == PHOENIX, PHX == 1 ;set the appropriate ones true as desired
  242+    X      .iif true, HOST_BOARD == PHOENIX_AD, PAD == 1 ;set the appropriate ones true as desired
  243+    X      .iif true, HOST_BOARD == FLAGSTAFF, FLG == 1 ;set the appropriate ones true as desired
  244+    X      .iif true, HOST_BOARD == SEATTLE, SEA == 1 ;set the appropriate ones true as desired
  245+    X      .iif true, HOST_BOARD == VEGAS, VEG == 1 ;set the appropriate ones true as desired
  246+          ;
  247+    X     	.macro .condit flag,exp		; The .condit macro does an expression test ...
  248+    X     	.if identical,<flag>,<T>
  249+    X     		.iif false,exp,.mexit 10 ; ... and aborts higher level macros if false
  250+    X     		.mexit
  251+    X     	.endc
  252+    X     	.if identical,<flag>,<F>
  253+    X     		.iif true,exp,.mexit 10	; ... etc.
  254+    X     		.mexit
  255+    X     	.endc
  256+    X     	.if identical,<flag>,<D>
  257+    X     		.iif not_defined,exp,.mexit 10
  258+    X     		.mexit
  259+    X     	.endc
  260+    X     	.if identical,<flag>,<N>
  261+    X     		.iif defined,exp,.mexit 10
  262+    X     		.mexit
  263+    X     	.endc
  264+    X     	.endm
  265+          ;	
  266+    X     	.macro boilerplate file_name
  267+    X     /*		file_name
  268+    X      *
  269+    X      *		Copyright 1996 Atari Games Corporation
  270+    X      *	Unauthorized reproduction, adaptation, distribution, performance or 
  271+    X      *	display of this computer program or the associated audiovisual work
  272+    X      *	is strictly prohibited.
  273+    X      *
  274+    X      * ++++++ WARNING WARNING WARNING WARNING WARNING +++++
  275+    X      * This file is machine generated. Any changes you put in here will be lost
  276+    X      * the next time phx_vecs.mac is touched. You need to make your changes to
  277+    X      * phx_vecs.mac instead of this file.
  278+    X      */
  279+    X     	.endm
  280+    X     	boilerplate dispatch.c
  281+    X     	.outfile	1		;The externs go into the .h file
  282+    X     	boilerplate intvecs.h
  283+    X     #if !defined(_INTVECS_H_)
  284+    X     #define _INTVECS_H_
  285+          
  286+    X     struct irq_tab {
  287+    X     	void 	(**softvec)();
  288+    X     	void    (*(*installer)(const struct irq_tab *, void(*new)()))();
  289+    X     	int	notes;
  290+    X     };
  291+          ;
  292+    X     	.macro VDF cond, name, softvec, intern, installer, notes, physical, default, comments
  293+    X     	.condit cond	
dispatch.c                               Atari Games Corp. macpp v9.12   "Oct 16 1997 13:26:41"


  294+    X      .if dif,<softvec>,<0>
  295+    X       ...1 == 0
  296+    X       .iif idn,<intern>,<VINT>,...1 == 1
  297+    X       .iif idn,<intern>,<VEXT>,...1 == 1
  298+    X       .if true, ...1
  299+    X     extern	void (* volatile softvec)();	/* comments */
  300+    X       .iff
  301+    X     extern  void (*softvec)();	/* comments */
  302+    X       .endc
  303+    X      .endc
  304+    X     	.endm
  305+          ;
  306+    X     	_DISPATCH_MAC_ == 1		;next time we process the IRQ table
  307+    X     	.include phx_vecs.mac		;Make the externs
  308+          
  309+    X     enum vecs {
  310+    X     	.macro VDF cond, name, softvec, intern, installer, notes, physical, default, comments
  311+    X     	.condit cond	
  312+    X         name'_INTVEC,
  313+    X     	.endm
  314+    X     	.include phx_vecs.mac		;Make the enums
  315+    X         N_INTVECS
  316+    X     };
  317+          
  318+    X     void (*prc_set_vec (unsigned int vecnum, void (*routine)() ))();
  319+    X     void prc_init_vecs(void);		/* set the default vectors */
  320+          ;
  321+          ; Add a prototype for an as yet unused function
  322+    X     .if true, 0
  323+          
  324+    X     /*		prc_set_vecp(which, what)
  325+    X      *	Sets a special vector for the interrupt identified by <which>
  326+    X      *	to call the routine specified by <what>. <what> is
  327+    X      *	a struct that contains both a pointer to the code
  328+    X      *	to execute and an optional pointer to the private
  329+    X      *	variables for that routine. This is a change from the
  330+    X      *	behavior of prc_set_vec, and is intended to allow
  331+    X      *	multiple incarnations of a given device to share code.
  332+    X      */
  333+          
  334+    X     struct opaque;
  335+    X     extern struct VECP_vector {
  336+    X         void (*function)(struct opaque *);	/* Who you gonna call */
  337+    X         struct opaque *cookie;		/* a magic cookie to hand him */
  338+    X     } prc_set_vecp (
  339+    X         int __which,			/* one of xxx_INTVEC */
  340+    X         struct IRQ_vector __what		/* BY VALUE!!! */
  341+    X     );
  342+    X     .endc
  343+    X     #endif		/* _INTVECS_H_ */
  344+          ;
  345+          ; At this point, we have completed all processing of the .h file
  346+          ; so switch back to the .c file
  347+          ;
  348+    X     	.outfile	0		;switch back to dispatch.c
  349+          ;
  350+    X     #include <config.h>			/* begining of dispatch.c */
dispatch.c                               Atari Games Corp. macpp v9.12   "Oct 16 1997 13:26:41"


  351+    X     #include <os_proto.h>
  352+    X     #include <intvecs.h>
  353+          
  354+    X     #ifndef BLABF
  355+    X     # define BLABF(x)
  356+    X     #endif
  357+          
  358+    X     #ifndef BLAB
  359+    X     # define BLAB(x)
  360+    X     #endif
  361+          
  362+    X      .if true, 1
  363+    X     	.macro VDF cond, name, softvec, intern, installer, notes, physical, default, comments
  364+    X     	.condit cond	
  365+    X       .iif idn,<name>,<XBUS0>,.mexit
  366+    X       .iif idn,<name>,<XBUS1>,.mexit
  367+    X       .iif idn,<name>,<XBUS2>,.mexit
  368+    X       .iif idn,<name>,<XBUS3>,.mexit
  369+    X       .iif idn,<name>,<INT0>,.mexit
  370+    X       .iif idn,<name>,<INT1>,.mexit
  371+    X       .iif idn,<name>,<INT2>,.mexit
  372+    X       .iif idn,<name>,<INT3>,.mexit
  373+    X       .iif idn,<name>,<INT4>,.mexit
  374+    X       .iif idn,<name>,<INT5>,.mexit
  375+    X       .if true, PHX
  376+    X         .if true, physical == XBUS0_LVL
  377+    X     	  ...XBUS0 == ...XBUS0 + 1
  378+    X     	  .mexit
  379+    X         .endc
  380+    X         .if true, physical == XBUS1_LVL
  381+    X     	  ...XBUS1 == ...XBUS1 + 1
  382+    X     	  .mexit
  383+    X         .endc
  384+    X         .if true, physical == XBUS2_LVL
  385+    X     	  ...XBUS2 == ...XBUS2 + 1
  386+    X     	  .mexit
  387+    X         .endc
  388+    X         .if true, physical == XBUS3_LVL
  389+    X     	  ...XBUS3 == ...XBUS3 + 1
  390+    X     	  .mexit
  391+    X         .endc
  392+    X       .endc
  393+    X       .if true, physical == INT0_LVL
  394+    X         	...INT0 == ...INT0 + 1
  395+    X     	.mexit
  396+    X       .endc
  397+    X       .if true, physical == INT1_LVL
  398+    X         	...INT1 == ...INT1 + 1
  399+    X        .if true, PAD || FLG || SEA || VEG
  400+    X     	...IOA == ...IOA + 1
  401+    X         .if ndf, notes
  402+    X     #define notes IO_MAIN_GLOBAL_INT
  403+    X         .endc
  404+    X        .endc
  405+    X     	.mexit
  406+    X       .endc
  407+    X       .if true, physical == INT2_LVL
dispatch.c                               Atari Games Corp. macpp v9.12   "Oct 16 1997 13:26:41"


  408+    X         	...INT2 == ...INT2 + 1
  409+    X     	.mexit
  410+    X       .endc
  411+    X       .if true, physical == INT3_LVL
  412+    X         	...INT3 == ...INT3 + 1
  413+    X     	.mexit
  414+    X       .endc
  415+    X       .if true, physical == INT4_LVL
  416+    X         	...INT4 == ...INT4 + 1
  417+    X     	.mexit
  418+    X       .endc
  419+    X       .if true, physical == INT5_LVL
  420+    X         	...INT5 == ...INT5 + 1
  421+    X     	.mexit
  422+    X       .endc
  423+    X       .if true, physical == IOASIC_LVL
  424+    X         	...IOA == ...IOA + 1
  425+    X        .if ndf, notes
  426+    X     #define notes IO_MAIN_GLOBAL_INT
  427+    X        .endc
  428+    X     	.mexit
  429+    X       .endc
  430+    X     	.endm
  431+    X     ...XBUS0 == 0
  432+    X     ...XBUS1 == 0
  433+    X     ...XBUS2 == 0
  434+    X     ...XBUS3 == 0
  435+    X     ...INT0 == 0
  436+    X     ...INT1 == 0
  437+    X     ...INT2 == 0
  438+    X     ...INT3 == 0
  439+    X     ...INT4 == 0
  440+    X     ...INT5 == 0
  441+    X     ...IOA == 0
  442+    X     	.include phx_vecs.mac	; count vectors requiring dispatch
  443+    X      .endc
  444+          ; 
  445+    X     .macro VDF cond, name, softvec, intern, installer, notes, physical, default, comments
  446+    X      .condit cond	
  447+    X      .if dif,<softvec>,<0>
  448+    X       .if idn,<intern>,<INT>
  449+    X     void (*softvec)();	/* comments */
  450+    X       .endc
  451+    X       .if idn,<intern>,<VINT>
  452+    X     void (* volatile softvec)();	/* comments */
  453+    X       .endc
  454+    X      .endc
  455+    X      .if dif,<default>,<0>
  456+    X       .if idn,<name>,<INT0>
  457+    X        .if true, ...INT0
  458+    X     static void 'default'(void);	/* comments */
  459+    X        .endc
  460+    X        .mexit
  461+    X       .endc
  462+    X       .if idn,<name>,<INT1>
  463+    X        .if true, ...INT1
  464+    X     static void 'default'(void);	/* comments */
dispatch.c                               Atari Games Corp. macpp v9.12   "Oct 16 1997 13:26:41"


  465+    X        .endc
  466+    X        .mexit
  467+    X       .endc
  468+    X       .if idn,<name>,<INT2>
  469+    X        .if true, ...INT2
  470+    X     static void 'default'(void);	/* comments */
  471+    X        .endc
  472+    X        .mexit
  473+    X       .endc
  474+    X       .if idn,<name>,<INT3>
  475+    X        .if true, ...INT3
  476+    X     static void 'default'(void);	/* comments */
  477+    X        .endc
  478+    X        .mexit
  479+    X       .endc
  480+    X       .if idn,<name>,<INT4>
  481+    X        .if true, ...INT4
  482+    X     static void 'default'(void);	/* comments */
  483+    X        .endc
  484+    X        .mexit
  485+    X       .endc
  486+    X       .if idn,<name>,<INT5>
  487+    X        .if true, ...INT5
  488+    X     static void 'default'(void);	/* comments */
  489+    X        .endc
  490+    X        .mexit
  491+    X       .endc
  492+    X       .if idn,<name>,<INT6>
  493+    X        .if true, ...INT6
  494+    X     static void 'default'(void);	/* comments */
  495+    X        .endc
  496+    X        .mexit
  497+    X       .endc
  498+    X       .if idn,<name>,<INT7>
  499+    X        .if true, ...INT7
  500+    X     static void 'default'(void);	/* comments */
  501+    X        .endc
  502+    X        .mexit
  503+    X       .endc
  504+    X       .if true, PHX
  505+    X        .if idn,<name>,<XBUS>
  506+    X         .if true, ...XBUS0|...XBUS1|...XBUS2|...XBUS3
  507+    X     static void 'default'(void);
  508+    X         .endc
  509+    X         .mexit
  510+    X        .endc
  511+    X        .if idn,<name>,<XBUS0>
  512+    X         .if true, ...XBUS0
  513+    X     static void 'default'(void);
  514+    X         .endc
  515+    X         .mexit
  516+    X        .endc
  517+    X        .if idn,<name>,<XBUS1>
  518+    X         .if true, ...XBUS1
  519+    X     static void 'default'(void);
  520+    X         .endc
  521+    X         .mexit
dispatch.c                               Atari Games Corp. macpp v9.12   "Oct 16 1997 13:26:41"


  522+    X        .endc
  523+    X        .if idn,<name>,<XBUS2>
  524+    X         .if true, ...XBUS2
  525+    X     static void 'default'(void);
  526+    X         .endc
  527+    X         .mexit
  528+    X        .endc
  529+    X        .if idn,<name>,<XBUS3>
  530+    X         .if true, ...XBUS3
  531+    X     static void 'default'(void);
  532+    X         .endc
  533+    X         .mexit
  534+    X        .endc
  535+    X       .endc			; PHX
  536+    X       .if idn,<name>,<IOA>
  537+    X        .if true, ...IOA
  538+    X     static void 'default'(void);
  539+    X        .endc
  540+    X        .mexit
  541+    X       .endc
  542+    X     extern void 'default'(void);
  543+    X      .endc
  544+    X     .endm
  545+    X     	.include phx_vecs.mac		;Declare the non-extern vectors
  546+          ;
  547+    X      .if true, ((PROCESSOR&-16) == MIPS3000) || ((PROCESSOR&-16) == MIPS4000)
  548+    X     static void (*hwvinst(const struct irq_tab *, void (*)()))();
  549+    X      .endc
  550+          ;
  551+    X     .if df, PHOENIX_INTCTL_MASK
  552+    X     static void (*pvinst(const struct irq_tab *, void (*)()))();
  553+    X     .endc
  554+          ;
  555+    X     .if df, GALILEO_INTCTL_MASK
  556+    X     static void (*gvinst(const struct irq_tab *, void (*)()))();
  557+    X     .endc
  558+          ;
  559+    X     .if true, ...IOA
  560+    X     static void (*ioainst(const struct irq_tab *, void (*)()))();
  561+    X     .endc
  562+          ;
  563+    X     static const struct irq_tab irq_inits[] = {
  564+    X     	.macro VDF cond, name, softvec, intern, installer, notes, physical, default, comments
  565+    X     	.condit cond	
  566+    X      .if dif,<softvec>,<0>
  567+    X      { (void (**)())&softvec, installer, notes },	/* comments */
  568+    X      .iff
  569+    X      { 0, installer, notes },	/* comments */
  570+    X      .endc
  571+    X     	.endm
  572+    X     	.include phx_vecs.mac		;Build the irq_inits array
  573+    X      { 0, 0, 0} };
  574+          ;
  575+    X     .if true, ((PROCESSOR&-16) == MIPS3000) || ((PROCESSOR&-16) == MIPS4000)
  576+          
  577+    X     extern void (*ramv_tbl[])();
  578+          
dispatch.c                               Atari Games Corp. macpp v9.12   "Oct 16 1997 13:26:41"


  579+    X     static void (*hwvinst(const struct irq_tab *it, void (*new)()))() {
  580+    X         int indx;
  581+    X         void (*old_rtn)();
  582+          
  583+    X         indx = it->notes;
  584+    X         if (indx >= VN_MAX) return 0;
  585+    X         old_rtn = ramv_tbl[indx];
  586+    X         ramv_tbl[indx] = new;
  587+    X         return old_rtn;
  588+    X     }
  589+          
  590+    X      .if df, PHOENIX_INTCTL_MASK
  591+    X     static void (*pvinst(const struct irq_tab *it, void (*new)()))() {
  592+          
  593+    X         if (it->notes) {
  594+    X     	BLABF(("\ndispatch: Adding 0x%08lX to main INTCTL (0x%08lX)...", it->notes, *(VU32*)INTCTL_IE));
  595+    X     	*((VU32 *)(INTCTL_IE)) |= it->notes;
  596+    X         }
  597+    X         return 0;
  598+    X     }
  599+    X      .endc
  600+          
  601+    X      .if df, GALILEO_INTCTL_MASK
  602+    X     static void (*gvinst(const struct irq_tab *it, void (*new)()))() {
  603+          
  604+    X         if (it->notes) {
  605+    X     	BLABF(("\ndispatch: Adding 0x%08lX to Galileo INTCTL (0x%08lX)...", it->notes, \
  606+    X     			*(VU32*)GALILEO_CPU_I_ENA));
  607+    X     	*((VU32 *)(GALILEO_CPU_I_ENA)) |= it->notes;
  608+    X         }
  609+    X         return 0;
  610+    X     }
  611+    X      .endc
  612+          
  613+    X      .if true, ...IOA
  614+    X     static void (*ioainst(const struct irq_tab *it, void (*new)()))() {
  615+    X     extern void prc_wait_n_usecs( int );
  616+    X         if (it->notes)
  617+    X         {
  618+    X          BLABF(("\ndispatch: Adding 0x%04X to IOASIC INTCTL: (0x%04X)...", (int)it->notes, \
  619+    X     		*(VU32*)IO_MAIN_CTL&0xFFFF));
  620+    X          while ( ( *((VU32 *)IO_MAIN_CTL) & it->notes ) != it->notes )
  621+    X          {
  622+    X     #ifdef LED_OUT
  623+    X           *(VU32 *)LED_OUT = ~( 1 << B_LED_RED );
  624+    X     #endif
  625+    X           do
  626+    X           {
  627+    X            *((VU32 *)IO_MAIN_CTL) |= it->notes;
  628+    X            prc_wait_n_usecs( 1000 );
  629+    X           } while ( ( *((VU32 *)IO_MAIN_CTL) & it->notes ) != it->notes );
  630+    X           prc_wait_n_usecs( 1000 );
  631+    X     #ifdef LED_OUT
  632+    X           *(VU32 *)LED_OUT |= ( 1 << B_LED_RED );
  633+    X     #endif
  634+    X          }
  635+    X         }
dispatch.c                               Atari Games Corp. macpp v9.12   "Oct 16 1997 13:26:41"


  636+    X         return 0;
  637+    X     }
  638+    X      .endc
  639+    X     .endc
  640+          
  641+    X     void (*prc_set_vec (unsigned int vecnum, void (*routine)() ))()
  642+    X     {
  643+    X         void (*old_rtn)();
  644+    X         void (**softvec)();
  645+    X         const struct irq_tab *tbp;
  646+    X         int old_ipl;
  647+          
  648+    X         if ( vecnum >= N_INTVECS ) return 0;
  649+    X         tbp = irq_inits+vecnum;
  650+    X         softvec = tbp->softvec;
  651+    X         old_rtn = 0;
  652+    X         old_ipl = prc_set_ipl(INTS_OFF);
  653+    X         if ( tbp->installer ) old_rtn = tbp->installer(tbp, routine);
  654+    X         if ( softvec ) {
  655+    X     	if (!old_rtn) old_rtn = *softvec;
  656+    X     	*softvec = routine;
  657+    X         }
  658+    X         prc_set_ipl(old_ipl);
  659+    X         return old_rtn;
  660+    X     }
  661+          
  662+    X      .if true, PHX
  663+    X       .if true, ...XBUS0
  664+    X     static void xbus0_irq(void) {
  665+    X     	.macro VDF cond, name, softvec, intern, installer, notes, physical, default, comments
  666+    X     	.condit cond	
  667+    X       .iif idn,<name>,<XBUS0>,.mexit
  668+    X       .iif idn,<softvec>,<0>,.mexit
  669+    X       .if true, physical == XBUS0_LVL
  670+    X         if (softvec) softvec();
  671+    X       .endc
  672+    X     	.endm
  673+    X     	.include phx_vecs.mac		; pickup all vectors assigned to XBUS0_LVL
  674+    X         return;
  675+    X     }
  676+          
  677+    X       .endc		; ...XBUS0
  678+    X       .if true, ...XBUS1
  679+    X     static void xbus1_irq(void) {
  680+    X     	.macro VDF cond, name, softvec, intern, installer, notes, physical, default, comments
  681+    X     	.condit cond	
  682+    X       .iif idn,<name>,<XBUS1>,.mexit
  683+    X       .iif idn,<softvec>,<0>,.mexit
  684+    X       .if true, physical == XBUS1_LVL
  685+    X         if (softvec) softvec();
  686+    X       .endc
  687+    X     	.endm
  688+    X     	.include phx_vecs.mac		; pickup all vectors assigned to XBUS1_LVL
  689+    X         return;
  690+    X     }
  691+          
  692+    X       .endc		; ...XBUS1
dispatch.c                               Atari Games Corp. macpp v9.12   "Oct 16 1997 13:26:41"


  693+    X       .if true, ...XBUS2
  694+    X     static void xbus2_irq(void) {
  695+    X     	.macro VDF cond, name, softvec, intern, installer, notes, physical, default, comments
  696+    X     	.condit cond	
  697+    X       .iif idn,<name>,<XBUS2>,.mexit
  698+    X       .iif idn,<softvec>,<0>,.mexit
  699+    X       .if true, physical == XBUS2_LVL
  700+    X         if (softvec) softvec();
  701+    X       .endc
  702+    X     	.endm
  703+    X     	.include phx_vecs.mac		; pickup all vectors assigned to XBUS2_LVL
  704+    X         return;
  705+    X     }
  706+          
  707+    X       .endc		; ...XBUS2
  708+    X       .if true, ...XBUS3
  709+    X     static void xbus3_irq(void) {
  710+    X     	.macro VDF cond, name, softvec, intern, installer, notes, physical, default, comments
  711+    X     	.condit cond	
  712+    X       .iif idn,<name>,<XBUS3>,.mexit
  713+    X       .iif idn,<softvec>,<0>,.mexit
  714+    X       .if true, physical == XBUS3_LVL
  715+    X         if (softvec) softvec();
  716+    X       .endc
  717+    X     	.endm
  718+    X     	.include phx_vecs.mac		; pickup all vectors assigned to XBUS3_LVL
  719+    X         return;
  720+    X     }
  721+          
  722+    X       .endc		; ...XBUS3
  723+    X      .endc		; PHX
  724+    X      .if true, ...INT0
  725+    X     static void int0_irq(void) {
  726+    X     	.macro VDF cond, name, softvec, intern, installer, notes, physical, default, comments
  727+    X     	.condit cond	
  728+    X       .iif idn,<name>,<INT0>,.mexit
  729+    X       .iif idn,<softvec>,<0>,.mexit
  730+    X       .if true, physical == INT0_LVL
  731+    X         if (softvec) softvec();
  732+    X       .endc
  733+    X     	.endm
  734+    X     	.include phx_vecs.mac		; pickup all vectors assigned to IRQ 0
  735+    X         return;
  736+    X     }
  737+          
  738+    X      .endc		; ...INT0
  739+    X      .if true, ...INT1
  740+    X     static void int1_irq(void) {
  741+    X     	.macro VDF cond, name, softvec, intern, installer, notes, physical, default, comments
  742+    X     	.condit cond	
  743+    X       .iif idn,<name>,<INT1>,.mexit
  744+    X       .iif idn,<softvec>,<0>,.mexit
  745+    X       .if true, physical == INT1_LVL
  746+    X         if (softvec) softvec();
  747+    X       .endc
  748+    X     	.endm
  749+    X     	.include phx_vecs.mac		; pickup all vectors assigned to IRQ 1
dispatch.c                               Atari Games Corp. macpp v9.12   "Oct 16 1997 13:26:41"


  750+    X         return;
  751+    X     }
  752+          
  753+    X      .endc		; ...INT1
  754+    X      .if true, ...INT2
  755+    X     static void int2_irq(void) {
  756+    X     	.macro VDF cond, name, softvec, intern, installer, notes, physical, default, comments
  757+    X     	.condit cond	
  758+    X       .iif idn,<name>,<INT2>,.mexit
  759+    X       .iif idn,<softvec>,<0>,.mexit
  760+    X       .if true, physical == INT2_LVL
  761+    X         if (softvec) softvec();
  762+    X       .endc
  763+    X     	.endm
  764+    X     	.include phx_vecs.mac		; pickup all vectors assigned to IRQ 2
  765+    X         return;
  766+    X     }
  767+          
  768+    X      .endc		; ...INT2
  769+    X      .if true, ...INT3
  770+    X     static void int3_irq(void) {
  771+    X     	.macro VDF cond, name, softvec, intern, installer, notes, physical, default, comments
  772+    X     	.condit cond	
  773+    X       .iif idn,<name>,<INT3>,.mexit
  774+    X       .iif idn,<softvec>,<0>,.mexit
  775+    X       .if true, physical == INT3_LVL
  776+    X         if (softvec) softvec();
  777+    X       .endc
  778+    X     	.endm
  779+    X     	.include phx_vecs.mac		; pickup all vectors assigned to IRQ 3
  780+    X         return;
  781+    X     }
  782+          
  783+    X      .endc		; ...INT3
  784+    X      .if true, ...INT4
  785+    X     static void int4_irq(void) {
  786+    X     	.macro VDF cond, name, softvec, intern, installer, notes, physical, default, comments
  787+    X     	.condit cond	
  788+    X       .iif idn,<name>,<INT4>,.mexit
  789+    X       .iif idn,<softvec>,<0>,.mexit
  790+    X       .if true, physical == INT4_LVL
  791+    X         if (softvec) softvec();
  792+    X       .endc
  793+    X     	.endm
  794+    X     	.include phx_vecs.mac		; pickup all vectors assigned to IRQ 4
  795+    X         return;
  796+    X     }
  797+          
  798+    X      .endc		; ...INT4
  799+    X      .if true, ...INT5
  800+    X     static void int5_irq(void) {
  801+    X     	.macro VDF cond, name, softvec, intern, installer, notes, physical, default, comments
  802+    X     	.condit cond	
  803+    X       .iif idn,<name>,<INT5>,.mexit
  804+    X       .iif idn,<softvec>,<0>,.mexit
  805+    X       .if true, physical == INT5_LVL
  806+    X         if (softvec) softvec();
dispatch.c                               Atari Games Corp. macpp v9.12   "Oct 16 1997 13:26:41"


  807+    X       .endc
  808+    X     	.endm
  809+    X     	.include phx_vecs.mac		; pickup all vectors assigned to IRQ 5
  810+    X         return;
  811+    X     }
  812+          
  813+    X      .endc		; ...INT5
  814+    X      .if true, ...IOA && PHX
  815+    X     static void ioa_irq(void) {
  816+    X     	.macro VDF cond, name, softvec, intern, installer, notes, physical, default, comments
  817+    X     	.condit cond	
  818+    X       .iif idn,<name>,<IOA>,.mexit
  819+    X       .iif idn,<softvec>,<0>,.mexit
  820+    X       .if true, physical == IOASIC_LVL
  821+    X         if (softvec) softvec();
  822+    X       .endc
  823+    X     	.endm
  824+    X     	.include phx_vecs.mac		; pickup all vectors assigned to IRQ 5
  825+    X         return;
  826+    X     }
  827+          
  828+    X      .endc		; ...IOA
  829+    X      .if true, PHX
  830+    X       .if true, ...XBUS0|...XBUS1|...XBUS2|...XBUS3
  831+    X     static void xbus_irq(void) {
  832+    X         int which;
  833+    X         which = *(VU32 *)(XBUS_SLOT0+4);
  834+    X       .if true, ...XBUS0
  835+    X         if (!(which&1)) xbus0_irq();
  836+    X       .endc
  837+    X       .if true, ...XBUS1
  838+    X         if (!(which&2)) xbus1_irq();
  839+    X       .endc
  840+    X       .if true, ...XBUS2
  841+    X         if (!(which&4)) xbus2_irq();
  842+    X       .endc
  843+    X       .if true, ...XBUS3
  844+    X         if (!(which&8)) xbus3_irq();
  845+    X       .endc
  846+    X         return;
  847+    X     }
  848+    X       .endc
  849+    X      .endc		; PHX
  850+    X     void prc_init_vecs(void) {
  851+    X     	.macro VDF cond, name, softvec, intern, installer, notes, physical, default, comments
  852+    X     	.condit cond	
  853+    X     .if dif,<default>,<0>
  854+    X      .if true, PHX
  855+    X       .if idn,<name>,<XBUS0>
  856+    X        .iif true, ...XBUS0 == 0, .mexit
  857+    X       .endc
  858+    X       .if idn,<name>,<XBUS1>
  859+    X        .iif true, ...XBUS1 == 0, .mexit
  860+    X       .endc
  861+    X       .if idn,<name>,<XBUS2>
  862+    X        .iif true, ...XBUS2 == 0, .mexit
  863+    X       .endc
dispatch.c                               Atari Games Corp. macpp v9.12   "Oct 16 1997 13:26:41"


  864+    X       .if idn,<name>,<XBUS3>
  865+    X        .iif true, ...XBUS3 == 0, .mexit
  866+    X       .endc
  867+    X       .if idn,<name>,<XBUS>
  868+    X        .iif true, (...XBUS0|...XBUS1|...XBUS2|...XBUS3) == 0, .mexit
  869+    X       .endc
  870+    X      .endc	; PHX
  871+    X      .if idn,<name>,<INT0>
  872+    X       .iif true, ...INT0 == 0, .mexit
  873+    X      .endc
  874+    X      .if idn,<name>,<INT1>
  875+    X       .iif true, ...INT1 == 0, .mexit
  876+    X      .endc
  877+    X      .if idn,<name>,<INT2>
  878+    X       .iif true, ...INT2 == 0, .mexit
  879+    X      .endc
  880+    X      .if idn,<name>,<INT3>
  881+    X       .iif true, ...INT3 == 0, .mexit
  882+    X      .endc
  883+    X      .if idn,<name>,<INT4>
  884+    X       .iif true, ...INT4 == 0, .mexit
  885+    X      .endc
  886+    X      .if idn,<name>,<INT5>
  887+    X       .iif true, ...INT5 == 0, .mexit
  888+    X      .endc
  889+    X      .if idn,<name>,<IOA>
  890+    X       .iif true, ...IOA == 0, .mexit
  891+    X      .endc
  892+    X         prc_set_vec('name'_INTVEC, default);
  893+    X     .endc
  894+    X     	.endm
  895+    X     	.include phx_vecs.mac
  896+          
  897+    X     /* Map the Phoenix interrupts */
  898+          
  899+    X     .if df, INTCTL_MAPA_INIT
  900+    X         BLABF(("\ndispatch: Mapping the A interrupts: 0x%08lX...", INTCTL_MAPA_INIT));
  901+    X         *((VU32 *)(INTCTL_MAPA)) = INTCTL_MAPA_INIT;
  902+    X     .endc
  903+    X     .if df, INTCTL_MAPB_INIT
  904+    X         BLABF(("\ndispatch: Mapping the B interrupts: 0x%08lX...", INTCTL_MAPB_INIT));
  905+    X         *((VU32 *)(INTCTL_MAPB)) = INTCTL_MAPB_INIT;
  906+    X     .endc
  907+          
  908+    X     .if defined, ANNOUNCE_BOOT_ACTIONS
  909+    X      .if true, ANNOUNCE_BOOT_ACTIONS
  910+    X         {
  911+    X     	int jj;
  912+    X     	extern int prc_get_cause(void), prc_get_ipl(void);
  913+    X     	jj = prc_get_cause();
  914+    X     	if (jj&0xFF00) BLABF(("\ndispatch: CPU cause reg: %08lX, CPU SR reg: %08lX", jj, prc_get_ipl()));
  915+    X     	if (jj&0x0400) {
  916+    X       .if true, ...INT0
  917+    X     	.macro VDF cond, name, softvec, intern, installer, notes, physical, default, comments
  918+    X     	.condit cond	
  919+    X        .iif idn,<name>,<INT0>,.mexit
  920+    X        .iif idn,<softvec>,<0>,.mexit
dispatch.c                               Atari Games Corp. macpp v9.12   "Oct 16 1997 13:26:41"


  921+    X        .if true, physical == INT0_LVL
  922+    X     	    if (!softvec) BLAB("\ndispatch: Warning, IRQ 0 pending \"'comments'\"");
  923+    X        .endc
  924+    X     	.endm
  925+    X     	.include phx_vecs.mac		; pickup all vectors assigned to IRQ 0
  926+    X       .iff
  927+    X     	    BLAB("\ndispatch: Warning, IRQ 0 pending with no vector assigned");
  928+    X       .endc		; ...INT0
  929+    X     	}
  930+    X     	if (jj&0x0800) {
  931+    X       .if true, ...INT1
  932+    X     	.macro VDF cond, name, softvec, intern, installer, notes, physical, default, comments
  933+    X     	.condit cond	
  934+    X        .iif idn,<name>,<INT1>,.mexit
  935+    X        .iif idn,<softvec>,<0>,.mexit
  936+    X        .if true, physical == INT1_LVL
  937+    X     	    if (!softvec) BLAB("\ndispatch: Warning, IRQ 1 pending \"'comments'\"");
  938+    X        .endc
  939+    X     	.endm
  940+    X     	.include phx_vecs.mac		; pickup all vectors assigned to IRQ 1
  941+    X       .iff
  942+    X     	    BLAB("\ndispatch: Warning, IRQ 1 pending with no vector assigned");
  943+    X       .endc		; ...INT1
  944+    X     	}
  945+    X     	if (jj&0x1000) {
  946+    X       .if true, ...INT2
  947+    X     	.macro VDF cond, name, softvec, intern, installer, notes, physical, default, comments
  948+    X     	.condit cond	
  949+    X        .iif idn,<name>,<INT2>,.mexit
  950+    X        .iif idn,<softvec>,<0>,.mexit
  951+    X        .if true, physical == INT2_LVL
  952+    X     	    if (!softvec) BLAB("\ndispatch: Warning, IRQ 2 pending \"'comments'\"");
  953+    X        .endc
  954+    X     	.endm
  955+    X     	.include phx_vecs.mac		; pickup all vectors assigned to IRQ 2
  956+    X       .iff
  957+    X     	    BLAB("\ndispatch: Warning, IRQ 2 pending with no vector assigned");
  958+    X       .endc		; ...INT2
  959+    X     	}
  960+    X     	if (jj&0x2000) {
  961+    X       .if true, ...INT3
  962+    X     	.macro VDF cond, name, softvec, intern, installer, notes, physical, default, comments
  963+    X     	.condit cond	
  964+    X        .iif idn,<name>,<INT3>,.mexit
  965+    X        .iif idn,<softvec>,<0>,.mexit
  966+    X        .if true, physical == INT3_LVL
  967+    X     	    if (!softvec) BLAB("\ndispatch: Warning, IRQ 3 pending \"'comments'\"");
  968+    X        .endc
  969+    X     	.endm
  970+    X     	.include phx_vecs.mac		; pickup all vectors assigned to IRQ 3
  971+    X       .iff
  972+    X     	    BLAB("\ndispatch: Warning, IRQ 3 pending with no vector assigned");
  973+    X       .endc		; ...INT3
  974+    X     	}
  975+    X     	if (jj&0x4000) {
  976+    X       .if true, ...INT4
  977+    X     	.macro VDF cond, name, softvec, intern, installer, notes, physical, default, comments
dispatch.c                               Atari Games Corp. macpp v9.12   "Oct 16 1997 13:26:41"


  978+    X     	.condit cond	
  979+    X        .iif idn,<name>,<INT4>,.mexit
  980+    X        .iif idn,<softvec>,<0>,.mexit
  981+    X        .if true, physical == INT4_LVL
  982+    X     	    if (!softvec) BLAB("\ndispatch: Warning, IRQ 4 pending \"'comments'\"");
  983+    X        .endc
  984+    X     	.endm
  985+    X     	.include phx_vecs.mac		; pickup all vectors assigned to IRQ 4
  986+    X       .iff
  987+    X     	    BLAB("\ndispatch: Warning, IRQ 4 pending with no vector assigned");
  988+    X       .endc		; ...INT4
  989+    X     	}
  990+    X     	if (jj&0x8000) {
  991+    X       .if true, ...INT5
  992+    X     	.macro VDF cond, name, softvec, intern, installer, notes, physical, default, comments
  993+    X     	.condit cond	
  994+    X        .iif idn,<name>,<INT5>,.mexit
  995+    X        .iif idn,<softvec>,<0>,.mexit
  996+    X        .if true, physical == INT5_LVL
  997+    X     	    if (!softvec) BLAB("\ndispatch: Warning, IRQ 5 pending \"'comments'\"");
  998+    X        .endc
  999+    X     	.endm
 1000+    X     	.include phx_vecs.mac		; pickup all vectors assigned to IRQ 5
 1001+    X       .iff
 1002+    X     	    BLAB("\ndispatch: Warning, IRQ 5 pending with no vector assigned");
 1003+    X       .endc		; ...INT5
 1004+    X     	}
 1005+    X         }
 1006+    X      .endc		; true, ANNOUNCE_BOOT_ACTIONS
 1007+    X     .endc		; defined, ANNOUNCE_BOOT_ACTIONS
 1008+    X         return;
 1009+    X     }
 1010+   (1)    .endc		; _DISPATCH_MAC_ == 0
  573            { 0, 0, 0} };
  574           ;
  575    (1)    .if true, ((PROCESSOR&-16) == MIPS3000) || ((PROCESSOR&-16) == MIPS4000)
  576           
  577           extern void (*ramv_tbl[])();
  578           
  579           static void (*hwvinst(const struct irq_tab *it, void (*new)()))() {
  580               int indx;
  581               void (*old_rtn)();
  582           
  583               indx = it->notes;
  584               if (indx >= VN_MAX) return 0;
  585               old_rtn = ramv_tbl[indx];
  586               ramv_tbl[indx] = new;
  587               return old_rtn;
  588           }
  589           
  590    (2)     .if df, PHOENIX_INTCTL_MASK
  591           static void (*pvinst(const struct irq_tab *it, void (*new)()))() {
  592           
  593               if (it->notes) {
  594           	BLABF(("\ndispatch: Adding 0x%08lX to main INTCTL (0x%08lX)...", it->notes, *(VU32*)INTCTL_IE));
  595           	*((VU32 *)(INTCTL_IE)) |= it->notes;
  596               }
dispatch.c                               Atari Games Corp. macpp v9.12   "Oct 16 1997 13:26:41"


  597               return 0;
  598           }
  599    (2)     .endc
  600           
  601    (2)     .if df, GALILEO_INTCTL_MASK
  602           static void (*gvinst(const struct irq_tab *it, void (*new)()))() {
  603           
  604               if (it->notes) {
  605           	BLABF(("\ndispatch: Adding 0x%08lX to Galileo INTCTL (0x%08lX)...", it->notes, \
  606           			*(VU32*)GALILEO_CPU_I_ENA));
  607           	*((VU32 *)(GALILEO_CPU_I_ENA)) |= it->notes;
  608               }
  609               return 0;
  610           }
  611    (2)     .endc
  612           
  613    (2)     .if true, ...IOA
  614           static void (*ioainst(const struct irq_tab *it, void (*new)()))() {
  615           extern void prc_wait_n_usecs( int );
  616               if (it->notes)
  617               {
  618                BLABF(("\ndispatch: Adding 0x%04X to IOASIC INTCTL: (0x%04X)...", (int)it->notes, \
  619           		*(VU32*)IO_MAIN_CTL&0xFFFF));
  620                while ( ( *((VU32 *)IO_MAIN_CTL) & it->notes ) != it->notes )
  621                {
  622           #ifdef LED_OUT
  623                 *(VU32 *)LED_OUT = ~( 1 << B_LED_RED );
  624           #endif
  625                 do
  626                 {
  627                  *((VU32 *)IO_MAIN_CTL) |= it->notes;
  628                  prc_wait_n_usecs( 1000 );
  629                 } while ( ( *((VU32 *)IO_MAIN_CTL) & it->notes ) != it->notes );
  630                 prc_wait_n_usecs( 1000 );
  631           #ifdef LED_OUT
  632                 *(VU32 *)LED_OUT |= ( 1 << B_LED_RED );
  633           #endif
  634                }
  635               }
  636               return 0;
  637           }
  638    (2)     .endc
  639    (1)    .endc
  640           
  641           void (*prc_set_vec (unsigned int vecnum, void (*routine)() ))()
  642           {
  643               void (*old_rtn)();
  644               void (**softvec)();
  645               const struct irq_tab *tbp;
  646               int old_ipl;
  647           
  648               if ( vecnum >= N_INTVECS ) return 0;
  649               tbp = irq_inits+vecnum;
  650               softvec = tbp->softvec;
  651               old_rtn = 0;
  652               old_ipl = prc_set_ipl(INTS_OFF);
  653               if ( tbp->installer ) old_rtn = tbp->installer(tbp, routine);
dispatch.c                               Atari Games Corp. macpp v9.12   "Oct 16 1997 13:26:41"


  654               if ( softvec ) {
  655           	if (!old_rtn) old_rtn = *softvec;
  656           	*softvec = routine;
  657               }
  658               prc_set_ipl(old_ipl);
  659               return old_rtn;
  660           }
  661           
  662    (1)     .if true, PHX
  663     X       .if true, ...XBUS0
  664     X     static void xbus0_irq(void) {
  665     X     	.macro VDF cond, name, softvec, intern, installer, notes, physical, default, comments
  666     X     	.condit cond	
  667     X       .iif idn,<name>,<XBUS0>,.mexit
  668     X       .iif idn,<softvec>,<0>,.mexit
  669     X       .if true, physical == XBUS0_LVL
  670     X         if (softvec) softvec();
  671     X       .endc
  672     X     	.endm
  673     X     	.include phx_vecs.mac		; pickup all vectors assigned to XBUS0_LVL
  674     X         return;
  675     X     }
  676           
  677     X       .endc		; ...XBUS0
  678     X       .if true, ...XBUS1
  679     X     static void xbus1_irq(void) {
  680     X     	.macro VDF cond, name, softvec, intern, installer, notes, physical, default, comments
  681     X     	.condit cond	
  682     X       .iif idn,<name>,<XBUS1>,.mexit
  683     X       .iif idn,<softvec>,<0>,.mexit
  684     X       .if true, physical == XBUS1_LVL
  685     X         if (softvec) softvec();
  686     X       .endc
  687     X     	.endm
  688     X     	.include phx_vecs.mac		; pickup all vectors assigned to XBUS1_LVL
  689     X         return;
  690     X     }
  691           
  692     X       .endc		; ...XBUS1
  693     X       .if true, ...XBUS2
  694     X     static void xbus2_irq(void) {
  695     X     	.macro VDF cond, name, softvec, intern, installer, notes, physical, default, comments
  696     X     	.condit cond	
  697     X       .iif idn,<name>,<XBUS2>,.mexit
  698     X       .iif idn,<softvec>,<0>,.mexit
  699     X       .if true, physical == XBUS2_LVL
  700     X         if (softvec) softvec();
  701     X       .endc
  702     X     	.endm
  703     X     	.include phx_vecs.mac		; pickup all vectors assigned to XBUS2_LVL
  704     X         return;
  705     X     }
  706           
  707     X       .endc		; ...XBUS2
  708     X       .if true, ...XBUS3
  709     X     static void xbus3_irq(void) {
  710     X     	.macro VDF cond, name, softvec, intern, installer, notes, physical, default, comments
dispatch.c                               Atari Games Corp. macpp v9.12   "Oct 16 1997 13:26:41"


  711     X     	.condit cond	
  712     X       .iif idn,<name>,<XBUS3>,.mexit
  713     X       .iif idn,<softvec>,<0>,.mexit
  714     X       .if true, physical == XBUS3_LVL
  715     X         if (softvec) softvec();
  716     X       .endc
  717     X     	.endm
  718     X     	.include phx_vecs.mac		; pickup all vectors assigned to XBUS3_LVL
  719     X         return;
  720     X     }
  721           
  722     X       .endc		; ...XBUS3
  723    (1)     .endc		; PHX
  724    (1)     .if true, ...INT0
  725           static void int0_irq(void) {
  726           	.macro VDF cond, name, softvec, intern, installer, notes, physical, default, comments
  727           	.condit cond	
  728             .iif idn,<name>,<INT0>,.mexit
  729             .iif idn,<softvec>,<0>,.mexit
  730             .if true, physical == INT0_LVL
  731               if (softvec) softvec();
  732             .endc
  733           	.endm
  734           	.include phx_vecs.mac		; pickup all vectors assigned to IRQ 0
    1+          ;/*		phx_vecs.mac
    2+          ; *
    3+          ; *		Copyright 1996 Atari Games Corporation
    4+          ; *	Unauthorized reproduction, adaptation, distribution, performance or 
    5+          ; *	display of this computer program or the associated audiovisual work
    6+          ; *	is strictly prohibited.
    7+          ; *
    8+          ; *	This file is processed by MACPP to produce dispatch.c and intvecs.h.
    9+          ; *
   10+          ; *	The definitions placed in intvecs.h declare virtual vector numbers
   11+          ; *	in the form of xxx_INTVEC and a cross reference table(s) so the
   12+          ; *	dispatcher can call the appropriate functions.
   13+          ; *
   14+          ; *	intvecs.h should be #include'd by any module that uses prc_set_vec().
   15+          ; */
   16+          ;
   17+          ; This file recursivley '.includes' itself to succesively build up the approprate
   18+          ; tables and functions in C and places the results in one of two files (the
   19+          ; first -out=file supplied on the MACPP command line is expected to be dispatch.c
   20+          ; and the second -out=file is expected to be intvecs.h and the third is expected to
   21+          ; be /dev/null). If you don't speak fluent MACPP, then you probably shouldn't be
   22+          ; changing anything in this file other than the VDF table listed below.
   23+          ;
   24+   (2)    .if not_defined, _DISPATCH_MAC_		;1 +++++
   25+    X     _DISPATCH_MAC_ == 0			;2 Don't move ...
   26+    X     OUTPUT_LANG == 5 ;LANG_NONE		;3 ... or change ... 
   27+    X     	.outfile 2			;4 ... anything on ...
   28+    X     	.include config.mac		;5 ... these ...
   29+    X     	.outfile 0			;6 ... nine  ...
   30+   (2)    .endc					;7 ... lines ...
   31+   (2)    .if true, (_DISPATCH_MAC_&1) != 0	;8
   32+   (3)     .if true, 0				;9 -----
   33+          
dispatch.c                               Atari Games Corp. macpp v9.12   "Oct 16 1997 13:26:41"


   34+    X     You are free to add or remove entries from this table according to your
   35+    X     requirements. There are 10 fields used on each line in this table. The
   36+    X     description of each field follows:
   37+          
   38+    X     Field 1 = macro call
   39+          
   40+    X     It must always be the keyword VDF (case is not significant).
   41+          
   42+    X     Field 2 = condition
   43+          
   44+    X     This is a dual operand field, so the two operands together must be enclosed in
   45+    X     <>'s. The first operand is one of T, F, D or N representing True, False,
   46+    X     Defined or Not_defined respectively. Case is significant, use uppercase only
   47+    X     please. For the conditions T or F the second operand must be an expression
   48+    X     which must resolve to non-$0 (True) or $0 (False) in order for the macro
   49+    X     to be processed (else it is ignored). The expression can contain no embedded
   50+    X     spaces. For the conditions D and N, the second operand must only be a symbol
   51+    X     which must be Defined or Not-defined respectively in order for the macro to be
   52+    X     processed. Some short cut expressions have been preprocessed to make using the
   53+    X     expressions a little more concise. These are:
   54+          
   55+    X     	PHX = not $0 if HOST_BOARD == PHOENIX
   56+    X     	PAD = not $0 if HOST_BOARD == PHOENIX_AD
   57+    X     	FLG = not $0 if HOST_BOARD == FLAGSTAFF
   58+    X     	SEA = not $0 if HOST_BOARD == SEATTLE
   59+    X     	VEG = not $0 if HOST_BOARD == VEGAS
   60+          
   61+    X     Field 3 = vector name
   62+          
   63+    X     The NAME field is the name of the virtual vector. An _INTVEC will be appended
   64+    X     to it in the C definitions in intvecs.h, but otherwise the name is unmolested.
   65+    X     Case is significant only if you want it to be. The R3K/R4K has an option where
   66+    X     a number of vectors are maintained in an array of pointers rather than each
   67+    X     one having its own name. The index into the array is same as the number
   68+    X     returned in the processor's CAUSE register for that particluar interrupt. This
   69+    X     procedure is done simply for performance reasons. The option is selected by
   70+    X     using a 0 for this field and using an installer function with the vector index
   71+    X     as the parameter to the installer.
   72+          
   73+    X     Field 4 = Vector pointer
   74+          
   75+    X     This field identifies the name of a variable in BSS that contains a pointer
   76+    X     to the function to call at interrupt (or will be set by the prc_set_vec()
   77+    X     function). This is the name of the "soft" or logical vector and is either
   78+    X     declared in dispatch.c or externally according to the INT/EXT field described
   79+    X     next.
   80+          
   81+    X     Field 5 = INTernal or EXTernal vector
   82+          
   83+    X     This field contains the keywords INT, EXT, VINT or VEXT identifying the vector
   84+    X     in field 4 as being defined INTernally, EXTernally, Volatile INTernally or
   85+    X     Volatile Externally to dispatch.c respectively.
   86+          
   87+    X     Field 6 = name of vector installer
   88+          
   89+    X     This field identifies the name of a function that prc_set_vec() will call to
   90+    X     actually install the vector or 0 if there is no special stuff that needs to
dispatch.c                               Atari Games Corp. macpp v9.12   "Oct 16 1997 13:26:41"


   91+    X     be performed during vector installation.
   92+          
   93+    X     Field 7 = Notes for the installer.
   94+          
   95+    X     The Notes field is a parameter that is passed to the installer if there is one.
   96+          
   97+    X     Field 8 = Physical vector attachment.
   98+          
   99+    X     A dispatch routine is constructed for each of the 4 XBUS interrupts and for each of
  100+    X     the 6 CPU interrupts.  This field instructs phx_vecs.mac into which of the XBUS or
  101+    X     INTx dispatchers a caller to this vector belongs.  If this vector is not associated
  102+    X     with an XBUS or an INTx interrupt, it needs to be -1.  Place the interrupt routines
  103+    X     in this table in the order in which you want them executed.
  104+          
  105+    X     Field 9 = Default function.
  106+          
  107+    X     Name of default routine to install in the vector, or 0 if none.  phx_vecs.mac builds
  108+    X     a function called prc_init_vecs(void) which, when called, will perform a string of
  109+    X     prc_set_vec()'s for all the vectors having this field non-zero.  After the vectors
  110+    X     have been loaded, prc_init_vecs(void) will map the phoenix and galileo interrupts as
  111+    X     specified in phoenix.mac.
  112+          
  113+    X     Field 10 = Comments.
  114+          
  115+    X     The Comments field is placed on selected lines in intvecs.h and/or dispatch.c
  116+    X     as simple 'C' comments.
  117+          
  118+   (3)     .endc				; Don't move this line
  119+          ;
  120+          ;   Condit	Name	   Vector   I/E	Installer   Notes      Phys	Default	Comments
  121+          ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  122+          VDF <T,1>	GAMEVB,	   gameint, EXT	0,          0,		-1,	0,	< post-wierdness Vblank >
  123+          VDF <T,1>	MS4,       ms4vec,  EXT	0,          0,		-1,	0,	< 4 Millisecond timer >
  124+          VDF <T,1>	PRC_DELAY, prc_delay_vec, EXT 0,    0,		-1,	sst_prc_delay, < prc_delay soft vector >
  125+          VDF <T,1>	PRC_SET_IPL, set_ipl_vec, INT 0,    0,		-1,	0,	< prc_set_ipl soft vector >
  126+          VDF <T,1>	SAVE,      savintp, EXT 0,          0,		-1,	0,	< context save soft vector >
  127+          VDF <T,1>	RESTORE,   restintp,EXT 0,          0,		-1,	0,	< context restore soft vector >
  128+          VDF <T,1>	SW0,	   0,	    INT hwvinst,    VN_IRQ0,    -1,	0,	< Software interrupt 0 >
  129+          VDF <T,1>	SW1,	   0,       INT hwvinst,    VN_IRQ1,    -1,	0,	< Software interrupt 0 >
  130+          VDF <T,1>	INT0,	   0,       INT hwvinst,    VN_IRQ2,    -1,	int0_irq, < Hardware interrupt 0 >
  131+          VDF <T,1>	INT1,	   0,	    INT hwvinst,    VN_IRQ3,    -1,	int1_irq, < Hardware interrupt 1 >
  132+          VDF <T,PHX>	INT2,	   0,	    INT hwvinst,    VN_IRQ4,    -1,	int2_irq, < Hardware interrupt 2 >
  133+          VDF <T,1>	INT3,	   0,       INT hwvinst,    VN_IRQ5,    -1,	int3_irq, < Hardware interrupt 3 >
  134+          VDF <T,1>	INT4,	   0,	    INT hwvinst,    VN_IRQ6,    -1,	int4_irq, < Hardware interrupt 4 >
  135+          VDF <T,1>	INT5,	   0,	    INT hwvinst,    VN_IRQ7,    -1,	int5_irq, < Hardware interrupt 5 >
  136+          VDF <T,1>	TLBMOD,	   0,	    INT hwvinst,    VN_TLBM,    -1,	0,	< TLB modification >
  137+          VDF <T,1>	TLBLOAD,   0,	    INT hwvinst,    VN_TLBL,    -1,	0,	< TLB miss on I or D fetch >
  138+          VDF <T,1>	TLBSTORE,  0,	    INT hwvinst,    VN_TLBS,    -1,	0,	< TLB miss on store >
  139+          VDF <T,1>	ADDRERRL,  0,	    INT hwvinst,    VN_ADDRL,   -1,	0,	< Address error on I or D fetch >
  140+          VDF <T,1>	ADDRERRS,  0,	    INT hwvinst,    VN_ADDRS,   -1,	0,	< Address error on store >
  141+          VDF <T,1>	BUSERRI,   0,	    INT hwvinst,    VN_BUSERRI, -1,	0,	< Bus error on I-fetch >
  142+          VDF <T,1>	BUSERRD,   0,	    INT hwvinst,    VN_BUSERRD, -1,	0,	< Bus error on D-fetch >
  143+          VDF <T,1>	SYSCALL,   0,       INT hwvinst,    VN_SYSCALL, -1,	0,	< SYSCALL instruction >
  144+          VDF <T,1>	BREAK,     0,       INT hwvinst,    VN_BREAK,   -1,	0,	< Breakpoint instruction >
  145+          VDF <T,1>	RESERV,    0,       INT hwvinst,    VN_RESERV,  -1,	0,	< Reserved instruction >
  146+          VDF <T,1>	COPROC,    0,       INT hwvinst,    VN_COPROC,  -1,	0,	< Coprocessor unusable >
  147+          VDF <T,1>	OVRFLOW,   0,       INT hwvinst,    VN_OVERFL,  -1,	0,	< Integer Arithmetic Overflow >
dispatch.c                               Atari Games Corp. macpp v9.12   "Oct 16 1997 13:26:41"


  148+          VDF <T,1>	TRAP,      0,       INT hwvinst,    VN_TRAPV,   -1,	0,	< TRAP exception >
  149+          VDF <T,1>	FLOAT,     0,       INT hwvinst,    VN_FPE,     -1,	0,	< FLoating point exception >
  150+          VDF <T,1>	TIMER,	   timervec, INT 0,	    0,          -1,	0,	< Soft Timer interrupt >
  151+          VDF <T,1>	TIMERPLL,  tpllvec, VEXT 0,	    0,		-1,	0,	<Adjust 1MS timer>
  152+          VDF <T,1>	GAMEFRAME, framevec,INT 0,	    0,		-1,	0,	< Frame complete >
  153+   (3)    .if true, PHX
  154+    X     VDF <D,NET_LVL>	NET,       netintp, INT 0,          0,		NET_LVL,0,	< network int soft vector >
  155+    X     VDF <D,XBUS>	XBUS,	   xbusintp, INT pvinst,    XBUS_NOTES,	XBUS_LVL,xbus_irq, < Any XBUS interrupt >
  156+    X     VDF <T,XS0>	XS0,       xs0intp, INT pvinst,	    XS0_NOTES,	XS0_LVL,0,	< Expansion Slot 0 interrupt >
  157+    X     VDF <T,XS1>	XS1,       xs1intp, INT pvinst,	    XS1_NOTES,	XS1_LVL,0,	< Expansion Slot 1 interrupt >
  158+    X     VDF <T,XS2>	XS2,       xs2intp, INT pvinst,	    XS2_NOTES,	XS2_LVL,0,	< Expansion Slot 2 interrupt >
  159+    X     VDF <T,XS3>	XS3,       xs3intp, INT pvinst,	    XS3_NOTES,	XS3_LVL,0,	< Expansion Slot 3 interrupt >
  160+    X     VDF <T,MIO>	MIO,       miointp, INT pvinst,	    MIO_NOTES,	MIO_LVL,0,	< Miscellaneous I/O interrupt >
  161+    X     VDF <T,CU1>	CU1,       cu1intp, INT pvinst,	    CU1_NOTES,	CU1_LVL,0,	< Combo UART 1 interrupt >
  162+    X     VDF <T,CU2>	CU2,       cu2intp, INT pvinst,	    CU2_NOTES,	CU2_LVL,0,	< Combo UART 2 interrupt >
  163+    X     VDF <T,CPP>	CPP,       cppintp, INT pvinst,	    CPP_NOTES,	CPP_LVL,0,	< Combo Parallel Port interrupt >
  164+    X     VDF <T,PCA>	PCA,       pcaintp, INT pvinst,	    PCA_NOTES,	PCA_LVL,0,	< PCI A interrupt >
  165+    X     VDF <T,PCB>	PCB,       pcbintp, INT pvinst,	    PCB_NOTES,	PCB_LVL,0,	< PCI B interrupt >
  166+    X     VDF <T,PCC>	PCC,       pccintp, INT pvinst,	    PCC_NOTES,	PCC_LVL,0,	< PCI C interrupt >
  167+    X     VDF <T,VSY>	VSY,       vsyintp, INT pvinst,	    VSY_NOTES,	VSY_LVL,0,	< PCI D (VSYNC) interrupt >
  168+    X     VDF <T,IDE>	IDE,	   ideintp, INT pvinst,	    IDE_NOTES,	IDE_LVL,0,	< IDE interrupt >
  169+    X     VDF <T,IOA>	IOA,	   ioaintp, INT pvinst,	    IOA_NOTES,	IOA_LVL,ioa_irq,< I/O Asic interrupt >
  170+    X     VDF <T,ADC>	ADC,	   adcintp, INT pvinst,	    ADC_NOTES,	ADC_LVL,0,	< A/D Converter interrupt >
  171+    X     VDF <D,SND_I>	CAGE,      cagevec, INT 0,          0,		CAGE_LVL,aud_irq, < CAGE interrupt >
  172+   (3)    .endc
  173+   (3)    .if true, PAD || FLG || SEA || VEG
  174+          ;VDF <T,1>	IOA,	   0,	    INT hwvinst,    VN_IRQ3,	-1,	0,	< I/O Asic interrupt >
  175+          VDF <T,1>	IDE,	   0,	    INT hwvinst,    VN_IRQ4,    -1,	0,	< IDE interrupt >
  176+          VDF <T,EXP>	EXP,       expintp, INT pvinst,	    EXP_NOTES,	EXP_LVL,0,	< Expansion Slot interrupt >
  177+   (4)     .if true, PAD || SEA
  178+          VDF <T,NSS>	NSS,	   nssintp, INT pvinst,	    NSS_NOTES,  NSS_LVL,0,	< NSS/Hi-Link interrupt>
  179+   (4)     .endc
  180+   (4)     .if true, FLG
  181+    X     VDF <T,ETH>	ETH,	   ethintp, INT pvinst,     ETH_NOTES,  ETH_LVL,0,	< ethernet interrupt >
  182+    X     VDF <D,SND_I>	CAGE,	   cagevec, INT ioainst,    CAGE_NOTES, CAGE_LVL,aud_irq, < CAGE interrupt >
  183+   (4)     .endc
  184+          VDF <T,WD1>	WD1,	   wd1intp, INT pvinst,	    WD1_NOTES,  WD1_LVL,0,	< Widget interrupt 1>
  185+          VDF <T,PCI>	PCI,       pciintp, INT pvinst,	    PCI_NOTES,	PCI_LVL,0,	< PCI interrupt >
  186+          VDF <T,ADC>	ADC,	   adcintp, INT pvinst,	    ADC_NOTES,	ADC_LVL,0,	< A/D Converter interrupt >
  187+          VDF <T,WD2>	WD2,	   wd2intp, INT pvinst,	    WD2_NOTES,  WD2_LVL,0,	< Widget interrupt 2>
  188+          VDF <T,DBG>	DBG,	   dbgintp, INT pvinst,	    DBG_NOTES,	DBG_LVL,0,	< Debug switch interrupt >
  189+          VDF <T,VSY>	VSY,	   vsyintp, INT pvinst,	    VSY_NOTES,	VSY_LVL,0,	< VSYNC interrupt >
  190+   (3)    .endc
  191+          VDF <T,GAL>	GAL,	   0,       INT gvinst,	    GAL_NOTES,  GAL_LVL,galileoint, < Any Galileo Error Interrupt >
  192+          VDF <T,MOE>	MOE,	   moeintp, INT gvinst,	    MOE_NOTES,	MOE_LVL,0,	< Galileo MemOut >
  193+          VDF <T,DOE>	DOE,	   doeintp, INT gvinst,	    DOE_NOTES,	DOE_LVL,0,	< Galileo DMAOut >
  194+          VDF <T,COE>	COE,	   coeintp, INT gvinst,	    COE_NOTES,	COE_LVL,0,	< Galileo CPUOut >
  195+          VDF <T,DM0>	DM0,	   dm0intp, INT gvinst,	    DM0_NOTES,	DM0_LVL,0,	< Galileo DMA0Comp >
  196+          VDF <T,DM1>	DM1,	   dm1intp, INT gvinst,	    DM1_NOTES,	DM1_LVL,0,	< Galileo DMA1Comp >
  197+          VDF <T,DM2>	DM2,	   dm2intp, INT gvinst,	    DM2_NOTES,	DM2_LVL,0,	< Galileo DMA2Comp >
  198+          VDF <T,DM3>	DM3,	   dm3intp, INT gvinst,	    DM3_NOTES,	DM3_LVL,0,	< Galileo DMA3Comp >
  199+          VDF <T,TM0>	TM0,	   tm0intp, INT gvinst,	    TM0_NOTES,	TM0_LVL,0,	< Galileo T0Exp >
  200+          VDF <T,TM1>	TM1,	   tm1intp, INT gvinst,	    TM1_NOTES,	TM1_LVL,0,	< Galileo T1Exp >
  201+          VDF <T,TM2>	TM2,	   tm2intp, INT gvinst,	    TM2_NOTES,	TM2_LVL,0,	< Galileo T2Exp >
  202+          VDF <T,TM3>	TM3,	   tm3intp, INT gvinst,	    TM3_NOTES,	TM3_LVL,cputimerint, < Galileo T3EXP timer interrupt >
  203+          VDF <T,MRE>	MRE,	   mreintp, INT gvinst,	    MRE_NOTES,	MRE_LVL,0,	< Galileo MasRdErr >
  204+          VDF <T,SWE>	SWE,	   sweintp, INT gvinst,	    SWE_NOTES,	SWE_LVL,0,	< Galileo SlvWrErr >
dispatch.c                               Atari Games Corp. macpp v9.12   "Oct 16 1997 13:26:41"


  205+          VDF <T,MWE>	MWE,	   mweintp, INT gvinst,	    MWE_NOTES,	MWE_LVL,0,	< Galileo MasWrErr >
  206+          VDF <T,SRE>	SRE,	   sreintp, INT gvinst,	    SRE_NOTES,	SRE_LVL,0,	< Galileo SlvRdErr >
  207+          VDF <T,AEP>	AEP,	   aepintp, INT gvinst,	    AEP_NOTES,	AEP_LVL,0,	< Galileo AddrErr >
  208+          VDF <T,MEP>	MEP,	   mepintp, INT gvinst,	    MEP_NOTES,	MEP_LVL,0,	< Galileo MemErr >
  209+          VDF <T,MAS>	MAS,	   masintp, INT gvinst,	    MAS_NOTES,	MAS_LVL,0,	< Galileo MasAbort >
  210+          VDF <T,TAR>	TAR,	   tarintp, INT gvinst,	    TAR_NOTES,	TAR_LVL,0,	< Galileo TarAbort >
  211+          VDF <T,RTY>	RTY,	   rtyintp, INT gvinst,	    RTY_NOTES,	RTY_LVL,0,	< Galileo RetryCtr >
  212+          VDF <T,PC0>	PC0,	   pc0intp, INT gvinst,	    PC0_NOTES,	PC0_LVL,0,	< Galileo PCI Interrupt >
  213+          VDF <T,PC1>	PC1,	   pc1intp, INT gvinst,	    PC1_NOTES,	PC1_LVL,0,	< Galileo PCI Interrupt >
  214+          VDF <T,PC2>	PC2,	   pc2intp, INT gvinst,	    PC2_NOTES,	PC2_LVL,0,	< Galileo PCI Interrupt >
  215+          VDF <T,PC3>	PC3,	   pc3intp, INT gvinst,	    PC3_NOTES,	PC3_LVL,0,	< Galileo PCI Interrupt >
  216+          VDF <D,UART_LVL> UART,	   uartintp,INT ioainst,    UART_NOTES,	UART_LVL,0,	< I/O ASIC UART interrupts >
  217+          VDF <D,SND_LVL>	SND,	   sndintp, INT ioainst,    SND_NOTES,	SND_LVL, 0,	< I/O ASIC Sound interrupts >
  218+          VDF <D,MC_LVL>	MC,	   mcintp,  INT ioainst,    MC_NOTES,	MC_LVL,	0,	< I/O ASIC Microcontroller interrupt >
  219+          ;
  220+   (2)    .endc			; (_DISPATCH_MAC_&1) != 0 *** DON'T MOVE THIS LINE EITHER ***
  221+          ;
  222+          ;+++++++ From here on, there are few user servicable parts inside. ++++
  223+          ;
  224+          ; This is sortof how it works:
  225+          ; The first pass through, _DISPATCH_MAC_ will be 0 (set above by the .if not_defined).
  226+          ; First the copyright boilerplate is inserted into both output files and the macro VDF
  227+          ; is defined to create externs. Some struct definitions and unique externs are depositied
  228+          ; into the .h file. Next _DISPATCH_MAC_ is set to 1 and this file is .included
  229+          ; again. This will cause MACPP to read the VDF table above and output the appropriate
  230+          ; information in the .h file but ignore the rest of the file. The VDF macro is redefined,
  231+          ; and the procedure is repeated causing the creation of different items according to what
  232+          ; is needed. Once the whole .h file is built, the procedure repeats for the building of the
  233+          ; .c file.
  234+          ;
  235+   (2)    .if true, _DISPATCH_MAC_ == 0		; First (main) pass
  236+    X      PHX == 0
  237+    X      PAD == 0
  238+    X      FLG == 0
  239+    X      SEA == 0
  240+    X      VEG == 0
  241+    X      .iif true, HOST_BOARD == PHOENIX, PHX == 1 ;set the appropriate ones true as desired
  242+    X      .iif true, HOST_BOARD == PHOENIX_AD, PAD == 1 ;set the appropriate ones true as desired
  243+    X      .iif true, HOST_BOARD == FLAGSTAFF, FLG == 1 ;set the appropriate ones true as desired
  244+    X      .iif true, HOST_BOARD == SEATTLE, SEA == 1 ;set the appropriate ones true as desired
  245+    X      .iif true, HOST_BOARD == VEGAS, VEG == 1 ;set the appropriate ones true as desired
  246+          ;
  247+    X     	.macro .condit flag,exp		; The .condit macro does an expression test ...
  248+    X     	.if identical,<flag>,<T>
  249+    X     		.iif false,exp,.mexit 10 ; ... and aborts higher level macros if false
  250+    X     		.mexit
  251+    X     	.endc
  252+    X     	.if identical,<flag>,<F>
  253+    X     		.iif true,exp,.mexit 10	; ... etc.
  254+    X     		.mexit
  255+    X     	.endc
  256+    X     	.if identical,<flag>,<D>
  257+    X     		.iif not_defined,exp,.mexit 10
  258+    X     		.mexit
  259+    X     	.endc
  260+    X     	.if identical,<flag>,<N>
  261+    X     		.iif defined,exp,.mexit 10
dispatch.c                               Atari Games Corp. macpp v9.12   "Oct 16 1997 13:26:41"


  262+    X     		.mexit
  263+    X     	.endc
  264+    X     	.endm
  265+          ;	
  266+    X     	.macro boilerplate file_name
  267+    X     /*		file_name
  268+    X      *
  269+    X      *		Copyright 1996 Atari Games Corporation
  270+    X      *	Unauthorized reproduction, adaptation, distribution, performance or 
  271+    X      *	display of this computer program or the associated audiovisual work
  272+    X      *	is strictly prohibited.
  273+    X      *
  274+    X      * ++++++ WARNING WARNING WARNING WARNING WARNING +++++
  275+    X      * This file is machine generated. Any changes you put in here will be lost
  276+    X      * the next time phx_vecs.mac is touched. You need to make your changes to
  277+    X      * phx_vecs.mac instead of this file.
  278+    X      */
  279+    X     	.endm
  280+    X     	boilerplate dispatch.c
  281+    X     	.outfile	1		;The externs go into the .h file
  282+    X     	boilerplate intvecs.h
  283+    X     #if !defined(_INTVECS_H_)
  284+    X     #define _INTVECS_H_
  285+          
  286+    X     struct irq_tab {
  287+    X     	void 	(**softvec)();
  288+    X     	void    (*(*installer)(const struct irq_tab *, void(*new)()))();
  289+    X     	int	notes;
  290+    X     };
  291+          ;
  292+    X     	.macro VDF cond, name, softvec, intern, installer, notes, physical, default, comments
  293+    X     	.condit cond	
  294+    X      .if dif,<softvec>,<0>
  295+    X       ...1 == 0
  296+    X       .iif idn,<intern>,<VINT>,...1 == 1
  297+    X       .iif idn,<intern>,<VEXT>,...1 == 1
  298+    X       .if true, ...1
  299+    X     extern	void (* volatile softvec)();	/* comments */
  300+    X       .iff
  301+    X     extern  void (*softvec)();	/* comments */
  302+    X       .endc
  303+    X      .endc
  304+    X     	.endm
  305+          ;
  306+    X     	_DISPATCH_MAC_ == 1		;next time we process the IRQ table
  307+    X     	.include phx_vecs.mac		;Make the externs
  308+          
  309+    X     enum vecs {
  310+    X     	.macro VDF cond, name, softvec, intern, installer, notes, physical, default, comments
  311+    X     	.condit cond	
  312+    X         name'_INTVEC,
  313+    X     	.endm
  314+    X     	.include phx_vecs.mac		;Make the enums
  315+    X         N_INTVECS
  316+    X     };
  317+          
  318+    X     void (*prc_set_vec (unsigned int vecnum, void (*routine)() ))();
dispatch.c                               Atari Games Corp. macpp v9.12   "Oct 16 1997 13:26:41"


  319+    X     void prc_init_vecs(void);		/* set the default vectors */
  320+          ;
  321+          ; Add a prototype for an as yet unused function
  322+    X     .if true, 0
  323+          
  324+    X     /*		prc_set_vecp(which, what)
  325+    X      *	Sets a special vector for the interrupt identified by <which>
  326+    X      *	to call the routine specified by <what>. <what> is
  327+    X      *	a struct that contains both a pointer to the code
  328+    X      *	to execute and an optional pointer to the private
  329+    X      *	variables for that routine. This is a change from the
  330+    X      *	behavior of prc_set_vec, and is intended to allow
  331+    X      *	multiple incarnations of a given device to share code.
  332+    X      */
  333+          
  334+    X     struct opaque;
  335+    X     extern struct VECP_vector {
  336+    X         void (*function)(struct opaque *);	/* Who you gonna call */
  337+    X         struct opaque *cookie;		/* a magic cookie to hand him */
  338+    X     } prc_set_vecp (
  339+    X         int __which,			/* one of xxx_INTVEC */
  340+    X         struct IRQ_vector __what		/* BY VALUE!!! */
  341+    X     );
  342+    X     .endc
  343+    X     #endif		/* _INTVECS_H_ */
  344+          ;
  345+          ; At this point, we have completed all processing of the .h file
  346+          ; so switch back to the .c file
  347+          ;
  348+    X     	.outfile	0		;switch back to dispatch.c
  349+          ;
  350+    X     #include <config.h>			/* begining of dispatch.c */
  351+    X     #include <os_proto.h>
  352+    X     #include <intvecs.h>
  353+          
  354+    X     #ifndef BLABF
  355+    X     # define BLABF(x)
  356+    X     #endif
  357+          
  358+    X     #ifndef BLAB
  359+    X     # define BLAB(x)
  360+    X     #endif
  361+          
  362+    X      .if true, 1
  363+    X     	.macro VDF cond, name, softvec, intern, installer, notes, physical, default, comments
  364+    X     	.condit cond	
  365+    X       .iif idn,<name>,<XBUS0>,.mexit
  366+    X       .iif idn,<name>,<XBUS1>,.mexit
  367+    X       .iif idn,<name>,<XBUS2>,.mexit
  368+    X       .iif idn,<name>,<XBUS3>,.mexit
  369+    X       .iif idn,<name>,<INT0>,.mexit
  370+    X       .iif idn,<name>,<INT1>,.mexit
  371+    X       .iif idn,<name>,<INT2>,.mexit
  372+    X       .iif idn,<name>,<INT3>,.mexit
  373+    X       .iif idn,<name>,<INT4>,.mexit
  374+    X       .iif idn,<name>,<INT5>,.mexit
  375+    X       .if true, PHX
dispatch.c                               Atari Games Corp. macpp v9.12   "Oct 16 1997 13:26:41"


  376+    X         .if true, physical == XBUS0_LVL
  377+    X     	  ...XBUS0 == ...XBUS0 + 1
  378+    X     	  .mexit
  379+    X         .endc
  380+    X         .if true, physical == XBUS1_LVL
  381+    X     	  ...XBUS1 == ...XBUS1 + 1
  382+    X     	  .mexit
  383+    X         .endc
  384+    X         .if true, physical == XBUS2_LVL
  385+    X     	  ...XBUS2 == ...XBUS2 + 1
  386+    X     	  .mexit
  387+    X         .endc
  388+    X         .if true, physical == XBUS3_LVL
  389+    X     	  ...XBUS3 == ...XBUS3 + 1
  390+    X     	  .mexit
  391+    X         .endc
  392+    X       .endc
  393+    X       .if true, physical == INT0_LVL
  394+    X         	...INT0 == ...INT0 + 1
  395+    X     	.mexit
  396+    X       .endc
  397+    X       .if true, physical == INT1_LVL
  398+    X         	...INT1 == ...INT1 + 1
  399+    X        .if true, PAD || FLG || SEA || VEG
  400+    X     	...IOA == ...IOA + 1
  401+    X         .if ndf, notes
  402+    X     #define notes IO_MAIN_GLOBAL_INT
  403+    X         .endc
  404+    X        .endc
  405+    X     	.mexit
  406+    X       .endc
  407+    X       .if true, physical == INT2_LVL
  408+    X         	...INT2 == ...INT2 + 1
  409+    X     	.mexit
  410+    X       .endc
  411+    X       .if true, physical == INT3_LVL
  412+    X         	...INT3 == ...INT3 + 1
  413+    X     	.mexit
  414+    X       .endc
  415+    X       .if true, physical == INT4_LVL
  416+    X         	...INT4 == ...INT4 + 1
  417+    X     	.mexit
  418+    X       .endc
  419+    X       .if true, physical == INT5_LVL
  420+    X         	...INT5 == ...INT5 + 1
  421+    X     	.mexit
  422+    X       .endc
  423+    X       .if true, physical == IOASIC_LVL
  424+    X         	...IOA == ...IOA + 1
  425+    X        .if ndf, notes
  426+    X     #define notes IO_MAIN_GLOBAL_INT
  427+    X        .endc
  428+    X     	.mexit
  429+    X       .endc
  430+    X     	.endm
  431+    X     ...XBUS0 == 0
  432+    X     ...XBUS1 == 0
dispatch.c                               Atari Games Corp. macpp v9.12   "Oct 16 1997 13:26:41"


  433+    X     ...XBUS2 == 0
  434+    X     ...XBUS3 == 0
  435+    X     ...INT0 == 0
  436+    X     ...INT1 == 0
  437+    X     ...INT2 == 0
  438+    X     ...INT3 == 0
  439+    X     ...INT4 == 0
  440+    X     ...INT5 == 0
  441+    X     ...IOA == 0
  442+    X     	.include phx_vecs.mac	; count vectors requiring dispatch
  443+    X      .endc
  444+          ; 
  445+    X     .macro VDF cond, name, softvec, intern, installer, notes, physical, default, comments
  446+    X      .condit cond	
  447+    X      .if dif,<softvec>,<0>
  448+    X       .if idn,<intern>,<INT>
  449+    X     void (*softvec)();	/* comments */
  450+    X       .endc
  451+    X       .if idn,<intern>,<VINT>
  452+    X     void (* volatile softvec)();	/* comments */
  453+    X       .endc
  454+    X      .endc
  455+    X      .if dif,<default>,<0>
  456+    X       .if idn,<name>,<INT0>
  457+    X        .if true, ...INT0
  458+    X     static void 'default'(void);	/* comments */
  459+    X        .endc
  460+    X        .mexit
  461+    X       .endc
  462+    X       .if idn,<name>,<INT1>
  463+    X        .if true, ...INT1
  464+    X     static void 'default'(void);	/* comments */
  465+    X        .endc
  466+    X        .mexit
  467+    X       .endc
  468+    X       .if idn,<name>,<INT2>
  469+    X        .if true, ...INT2
  470+    X     static void 'default'(void);	/* comments */
  471+    X        .endc
  472+    X        .mexit
  473+    X       .endc
  474+    X       .if idn,<name>,<INT3>
  475+    X        .if true, ...INT3
  476+    X     static void 'default'(void);	/* comments */
  477+    X        .endc
  478+    X        .mexit
  479+    X       .endc
  480+    X       .if idn,<name>,<INT4>
  481+    X        .if true, ...INT4
  482+    X     static void 'default'(void);	/* comments */
  483+    X        .endc
  484+    X        .mexit
  485+    X       .endc
  486+    X       .if idn,<name>,<INT5>
  487+    X        .if true, ...INT5
  488+    X     static void 'default'(void);	/* comments */
  489+    X        .endc
dispatch.c                               Atari Games Corp. macpp v9.12   "Oct 16 1997 13:26:41"


  490+    X        .mexit
  491+    X       .endc
  492+    X       .if idn,<name>,<INT6>
  493+    X        .if true, ...INT6
  494+    X     static void 'default'(void);	/* comments */
  495+    X        .endc
  496+    X        .mexit
  497+    X       .endc
  498+    X       .if idn,<name>,<INT7>
  499+    X        .if true, ...INT7
  500+    X     static void 'default'(void);	/* comments */
  501+    X        .endc
  502+    X        .mexit
  503+    X       .endc
  504+    X       .if true, PHX
  505+    X        .if idn,<name>,<XBUS>
  506+    X         .if true, ...XBUS0|...XBUS1|...XBUS2|...XBUS3
  507+    X     static void 'default'(void);
  508+    X         .endc
  509+    X         .mexit
  510+    X        .endc
  511+    X        .if idn,<name>,<XBUS0>
  512+    X         .if true, ...XBUS0
  513+    X     static void 'default'(void);
  514+    X         .endc
  515+    X         .mexit
  516+    X        .endc
  517+    X        .if idn,<name>,<XBUS1>
  518+    X         .if true, ...XBUS1
  519+    X     static void 'default'(void);
  520+    X         .endc
  521+    X         .mexit
  522+    X        .endc
  523+    X        .if idn,<name>,<XBUS2>
  524+    X         .if true, ...XBUS2
  525+    X     static void 'default'(void);
  526+    X         .endc
  527+    X         .mexit
  528+    X        .endc
  529+    X        .if idn,<name>,<XBUS3>
  530+    X         .if true, ...XBUS3
  531+    X     static void 'default'(void);
  532+    X         .endc
  533+    X         .mexit
  534+    X        .endc
  535+    X       .endc			; PHX
  536+    X       .if idn,<name>,<IOA>
  537+    X        .if true, ...IOA
  538+    X     static void 'default'(void);
  539+    X        .endc
  540+    X        .mexit
  541+    X       .endc
  542+    X     extern void 'default'(void);
  543+    X      .endc
  544+    X     .endm
  545+    X     	.include phx_vecs.mac		;Declare the non-extern vectors
  546+          ;
dispatch.c                               Atari Games Corp. macpp v9.12   "Oct 16 1997 13:26:41"


  547+    X      .if true, ((PROCESSOR&-16) == MIPS3000) || ((PROCESSOR&-16) == MIPS4000)
  548+    X     static void (*hwvinst(const struct irq_tab *, void (*)()))();
  549+    X      .endc
  550+          ;
  551+    X     .if df, PHOENIX_INTCTL_MASK
  552+    X     static void (*pvinst(const struct irq_tab *, void (*)()))();
  553+    X     .endc
  554+          ;
  555+    X     .if df, GALILEO_INTCTL_MASK
  556+    X     static void (*gvinst(const struct irq_tab *, void (*)()))();
  557+    X     .endc
  558+          ;
  559+    X     .if true, ...IOA
  560+    X     static void (*ioainst(const struct irq_tab *, void (*)()))();
  561+    X     .endc
  562+          ;
  563+    X     static const struct irq_tab irq_inits[] = {
  564+    X     	.macro VDF cond, name, softvec, intern, installer, notes, physical, default, comments
  565+    X     	.condit cond	
  566+    X      .if dif,<softvec>,<0>
  567+    X      { (void (**)())&softvec, installer, notes },	/* comments */
  568+    X      .iff
  569+    X      { 0, installer, notes },	/* comments */
  570+    X      .endc
  571+    X     	.endm
  572+    X     	.include phx_vecs.mac		;Build the irq_inits array
  573+    X      { 0, 0, 0} };
  574+          ;
  575+    X     .if true, ((PROCESSOR&-16) == MIPS3000) || ((PROCESSOR&-16) == MIPS4000)
  576+          
  577+    X     extern void (*ramv_tbl[])();
  578+          
  579+    X     static void (*hwvinst(const struct irq_tab *it, void (*new)()))() {
  580+    X         int indx;
  581+    X         void (*old_rtn)();
  582+          
  583+    X         indx = it->notes;
  584+    X         if (indx >= VN_MAX) return 0;
  585+    X         old_rtn = ramv_tbl[indx];
  586+    X         ramv_tbl[indx] = new;
  587+    X         return old_rtn;
  588+    X     }
  589+          
  590+    X      .if df, PHOENIX_INTCTL_MASK
  591+    X     static void (*pvinst(const struct irq_tab *it, void (*new)()))() {
  592+          
  593+    X         if (it->notes) {
  594+    X     	BLABF(("\ndispatch: Adding 0x%08lX to main INTCTL (0x%08lX)...", it->notes, *(VU32*)INTCTL_IE));
  595+    X     	*((VU32 *)(INTCTL_IE)) |= it->notes;
  596+    X         }
  597+    X         return 0;
  598+    X     }
  599+    X      .endc
  600+          
  601+    X      .if df, GALILEO_INTCTL_MASK
  602+    X     static void (*gvinst(const struct irq_tab *it, void (*new)()))() {
  603+          
dispatch.c                               Atari Games Corp. macpp v9.12   "Oct 16 1997 13:26:41"


  604+    X         if (it->notes) {
  605+    X     	BLABF(("\ndispatch: Adding 0x%08lX to Galileo INTCTL (0x%08lX)...", it->notes, \
  606+    X     			*(VU32*)GALILEO_CPU_I_ENA));
  607+    X     	*((VU32 *)(GALILEO_CPU_I_ENA)) |= it->notes;
  608+    X         }
  609+    X         return 0;
  610+    X     }
  611+    X      .endc
  612+          
  613+    X      .if true, ...IOA
  614+    X     static void (*ioainst(const struct irq_tab *it, void (*new)()))() {
  615+    X     extern void prc_wait_n_usecs( int );
  616+    X         if (it->notes)
  617+    X         {
  618+    X          BLABF(("\ndispatch: Adding 0x%04X to IOASIC INTCTL: (0x%04X)...", (int)it->notes, \
  619+    X     		*(VU32*)IO_MAIN_CTL&0xFFFF));
  620+    X          while ( ( *((VU32 *)IO_MAIN_CTL) & it->notes ) != it->notes )
  621+    X          {
  622+    X     #ifdef LED_OUT
  623+    X           *(VU32 *)LED_OUT = ~( 1 << B_LED_RED );
  624+    X     #endif
  625+    X           do
  626+    X           {
  627+    X            *((VU32 *)IO_MAIN_CTL) |= it->notes;
  628+    X            prc_wait_n_usecs( 1000 );
  629+    X           } while ( ( *((VU32 *)IO_MAIN_CTL) & it->notes ) != it->notes );
  630+    X           prc_wait_n_usecs( 1000 );
  631+    X     #ifdef LED_OUT
  632+    X           *(VU32 *)LED_OUT |= ( 1 << B_LED_RED );
  633+    X     #endif
  634+    X          }
  635+    X         }
  636+    X         return 0;
  637+    X     }
  638+    X      .endc
  639+    X     .endc
  640+          
  641+    X     void (*prc_set_vec (unsigned int vecnum, void (*routine)() ))()
  642+    X     {
  643+    X         void (*old_rtn)();
  644+    X         void (**softvec)();
  645+    X         const struct irq_tab *tbp;
  646+    X         int old_ipl;
  647+          
  648+    X         if ( vecnum >= N_INTVECS ) return 0;
  649+    X         tbp = irq_inits+vecnum;
  650+    X         softvec = tbp->softvec;
  651+    X         old_rtn = 0;
  652+    X         old_ipl = prc_set_ipl(INTS_OFF);
  653+    X         if ( tbp->installer ) old_rtn = tbp->installer(tbp, routine);
  654+    X         if ( softvec ) {
  655+    X     	if (!old_rtn) old_rtn = *softvec;
  656+    X     	*softvec = routine;
  657+    X         }
  658+    X         prc_set_ipl(old_ipl);
  659+    X         return old_rtn;
  660+    X     }
dispatch.c                               Atari Games Corp. macpp v9.12   "Oct 16 1997 13:26:41"


  661+          
  662+    X      .if true, PHX
  663+    X       .if true, ...XBUS0
  664+    X     static void xbus0_irq(void) {
  665+    X     	.macro VDF cond, name, softvec, intern, installer, notes, physical, default, comments
  666+    X     	.condit cond	
  667+    X       .iif idn,<name>,<XBUS0>,.mexit
  668+    X       .iif idn,<softvec>,<0>,.mexit
  669+    X       .if true, physical == XBUS0_LVL
  670+    X         if (softvec) softvec();
  671+    X       .endc
  672+    X     	.endm
  673+    X     	.include phx_vecs.mac		; pickup all vectors assigned to XBUS0_LVL
  674+    X         return;
  675+    X     }
  676+          
  677+    X       .endc		; ...XBUS0
  678+    X       .if true, ...XBUS1
  679+    X     static void xbus1_irq(void) {
  680+    X     	.macro VDF cond, name, softvec, intern, installer, notes, physical, default, comments
  681+    X     	.condit cond	
  682+    X       .iif idn,<name>,<XBUS1>,.mexit
  683+    X       .iif idn,<softvec>,<0>,.mexit
  684+    X       .if true, physical == XBUS1_LVL
  685+    X         if (softvec) softvec();
  686+    X       .endc
  687+    X     	.endm
  688+    X     	.include phx_vecs.mac		; pickup all vectors assigned to XBUS1_LVL
  689+    X         return;
  690+    X     }
  691+          
  692+    X       .endc		; ...XBUS1
  693+    X       .if true, ...XBUS2
  694+    X     static void xbus2_irq(void) {
  695+    X     	.macro VDF cond, name, softvec, intern, installer, notes, physical, default, comments
  696+    X     	.condit cond	
  697+    X       .iif idn,<name>,<XBUS2>,.mexit
  698+    X       .iif idn,<softvec>,<0>,.mexit
  699+    X       .if true, physical == XBUS2_LVL
  700+    X         if (softvec) softvec();
  701+    X       .endc
  702+    X     	.endm
  703+    X     	.include phx_vecs.mac		; pickup all vectors assigned to XBUS2_LVL
  704+    X         return;
  705+    X     }
  706+          
  707+    X       .endc		; ...XBUS2
  708+    X       .if true, ...XBUS3
  709+    X     static void xbus3_irq(void) {
  710+    X     	.macro VDF cond, name, softvec, intern, installer, notes, physical, default, comments
  711+    X     	.condit cond	
  712+    X       .iif idn,<name>,<XBUS3>,.mexit
  713+    X       .iif idn,<softvec>,<0>,.mexit
  714+    X       .if true, physical == XBUS3_LVL
  715+    X         if (softvec) softvec();
  716+    X       .endc
  717+    X     	.endm
dispatch.c                               Atari Games Corp. macpp v9.12   "Oct 16 1997 13:26:41"


  718+    X     	.include phx_vecs.mac		; pickup all vectors assigned to XBUS3_LVL
  719+    X         return;
  720+    X     }
  721+          
  722+    X       .endc		; ...XBUS3
  723+    X      .endc		; PHX
  724+    X      .if true, ...INT0
  725+    X     static void int0_irq(void) {
  726+    X     	.macro VDF cond, name, softvec, intern, installer, notes, physical, default, comments
  727+    X     	.condit cond	
  728+    X       .iif idn,<name>,<INT0>,.mexit
  729+    X       .iif idn,<softvec>,<0>,.mexit
  730+    X       .if true, physical == INT0_LVL
  731+    X         if (softvec) softvec();
  732+    X       .endc
  733+    X     	.endm
  734+    X     	.include phx_vecs.mac		; pickup all vectors assigned to IRQ 0
  735+    X         return;
  736+    X     }
  737+          
  738+    X      .endc		; ...INT0
  739+    X      .if true, ...INT1
  740+    X     static void int1_irq(void) {
  741+    X     	.macro VDF cond, name, softvec, intern, installer, notes, physical, default, comments
  742+    X     	.condit cond	
  743+    X       .iif idn,<name>,<INT1>,.mexit
  744+    X       .iif idn,<softvec>,<0>,.mexit
  745+    X       .if true, physical == INT1_LVL
  746+    X         if (softvec) softvec();
  747+    X       .endc
  748+    X     	.endm
  749+    X     	.include phx_vecs.mac		; pickup all vectors assigned to IRQ 1
  750+    X         return;
  751+    X     }
  752+          
  753+    X      .endc		; ...INT1
  754+    X      .if true, ...INT2
  755+    X     static void int2_irq(void) {
  756+    X     	.macro VDF cond, name, softvec, intern, installer, notes, physical, default, comments
  757+    X     	.condit cond	
  758+    X       .iif idn,<name>,<INT2>,.mexit
  759+    X       .iif idn,<softvec>,<0>,.mexit
  760+    X       .if true, physical == INT2_LVL
  761+    X         if (softvec) softvec();
  762+    X       .endc
  763+    X     	.endm
  764+    X     	.include phx_vecs.mac		; pickup all vectors assigned to IRQ 2
  765+    X         return;
  766+    X     }
  767+          
  768+    X      .endc		; ...INT2
  769+    X      .if true, ...INT3
  770+    X     static void int3_irq(void) {
  771+    X     	.macro VDF cond, name, softvec, intern, installer, notes, physical, default, comments
  772+    X     	.condit cond	
  773+    X       .iif idn,<name>,<INT3>,.mexit
  774+    X       .iif idn,<softvec>,<0>,.mexit
dispatch.c                               Atari Games Corp. macpp v9.12   "Oct 16 1997 13:26:41"


  775+    X       .if true, physical == INT3_LVL
  776+    X         if (softvec) softvec();
  777+    X       .endc
  778+    X     	.endm
  779+    X     	.include phx_vecs.mac		; pickup all vectors assigned to IRQ 3
  780+    X         return;
  781+    X     }
  782+          
  783+    X      .endc		; ...INT3
  784+    X      .if true, ...INT4
  785+    X     static void int4_irq(void) {
  786+    X     	.macro VDF cond, name, softvec, intern, installer, notes, physical, default, comments
  787+    X     	.condit cond	
  788+    X       .iif idn,<name>,<INT4>,.mexit
  789+    X       .iif idn,<softvec>,<0>,.mexit
  790+    X       .if true, physical == INT4_LVL
  791+    X         if (softvec) softvec();
  792+    X       .endc
  793+    X     	.endm
  794+    X     	.include phx_vecs.mac		; pickup all vectors assigned to IRQ 4
  795+    X         return;
  796+    X     }
  797+          
  798+    X      .endc		; ...INT4
  799+    X      .if true, ...INT5
  800+    X     static void int5_irq(void) {
  801+    X     	.macro VDF cond, name, softvec, intern, installer, notes, physical, default, comments
  802+    X     	.condit cond	
  803+    X       .iif idn,<name>,<INT5>,.mexit
  804+    X       .iif idn,<softvec>,<0>,.mexit
  805+    X       .if true, physical == INT5_LVL
  806+    X         if (softvec) softvec();
  807+    X       .endc
  808+    X     	.endm
  809+    X     	.include phx_vecs.mac		; pickup all vectors assigned to IRQ 5
  810+    X         return;
  811+    X     }
  812+          
  813+    X      .endc		; ...INT5
  814+    X      .if true, ...IOA && PHX
  815+    X     static void ioa_irq(void) {
  816+    X     	.macro VDF cond, name, softvec, intern, installer, notes, physical, default, comments
  817+    X     	.condit cond	
  818+    X       .iif idn,<name>,<IOA>,.mexit
  819+    X       .iif idn,<softvec>,<0>,.mexit
  820+    X       .if true, physical == IOASIC_LVL
  821+    X         if (softvec) softvec();
  822+    X       .endc
  823+    X     	.endm
  824+    X     	.include phx_vecs.mac		; pickup all vectors assigned to IRQ 5
  825+    X         return;
  826+    X     }
  827+          
  828+    X      .endc		; ...IOA
  829+    X      .if true, PHX
  830+    X       .if true, ...XBUS0|...XBUS1|...XBUS2|...XBUS3
  831+    X     static void xbus_irq(void) {
dispatch.c                               Atari Games Corp. macpp v9.12   "Oct 16 1997 13:26:41"


  832+    X         int which;
  833+    X         which = *(VU32 *)(XBUS_SLOT0+4);
  834+    X       .if true, ...XBUS0
  835+    X         if (!(which&1)) xbus0_irq();
  836+    X       .endc
  837+    X       .if true, ...XBUS1
  838+    X         if (!(which&2)) xbus1_irq();
  839+    X       .endc
  840+    X       .if true, ...XBUS2
  841+    X         if (!(which&4)) xbus2_irq();
  842+    X       .endc
  843+    X       .if true, ...XBUS3
  844+    X         if (!(which&8)) xbus3_irq();
  845+    X       .endc
  846+    X         return;
  847+    X     }
  848+    X       .endc
  849+    X      .endc		; PHX
  850+    X     void prc_init_vecs(void) {
  851+    X     	.macro VDF cond, name, softvec, intern, installer, notes, physical, default, comments
  852+    X     	.condit cond	
  853+    X     .if dif,<default>,<0>
  854+    X      .if true, PHX
  855+    X       .if idn,<name>,<XBUS0>
  856+    X        .iif true, ...XBUS0 == 0, .mexit
  857+    X       .endc
  858+    X       .if idn,<name>,<XBUS1>
  859+    X        .iif true, ...XBUS1 == 0, .mexit
  860+    X       .endc
  861+    X       .if idn,<name>,<XBUS2>
  862+    X        .iif true, ...XBUS2 == 0, .mexit
  863+    X       .endc
  864+    X       .if idn,<name>,<XBUS3>
  865+    X        .iif true, ...XBUS3 == 0, .mexit
  866+    X       .endc
  867+    X       .if idn,<name>,<XBUS>
  868+    X        .iif true, (...XBUS0|...XBUS1|...XBUS2|...XBUS3) == 0, .mexit
  869+    X       .endc
  870+    X      .endc	; PHX
  871+    X      .if idn,<name>,<INT0>
  872+    X       .iif true, ...INT0 == 0, .mexit
  873+    X      .endc
  874+    X      .if idn,<name>,<INT1>
  875+    X       .iif true, ...INT1 == 0, .mexit
  876+    X      .endc
  877+    X      .if idn,<name>,<INT2>
  878+    X       .iif true, ...INT2 == 0, .mexit
  879+    X      .endc
  880+    X      .if idn,<name>,<INT3>
  881+    X       .iif true, ...INT3 == 0, .mexit
  882+    X      .endc
  883+    X      .if idn,<name>,<INT4>
  884+    X       .iif true, ...INT4 == 0, .mexit
  885+    X      .endc
  886+    X      .if idn,<name>,<INT5>
  887+    X       .iif true, ...INT5 == 0, .mexit
  888+    X      .endc
dispatch.c                               Atari Games Corp. macpp v9.12   "Oct 16 1997 13:26:41"


  889+    X      .if idn,<name>,<IOA>
  890+    X       .iif true, ...IOA == 0, .mexit
  891+    X      .endc
  892+    X         prc_set_vec('name'_INTVEC, default);
  893+    X     .endc
  894+    X     	.endm
  895+    X     	.include phx_vecs.mac
  896+          
  897+    X     /* Map the Phoenix interrupts */
  898+          
  899+    X     .if df, INTCTL_MAPA_INIT
  900+    X         BLABF(("\ndispatch: Mapping the A interrupts: 0x%08lX...", INTCTL_MAPA_INIT));
  901+    X         *((VU32 *)(INTCTL_MAPA)) = INTCTL_MAPA_INIT;
  902+    X     .endc
  903+    X     .if df, INTCTL_MAPB_INIT
  904+    X         BLABF(("\ndispatch: Mapping the B interrupts: 0x%08lX...", INTCTL_MAPB_INIT));
  905+    X         *((VU32 *)(INTCTL_MAPB)) = INTCTL_MAPB_INIT;
  906+    X     .endc
  907+          
  908+    X     .if defined, ANNOUNCE_BOOT_ACTIONS
  909+    X      .if true, ANNOUNCE_BOOT_ACTIONS
  910+    X         {
  911+    X     	int jj;
  912+    X     	extern int prc_get_cause(void), prc_get_ipl(void);
  913+    X     	jj = prc_get_cause();
  914+    X     	if (jj&0xFF00) BLABF(("\ndispatch: CPU cause reg: %08lX, CPU SR reg: %08lX", jj, prc_get_ipl()));
  915+    X     	if (jj&0x0400) {
  916+    X       .if true, ...INT0
  917+    X     	.macro VDF cond, name, softvec, intern, installer, notes, physical, default, comments
  918+    X     	.condit cond	
  919+    X        .iif idn,<name>,<INT0>,.mexit
  920+    X        .iif idn,<softvec>,<0>,.mexit
  921+    X        .if true, physical == INT0_LVL
  922+    X     	    if (!softvec) BLAB("\ndispatch: Warning, IRQ 0 pending \"'comments'\"");
  923+    X        .endc
  924+    X     	.endm
  925+    X     	.include phx_vecs.mac		; pickup all vectors assigned to IRQ 0
  926+    X       .iff
  927+    X     	    BLAB("\ndispatch: Warning, IRQ 0 pending with no vector assigned");
  928+    X       .endc		; ...INT0
  929+    X     	}
  930+    X     	if (jj&0x0800) {
  931+    X       .if true, ...INT1
  932+    X     	.macro VDF cond, name, softvec, intern, installer, notes, physical, default, comments
  933+    X     	.condit cond	
  934+    X        .iif idn,<name>,<INT1>,.mexit
  935+    X        .iif idn,<softvec>,<0>,.mexit
  936+    X        .if true, physical == INT1_LVL
  937+    X     	    if (!softvec) BLAB("\ndispatch: Warning, IRQ 1 pending \"'comments'\"");
  938+    X        .endc
  939+    X     	.endm
  940+    X     	.include phx_vecs.mac		; pickup all vectors assigned to IRQ 1
  941+    X       .iff
  942+    X     	    BLAB("\ndispatch: Warning, IRQ 1 pending with no vector assigned");
  943+    X       .endc		; ...INT1
  944+    X     	}
  945+    X     	if (jj&0x1000) {
dispatch.c                               Atari Games Corp. macpp v9.12   "Oct 16 1997 13:26:41"


  946+    X       .if true, ...INT2
  947+    X     	.macro VDF cond, name, softvec, intern, installer, notes, physical, default, comments
  948+    X     	.condit cond	
  949+    X        .iif idn,<name>,<INT2>,.mexit
  950+    X        .iif idn,<softvec>,<0>,.mexit
  951+    X        .if true, physical == INT2_LVL
  952+    X     	    if (!softvec) BLAB("\ndispatch: Warning, IRQ 2 pending \"'comments'\"");
  953+    X        .endc
  954+    X     	.endm
  955+    X     	.include phx_vecs.mac		; pickup all vectors assigned to IRQ 2
  956+    X       .iff
  957+    X     	    BLAB("\ndispatch: Warning, IRQ 2 pending with no vector assigned");
  958+    X       .endc		; ...INT2
  959+    X     	}
  960+    X     	if (jj&0x2000) {
  961+    X       .if true, ...INT3
  962+    X     	.macro VDF cond, name, softvec, intern, installer, notes, physical, default, comments
  963+    X     	.condit cond	
  964+    X        .iif idn,<name>,<INT3>,.mexit
  965+    X        .iif idn,<softvec>,<0>,.mexit
  966+    X        .if true, physical == INT3_LVL
  967+    X     	    if (!softvec) BLAB("\ndispatch: Warning, IRQ 3 pending \"'comments'\"");
  968+    X        .endc
  969+    X     	.endm
  970+    X     	.include phx_vecs.mac		; pickup all vectors assigned to IRQ 3
  971+    X       .iff
  972+    X     	    BLAB("\ndispatch: Warning, IRQ 3 pending with no vector assigned");
  973+    X       .endc		; ...INT3
  974+    X     	}
  975+    X     	if (jj&0x4000) {
  976+    X       .if true, ...INT4
  977+    X     	.macro VDF cond, name, softvec, intern, installer, notes, physical, default, comments
  978+    X     	.condit cond	
  979+    X        .iif idn,<name>,<INT4>,.mexit
  980+    X        .iif idn,<softvec>,<0>,.mexit
  981+    X        .if true, physical == INT4_LVL
  982+    X     	    if (!softvec) BLAB("\ndispatch: Warning, IRQ 4 pending \"'comments'\"");
  983+    X        .endc
  984+    X     	.endm
  985+    X     	.include phx_vecs.mac		; pickup all vectors assigned to IRQ 4
  986+    X       .iff
  987+    X     	    BLAB("\ndispatch: Warning, IRQ 4 pending with no vector assigned");
  988+    X       .endc		; ...INT4
  989+    X     	}
  990+    X     	if (jj&0x8000) {
  991+    X       .if true, ...INT5
  992+    X     	.macro VDF cond, name, softvec, intern, installer, notes, physical, default, comments
  993+    X     	.condit cond	
  994+    X        .iif idn,<name>,<INT5>,.mexit
  995+    X        .iif idn,<softvec>,<0>,.mexit
  996+    X        .if true, physical == INT5_LVL
  997+    X     	    if (!softvec) BLAB("\ndispatch: Warning, IRQ 5 pending \"'comments'\"");
  998+    X        .endc
  999+    X     	.endm
 1000+    X     	.include phx_vecs.mac		; pickup all vectors assigned to IRQ 5
 1001+    X       .iff
 1002+    X     	    BLAB("\ndispatch: Warning, IRQ 5 pending with no vector assigned");
dispatch.c                               Atari Games Corp. macpp v9.12   "Oct 16 1997 13:26:41"


 1003+    X       .endc		; ...INT5
 1004+    X     	}
 1005+    X         }
 1006+    X      .endc		; true, ANNOUNCE_BOOT_ACTIONS
 1007+    X     .endc		; defined, ANNOUNCE_BOOT_ACTIONS
 1008+    X         return;
 1009+    X     }
 1010+   (2)    .endc		; _DISPATCH_MAC_ == 0
  735               return;
  736           }
  737           
  738    (1)     .endc		; ...INT0
  739    (1)     .if true, ...INT1
  740           static void int1_irq(void) {
  741           	.macro VDF cond, name, softvec, intern, installer, notes, physical, default, comments
  742           	.condit cond	
  743             .iif idn,<name>,<INT1>,.mexit
  744             .iif idn,<softvec>,<0>,.mexit
  745             .if true, physical == INT1_LVL
  746               if (softvec) softvec();
  747             .endc
  748           	.endm
  749           	.include phx_vecs.mac		; pickup all vectors assigned to IRQ 1
    1+          ;/*		phx_vecs.mac
    2+          ; *
    3+          ; *		Copyright 1996 Atari Games Corporation
    4+          ; *	Unauthorized reproduction, adaptation, distribution, performance or 
    5+          ; *	display of this computer program or the associated audiovisual work
    6+          ; *	is strictly prohibited.
    7+          ; *
    8+          ; *	This file is processed by MACPP to produce dispatch.c and intvecs.h.
    9+          ; *
   10+          ; *	The definitions placed in intvecs.h declare virtual vector numbers
   11+          ; *	in the form of xxx_INTVEC and a cross reference table(s) so the
   12+          ; *	dispatcher can call the appropriate functions.
   13+          ; *
   14+          ; *	intvecs.h should be #include'd by any module that uses prc_set_vec().
   15+          ; */
   16+          ;
   17+          ; This file recursivley '.includes' itself to succesively build up the approprate
   18+          ; tables and functions in C and places the results in one of two files (the
   19+          ; first -out=file supplied on the MACPP command line is expected to be dispatch.c
   20+          ; and the second -out=file is expected to be intvecs.h and the third is expected to
   21+          ; be /dev/null). If you don't speak fluent MACPP, then you probably shouldn't be
   22+          ; changing anything in this file other than the VDF table listed below.
   23+          ;
   24+   (2)    .if not_defined, _DISPATCH_MAC_		;1 +++++
   25+    X     _DISPATCH_MAC_ == 0			;2 Don't move ...
   26+    X     OUTPUT_LANG == 5 ;LANG_NONE		;3 ... or change ... 
   27+    X     	.outfile 2			;4 ... anything on ...
   28+    X     	.include config.mac		;5 ... these ...
   29+    X     	.outfile 0			;6 ... nine  ...
   30+   (2)    .endc					;7 ... lines ...
   31+   (2)    .if true, (_DISPATCH_MAC_&1) != 0	;8
   32+   (3)     .if true, 0				;9 -----
   33+          
   34+    X     You are free to add or remove entries from this table according to your
dispatch.c                               Atari Games Corp. macpp v9.12   "Oct 16 1997 13:26:41"


   35+    X     requirements. There are 10 fields used on each line in this table. The
   36+    X     description of each field follows:
   37+          
   38+    X     Field 1 = macro call
   39+          
   40+    X     It must always be the keyword VDF (case is not significant).
   41+          
   42+    X     Field 2 = condition
   43+          
   44+    X     This is a dual operand field, so the two operands together must be enclosed in
   45+    X     <>'s. The first operand is one of T, F, D or N representing True, False,
   46+    X     Defined or Not_defined respectively. Case is significant, use uppercase only
   47+    X     please. For the conditions T or F the second operand must be an expression
   48+    X     which must resolve to non-$0 (True) or $0 (False) in order for the macro
   49+    X     to be processed (else it is ignored). The expression can contain no embedded
   50+    X     spaces. For the conditions D and N, the second operand must only be a symbol
   51+    X     which must be Defined or Not-defined respectively in order for the macro to be
   52+    X     processed. Some short cut expressions have been preprocessed to make using the
   53+    X     expressions a little more concise. These are:
   54+          
   55+    X     	PHX = not $0 if HOST_BOARD == PHOENIX
   56+    X     	PAD = not $0 if HOST_BOARD == PHOENIX_AD
   57+    X     	FLG = not $0 if HOST_BOARD == FLAGSTAFF
   58+    X     	SEA = not $0 if HOST_BOARD == SEATTLE
   59+    X     	VEG = not $0 if HOST_BOARD == VEGAS
   60+          
   61+    X     Field 3 = vector name
   62+          
   63+    X     The NAME field is the name of the virtual vector. An _INTVEC will be appended
   64+    X     to it in the C definitions in intvecs.h, but otherwise the name is unmolested.
   65+    X     Case is significant only if you want it to be. The R3K/R4K has an option where
   66+    X     a number of vectors are maintained in an array of pointers rather than each
   67+    X     one having its own name. The index into the array is same as the number
   68+    X     returned in the processor's CAUSE register for that particluar interrupt. This
   69+    X     procedure is done simply for performance reasons. The option is selected by
   70+    X     using a 0 for this field and using an installer function with the vector index
   71+    X     as the parameter to the installer.
   72+          
   73+    X     Field 4 = Vector pointer
   74+          
   75+    X     This field identifies the name of a variable in BSS that contains a pointer
   76+    X     to the function to call at interrupt (or will be set by the prc_set_vec()
   77+    X     function). This is the name of the "soft" or logical vector and is either
   78+    X     declared in dispatch.c or externally according to the INT/EXT field described
   79+    X     next.
   80+          
   81+    X     Field 5 = INTernal or EXTernal vector
   82+          
   83+    X     This field contains the keywords INT, EXT, VINT or VEXT identifying the vector
   84+    X     in field 4 as being defined INTernally, EXTernally, Volatile INTernally or
   85+    X     Volatile Externally to dispatch.c respectively.
   86+          
   87+    X     Field 6 = name of vector installer
   88+          
   89+    X     This field identifies the name of a function that prc_set_vec() will call to
   90+    X     actually install the vector or 0 if there is no special stuff that needs to
   91+    X     be performed during vector installation.
dispatch.c                               Atari Games Corp. macpp v9.12   "Oct 16 1997 13:26:41"


   92+          
   93+    X     Field 7 = Notes for the installer.
   94+          
   95+    X     The Notes field is a parameter that is passed to the installer if there is one.
   96+          
   97+    X     Field 8 = Physical vector attachment.
   98+          
   99+    X     A dispatch routine is constructed for each of the 4 XBUS interrupts and for each of
  100+    X     the 6 CPU interrupts.  This field instructs phx_vecs.mac into which of the XBUS or
  101+    X     INTx dispatchers a caller to this vector belongs.  If this vector is not associated
  102+    X     with an XBUS or an INTx interrupt, it needs to be -1.  Place the interrupt routines
  103+    X     in this table in the order in which you want them executed.
  104+          
  105+    X     Field 9 = Default function.
  106+          
  107+    X     Name of default routine to install in the vector, or 0 if none.  phx_vecs.mac builds
  108+    X     a function called prc_init_vecs(void) which, when called, will perform a string of
  109+    X     prc_set_vec()'s for all the vectors having this field non-zero.  After the vectors
  110+    X     have been loaded, prc_init_vecs(void) will map the phoenix and galileo interrupts as
  111+    X     specified in phoenix.mac.
  112+          
  113+    X     Field 10 = Comments.
  114+          
  115+    X     The Comments field is placed on selected lines in intvecs.h and/or dispatch.c
  116+    X     as simple 'C' comments.
  117+          
  118+   (3)     .endc				; Don't move this line
  119+          ;
  120+          ;   Condit	Name	   Vector   I/E	Installer   Notes      Phys	Default	Comments
  121+          ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  122+          VDF <T,1>	GAMEVB,	   gameint, EXT	0,          0,		-1,	0,	< post-wierdness Vblank >
  123+          VDF <T,1>	MS4,       ms4vec,  EXT	0,          0,		-1,	0,	< 4 Millisecond timer >
  124+          VDF <T,1>	PRC_DELAY, prc_delay_vec, EXT 0,    0,		-1,	sst_prc_delay, < prc_delay soft vector >
  125+          VDF <T,1>	PRC_SET_IPL, set_ipl_vec, INT 0,    0,		-1,	0,	< prc_set_ipl soft vector >
  126+          VDF <T,1>	SAVE,      savintp, EXT 0,          0,		-1,	0,	< context save soft vector >
  127+          VDF <T,1>	RESTORE,   restintp,EXT 0,          0,		-1,	0,	< context restore soft vector >
  128+          VDF <T,1>	SW0,	   0,	    INT hwvinst,    VN_IRQ0,    -1,	0,	< Software interrupt 0 >
  129+          VDF <T,1>	SW1,	   0,       INT hwvinst,    VN_IRQ1,    -1,	0,	< Software interrupt 0 >
  130+          VDF <T,1>	INT0,	   0,       INT hwvinst,    VN_IRQ2,    -1,	int0_irq, < Hardware interrupt 0 >
  131+          VDF <T,1>	INT1,	   0,	    INT hwvinst,    VN_IRQ3,    -1,	int1_irq, < Hardware interrupt 1 >
  132+          VDF <T,PHX>	INT2,	   0,	    INT hwvinst,    VN_IRQ4,    -1,	int2_irq, < Hardware interrupt 2 >
  133+          VDF <T,1>	INT3,	   0,       INT hwvinst,    VN_IRQ5,    -1,	int3_irq, < Hardware interrupt 3 >
  134+          VDF <T,1>	INT4,	   0,	    INT hwvinst,    VN_IRQ6,    -1,	int4_irq, < Hardware interrupt 4 >
  135+          VDF <T,1>	INT5,	   0,	    INT hwvinst,    VN_IRQ7,    -1,	int5_irq, < Hardware interrupt 5 >
  136+          VDF <T,1>	TLBMOD,	   0,	    INT hwvinst,    VN_TLBM,    -1,	0,	< TLB modification >
  137+          VDF <T,1>	TLBLOAD,   0,	    INT hwvinst,    VN_TLBL,    -1,	0,	< TLB miss on I or D fetch >
  138+          VDF <T,1>	TLBSTORE,  0,	    INT hwvinst,    VN_TLBS,    -1,	0,	< TLB miss on store >
  139+          VDF <T,1>	ADDRERRL,  0,	    INT hwvinst,    VN_ADDRL,   -1,	0,	< Address error on I or D fetch >
  140+          VDF <T,1>	ADDRERRS,  0,	    INT hwvinst,    VN_ADDRS,   -1,	0,	< Address error on store >
  141+          VDF <T,1>	BUSERRI,   0,	    INT hwvinst,    VN_BUSERRI, -1,	0,	< Bus error on I-fetch >
  142+          VDF <T,1>	BUSERRD,   0,	    INT hwvinst,    VN_BUSERRD, -1,	0,	< Bus error on D-fetch >
  143+          VDF <T,1>	SYSCALL,   0,       INT hwvinst,    VN_SYSCALL, -1,	0,	< SYSCALL instruction >
  144+          VDF <T,1>	BREAK,     0,       INT hwvinst,    VN_BREAK,   -1,	0,	< Breakpoint instruction >
  145+          VDF <T,1>	RESERV,    0,       INT hwvinst,    VN_RESERV,  -1,	0,	< Reserved instruction >
  146+          VDF <T,1>	COPROC,    0,       INT hwvinst,    VN_COPROC,  -1,	0,	< Coprocessor unusable >
  147+          VDF <T,1>	OVRFLOW,   0,       INT hwvinst,    VN_OVERFL,  -1,	0,	< Integer Arithmetic Overflow >
  148+          VDF <T,1>	TRAP,      0,       INT hwvinst,    VN_TRAPV,   -1,	0,	< TRAP exception >
dispatch.c                               Atari Games Corp. macpp v9.12   "Oct 16 1997 13:26:41"


  149+          VDF <T,1>	FLOAT,     0,       INT hwvinst,    VN_FPE,     -1,	0,	< FLoating point exception >
  150+          VDF <T,1>	TIMER,	   timervec, INT 0,	    0,          -1,	0,	< Soft Timer interrupt >
  151+          VDF <T,1>	TIMERPLL,  tpllvec, VEXT 0,	    0,		-1,	0,	<Adjust 1MS timer>
  152+          VDF <T,1>	GAMEFRAME, framevec,INT 0,	    0,		-1,	0,	< Frame complete >
  153+   (3)    .if true, PHX
  154+    X     VDF <D,NET_LVL>	NET,       netintp, INT 0,          0,		NET_LVL,0,	< network int soft vector >
  155+    X     VDF <D,XBUS>	XBUS,	   xbusintp, INT pvinst,    XBUS_NOTES,	XBUS_LVL,xbus_irq, < Any XBUS interrupt >
  156+    X     VDF <T,XS0>	XS0,       xs0intp, INT pvinst,	    XS0_NOTES,	XS0_LVL,0,	< Expansion Slot 0 interrupt >
  157+    X     VDF <T,XS1>	XS1,       xs1intp, INT pvinst,	    XS1_NOTES,	XS1_LVL,0,	< Expansion Slot 1 interrupt >
  158+    X     VDF <T,XS2>	XS2,       xs2intp, INT pvinst,	    XS2_NOTES,	XS2_LVL,0,	< Expansion Slot 2 interrupt >
  159+    X     VDF <T,XS3>	XS3,       xs3intp, INT pvinst,	    XS3_NOTES,	XS3_LVL,0,	< Expansion Slot 3 interrupt >
  160+    X     VDF <T,MIO>	MIO,       miointp, INT pvinst,	    MIO_NOTES,	MIO_LVL,0,	< Miscellaneous I/O interrupt >
  161+    X     VDF <T,CU1>	CU1,       cu1intp, INT pvinst,	    CU1_NOTES,	CU1_LVL,0,	< Combo UART 1 interrupt >
  162+    X     VDF <T,CU2>	CU2,       cu2intp, INT pvinst,	    CU2_NOTES,	CU2_LVL,0,	< Combo UART 2 interrupt >
  163+    X     VDF <T,CPP>	CPP,       cppintp, INT pvinst,	    CPP_NOTES,	CPP_LVL,0,	< Combo Parallel Port interrupt >
  164+    X     VDF <T,PCA>	PCA,       pcaintp, INT pvinst,	    PCA_NOTES,	PCA_LVL,0,	< PCI A interrupt >
  165+    X     VDF <T,PCB>	PCB,       pcbintp, INT pvinst,	    PCB_NOTES,	PCB_LVL,0,	< PCI B interrupt >
  166+    X     VDF <T,PCC>	PCC,       pccintp, INT pvinst,	    PCC_NOTES,	PCC_LVL,0,	< PCI C interrupt >
  167+    X     VDF <T,VSY>	VSY,       vsyintp, INT pvinst,	    VSY_NOTES,	VSY_LVL,0,	< PCI D (VSYNC) interrupt >
  168+    X     VDF <T,IDE>	IDE,	   ideintp, INT pvinst,	    IDE_NOTES,	IDE_LVL,0,	< IDE interrupt >
  169+    X     VDF <T,IOA>	IOA,	   ioaintp, INT pvinst,	    IOA_NOTES,	IOA_LVL,ioa_irq,< I/O Asic interrupt >
  170+    X     VDF <T,ADC>	ADC,	   adcintp, INT pvinst,	    ADC_NOTES,	ADC_LVL,0,	< A/D Converter interrupt >
  171+    X     VDF <D,SND_I>	CAGE,      cagevec, INT 0,          0,		CAGE_LVL,aud_irq, < CAGE interrupt >
  172+   (3)    .endc
  173+   (3)    .if true, PAD || FLG || SEA || VEG
  174+          ;VDF <T,1>	IOA,	   0,	    INT hwvinst,    VN_IRQ3,	-1,	0,	< I/O Asic interrupt >
  175+          VDF <T,1>	IDE,	   0,	    INT hwvinst,    VN_IRQ4,    -1,	0,	< IDE interrupt >
  176+          VDF <T,EXP>	EXP,       expintp, INT pvinst,	    EXP_NOTES,	EXP_LVL,0,	< Expansion Slot interrupt >
  177+   (4)     .if true, PAD || SEA
  178+          VDF <T,NSS>	NSS,	   nssintp, INT pvinst,	    NSS_NOTES,  NSS_LVL,0,	< NSS/Hi-Link interrupt>
  179+   (4)     .endc
  180+   (4)     .if true, FLG
  181+    X     VDF <T,ETH>	ETH,	   ethintp, INT pvinst,     ETH_NOTES,  ETH_LVL,0,	< ethernet interrupt >
  182+    X     VDF <D,SND_I>	CAGE,	   cagevec, INT ioainst,    CAGE_NOTES, CAGE_LVL,aud_irq, < CAGE interrupt >
  183+   (4)     .endc
  184+          VDF <T,WD1>	WD1,	   wd1intp, INT pvinst,	    WD1_NOTES,  WD1_LVL,0,	< Widget interrupt 1>
  185+          VDF <T,PCI>	PCI,       pciintp, INT pvinst,	    PCI_NOTES,	PCI_LVL,0,	< PCI interrupt >
  186+          VDF <T,ADC>	ADC,	   adcintp, INT pvinst,	    ADC_NOTES,	ADC_LVL,0,	< A/D Converter interrupt >
  187+          VDF <T,WD2>	WD2,	   wd2intp, INT pvinst,	    WD2_NOTES,  WD2_LVL,0,	< Widget interrupt 2>
  188+          VDF <T,DBG>	DBG,	   dbgintp, INT pvinst,	    DBG_NOTES,	DBG_LVL,0,	< Debug switch interrupt >
  189+          VDF <T,VSY>	VSY,	   vsyintp, INT pvinst,	    VSY_NOTES,	VSY_LVL,0,	< VSYNC interrupt >
  190+   (3)    .endc
  191+          VDF <T,GAL>	GAL,	   0,       INT gvinst,	    GAL_NOTES,  GAL_LVL,galileoint, < Any Galileo Error Interrupt >
  192+          VDF <T,MOE>	MOE,	   moeintp, INT gvinst,	    MOE_NOTES,	MOE_LVL,0,	< Galileo MemOut >
  193+          VDF <T,DOE>	DOE,	   doeintp, INT gvinst,	    DOE_NOTES,	DOE_LVL,0,	< Galileo DMAOut >
  194+          VDF <T,COE>	COE,	   coeintp, INT gvinst,	    COE_NOTES,	COE_LVL,0,	< Galileo CPUOut >
  195+          VDF <T,DM0>	DM0,	   dm0intp, INT gvinst,	    DM0_NOTES,	DM0_LVL,0,	< Galileo DMA0Comp >
  196+          VDF <T,DM1>	DM1,	   dm1intp, INT gvinst,	    DM1_NOTES,	DM1_LVL,0,	< Galileo DMA1Comp >
  197+          VDF <T,DM2>	DM2,	   dm2intp, INT gvinst,	    DM2_NOTES,	DM2_LVL,0,	< Galileo DMA2Comp >
  198+          VDF <T,DM3>	DM3,	   dm3intp, INT gvinst,	    DM3_NOTES,	DM3_LVL,0,	< Galileo DMA3Comp >
  199+          VDF <T,TM0>	TM0,	   tm0intp, INT gvinst,	    TM0_NOTES,	TM0_LVL,0,	< Galileo T0Exp >
  200+          VDF <T,TM1>	TM1,	   tm1intp, INT gvinst,	    TM1_NOTES,	TM1_LVL,0,	< Galileo T1Exp >
  201+          VDF <T,TM2>	TM2,	   tm2intp, INT gvinst,	    TM2_NOTES,	TM2_LVL,0,	< Galileo T2Exp >
  202+          VDF <T,TM3>	TM3,	   tm3intp, INT gvinst,	    TM3_NOTES,	TM3_LVL,cputimerint, < Galileo T3EXP timer interrupt >
  203+          VDF <T,MRE>	MRE,	   mreintp, INT gvinst,	    MRE_NOTES,	MRE_LVL,0,	< Galileo MasRdErr >
  204+          VDF <T,SWE>	SWE,	   sweintp, INT gvinst,	    SWE_NOTES,	SWE_LVL,0,	< Galileo SlvWrErr >
  205+          VDF <T,MWE>	MWE,	   mweintp, INT gvinst,	    MWE_NOTES,	MWE_LVL,0,	< Galileo MasWrErr >
dispatch.c                               Atari Games Corp. macpp v9.12   "Oct 16 1997 13:26:41"


  206+          VDF <T,SRE>	SRE,	   sreintp, INT gvinst,	    SRE_NOTES,	SRE_LVL,0,	< Galileo SlvRdErr >
  207+          VDF <T,AEP>	AEP,	   aepintp, INT gvinst,	    AEP_NOTES,	AEP_LVL,0,	< Galileo AddrErr >
  208+          VDF <T,MEP>	MEP,	   mepintp, INT gvinst,	    MEP_NOTES,	MEP_LVL,0,	< Galileo MemErr >
  209+          VDF <T,MAS>	MAS,	   masintp, INT gvinst,	    MAS_NOTES,	MAS_LVL,0,	< Galileo MasAbort >
  210+          VDF <T,TAR>	TAR,	   tarintp, INT gvinst,	    TAR_NOTES,	TAR_LVL,0,	< Galileo TarAbort >
  211+          VDF <T,RTY>	RTY,	   rtyintp, INT gvinst,	    RTY_NOTES,	RTY_LVL,0,	< Galileo RetryCtr >
  212+          VDF <T,PC0>	PC0,	   pc0intp, INT gvinst,	    PC0_NOTES,	PC0_LVL,0,	< Galileo PCI Interrupt >
  213+          VDF <T,PC1>	PC1,	   pc1intp, INT gvinst,	    PC1_NOTES,	PC1_LVL,0,	< Galileo PCI Interrupt >
  214+          VDF <T,PC2>	PC2,	   pc2intp, INT gvinst,	    PC2_NOTES,	PC2_LVL,0,	< Galileo PCI Interrupt >
  215+          VDF <T,PC3>	PC3,	   pc3intp, INT gvinst,	    PC3_NOTES,	PC3_LVL,0,	< Galileo PCI Interrupt >
  216+          VDF <D,UART_LVL> UART,	   uartintp,INT ioainst,    UART_NOTES,	UART_LVL,0,	< I/O ASIC UART interrupts >
  217+          VDF <D,SND_LVL>	SND,	   sndintp, INT ioainst,    SND_NOTES,	SND_LVL, 0,	< I/O ASIC Sound interrupts >
  218+          VDF <D,MC_LVL>	MC,	   mcintp,  INT ioainst,    MC_NOTES,	MC_LVL,	0,	< I/O ASIC Microcontroller interrupt >
  219+          ;
  220+   (2)    .endc			; (_DISPATCH_MAC_&1) != 0 *** DON'T MOVE THIS LINE EITHER ***
  221+          ;
  222+          ;+++++++ From here on, there are few user servicable parts inside. ++++
  223+          ;
  224+          ; This is sortof how it works:
  225+          ; The first pass through, _DISPATCH_MAC_ will be 0 (set above by the .if not_defined).
  226+          ; First the copyright boilerplate is inserted into both output files and the macro VDF
  227+          ; is defined to create externs. Some struct definitions and unique externs are depositied
  228+          ; into the .h file. Next _DISPATCH_MAC_ is set to 1 and this file is .included
  229+          ; again. This will cause MACPP to read the VDF table above and output the appropriate
  230+          ; information in the .h file but ignore the rest of the file. The VDF macro is redefined,
  231+          ; and the procedure is repeated causing the creation of different items according to what
  232+          ; is needed. Once the whole .h file is built, the procedure repeats for the building of the
  233+          ; .c file.
  234+          ;
  235+   (2)    .if true, _DISPATCH_MAC_ == 0		; First (main) pass
  236+    X      PHX == 0
  237+    X      PAD == 0
  238+    X      FLG == 0
  239+    X      SEA == 0
  240+    X      VEG == 0
  241+    X      .iif true, HOST_BOARD == PHOENIX, PHX == 1 ;set the appropriate ones true as desired
  242+    X      .iif true, HOST_BOARD == PHOENIX_AD, PAD == 1 ;set the appropriate ones true as desired
  243+    X      .iif true, HOST_BOARD == FLAGSTAFF, FLG == 1 ;set the appropriate ones true as desired
  244+    X      .iif true, HOST_BOARD == SEATTLE, SEA == 1 ;set the appropriate ones true as desired
  245+    X      .iif true, HOST_BOARD == VEGAS, VEG == 1 ;set the appropriate ones true as desired
  246+          ;
  247+    X     	.macro .condit flag,exp		; The .condit macro does an expression test ...
  248+    X     	.if identical,<flag>,<T>
  249+    X     		.iif false,exp,.mexit 10 ; ... and aborts higher level macros if false
  250+    X     		.mexit
  251+    X     	.endc
  252+    X     	.if identical,<flag>,<F>
  253+    X     		.iif true,exp,.mexit 10	; ... etc.
  254+    X     		.mexit
  255+    X     	.endc
  256+    X     	.if identical,<flag>,<D>
  257+    X     		.iif not_defined,exp,.mexit 10
  258+    X     		.mexit
  259+    X     	.endc
  260+    X     	.if identical,<flag>,<N>
  261+    X     		.iif defined,exp,.mexit 10
  262+    X     		.mexit
dispatch.c                               Atari Games Corp. macpp v9.12   "Oct 16 1997 13:26:41"


  263+    X     	.endc
  264+    X     	.endm
  265+          ;	
  266+    X     	.macro boilerplate file_name
  267+    X     /*		file_name
  268+    X      *
  269+    X      *		Copyright 1996 Atari Games Corporation
  270+    X      *	Unauthorized reproduction, adaptation, distribution, performance or 
  271+    X      *	display of this computer program or the associated audiovisual work
  272+    X      *	is strictly prohibited.
  273+    X      *
  274+    X      * ++++++ WARNING WARNING WARNING WARNING WARNING +++++
  275+    X      * This file is machine generated. Any changes you put in here will be lost
  276+    X      * the next time phx_vecs.mac is touched. You need to make your changes to
  277+    X      * phx_vecs.mac instead of this file.
  278+    X      */
  279+    X     	.endm
  280+    X     	boilerplate dispatch.c
  281+    X     	.outfile	1		;The externs go into the .h file
  282+    X     	boilerplate intvecs.h
  283+    X     #if !defined(_INTVECS_H_)
  284+    X     #define _INTVECS_H_
  285+          
  286+    X     struct irq_tab {
  287+    X     	void 	(**softvec)();
  288+    X     	void    (*(*installer)(const struct irq_tab *, void(*new)()))();
  289+    X     	int	notes;
  290+    X     };
  291+          ;
  292+    X     	.macro VDF cond, name, softvec, intern, installer, notes, physical, default, comments
  293+    X     	.condit cond	
  294+    X      .if dif,<softvec>,<0>
  295+    X       ...1 == 0
  296+    X       .iif idn,<intern>,<VINT>,...1 == 1
  297+    X       .iif idn,<intern>,<VEXT>,...1 == 1
  298+    X       .if true, ...1
  299+    X     extern	void (* volatile softvec)();	/* comments */
  300+    X       .iff
  301+    X     extern  void (*softvec)();	/* comments */
  302+    X       .endc
  303+    X      .endc
  304+    X     	.endm
  305+          ;
  306+    X     	_DISPATCH_MAC_ == 1		;next time we process the IRQ table
  307+    X     	.include phx_vecs.mac		;Make the externs
  308+          
  309+    X     enum vecs {
  310+    X     	.macro VDF cond, name, softvec, intern, installer, notes, physical, default, comments
  311+    X     	.condit cond	
  312+    X         name'_INTVEC,
  313+    X     	.endm
  314+    X     	.include phx_vecs.mac		;Make the enums
  315+    X         N_INTVECS
  316+    X     };
  317+          
  318+    X     void (*prc_set_vec (unsigned int vecnum, void (*routine)() ))();
  319+    X     void prc_init_vecs(void);		/* set the default vectors */
dispatch.c                               Atari Games Corp. macpp v9.12   "Oct 16 1997 13:26:41"


  320+          ;
  321+          ; Add a prototype for an as yet unused function
  322+    X     .if true, 0
  323+          
  324+    X     /*		prc_set_vecp(which, what)
  325+    X      *	Sets a special vector for the interrupt identified by <which>
  326+    X      *	to call the routine specified by <what>. <what> is
  327+    X      *	a struct that contains both a pointer to the code
  328+    X      *	to execute and an optional pointer to the private
  329+    X      *	variables for that routine. This is a change from the
  330+    X      *	behavior of prc_set_vec, and is intended to allow
  331+    X      *	multiple incarnations of a given device to share code.
  332+    X      */
  333+          
  334+    X     struct opaque;
  335+    X     extern struct VECP_vector {
  336+    X         void (*function)(struct opaque *);	/* Who you gonna call */
  337+    X         struct opaque *cookie;		/* a magic cookie to hand him */
  338+    X     } prc_set_vecp (
  339+    X         int __which,			/* one of xxx_INTVEC */
  340+    X         struct IRQ_vector __what		/* BY VALUE!!! */
  341+    X     );
  342+    X     .endc
  343+    X     #endif		/* _INTVECS_H_ */
  344+          ;
  345+          ; At this point, we have completed all processing of the .h file
  346+          ; so switch back to the .c file
  347+          ;
  348+    X     	.outfile	0		;switch back to dispatch.c
  349+          ;
  350+    X     #include <config.h>			/* begining of dispatch.c */
  351+    X     #include <os_proto.h>
  352+    X     #include <intvecs.h>
  353+          
  354+    X     #ifndef BLABF
  355+    X     # define BLABF(x)
  356+    X     #endif
  357+          
  358+    X     #ifndef BLAB
  359+    X     # define BLAB(x)
  360+    X     #endif
  361+          
  362+    X      .if true, 1
  363+    X     	.macro VDF cond, name, softvec, intern, installer, notes, physical, default, comments
  364+    X     	.condit cond	
  365+    X       .iif idn,<name>,<XBUS0>,.mexit
  366+    X       .iif idn,<name>,<XBUS1>,.mexit
  367+    X       .iif idn,<name>,<XBUS2>,.mexit
  368+    X       .iif idn,<name>,<XBUS3>,.mexit
  369+    X       .iif idn,<name>,<INT0>,.mexit
  370+    X       .iif idn,<name>,<INT1>,.mexit
  371+    X       .iif idn,<name>,<INT2>,.mexit
  372+    X       .iif idn,<name>,<INT3>,.mexit
  373+    X       .iif idn,<name>,<INT4>,.mexit
  374+    X       .iif idn,<name>,<INT5>,.mexit
  375+    X       .if true, PHX
  376+    X         .if true, physical == XBUS0_LVL
dispatch.c                               Atari Games Corp. macpp v9.12   "Oct 16 1997 13:26:41"


  377+    X     	  ...XBUS0 == ...XBUS0 + 1
  378+    X     	  .mexit
  379+    X         .endc
  380+    X         .if true, physical == XBUS1_LVL
  381+    X     	  ...XBUS1 == ...XBUS1 + 1
  382+    X     	  .mexit
  383+    X         .endc
  384+    X         .if true, physical == XBUS2_LVL
  385+    X     	  ...XBUS2 == ...XBUS2 + 1
  386+    X     	  .mexit
  387+    X         .endc
  388+    X         .if true, physical == XBUS3_LVL
  389+    X     	  ...XBUS3 == ...XBUS3 + 1
  390+    X     	  .mexit
  391+    X         .endc
  392+    X       .endc
  393+    X       .if true, physical == INT0_LVL
  394+    X         	...INT0 == ...INT0 + 1
  395+    X     	.mexit
  396+    X       .endc
  397+    X       .if true, physical == INT1_LVL
  398+    X         	...INT1 == ...INT1 + 1
  399+    X        .if true, PAD || FLG || SEA || VEG
  400+    X     	...IOA == ...IOA + 1
  401+    X         .if ndf, notes
  402+    X     #define notes IO_MAIN_GLOBAL_INT
  403+    X         .endc
  404+    X        .endc
  405+    X     	.mexit
  406+    X       .endc
  407+    X       .if true, physical == INT2_LVL
  408+    X         	...INT2 == ...INT2 + 1
  409+    X     	.mexit
  410+    X       .endc
  411+    X       .if true, physical == INT3_LVL
  412+    X         	...INT3 == ...INT3 + 1
  413+    X     	.mexit
  414+    X       .endc
  415+    X       .if true, physical == INT4_LVL
  416+    X         	...INT4 == ...INT4 + 1
  417+    X     	.mexit
  418+    X       .endc
  419+    X       .if true, physical == INT5_LVL
  420+    X         	...INT5 == ...INT5 + 1
  421+    X     	.mexit
  422+    X       .endc
  423+    X       .if true, physical == IOASIC_LVL
  424+    X         	...IOA == ...IOA + 1
  425+    X        .if ndf, notes
  426+    X     #define notes IO_MAIN_GLOBAL_INT
  427+    X        .endc
  428+    X     	.mexit
  429+    X       .endc
  430+    X     	.endm
  431+    X     ...XBUS0 == 0
  432+    X     ...XBUS1 == 0
  433+    X     ...XBUS2 == 0
dispatch.c                               Atari Games Corp. macpp v9.12   "Oct 16 1997 13:26:41"


  434+    X     ...XBUS3 == 0
  435+    X     ...INT0 == 0
  436+    X     ...INT1 == 0
  437+    X     ...INT2 == 0
  438+    X     ...INT3 == 0
  439+    X     ...INT4 == 0
  440+    X     ...INT5 == 0
  441+    X     ...IOA == 0
  442+    X     	.include phx_vecs.mac	; count vectors requiring dispatch
  443+    X      .endc
  444+          ; 
  445+    X     .macro VDF cond, name, softvec, intern, installer, notes, physical, default, comments
  446+    X      .condit cond	
  447+    X      .if dif,<softvec>,<0>
  448+    X       .if idn,<intern>,<INT>
  449+    X     void (*softvec)();	/* comments */
  450+    X       .endc
  451+    X       .if idn,<intern>,<VINT>
  452+    X     void (* volatile softvec)();	/* comments */
  453+    X       .endc
  454+    X      .endc
  455+    X      .if dif,<default>,<0>
  456+    X       .if idn,<name>,<INT0>
  457+    X        .if true, ...INT0
  458+    X     static void 'default'(void);	/* comments */
  459+    X        .endc
  460+    X        .mexit
  461+    X       .endc
  462+    X       .if idn,<name>,<INT1>
  463+    X        .if true, ...INT1
  464+    X     static void 'default'(void);	/* comments */
  465+    X        .endc
  466+    X        .mexit
  467+    X       .endc
  468+    X       .if idn,<name>,<INT2>
  469+    X        .if true, ...INT2
  470+    X     static void 'default'(void);	/* comments */
  471+    X        .endc
  472+    X        .mexit
  473+    X       .endc
  474+    X       .if idn,<name>,<INT3>
  475+    X        .if true, ...INT3
  476+    X     static void 'default'(void);	/* comments */
  477+    X        .endc
  478+    X        .mexit
  479+    X       .endc
  480+    X       .if idn,<name>,<INT4>
  481+    X        .if true, ...INT4
  482+    X     static void 'default'(void);	/* comments */
  483+    X        .endc
  484+    X        .mexit
  485+    X       .endc
  486+    X       .if idn,<name>,<INT5>
  487+    X        .if true, ...INT5
  488+    X     static void 'default'(void);	/* comments */
  489+    X        .endc
  490+    X        .mexit
dispatch.c                               Atari Games Corp. macpp v9.12   "Oct 16 1997 13:26:41"


  491+    X       .endc
  492+    X       .if idn,<name>,<INT6>
  493+    X        .if true, ...INT6
  494+    X     static void 'default'(void);	/* comments */
  495+    X        .endc
  496+    X        .mexit
  497+    X       .endc
  498+    X       .if idn,<name>,<INT7>
  499+    X        .if true, ...INT7
  500+    X     static void 'default'(void);	/* comments */
  501+    X        .endc
  502+    X        .mexit
  503+    X       .endc
  504+    X       .if true, PHX
  505+    X        .if idn,<name>,<XBUS>
  506+    X         .if true, ...XBUS0|...XBUS1|...XBUS2|...XBUS3
  507+    X     static void 'default'(void);
  508+    X         .endc
  509+    X         .mexit
  510+    X        .endc
  511+    X        .if idn,<name>,<XBUS0>
  512+    X         .if true, ...XBUS0
  513+    X     static void 'default'(void);
  514+    X         .endc
  515+    X         .mexit
  516+    X        .endc
  517+    X        .if idn,<name>,<XBUS1>
  518+    X         .if true, ...XBUS1
  519+    X     static void 'default'(void);
  520+    X         .endc
  521+    X         .mexit
  522+    X        .endc
  523+    X        .if idn,<name>,<XBUS2>
  524+    X         .if true, ...XBUS2
  525+    X     static void 'default'(void);
  526+    X         .endc
  527+    X         .mexit
  528+    X        .endc
  529+    X        .if idn,<name>,<XBUS3>
  530+    X         .if true, ...XBUS3
  531+    X     static void 'default'(void);
  532+    X         .endc
  533+    X         .mexit
  534+    X        .endc
  535+    X       .endc			; PHX
  536+    X       .if idn,<name>,<IOA>
  537+    X        .if true, ...IOA
  538+    X     static void 'default'(void);
  539+    X        .endc
  540+    X        .mexit
  541+    X       .endc
  542+    X     extern void 'default'(void);
  543+    X      .endc
  544+    X     .endm
  545+    X     	.include phx_vecs.mac		;Declare the non-extern vectors
  546+          ;
  547+    X      .if true, ((PROCESSOR&-16) == MIPS3000) || ((PROCESSOR&-16) == MIPS4000)
dispatch.c                               Atari Games Corp. macpp v9.12   "Oct 16 1997 13:26:41"


  548+    X     static void (*hwvinst(const struct irq_tab *, void (*)()))();
  549+    X      .endc
  550+          ;
  551+    X     .if df, PHOENIX_INTCTL_MASK
  552+    X     static void (*pvinst(const struct irq_tab *, void (*)()))();
  553+    X     .endc
  554+          ;
  555+    X     .if df, GALILEO_INTCTL_MASK
  556+    X     static void (*gvinst(const struct irq_tab *, void (*)()))();
  557+    X     .endc
  558+          ;
  559+    X     .if true, ...IOA
  560+    X     static void (*ioainst(const struct irq_tab *, void (*)()))();
  561+    X     .endc
  562+          ;
  563+    X     static const struct irq_tab irq_inits[] = {
  564+    X     	.macro VDF cond, name, softvec, intern, installer, notes, physical, default, comments
  565+    X     	.condit cond	
  566+    X      .if dif,<softvec>,<0>
  567+    X      { (void (**)())&softvec, installer, notes },	/* comments */
  568+    X      .iff
  569+    X      { 0, installer, notes },	/* comments */
  570+    X      .endc
  571+    X     	.endm
  572+    X     	.include phx_vecs.mac		;Build the irq_inits array
  573+    X      { 0, 0, 0} };
  574+          ;
  575+    X     .if true, ((PROCESSOR&-16) == MIPS3000) || ((PROCESSOR&-16) == MIPS4000)
  576+          
  577+    X     extern void (*ramv_tbl[])();
  578+          
  579+    X     static void (*hwvinst(const struct irq_tab *it, void (*new)()))() {
  580+    X         int indx;
  581+    X         void (*old_rtn)();
  582+          
  583+    X         indx = it->notes;
  584+    X         if (indx >= VN_MAX) return 0;
  585+    X         old_rtn = ramv_tbl[indx];
  586+    X         ramv_tbl[indx] = new;
  587+    X         return old_rtn;
  588+    X     }
  589+          
  590+    X      .if df, PHOENIX_INTCTL_MASK
  591+    X     static void (*pvinst(const struct irq_tab *it, void (*new)()))() {
  592+          
  593+    X         if (it->notes) {
  594+    X     	BLABF(("\ndispatch: Adding 0x%08lX to main INTCTL (0x%08lX)...", it->notes, *(VU32*)INTCTL_IE));
  595+    X     	*((VU32 *)(INTCTL_IE)) |= it->notes;
  596+    X         }
  597+    X         return 0;
  598+    X     }
  599+    X      .endc
  600+          
  601+    X      .if df, GALILEO_INTCTL_MASK
  602+    X     static void (*gvinst(const struct irq_tab *it, void (*new)()))() {
  603+          
  604+    X         if (it->notes) {
dispatch.c                               Atari Games Corp. macpp v9.12   "Oct 16 1997 13:26:41"


  605+    X     	BLABF(("\ndispatch: Adding 0x%08lX to Galileo INTCTL (0x%08lX)...", it->notes, \
  606+    X     			*(VU32*)GALILEO_CPU_I_ENA));
  607+    X     	*((VU32 *)(GALILEO_CPU_I_ENA)) |= it->notes;
  608+    X         }
  609+    X         return 0;
  610+    X     }
  611+    X      .endc
  612+          
  613+    X      .if true, ...IOA
  614+    X     static void (*ioainst(const struct irq_tab *it, void (*new)()))() {
  615+    X     extern void prc_wait_n_usecs( int );
  616+    X         if (it->notes)
  617+    X         {
  618+    X          BLABF(("\ndispatch: Adding 0x%04X to IOASIC INTCTL: (0x%04X)...", (int)it->notes, \
  619+    X     		*(VU32*)IO_MAIN_CTL&0xFFFF));
  620+    X          while ( ( *((VU32 *)IO_MAIN_CTL) & it->notes ) != it->notes )
  621+    X          {
  622+    X     #ifdef LED_OUT
  623+    X           *(VU32 *)LED_OUT = ~( 1 << B_LED_RED );
  624+    X     #endif
  625+    X           do
  626+    X           {
  627+    X            *((VU32 *)IO_MAIN_CTL) |= it->notes;
  628+    X            prc_wait_n_usecs( 1000 );
  629+    X           } while ( ( *((VU32 *)IO_MAIN_CTL) & it->notes ) != it->notes );
  630+    X           prc_wait_n_usecs( 1000 );
  631+    X     #ifdef LED_OUT
  632+    X           *(VU32 *)LED_OUT |= ( 1 << B_LED_RED );
  633+    X     #endif
  634+    X          }
  635+    X         }
  636+    X         return 0;
  637+    X     }
  638+    X      .endc
  639+    X     .endc
  640+          
  641+    X     void (*prc_set_vec (unsigned int vecnum, void (*routine)() ))()
  642+    X     {
  643+    X         void (*old_rtn)();
  644+    X         void (**softvec)();
  645+    X         const struct irq_tab *tbp;
  646+    X         int old_ipl;
  647+          
  648+    X         if ( vecnum >= N_INTVECS ) return 0;
  649+    X         tbp = irq_inits+vecnum;
  650+    X         softvec = tbp->softvec;
  651+    X         old_rtn = 0;
  652+    X         old_ipl = prc_set_ipl(INTS_OFF);
  653+    X         if ( tbp->installer ) old_rtn = tbp->installer(tbp, routine);
  654+    X         if ( softvec ) {
  655+    X     	if (!old_rtn) old_rtn = *softvec;
  656+    X     	*softvec = routine;
  657+    X         }
  658+    X         prc_set_ipl(old_ipl);
  659+    X         return old_rtn;
  660+    X     }
  661+          
dispatch.c                               Atari Games Corp. macpp v9.12   "Oct 16 1997 13:26:41"


  662+    X      .if true, PHX
  663+    X       .if true, ...XBUS0
  664+    X     static void xbus0_irq(void) {
  665+    X     	.macro VDF cond, name, softvec, intern, installer, notes, physical, default, comments
  666+    X     	.condit cond	
  667+    X       .iif idn,<name>,<XBUS0>,.mexit
  668+    X       .iif idn,<softvec>,<0>,.mexit
  669+    X       .if true, physical == XBUS0_LVL
  670+    X         if (softvec) softvec();
  671+    X       .endc
  672+    X     	.endm
  673+    X     	.include phx_vecs.mac		; pickup all vectors assigned to XBUS0_LVL
  674+    X         return;
  675+    X     }
  676+          
  677+    X       .endc		; ...XBUS0
  678+    X       .if true, ...XBUS1
  679+    X     static void xbus1_irq(void) {
  680+    X     	.macro VDF cond, name, softvec, intern, installer, notes, physical, default, comments
  681+    X     	.condit cond	
  682+    X       .iif idn,<name>,<XBUS1>,.mexit
  683+    X       .iif idn,<softvec>,<0>,.mexit
  684+    X       .if true, physical == XBUS1_LVL
  685+    X         if (softvec) softvec();
  686+    X       .endc
  687+    X     	.endm
  688+    X     	.include phx_vecs.mac		; pickup all vectors assigned to XBUS1_LVL
  689+    X         return;
  690+    X     }
  691+          
  692+    X       .endc		; ...XBUS1
  693+    X       .if true, ...XBUS2
  694+    X     static void xbus2_irq(void) {
  695+    X     	.macro VDF cond, name, softvec, intern, installer, notes, physical, default, comments
  696+    X     	.condit cond	
  697+    X       .iif idn,<name>,<XBUS2>,.mexit
  698+    X       .iif idn,<softvec>,<0>,.mexit
  699+    X       .if true, physical == XBUS2_LVL
  700+    X         if (softvec) softvec();
  701+    X       .endc
  702+    X     	.endm
  703+    X     	.include phx_vecs.mac		; pickup all vectors assigned to XBUS2_LVL
  704+    X         return;
  705+    X     }
  706+          
  707+    X       .endc		; ...XBUS2
  708+    X       .if true, ...XBUS3
  709+    X     static void xbus3_irq(void) {
  710+    X     	.macro VDF cond, name, softvec, intern, installer, notes, physical, default, comments
  711+    X     	.condit cond	
  712+    X       .iif idn,<name>,<XBUS3>,.mexit
  713+    X       .iif idn,<softvec>,<0>,.mexit
  714+    X       .if true, physical == XBUS3_LVL
  715+    X         if (softvec) softvec();
  716+    X       .endc
  717+    X     	.endm
  718+    X     	.include phx_vecs.mac		; pickup all vectors assigned to XBUS3_LVL
dispatch.c                               Atari Games Corp. macpp v9.12   "Oct 16 1997 13:26:41"


  719+    X         return;
  720+    X     }
  721+          
  722+    X       .endc		; ...XBUS3
  723+    X      .endc		; PHX
  724+    X      .if true, ...INT0
  725+    X     static void int0_irq(void) {
  726+    X     	.macro VDF cond, name, softvec, intern, installer, notes, physical, default, comments
  727+    X     	.condit cond	
  728+    X       .iif idn,<name>,<INT0>,.mexit
  729+    X       .iif idn,<softvec>,<0>,.mexit
  730+    X       .if true, physical == INT0_LVL
  731+    X         if (softvec) softvec();
  732+    X       .endc
  733+    X     	.endm
  734+    X     	.include phx_vecs.mac		; pickup all vectors assigned to IRQ 0
  735+    X         return;
  736+    X     }
  737+          
  738+    X      .endc		; ...INT0
  739+    X      .if true, ...INT1
  740+    X     static void int1_irq(void) {
  741+    X     	.macro VDF cond, name, softvec, intern, installer, notes, physical, default, comments
  742+    X     	.condit cond	
  743+    X       .iif idn,<name>,<INT1>,.mexit
  744+    X       .iif idn,<softvec>,<0>,.mexit
  745+    X       .if true, physical == INT1_LVL
  746+    X         if (softvec) softvec();
  747+    X       .endc
  748+    X     	.endm
  749+    X     	.include phx_vecs.mac		; pickup all vectors assigned to IRQ 1
  750+    X         return;
  751+    X     }
  752+          
  753+    X      .endc		; ...INT1
  754+    X      .if true, ...INT2
  755+    X     static void int2_irq(void) {
  756+    X     	.macro VDF cond, name, softvec, intern, installer, notes, physical, default, comments
  757+    X     	.condit cond	
  758+    X       .iif idn,<name>,<INT2>,.mexit
  759+    X       .iif idn,<softvec>,<0>,.mexit
  760+    X       .if true, physical == INT2_LVL
  761+    X         if (softvec) softvec();
  762+    X       .endc
  763+    X     	.endm
  764+    X     	.include phx_vecs.mac		; pickup all vectors assigned to IRQ 2
  765+    X         return;
  766+    X     }
  767+          
  768+    X      .endc		; ...INT2
  769+    X      .if true, ...INT3
  770+    X     static void int3_irq(void) {
  771+    X     	.macro VDF cond, name, softvec, intern, installer, notes, physical, default, comments
  772+    X     	.condit cond	
  773+    X       .iif idn,<name>,<INT3>,.mexit
  774+    X       .iif idn,<softvec>,<0>,.mexit
  775+    X       .if true, physical == INT3_LVL
dispatch.c                               Atari Games Corp. macpp v9.12   "Oct 16 1997 13:26:41"


  776+    X         if (softvec) softvec();
  777+    X       .endc
  778+    X     	.endm
  779+    X     	.include phx_vecs.mac		; pickup all vectors assigned to IRQ 3
  780+    X         return;
  781+    X     }
  782+          
  783+    X      .endc		; ...INT3
  784+    X      .if true, ...INT4
  785+    X     static void int4_irq(void) {
  786+    X     	.macro VDF cond, name, softvec, intern, installer, notes, physical, default, comments
  787+    X     	.condit cond	
  788+    X       .iif idn,<name>,<INT4>,.mexit
  789+    X       .iif idn,<softvec>,<0>,.mexit
  790+    X       .if true, physical == INT4_LVL
  791+    X         if (softvec) softvec();
  792+    X       .endc
  793+    X     	.endm
  794+    X     	.include phx_vecs.mac		; pickup all vectors assigned to IRQ 4
  795+    X         return;
  796+    X     }
  797+          
  798+    X      .endc		; ...INT4
  799+    X      .if true, ...INT5
  800+    X     static void int5_irq(void) {
  801+    X     	.macro VDF cond, name, softvec, intern, installer, notes, physical, default, comments
  802+    X     	.condit cond	
  803+    X       .iif idn,<name>,<INT5>,.mexit
  804+    X       .iif idn,<softvec>,<0>,.mexit
  805+    X       .if true, physical == INT5_LVL
  806+    X         if (softvec) softvec();
  807+    X       .endc
  808+    X     	.endm
  809+    X     	.include phx_vecs.mac		; pickup all vectors assigned to IRQ 5
  810+    X         return;
  811+    X     }
  812+          
  813+    X      .endc		; ...INT5
  814+    X      .if true, ...IOA && PHX
  815+    X     static void ioa_irq(void) {
  816+    X     	.macro VDF cond, name, softvec, intern, installer, notes, physical, default, comments
  817+    X     	.condit cond	
  818+    X       .iif idn,<name>,<IOA>,.mexit
  819+    X       .iif idn,<softvec>,<0>,.mexit
  820+    X       .if true, physical == IOASIC_LVL
  821+    X         if (softvec) softvec();
  822+    X       .endc
  823+    X     	.endm
  824+    X     	.include phx_vecs.mac		; pickup all vectors assigned to IRQ 5
  825+    X         return;
  826+    X     }
  827+          
  828+    X      .endc		; ...IOA
  829+    X      .if true, PHX
  830+    X       .if true, ...XBUS0|...XBUS1|...XBUS2|...XBUS3
  831+    X     static void xbus_irq(void) {
  832+    X         int which;
dispatch.c                               Atari Games Corp. macpp v9.12   "Oct 16 1997 13:26:41"


  833+    X         which = *(VU32 *)(XBUS_SLOT0+4);
  834+    X       .if true, ...XBUS0
  835+    X         if (!(which&1)) xbus0_irq();
  836+    X       .endc
  837+    X       .if true, ...XBUS1
  838+    X         if (!(which&2)) xbus1_irq();
  839+    X       .endc
  840+    X       .if true, ...XBUS2
  841+    X         if (!(which&4)) xbus2_irq();
  842+    X       .endc
  843+    X       .if true, ...XBUS3
  844+    X         if (!(which&8)) xbus3_irq();
  845+    X       .endc
  846+    X         return;
  847+    X     }
  848+    X       .endc
  849+    X      .endc		; PHX
  850+    X     void prc_init_vecs(void) {
  851+    X     	.macro VDF cond, name, softvec, intern, installer, notes, physical, default, comments
  852+    X     	.condit cond	
  853+    X     .if dif,<default>,<0>
  854+    X      .if true, PHX
  855+    X       .if idn,<name>,<XBUS0>
  856+    X        .iif true, ...XBUS0 == 0, .mexit
  857+    X       .endc
  858+    X       .if idn,<name>,<XBUS1>
  859+    X        .iif true, ...XBUS1 == 0, .mexit
  860+    X       .endc
  861+    X       .if idn,<name>,<XBUS2>
  862+    X        .iif true, ...XBUS2 == 0, .mexit
  863+    X       .endc
  864+    X       .if idn,<name>,<XBUS3>
  865+    X        .iif true, ...XBUS3 == 0, .mexit
  866+    X       .endc
  867+    X       .if idn,<name>,<XBUS>
  868+    X        .iif true, (...XBUS0|...XBUS1|...XBUS2|...XBUS3) == 0, .mexit
  869+    X       .endc
  870+    X      .endc	; PHX
  871+    X      .if idn,<name>,<INT0>
  872+    X       .iif true, ...INT0 == 0, .mexit
  873+    X      .endc
  874+    X      .if idn,<name>,<INT1>
  875+    X       .iif true, ...INT1 == 0, .mexit
  876+    X      .endc
  877+    X      .if idn,<name>,<INT2>
  878+    X       .iif true, ...INT2 == 0, .mexit
  879+    X      .endc
  880+    X      .if idn,<name>,<INT3>
  881+    X       .iif true, ...INT3 == 0, .mexit
  882+    X      .endc
  883+    X      .if idn,<name>,<INT4>
  884+    X       .iif true, ...INT4 == 0, .mexit
  885+    X      .endc
  886+    X      .if idn,<name>,<INT5>
  887+    X       .iif true, ...INT5 == 0, .mexit
  888+    X      .endc
  889+    X      .if idn,<name>,<IOA>
dispatch.c                               Atari Games Corp. macpp v9.12   "Oct 16 1997 13:26:41"


  890+    X       .iif true, ...IOA == 0, .mexit
  891+    X      .endc
  892+    X         prc_set_vec('name'_INTVEC, default);
  893+    X     .endc
  894+    X     	.endm
  895+    X     	.include phx_vecs.mac
  896+          
  897+    X     /* Map the Phoenix interrupts */
  898+          
  899+    X     .if df, INTCTL_MAPA_INIT
  900+    X         BLABF(("\ndispatch: Mapping the A interrupts: 0x%08lX...", INTCTL_MAPA_INIT));
  901+    X         *((VU32 *)(INTCTL_MAPA)) = INTCTL_MAPA_INIT;
  902+    X     .endc
  903+    X     .if df, INTCTL_MAPB_INIT
  904+    X         BLABF(("\ndispatch: Mapping the B interrupts: 0x%08lX...", INTCTL_MAPB_INIT));
  905+    X         *((VU32 *)(INTCTL_MAPB)) = INTCTL_MAPB_INIT;
  906+    X     .endc
  907+          
  908+    X     .if defined, ANNOUNCE_BOOT_ACTIONS
  909+    X      .if true, ANNOUNCE_BOOT_ACTIONS
  910+    X         {
  911+    X     	int jj;
  912+    X     	extern int prc_get_cause(void), prc_get_ipl(void);
  913+    X     	jj = prc_get_cause();
  914+    X     	if (jj&0xFF00) BLABF(("\ndispatch: CPU cause reg: %08lX, CPU SR reg: %08lX", jj, prc_get_ipl()));
  915+    X     	if (jj&0x0400) {
  916+    X       .if true, ...INT0
  917+    X     	.macro VDF cond, name, softvec, intern, installer, notes, physical, default, comments
  918+    X     	.condit cond	
  919+    X        .iif idn,<name>,<INT0>,.mexit
  920+    X        .iif idn,<softvec>,<0>,.mexit
  921+    X        .if true, physical == INT0_LVL
  922+    X     	    if (!softvec) BLAB("\ndispatch: Warning, IRQ 0 pending \"'comments'\"");
  923+    X        .endc
  924+    X     	.endm
  925+    X     	.include phx_vecs.mac		; pickup all vectors assigned to IRQ 0
  926+    X       .iff
  927+    X     	    BLAB("\ndispatch: Warning, IRQ 0 pending with no vector assigned");
  928+    X       .endc		; ...INT0
  929+    X     	}
  930+    X     	if (jj&0x0800) {
  931+    X       .if true, ...INT1
  932+    X     	.macro VDF cond, name, softvec, intern, installer, notes, physical, default, comments
  933+    X     	.condit cond	
  934+    X        .iif idn,<name>,<INT1>,.mexit
  935+    X        .iif idn,<softvec>,<0>,.mexit
  936+    X        .if true, physical == INT1_LVL
  937+    X     	    if (!softvec) BLAB("\ndispatch: Warning, IRQ 1 pending \"'comments'\"");
  938+    X        .endc
  939+    X     	.endm
  940+    X     	.include phx_vecs.mac		; pickup all vectors assigned to IRQ 1
  941+    X       .iff
  942+    X     	    BLAB("\ndispatch: Warning, IRQ 1 pending with no vector assigned");
  943+    X       .endc		; ...INT1
  944+    X     	}
  945+    X     	if (jj&0x1000) {
  946+    X       .if true, ...INT2
dispatch.c                               Atari Games Corp. macpp v9.12   "Oct 16 1997 13:26:41"


  947+    X     	.macro VDF cond, name, softvec, intern, installer, notes, physical, default, comments
  948+    X     	.condit cond	
  949+    X        .iif idn,<name>,<INT2>,.mexit
  950+    X        .iif idn,<softvec>,<0>,.mexit
  951+    X        .if true, physical == INT2_LVL
  952+    X     	    if (!softvec) BLAB("\ndispatch: Warning, IRQ 2 pending \"'comments'\"");
  953+    X        .endc
  954+    X     	.endm
  955+    X     	.include phx_vecs.mac		; pickup all vectors assigned to IRQ 2
  956+    X       .iff
  957+    X     	    BLAB("\ndispatch: Warning, IRQ 2 pending with no vector assigned");
  958+    X       .endc		; ...INT2
  959+    X     	}
  960+    X     	if (jj&0x2000) {
  961+    X       .if true, ...INT3
  962+    X     	.macro VDF cond, name, softvec, intern, installer, notes, physical, default, comments
  963+    X     	.condit cond	
  964+    X        .iif idn,<name>,<INT3>,.mexit
  965+    X        .iif idn,<softvec>,<0>,.mexit
  966+    X        .if true, physical == INT3_LVL
  967+    X     	    if (!softvec) BLAB("\ndispatch: Warning, IRQ 3 pending \"'comments'\"");
  968+    X        .endc
  969+    X     	.endm
  970+    X     	.include phx_vecs.mac		; pickup all vectors assigned to IRQ 3
  971+    X       .iff
  972+    X     	    BLAB("\ndispatch: Warning, IRQ 3 pending with no vector assigned");
  973+    X       .endc		; ...INT3
  974+    X     	}
  975+    X     	if (jj&0x4000) {
  976+    X       .if true, ...INT4
  977+    X     	.macro VDF cond, name, softvec, intern, installer, notes, physical, default, comments
  978+    X     	.condit cond	
  979+    X        .iif idn,<name>,<INT4>,.mexit
  980+    X        .iif idn,<softvec>,<0>,.mexit
  981+    X        .if true, physical == INT4_LVL
  982+    X     	    if (!softvec) BLAB("\ndispatch: Warning, IRQ 4 pending \"'comments'\"");
  983+    X        .endc
  984+    X     	.endm
  985+    X     	.include phx_vecs.mac		; pickup all vectors assigned to IRQ 4
  986+    X       .iff
  987+    X     	    BLAB("\ndispatch: Warning, IRQ 4 pending with no vector assigned");
  988+    X       .endc		; ...INT4
  989+    X     	}
  990+    X     	if (jj&0x8000) {
  991+    X       .if true, ...INT5
  992+    X     	.macro VDF cond, name, softvec, intern, installer, notes, physical, default, comments
  993+    X     	.condit cond	
  994+    X        .iif idn,<name>,<INT5>,.mexit
  995+    X        .iif idn,<softvec>,<0>,.mexit
  996+    X        .if true, physical == INT5_LVL
  997+    X     	    if (!softvec) BLAB("\ndispatch: Warning, IRQ 5 pending \"'comments'\"");
  998+    X        .endc
  999+    X     	.endm
 1000+    X     	.include phx_vecs.mac		; pickup all vectors assigned to IRQ 5
 1001+    X       .iff
 1002+    X     	    BLAB("\ndispatch: Warning, IRQ 5 pending with no vector assigned");
 1003+    X       .endc		; ...INT5
dispatch.c                               Atari Games Corp. macpp v9.12   "Oct 16 1997 13:26:41"


 1004+    X     	}
 1005+    X         }
 1006+    X      .endc		; true, ANNOUNCE_BOOT_ACTIONS
 1007+    X     .endc		; defined, ANNOUNCE_BOOT_ACTIONS
 1008+    X         return;
 1009+    X     }
 1010+   (2)    .endc		; _DISPATCH_MAC_ == 0
  750               return;
  751           }
  752           
  753    (1)     .endc		; ...INT1
  754    (1)     .if true, ...INT2
  755     X     static void int2_irq(void) {
  756     X     	.macro VDF cond, name, softvec, intern, installer, notes, physical, default, comments
  757     X     	.condit cond	
  758     X       .iif idn,<name>,<INT2>,.mexit
  759     X       .iif idn,<softvec>,<0>,.mexit
  760     X       .if true, physical == INT2_LVL
  761     X         if (softvec) softvec();
  762     X       .endc
  763     X     	.endm
  764     X     	.include phx_vecs.mac		; pickup all vectors assigned to IRQ 2
  765     X         return;
  766     X     }
  767           
  768    (1)     .endc		; ...INT2
  769    (1)     .if true, ...INT3
  770           static void int3_irq(void) {
  771           	.macro VDF cond, name, softvec, intern, installer, notes, physical, default, comments
  772           	.condit cond	
  773             .iif idn,<name>,<INT3>,.mexit
  774             .iif idn,<softvec>,<0>,.mexit
  775             .if true, physical == INT3_LVL
  776               if (softvec) softvec();
  777             .endc
  778           	.endm
  779           	.include phx_vecs.mac		; pickup all vectors assigned to IRQ 3
    1+          ;/*		phx_vecs.mac
    2+          ; *
    3+          ; *		Copyright 1996 Atari Games Corporation
    4+          ; *	Unauthorized reproduction, adaptation, distribution, performance or 
    5+          ; *	display of this computer program or the associated audiovisual work
    6+          ; *	is strictly prohibited.
    7+          ; *
    8+          ; *	This file is processed by MACPP to produce dispatch.c and intvecs.h.
    9+          ; *
   10+          ; *	The definitions placed in intvecs.h declare virtual vector numbers
   11+          ; *	in the form of xxx_INTVEC and a cross reference table(s) so the
   12+          ; *	dispatcher can call the appropriate functions.
   13+          ; *
   14+          ; *	intvecs.h should be #include'd by any module that uses prc_set_vec().
   15+          ; */
   16+          ;
   17+          ; This file recursivley '.includes' itself to succesively build up the approprate
   18+          ; tables and functions in C and places the results in one of two files (the
   19+          ; first -out=file supplied on the MACPP command line is expected to be dispatch.c
   20+          ; and the second -out=file is expected to be intvecs.h and the third is expected to
dispatch.c                               Atari Games Corp. macpp v9.12   "Oct 16 1997 13:26:41"


   21+          ; be /dev/null). If you don't speak fluent MACPP, then you probably shouldn't be
   22+          ; changing anything in this file other than the VDF table listed below.
   23+          ;
   24+   (2)    .if not_defined, _DISPATCH_MAC_		;1 +++++
   25+    X     _DISPATCH_MAC_ == 0			;2 Don't move ...
   26+    X     OUTPUT_LANG == 5 ;LANG_NONE		;3 ... or change ... 
   27+    X     	.outfile 2			;4 ... anything on ...
   28+    X     	.include config.mac		;5 ... these ...
   29+    X     	.outfile 0			;6 ... nine  ...
   30+   (2)    .endc					;7 ... lines ...
   31+   (2)    .if true, (_DISPATCH_MAC_&1) != 0	;8
   32+   (3)     .if true, 0				;9 -----
   33+          
   34+    X     You are free to add or remove entries from this table according to your
   35+    X     requirements. There are 10 fields used on each line in this table. The
   36+    X     description of each field follows:
   37+          
   38+    X     Field 1 = macro call
   39+          
   40+    X     It must always be the keyword VDF (case is not significant).
   41+          
   42+    X     Field 2 = condition
   43+          
   44+    X     This is a dual operand field, so the two operands together must be enclosed in
   45+    X     <>'s. The first operand is one of T, F, D or N representing True, False,
   46+    X     Defined or Not_defined respectively. Case is significant, use uppercase only
   47+    X     please. For the conditions T or F the second operand must be an expression
   48+    X     which must resolve to non-$0 (True) or $0 (False) in order for the macro
   49+    X     to be processed (else it is ignored). The expression can contain no embedded
   50+    X     spaces. For the conditions D and N, the second operand must only be a symbol
   51+    X     which must be Defined or Not-defined respectively in order for the macro to be
   52+    X     processed. Some short cut expressions have been preprocessed to make using the
   53+    X     expressions a little more concise. These are:
   54+          
   55+    X     	PHX = not $0 if HOST_BOARD == PHOENIX
   56+    X     	PAD = not $0 if HOST_BOARD == PHOENIX_AD
   57+    X     	FLG = not $0 if HOST_BOARD == FLAGSTAFF
   58+    X     	SEA = not $0 if HOST_BOARD == SEATTLE
   59+    X     	VEG = not $0 if HOST_BOARD == VEGAS
   60+          
   61+    X     Field 3 = vector name
   62+          
   63+    X     The NAME field is the name of the virtual vector. An _INTVEC will be appended
   64+    X     to it in the C definitions in intvecs.h, but otherwise the name is unmolested.
   65+    X     Case is significant only if you want it to be. The R3K/R4K has an option where
   66+    X     a number of vectors are maintained in an array of pointers rather than each
   67+    X     one having its own name. The index into the array is same as the number
   68+    X     returned in the processor's CAUSE register for that particluar interrupt. This
   69+    X     procedure is done simply for performance reasons. The option is selected by
   70+    X     using a 0 for this field and using an installer function with the vector index
   71+    X     as the parameter to the installer.
   72+          
   73+    X     Field 4 = Vector pointer
   74+          
   75+    X     This field identifies the name of a variable in BSS that contains a pointer
   76+    X     to the function to call at interrupt (or will be set by the prc_set_vec()
   77+    X     function). This is the name of the "soft" or logical vector and is either
dispatch.c                               Atari Games Corp. macpp v9.12   "Oct 16 1997 13:26:41"


   78+    X     declared in dispatch.c or externally according to the INT/EXT field described
   79+    X     next.
   80+          
   81+    X     Field 5 = INTernal or EXTernal vector
   82+          
   83+    X     This field contains the keywords INT, EXT, VINT or VEXT identifying the vector
   84+    X     in field 4 as being defined INTernally, EXTernally, Volatile INTernally or
   85+    X     Volatile Externally to dispatch.c respectively.
   86+          
   87+    X     Field 6 = name of vector installer
   88+          
   89+    X     This field identifies the name of a function that prc_set_vec() will call to
   90+    X     actually install the vector or 0 if there is no special stuff that needs to
   91+    X     be performed during vector installation.
   92+          
   93+    X     Field 7 = Notes for the installer.
   94+          
   95+    X     The Notes field is a parameter that is passed to the installer if there is one.
   96+          
   97+    X     Field 8 = Physical vector attachment.
   98+          
   99+    X     A dispatch routine is constructed for each of the 4 XBUS interrupts and for each of
  100+    X     the 6 CPU interrupts.  This field instructs phx_vecs.mac into which of the XBUS or
  101+    X     INTx dispatchers a caller to this vector belongs.  If this vector is not associated
  102+    X     with an XBUS or an INTx interrupt, it needs to be -1.  Place the interrupt routines
  103+    X     in this table in the order in which you want them executed.
  104+          
  105+    X     Field 9 = Default function.
  106+          
  107+    X     Name of default routine to install in the vector, or 0 if none.  phx_vecs.mac builds
  108+    X     a function called prc_init_vecs(void) which, when called, will perform a string of
  109+    X     prc_set_vec()'s for all the vectors having this field non-zero.  After the vectors
  110+    X     have been loaded, prc_init_vecs(void) will map the phoenix and galileo interrupts as
  111+    X     specified in phoenix.mac.
  112+          
  113+    X     Field 10 = Comments.
  114+          
  115+    X     The Comments field is placed on selected lines in intvecs.h and/or dispatch.c
  116+    X     as simple 'C' comments.
  117+          
  118+   (3)     .endc				; Don't move this line
  119+          ;
  120+          ;   Condit	Name	   Vector   I/E	Installer   Notes      Phys	Default	Comments
  121+          ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  122+          VDF <T,1>	GAMEVB,	   gameint, EXT	0,          0,		-1,	0,	< post-wierdness Vblank >
  123+          VDF <T,1>	MS4,       ms4vec,  EXT	0,          0,		-1,	0,	< 4 Millisecond timer >
  124+          VDF <T,1>	PRC_DELAY, prc_delay_vec, EXT 0,    0,		-1,	sst_prc_delay, < prc_delay soft vector >
  125+          VDF <T,1>	PRC_SET_IPL, set_ipl_vec, INT 0,    0,		-1,	0,	< prc_set_ipl soft vector >
  126+          VDF <T,1>	SAVE,      savintp, EXT 0,          0,		-1,	0,	< context save soft vector >
  127+          VDF <T,1>	RESTORE,   restintp,EXT 0,          0,		-1,	0,	< context restore soft vector >
  128+          VDF <T,1>	SW0,	   0,	    INT hwvinst,    VN_IRQ0,    -1,	0,	< Software interrupt 0 >
  129+          VDF <T,1>	SW1,	   0,       INT hwvinst,    VN_IRQ1,    -1,	0,	< Software interrupt 0 >
  130+          VDF <T,1>	INT0,	   0,       INT hwvinst,    VN_IRQ2,    -1,	int0_irq, < Hardware interrupt 0 >
  131+          VDF <T,1>	INT1,	   0,	    INT hwvinst,    VN_IRQ3,    -1,	int1_irq, < Hardware interrupt 1 >
  132+          VDF <T,PHX>	INT2,	   0,	    INT hwvinst,    VN_IRQ4,    -1,	int2_irq, < Hardware interrupt 2 >
  133+          VDF <T,1>	INT3,	   0,       INT hwvinst,    VN_IRQ5,    -1,	int3_irq, < Hardware interrupt 3 >
  134+          VDF <T,1>	INT4,	   0,	    INT hwvinst,    VN_IRQ6,    -1,	int4_irq, < Hardware interrupt 4 >
dispatch.c                               Atari Games Corp. macpp v9.12   "Oct 16 1997 13:26:41"


  135+          VDF <T,1>	INT5,	   0,	    INT hwvinst,    VN_IRQ7,    -1,	int5_irq, < Hardware interrupt 5 >
  136+          VDF <T,1>	TLBMOD,	   0,	    INT hwvinst,    VN_TLBM,    -1,	0,	< TLB modification >
  137+          VDF <T,1>	TLBLOAD,   0,	    INT hwvinst,    VN_TLBL,    -1,	0,	< TLB miss on I or D fetch >
  138+          VDF <T,1>	TLBSTORE,  0,	    INT hwvinst,    VN_TLBS,    -1,	0,	< TLB miss on store >
  139+          VDF <T,1>	ADDRERRL,  0,	    INT hwvinst,    VN_ADDRL,   -1,	0,	< Address error on I or D fetch >
  140+          VDF <T,1>	ADDRERRS,  0,	    INT hwvinst,    VN_ADDRS,   -1,	0,	< Address error on store >
  141+          VDF <T,1>	BUSERRI,   0,	    INT hwvinst,    VN_BUSERRI, -1,	0,	< Bus error on I-fetch >
  142+          VDF <T,1>	BUSERRD,   0,	    INT hwvinst,    VN_BUSERRD, -1,	0,	< Bus error on D-fetch >
  143+          VDF <T,1>	SYSCALL,   0,       INT hwvinst,    VN_SYSCALL, -1,	0,	< SYSCALL instruction >
  144+          VDF <T,1>	BREAK,     0,       INT hwvinst,    VN_BREAK,   -1,	0,	< Breakpoint instruction >
  145+          VDF <T,1>	RESERV,    0,       INT hwvinst,    VN_RESERV,  -1,	0,	< Reserved instruction >
  146+          VDF <T,1>	COPROC,    0,       INT hwvinst,    VN_COPROC,  -1,	0,	< Coprocessor unusable >
  147+          VDF <T,1>	OVRFLOW,   0,       INT hwvinst,    VN_OVERFL,  -1,	0,	< Integer Arithmetic Overflow >
  148+          VDF <T,1>	TRAP,      0,       INT hwvinst,    VN_TRAPV,   -1,	0,	< TRAP exception >
  149+          VDF <T,1>	FLOAT,     0,       INT hwvinst,    VN_FPE,     -1,	0,	< FLoating point exception >
  150+          VDF <T,1>	TIMER,	   timervec, INT 0,	    0,          -1,	0,	< Soft Timer interrupt >
  151+          VDF <T,1>	TIMERPLL,  tpllvec, VEXT 0,	    0,		-1,	0,	<Adjust 1MS timer>
  152+          VDF <T,1>	GAMEFRAME, framevec,INT 0,	    0,		-1,	0,	< Frame complete >
  153+   (3)    .if true, PHX
  154+    X     VDF <D,NET_LVL>	NET,       netintp, INT 0,          0,		NET_LVL,0,	< network int soft vector >
  155+    X     VDF <D,XBUS>	XBUS,	   xbusintp, INT pvinst,    XBUS_NOTES,	XBUS_LVL,xbus_irq, < Any XBUS interrupt >
  156+    X     VDF <T,XS0>	XS0,       xs0intp, INT pvinst,	    XS0_NOTES,	XS0_LVL,0,	< Expansion Slot 0 interrupt >
  157+    X     VDF <T,XS1>	XS1,       xs1intp, INT pvinst,	    XS1_NOTES,	XS1_LVL,0,	< Expansion Slot 1 interrupt >
  158+    X     VDF <T,XS2>	XS2,       xs2intp, INT pvinst,	    XS2_NOTES,	XS2_LVL,0,	< Expansion Slot 2 interrupt >
  159+    X     VDF <T,XS3>	XS3,       xs3intp, INT pvinst,	    XS3_NOTES,	XS3_LVL,0,	< Expansion Slot 3 interrupt >
  160+    X     VDF <T,MIO>	MIO,       miointp, INT pvinst,	    MIO_NOTES,	MIO_LVL,0,	< Miscellaneous I/O interrupt >
  161+    X     VDF <T,CU1>	CU1,       cu1intp, INT pvinst,	    CU1_NOTES,	CU1_LVL,0,	< Combo UART 1 interrupt >
  162+    X     VDF <T,CU2>	CU2,       cu2intp, INT pvinst,	    CU2_NOTES,	CU2_LVL,0,	< Combo UART 2 interrupt >
  163+    X     VDF <T,CPP>	CPP,       cppintp, INT pvinst,	    CPP_NOTES,	CPP_LVL,0,	< Combo Parallel Port interrupt >
  164+    X     VDF <T,PCA>	PCA,       pcaintp, INT pvinst,	    PCA_NOTES,	PCA_LVL,0,	< PCI A interrupt >
  165+    X     VDF <T,PCB>	PCB,       pcbintp, INT pvinst,	    PCB_NOTES,	PCB_LVL,0,	< PCI B interrupt >
  166+    X     VDF <T,PCC>	PCC,       pccintp, INT pvinst,	    PCC_NOTES,	PCC_LVL,0,	< PCI C interrupt >
  167+    X     VDF <T,VSY>	VSY,       vsyintp, INT pvinst,	    VSY_NOTES,	VSY_LVL,0,	< PCI D (VSYNC) interrupt >
  168+    X     VDF <T,IDE>	IDE,	   ideintp, INT pvinst,	    IDE_NOTES,	IDE_LVL,0,	< IDE interrupt >
  169+    X     VDF <T,IOA>	IOA,	   ioaintp, INT pvinst,	    IOA_NOTES,	IOA_LVL,ioa_irq,< I/O Asic interrupt >
  170+    X     VDF <T,ADC>	ADC,	   adcintp, INT pvinst,	    ADC_NOTES,	ADC_LVL,0,	< A/D Converter interrupt >
  171+    X     VDF <D,SND_I>	CAGE,      cagevec, INT 0,          0,		CAGE_LVL,aud_irq, < CAGE interrupt >
  172+   (3)    .endc
  173+   (3)    .if true, PAD || FLG || SEA || VEG
  174+          ;VDF <T,1>	IOA,	   0,	    INT hwvinst,    VN_IRQ3,	-1,	0,	< I/O Asic interrupt >
  175+          VDF <T,1>	IDE,	   0,	    INT hwvinst,    VN_IRQ4,    -1,	0,	< IDE interrupt >
  176+          VDF <T,EXP>	EXP,       expintp, INT pvinst,	    EXP_NOTES,	EXP_LVL,0,	< Expansion Slot interrupt >
  177+   (4)     .if true, PAD || SEA
  178+          VDF <T,NSS>	NSS,	   nssintp, INT pvinst,	    NSS_NOTES,  NSS_LVL,0,	< NSS/Hi-Link interrupt>
  179+   (4)     .endc
  180+   (4)     .if true, FLG
  181+    X     VDF <T,ETH>	ETH,	   ethintp, INT pvinst,     ETH_NOTES,  ETH_LVL,0,	< ethernet interrupt >
  182+    X     VDF <D,SND_I>	CAGE,	   cagevec, INT ioainst,    CAGE_NOTES, CAGE_LVL,aud_irq, < CAGE interrupt >
  183+   (4)     .endc
  184+          VDF <T,WD1>	WD1,	   wd1intp, INT pvinst,	    WD1_NOTES,  WD1_LVL,0,	< Widget interrupt 1>
  185+          VDF <T,PCI>	PCI,       pciintp, INT pvinst,	    PCI_NOTES,	PCI_LVL,0,	< PCI interrupt >
  186+          VDF <T,ADC>	ADC,	   adcintp, INT pvinst,	    ADC_NOTES,	ADC_LVL,0,	< A/D Converter interrupt >
  187+          VDF <T,WD2>	WD2,	   wd2intp, INT pvinst,	    WD2_NOTES,  WD2_LVL,0,	< Widget interrupt 2>
  188+          VDF <T,DBG>	DBG,	   dbgintp, INT pvinst,	    DBG_NOTES,	DBG_LVL,0,	< Debug switch interrupt >
  189+          VDF <T,VSY>	VSY,	   vsyintp, INT pvinst,	    VSY_NOTES,	VSY_LVL,0,	< VSYNC interrupt >
  190+   (3)    .endc
  191+          VDF <T,GAL>	GAL,	   0,       INT gvinst,	    GAL_NOTES,  GAL_LVL,galileoint, < Any Galileo Error Interrupt >
dispatch.c                               Atari Games Corp. macpp v9.12   "Oct 16 1997 13:26:41"


  192+          VDF <T,MOE>	MOE,	   moeintp, INT gvinst,	    MOE_NOTES,	MOE_LVL,0,	< Galileo MemOut >
  193+          VDF <T,DOE>	DOE,	   doeintp, INT gvinst,	    DOE_NOTES,	DOE_LVL,0,	< Galileo DMAOut >
  194+          VDF <T,COE>	COE,	   coeintp, INT gvinst,	    COE_NOTES,	COE_LVL,0,	< Galileo CPUOut >
  195+          VDF <T,DM0>	DM0,	   dm0intp, INT gvinst,	    DM0_NOTES,	DM0_LVL,0,	< Galileo DMA0Comp >
  196+          VDF <T,DM1>	DM1,	   dm1intp, INT gvinst,	    DM1_NOTES,	DM1_LVL,0,	< Galileo DMA1Comp >
  197+          VDF <T,DM2>	DM2,	   dm2intp, INT gvinst,	    DM2_NOTES,	DM2_LVL,0,	< Galileo DMA2Comp >
  198+          VDF <T,DM3>	DM3,	   dm3intp, INT gvinst,	    DM3_NOTES,	DM3_LVL,0,	< Galileo DMA3Comp >
  199+          VDF <T,TM0>	TM0,	   tm0intp, INT gvinst,	    TM0_NOTES,	TM0_LVL,0,	< Galileo T0Exp >
  200+          VDF <T,TM1>	TM1,	   tm1intp, INT gvinst,	    TM1_NOTES,	TM1_LVL,0,	< Galileo T1Exp >
  201+          VDF <T,TM2>	TM2,	   tm2intp, INT gvinst,	    TM2_NOTES,	TM2_LVL,0,	< Galileo T2Exp >
  202+          VDF <T,TM3>	TM3,	   tm3intp, INT gvinst,	    TM3_NOTES,	TM3_LVL,cputimerint, < Galileo T3EXP timer interrupt >
  203+          VDF <T,MRE>	MRE,	   mreintp, INT gvinst,	    MRE_NOTES,	MRE_LVL,0,	< Galileo MasRdErr >
  204+          VDF <T,SWE>	SWE,	   sweintp, INT gvinst,	    SWE_NOTES,	SWE_LVL,0,	< Galileo SlvWrErr >
  205+          VDF <T,MWE>	MWE,	   mweintp, INT gvinst,	    MWE_NOTES,	MWE_LVL,0,	< Galileo MasWrErr >
  206+          VDF <T,SRE>	SRE,	   sreintp, INT gvinst,	    SRE_NOTES,	SRE_LVL,0,	< Galileo SlvRdErr >
  207+          VDF <T,AEP>	AEP,	   aepintp, INT gvinst,	    AEP_NOTES,	AEP_LVL,0,	< Galileo AddrErr >
  208+          VDF <T,MEP>	MEP,	   mepintp, INT gvinst,	    MEP_NOTES,	MEP_LVL,0,	< Galileo MemErr >
  209+          VDF <T,MAS>	MAS,	   masintp, INT gvinst,	    MAS_NOTES,	MAS_LVL,0,	< Galileo MasAbort >
  210+          VDF <T,TAR>	TAR,	   tarintp, INT gvinst,	    TAR_NOTES,	TAR_LVL,0,	< Galileo TarAbort >
  211+          VDF <T,RTY>	RTY,	   rtyintp, INT gvinst,	    RTY_NOTES,	RTY_LVL,0,	< Galileo RetryCtr >
  212+          VDF <T,PC0>	PC0,	   pc0intp, INT gvinst,	    PC0_NOTES,	PC0_LVL,0,	< Galileo PCI Interrupt >
  213+          VDF <T,PC1>	PC1,	   pc1intp, INT gvinst,	    PC1_NOTES,	PC1_LVL,0,	< Galileo PCI Interrupt >
  214+          VDF <T,PC2>	PC2,	   pc2intp, INT gvinst,	    PC2_NOTES,	PC2_LVL,0,	< Galileo PCI Interrupt >
  215+          VDF <T,PC3>	PC3,	   pc3intp, INT gvinst,	    PC3_NOTES,	PC3_LVL,0,	< Galileo PCI Interrupt >
  216+          VDF <D,UART_LVL> UART,	   uartintp,INT ioainst,    UART_NOTES,	UART_LVL,0,	< I/O ASIC UART interrupts >
  217+          VDF <D,SND_LVL>	SND,	   sndintp, INT ioainst,    SND_NOTES,	SND_LVL, 0,	< I/O ASIC Sound interrupts >
  218+          VDF <D,MC_LVL>	MC,	   mcintp,  INT ioainst,    MC_NOTES,	MC_LVL,	0,	< I/O ASIC Microcontroller interrupt >
  219+          ;
  220+   (2)    .endc			; (_DISPATCH_MAC_&1) != 0 *** DON'T MOVE THIS LINE EITHER ***
  221+          ;
  222+          ;+++++++ From here on, there are few user servicable parts inside. ++++
  223+          ;
  224+          ; This is sortof how it works:
  225+          ; The first pass through, _DISPATCH_MAC_ will be 0 (set above by the .if not_defined).
  226+          ; First the copyright boilerplate is inserted into both output files and the macro VDF
  227+          ; is defined to create externs. Some struct definitions and unique externs are depositied
  228+          ; into the .h file. Next _DISPATCH_MAC_ is set to 1 and this file is .included
  229+          ; again. This will cause MACPP to read the VDF table above and output the appropriate
  230+          ; information in the .h file but ignore the rest of the file. The VDF macro is redefined,
  231+          ; and the procedure is repeated causing the creation of different items according to what
  232+          ; is needed. Once the whole .h file is built, the procedure repeats for the building of the
  233+          ; .c file.
  234+          ;
  235+   (2)    .if true, _DISPATCH_MAC_ == 0		; First (main) pass
  236+    X      PHX == 0
  237+    X      PAD == 0
  238+    X      FLG == 0
  239+    X      SEA == 0
  240+    X      VEG == 0
  241+    X      .iif true, HOST_BOARD == PHOENIX, PHX == 1 ;set the appropriate ones true as desired
  242+    X      .iif true, HOST_BOARD == PHOENIX_AD, PAD == 1 ;set the appropriate ones true as desired
  243+    X      .iif true, HOST_BOARD == FLAGSTAFF, FLG == 1 ;set the appropriate ones true as desired
  244+    X      .iif true, HOST_BOARD == SEATTLE, SEA == 1 ;set the appropriate ones true as desired
  245+    X      .iif true, HOST_BOARD == VEGAS, VEG == 1 ;set the appropriate ones true as desired
  246+          ;
  247+    X     	.macro .condit flag,exp		; The .condit macro does an expression test ...
  248+    X     	.if identical,<flag>,<T>
dispatch.c                               Atari Games Corp. macpp v9.12   "Oct 16 1997 13:26:41"


  249+    X     		.iif false,exp,.mexit 10 ; ... and aborts higher level macros if false
  250+    X     		.mexit
  251+    X     	.endc
  252+    X     	.if identical,<flag>,<F>
  253+    X     		.iif true,exp,.mexit 10	; ... etc.
  254+    X     		.mexit
  255+    X     	.endc
  256+    X     	.if identical,<flag>,<D>
  257+    X     		.iif not_defined,exp,.mexit 10
  258+    X     		.mexit
  259+    X     	.endc
  260+    X     	.if identical,<flag>,<N>
  261+    X     		.iif defined,exp,.mexit 10
  262+    X     		.mexit
  263+    X     	.endc
  264+    X     	.endm
  265+          ;	
  266+    X     	.macro boilerplate file_name
  267+    X     /*		file_name
  268+    X      *
  269+    X      *		Copyright 1996 Atari Games Corporation
  270+    X      *	Unauthorized reproduction, adaptation, distribution, performance or 
  271+    X      *	display of this computer program or the associated audiovisual work
  272+    X      *	is strictly prohibited.
  273+    X      *
  274+    X      * ++++++ WARNING WARNING WARNING WARNING WARNING +++++
  275+    X      * This file is machine generated. Any changes you put in here will be lost
  276+    X      * the next time phx_vecs.mac is touched. You need to make your changes to
  277+    X      * phx_vecs.mac instead of this file.
  278+    X      */
  279+    X     	.endm
  280+    X     	boilerplate dispatch.c
  281+    X     	.outfile	1		;The externs go into the .h file
  282+    X     	boilerplate intvecs.h
  283+    X     #if !defined(_INTVECS_H_)
  284+    X     #define _INTVECS_H_
  285+          
  286+    X     struct irq_tab {
  287+    X     	void 	(**softvec)();
  288+    X     	void    (*(*installer)(const struct irq_tab *, void(*new)()))();
  289+    X     	int	notes;
  290+    X     };
  291+          ;
  292+    X     	.macro VDF cond, name, softvec, intern, installer, notes, physical, default, comments
  293+    X     	.condit cond	
  294+    X      .if dif,<softvec>,<0>
  295+    X       ...1 == 0
  296+    X       .iif idn,<intern>,<VINT>,...1 == 1
  297+    X       .iif idn,<intern>,<VEXT>,...1 == 1
  298+    X       .if true, ...1
  299+    X     extern	void (* volatile softvec)();	/* comments */
  300+    X       .iff
  301+    X     extern  void (*softvec)();	/* comments */
  302+    X       .endc
  303+    X      .endc
  304+    X     	.endm
  305+          ;
dispatch.c                               Atari Games Corp. macpp v9.12   "Oct 16 1997 13:26:41"


  306+    X     	_DISPATCH_MAC_ == 1		;next time we process the IRQ table
  307+    X     	.include phx_vecs.mac		;Make the externs
  308+          
  309+    X     enum vecs {
  310+    X     	.macro VDF cond, name, softvec, intern, installer, notes, physical, default, comments
  311+    X     	.condit cond	
  312+    X         name'_INTVEC,
  313+    X     	.endm
  314+    X     	.include phx_vecs.mac		;Make the enums
  315+    X         N_INTVECS
  316+    X     };
  317+          
  318+    X     void (*prc_set_vec (unsigned int vecnum, void (*routine)() ))();
  319+    X     void prc_init_vecs(void);		/* set the default vectors */
  320+          ;
  321+          ; Add a prototype for an as yet unused function
  322+    X     .if true, 0
  323+          
  324+    X     /*		prc_set_vecp(which, what)
  325+    X      *	Sets a special vector for the interrupt identified by <which>
  326+    X      *	to call the routine specified by <what>. <what> is
  327+    X      *	a struct that contains both a pointer to the code
  328+    X      *	to execute and an optional pointer to the private
  329+    X      *	variables for that routine. This is a change from the
  330+    X      *	behavior of prc_set_vec, and is intended to allow
  331+    X      *	multiple incarnations of a given device to share code.
  332+    X      */
  333+          
  334+    X     struct opaque;
  335+    X     extern struct VECP_vector {
  336+    X         void (*function)(struct opaque *);	/* Who you gonna call */
  337+    X         struct opaque *cookie;		/* a magic cookie to hand him */
  338+    X     } prc_set_vecp (
  339+    X         int __which,			/* one of xxx_INTVEC */
  340+    X         struct IRQ_vector __what		/* BY VALUE!!! */
  341+    X     );
  342+    X     .endc
  343+    X     #endif		/* _INTVECS_H_ */
  344+          ;
  345+          ; At this point, we have completed all processing of the .h file
  346+          ; so switch back to the .c file
  347+          ;
  348+    X     	.outfile	0		;switch back to dispatch.c
  349+          ;
  350+    X     #include <config.h>			/* begining of dispatch.c */
  351+    X     #include <os_proto.h>
  352+    X     #include <intvecs.h>
  353+          
  354+    X     #ifndef BLABF
  355+    X     # define BLABF(x)
  356+    X     #endif
  357+          
  358+    X     #ifndef BLAB
  359+    X     # define BLAB(x)
  360+    X     #endif
  361+          
  362+    X      .if true, 1
dispatch.c                               Atari Games Corp. macpp v9.12   "Oct 16 1997 13:26:41"


  363+    X     	.macro VDF cond, name, softvec, intern, installer, notes, physical, default, comments
  364+    X     	.condit cond	
  365+    X       .iif idn,<name>,<XBUS0>,.mexit
  366+    X       .iif idn,<name>,<XBUS1>,.mexit
  367+    X       .iif idn,<name>,<XBUS2>,.mexit
  368+    X       .iif idn,<name>,<XBUS3>,.mexit
  369+    X       .iif idn,<name>,<INT0>,.mexit
  370+    X       .iif idn,<name>,<INT1>,.mexit
  371+    X       .iif idn,<name>,<INT2>,.mexit
  372+    X       .iif idn,<name>,<INT3>,.mexit
  373+    X       .iif idn,<name>,<INT4>,.mexit
  374+    X       .iif idn,<name>,<INT5>,.mexit
  375+    X       .if true, PHX
  376+    X         .if true, physical == XBUS0_LVL
  377+    X     	  ...XBUS0 == ...XBUS0 + 1
  378+    X     	  .mexit
  379+    X         .endc
  380+    X         .if true, physical == XBUS1_LVL
  381+    X     	  ...XBUS1 == ...XBUS1 + 1
  382+    X     	  .mexit
  383+    X         .endc
  384+    X         .if true, physical == XBUS2_LVL
  385+    X     	  ...XBUS2 == ...XBUS2 + 1
  386+    X     	  .mexit
  387+    X         .endc
  388+    X         .if true, physical == XBUS3_LVL
  389+    X     	  ...XBUS3 == ...XBUS3 + 1
  390+    X     	  .mexit
  391+    X         .endc
  392+    X       .endc
  393+    X       .if true, physical == INT0_LVL
  394+    X         	...INT0 == ...INT0 + 1
  395+    X     	.mexit
  396+    X       .endc
  397+    X       .if true, physical == INT1_LVL
  398+    X         	...INT1 == ...INT1 + 1
  399+    X        .if true, PAD || FLG || SEA || VEG
  400+    X     	...IOA == ...IOA + 1
  401+    X         .if ndf, notes
  402+    X     #define notes IO_MAIN_GLOBAL_INT
  403+    X         .endc
  404+    X        .endc
  405+    X     	.mexit
  406+    X       .endc
  407+    X       .if true, physical == INT2_LVL
  408+    X         	...INT2 == ...INT2 + 1
  409+    X     	.mexit
  410+    X       .endc
  411+    X       .if true, physical == INT3_LVL
  412+    X         	...INT3 == ...INT3 + 1
  413+    X     	.mexit
  414+    X       .endc
  415+    X       .if true, physical == INT4_LVL
  416+    X         	...INT4 == ...INT4 + 1
  417+    X     	.mexit
  418+    X       .endc
  419+    X       .if true, physical == INT5_LVL
dispatch.c                               Atari Games Corp. macpp v9.12   "Oct 16 1997 13:26:41"


  420+    X         	...INT5 == ...INT5 + 1
  421+    X     	.mexit
  422+    X       .endc
  423+    X       .if true, physical == IOASIC_LVL
  424+    X         	...IOA == ...IOA + 1
  425+    X        .if ndf, notes
  426+    X     #define notes IO_MAIN_GLOBAL_INT
  427+    X        .endc
  428+    X     	.mexit
  429+    X       .endc
  430+    X     	.endm
  431+    X     ...XBUS0 == 0
  432+    X     ...XBUS1 == 0
  433+    X     ...XBUS2 == 0
  434+    X     ...XBUS3 == 0
  435+    X     ...INT0 == 0
  436+    X     ...INT1 == 0
  437+    X     ...INT2 == 0
  438+    X     ...INT3 == 0
  439+    X     ...INT4 == 0
  440+    X     ...INT5 == 0
  441+    X     ...IOA == 0
  442+    X     	.include phx_vecs.mac	; count vectors requiring dispatch
  443+    X      .endc
  444+          ; 
  445+    X     .macro VDF cond, name, softvec, intern, installer, notes, physical, default, comments
  446+    X      .condit cond	
  447+    X      .if dif,<softvec>,<0>
  448+    X       .if idn,<intern>,<INT>
  449+    X     void (*softvec)();	/* comments */
  450+    X       .endc
  451+    X       .if idn,<intern>,<VINT>
  452+    X     void (* volatile softvec)();	/* comments */
  453+    X       .endc
  454+    X      .endc
  455+    X      .if dif,<default>,<0>
  456+    X       .if idn,<name>,<INT0>
  457+    X        .if true, ...INT0
  458+    X     static void 'default'(void);	/* comments */
  459+    X        .endc
  460+    X        .mexit
  461+    X       .endc
  462+    X       .if idn,<name>,<INT1>
  463+    X        .if true, ...INT1
  464+    X     static void 'default'(void);	/* comments */
  465+    X        .endc
  466+    X        .mexit
  467+    X       .endc
  468+    X       .if idn,<name>,<INT2>
  469+    X        .if true, ...INT2
  470+    X     static void 'default'(void);	/* comments */
  471+    X        .endc
  472+    X        .mexit
  473+    X       .endc
  474+    X       .if idn,<name>,<INT3>
  475+    X        .if true, ...INT3
  476+    X     static void 'default'(void);	/* comments */
dispatch.c                               Atari Games Corp. macpp v9.12   "Oct 16 1997 13:26:41"


  477+    X        .endc
  478+    X        .mexit
  479+    X       .endc
  480+    X       .if idn,<name>,<INT4>
  481+    X        .if true, ...INT4
  482+    X     static void 'default'(void);	/* comments */
  483+    X        .endc
  484+    X        .mexit
  485+    X       .endc
  486+    X       .if idn,<name>,<INT5>
  487+    X        .if true, ...INT5
  488+    X     static void 'default'(void);	/* comments */
  489+    X        .endc
  490+    X        .mexit
  491+    X       .endc
  492+    X       .if idn,<name>,<INT6>
  493+    X        .if true, ...INT6
  494+    X     static void 'default'(void);	/* comments */
  495+    X        .endc
  496+    X        .mexit
  497+    X       .endc
  498+    X       .if idn,<name>,<INT7>
  499+    X        .if true, ...INT7
  500+    X     static void 'default'(void);	/* comments */
  501+    X        .endc
  502+    X        .mexit
  503+    X       .endc
  504+    X       .if true, PHX
  505+    X        .if idn,<name>,<XBUS>
  506+    X         .if true, ...XBUS0|...XBUS1|...XBUS2|...XBUS3
  507+    X     static void 'default'(void);
  508+    X         .endc
  509+    X         .mexit
  510+    X        .endc
  511+    X        .if idn,<name>,<XBUS0>
  512+    X         .if true, ...XBUS0
  513+    X     static void 'default'(void);
  514+    X         .endc
  515+    X         .mexit
  516+    X        .endc
  517+    X        .if idn,<name>,<XBUS1>
  518+    X         .if true, ...XBUS1
  519+    X     static void 'default'(void);
  520+    X         .endc
  521+    X         .mexit
  522+    X        .endc
  523+    X        .if idn,<name>,<XBUS2>
  524+    X         .if true, ...XBUS2
  525+    X     static void 'default'(void);
  526+    X         .endc
  527+    X         .mexit
  528+    X        .endc
  529+    X        .if idn,<name>,<XBUS3>
  530+    X         .if true, ...XBUS3
  531+    X     static void 'default'(void);
  532+    X         .endc
  533+    X         .mexit
dispatch.c                               Atari Games Corp. macpp v9.12   "Oct 16 1997 13:26:41"


  534+    X        .endc
  535+    X       .endc			; PHX
  536+    X       .if idn,<name>,<IOA>
  537+    X        .if true, ...IOA
  538+    X     static void 'default'(void);
  539+    X        .endc
  540+    X        .mexit
  541+    X       .endc
  542+    X     extern void 'default'(void);
  543+    X      .endc
  544+    X     .endm
  545+    X     	.include phx_vecs.mac		;Declare the non-extern vectors
  546+          ;
  547+    X      .if true, ((PROCESSOR&-16) == MIPS3000) || ((PROCESSOR&-16) == MIPS4000)
  548+    X     static void (*hwvinst(const struct irq_tab *, void (*)()))();
  549+    X      .endc
  550+          ;
  551+    X     .if df, PHOENIX_INTCTL_MASK
  552+    X     static void (*pvinst(const struct irq_tab *, void (*)()))();
  553+    X     .endc
  554+          ;
  555+    X     .if df, GALILEO_INTCTL_MASK
  556+    X     static void (*gvinst(const struct irq_tab *, void (*)()))();
  557+    X     .endc
  558+          ;
  559+    X     .if true, ...IOA
  560+    X     static void (*ioainst(const struct irq_tab *, void (*)()))();
  561+    X     .endc
  562+          ;
  563+    X     static const struct irq_tab irq_inits[] = {
  564+    X     	.macro VDF cond, name, softvec, intern, installer, notes, physical, default, comments
  565+    X     	.condit cond	
  566+    X      .if dif,<softvec>,<0>
  567+    X      { (void (**)())&softvec, installer, notes },	/* comments */
  568+    X      .iff
  569+    X      { 0, installer, notes },	/* comments */
  570+    X      .endc
  571+    X     	.endm
  572+    X     	.include phx_vecs.mac		;Build the irq_inits array
  573+    X      { 0, 0, 0} };
  574+          ;
  575+    X     .if true, ((PROCESSOR&-16) == MIPS3000) || ((PROCESSOR&-16) == MIPS4000)
  576+          
  577+    X     extern void (*ramv_tbl[])();
  578+          
  579+    X     static void (*hwvinst(const struct irq_tab *it, void (*new)()))() {
  580+    X         int indx;
  581+    X         void (*old_rtn)();
  582+          
  583+    X         indx = it->notes;
  584+    X         if (indx >= VN_MAX) return 0;
  585+    X         old_rtn = ramv_tbl[indx];
  586+    X         ramv_tbl[indx] = new;
  587+    X         return old_rtn;
  588+    X     }
  589+          
  590+    X      .if df, PHOENIX_INTCTL_MASK
dispatch.c                               Atari Games Corp. macpp v9.12   "Oct 16 1997 13:26:41"


  591+    X     static void (*pvinst(const struct irq_tab *it, void (*new)()))() {
  592+          
  593+    X         if (it->notes) {
  594+    X     	BLABF(("\ndispatch: Adding 0x%08lX to main INTCTL (0x%08lX)...", it->notes, *(VU32*)INTCTL_IE));
  595+    X     	*((VU32 *)(INTCTL_IE)) |= it->notes;
  596+    X         }
  597+    X         return 0;
  598+    X     }
  599+    X      .endc
  600+          
  601+    X      .if df, GALILEO_INTCTL_MASK
  602+    X     static void (*gvinst(const struct irq_tab *it, void (*new)()))() {
  603+          
  604+    X         if (it->notes) {
  605+    X     	BLABF(("\ndispatch: Adding 0x%08lX to Galileo INTCTL (0x%08lX)...", it->notes, \
  606+    X     			*(VU32*)GALILEO_CPU_I_ENA));
  607+    X     	*((VU32 *)(GALILEO_CPU_I_ENA)) |= it->notes;
  608+    X         }
  609+    X         return 0;
  610+    X     }
  611+    X      .endc
  612+          
  613+    X      .if true, ...IOA
  614+    X     static void (*ioainst(const struct irq_tab *it, void (*new)()))() {
  615+    X     extern void prc_wait_n_usecs( int );
  616+    X         if (it->notes)
  617+    X         {
  618+    X          BLABF(("\ndispatch: Adding 0x%04X to IOASIC INTCTL: (0x%04X)...", (int)it->notes, \
  619+    X     		*(VU32*)IO_MAIN_CTL&0xFFFF));
  620+    X          while ( ( *((VU32 *)IO_MAIN_CTL) & it->notes ) != it->notes )
  621+    X          {
  622+    X     #ifdef LED_OUT
  623+    X           *(VU32 *)LED_OUT = ~( 1 << B_LED_RED );
  624+    X     #endif
  625+    X           do
  626+    X           {
  627+    X            *((VU32 *)IO_MAIN_CTL) |= it->notes;
  628+    X            prc_wait_n_usecs( 1000 );
  629+    X           } while ( ( *((VU32 *)IO_MAIN_CTL) & it->notes ) != it->notes );
  630+    X           prc_wait_n_usecs( 1000 );
  631+    X     #ifdef LED_OUT
  632+    X           *(VU32 *)LED_OUT |= ( 1 << B_LED_RED );
  633+    X     #endif
  634+    X          }
  635+    X         }
  636+    X         return 0;
  637+    X     }
  638+    X      .endc
  639+    X     .endc
  640+          
  641+    X     void (*prc_set_vec (unsigned int vecnum, void (*routine)() ))()
  642+    X     {
  643+    X         void (*old_rtn)();
  644+    X         void (**softvec)();
  645+    X         const struct irq_tab *tbp;
  646+    X         int old_ipl;
  647+          
dispatch.c                               Atari Games Corp. macpp v9.12   "Oct 16 1997 13:26:41"


  648+    X         if ( vecnum >= N_INTVECS ) return 0;
  649+    X         tbp = irq_inits+vecnum;
  650+    X         softvec = tbp->softvec;
  651+    X         old_rtn = 0;
  652+    X         old_ipl = prc_set_ipl(INTS_OFF);
  653+    X         if ( tbp->installer ) old_rtn = tbp->installer(tbp, routine);
  654+    X         if ( softvec ) {
  655+    X     	if (!old_rtn) old_rtn = *softvec;
  656+    X     	*softvec = routine;
  657+    X         }
  658+    X         prc_set_ipl(old_ipl);
  659+    X         return old_rtn;
  660+    X     }
  661+          
  662+    X      .if true, PHX
  663+    X       .if true, ...XBUS0
  664+    X     static void xbus0_irq(void) {
  665+    X     	.macro VDF cond, name, softvec, intern, installer, notes, physical, default, comments
  666+    X     	.condit cond	
  667+    X       .iif idn,<name>,<XBUS0>,.mexit
  668+    X       .iif idn,<softvec>,<0>,.mexit
  669+    X       .if true, physical == XBUS0_LVL
  670+    X         if (softvec) softvec();
  671+    X       .endc
  672+    X     	.endm
  673+    X     	.include phx_vecs.mac		; pickup all vectors assigned to XBUS0_LVL
  674+    X         return;
  675+    X     }
  676+          
  677+    X       .endc		; ...XBUS0
  678+    X       .if true, ...XBUS1
  679+    X     static void xbus1_irq(void) {
  680+    X     	.macro VDF cond, name, softvec, intern, installer, notes, physical, default, comments
  681+    X     	.condit cond	
  682+    X       .iif idn,<name>,<XBUS1>,.mexit
  683+    X       .iif idn,<softvec>,<0>,.mexit
  684+    X       .if true, physical == XBUS1_LVL
  685+    X         if (softvec) softvec();
  686+    X       .endc
  687+    X     	.endm
  688+    X     	.include phx_vecs.mac		; pickup all vectors assigned to XBUS1_LVL
  689+    X         return;
  690+    X     }
  691+          
  692+    X       .endc		; ...XBUS1
  693+    X       .if true, ...XBUS2
  694+    X     static void xbus2_irq(void) {
  695+    X     	.macro VDF cond, name, softvec, intern, installer, notes, physical, default, comments
  696+    X     	.condit cond	
  697+    X       .iif idn,<name>,<XBUS2>,.mexit
  698+    X       .iif idn,<softvec>,<0>,.mexit
  699+    X       .if true, physical == XBUS2_LVL
  700+    X         if (softvec) softvec();
  701+    X       .endc
  702+    X     	.endm
  703+    X     	.include phx_vecs.mac		; pickup all vectors assigned to XBUS2_LVL
  704+    X         return;
dispatch.c                               Atari Games Corp. macpp v9.12   "Oct 16 1997 13:26:41"


  705+    X     }
  706+          
  707+    X       .endc		; ...XBUS2
  708+    X       .if true, ...XBUS3
  709+    X     static void xbus3_irq(void) {
  710+    X     	.macro VDF cond, name, softvec, intern, installer, notes, physical, default, comments
  711+    X     	.condit cond	
  712+    X       .iif idn,<name>,<XBUS3>,.mexit
  713+    X       .iif idn,<softvec>,<0>,.mexit
  714+    X       .if true, physical == XBUS3_LVL
  715+    X         if (softvec) softvec();
  716+    X       .endc
  717+    X     	.endm
  718+    X     	.include phx_vecs.mac		; pickup all vectors assigned to XBUS3_LVL
  719+    X         return;
  720+    X     }
  721+          
  722+    X       .endc		; ...XBUS3
  723+    X      .endc		; PHX
  724+    X      .if true, ...INT0
  725+    X     static void int0_irq(void) {
  726+    X     	.macro VDF cond, name, softvec, intern, installer, notes, physical, default, comments
  727+    X     	.condit cond	
  728+    X       .iif idn,<name>,<INT0>,.mexit
  729+    X       .iif idn,<softvec>,<0>,.mexit
  730+    X       .if true, physical == INT0_LVL
  731+    X         if (softvec) softvec();
  732+    X       .endc
  733+    X     	.endm
  734+    X     	.include phx_vecs.mac		; pickup all vectors assigned to IRQ 0
  735+    X         return;
  736+    X     }
  737+          
  738+    X      .endc		; ...INT0
  739+    X      .if true, ...INT1
  740+    X     static void int1_irq(void) {
  741+    X     	.macro VDF cond, name, softvec, intern, installer, notes, physical, default, comments
  742+    X     	.condit cond	
  743+    X       .iif idn,<name>,<INT1>,.mexit
  744+    X       .iif idn,<softvec>,<0>,.mexit
  745+    X       .if true, physical == INT1_LVL
  746+    X         if (softvec) softvec();
  747+    X       .endc
  748+    X     	.endm
  749+    X     	.include phx_vecs.mac		; pickup all vectors assigned to IRQ 1
  750+    X         return;
  751+    X     }
  752+          
  753+    X      .endc		; ...INT1
  754+    X      .if true, ...INT2
  755+    X     static void int2_irq(void) {
  756+    X     	.macro VDF cond, name, softvec, intern, installer, notes, physical, default, comments
  757+    X     	.condit cond	
  758+    X       .iif idn,<name>,<INT2>,.mexit
  759+    X       .iif idn,<softvec>,<0>,.mexit
  760+    X       .if true, physical == INT2_LVL
  761+    X         if (softvec) softvec();
dispatch.c                               Atari Games Corp. macpp v9.12   "Oct 16 1997 13:26:41"


  762+    X       .endc
  763+    X     	.endm
  764+    X     	.include phx_vecs.mac		; pickup all vectors assigned to IRQ 2
  765+    X         return;
  766+    X     }
  767+          
  768+    X      .endc		; ...INT2
  769+    X      .if true, ...INT3
  770+    X     static void int3_irq(void) {
  771+    X     	.macro VDF cond, name, softvec, intern, installer, notes, physical, default, comments
  772+    X     	.condit cond	
  773+    X       .iif idn,<name>,<INT3>,.mexit
  774+    X       .iif idn,<softvec>,<0>,.mexit
  775+    X       .if true, physical == INT3_LVL
  776+    X         if (softvec) softvec();
  777+    X       .endc
  778+    X     	.endm
  779+    X     	.include phx_vecs.mac		; pickup all vectors assigned to IRQ 3
  780+    X         return;
  781+    X     }
  782+          
  783+    X      .endc		; ...INT3
  784+    X      .if true, ...INT4
  785+    X     static void int4_irq(void) {
  786+    X     	.macro VDF cond, name, softvec, intern, installer, notes, physical, default, comments
  787+    X     	.condit cond	
  788+    X       .iif idn,<name>,<INT4>,.mexit
  789+    X       .iif idn,<softvec>,<0>,.mexit
  790+    X       .if true, physical == INT4_LVL
  791+    X         if (softvec) softvec();
  792+    X       .endc
  793+    X     	.endm
  794+    X     	.include phx_vecs.mac		; pickup all vectors assigned to IRQ 4
  795+    X         return;
  796+    X     }
  797+          
  798+    X      .endc		; ...INT4
  799+    X      .if true, ...INT5
  800+    X     static void int5_irq(void) {
  801+    X     	.macro VDF cond, name, softvec, intern, installer, notes, physical, default, comments
  802+    X     	.condit cond	
  803+    X       .iif idn,<name>,<INT5>,.mexit
  804+    X       .iif idn,<softvec>,<0>,.mexit
  805+    X       .if true, physical == INT5_LVL
  806+    X         if (softvec) softvec();
  807+    X       .endc
  808+    X     	.endm
  809+    X     	.include phx_vecs.mac		; pickup all vectors assigned to IRQ 5
  810+    X         return;
  811+    X     }
  812+          
  813+    X      .endc		; ...INT5
  814+    X      .if true, ...IOA && PHX
  815+    X     static void ioa_irq(void) {
  816+    X     	.macro VDF cond, name, softvec, intern, installer, notes, physical, default, comments
  817+    X     	.condit cond	
  818+    X       .iif idn,<name>,<IOA>,.mexit
dispatch.c                               Atari Games Corp. macpp v9.12   "Oct 16 1997 13:26:41"


  819+    X       .iif idn,<softvec>,<0>,.mexit
  820+    X       .if true, physical == IOASIC_LVL
  821+    X         if (softvec) softvec();
  822+    X       .endc
  823+    X     	.endm
  824+    X     	.include phx_vecs.mac		; pickup all vectors assigned to IRQ 5
  825+    X         return;
  826+    X     }
  827+          
  828+    X      .endc		; ...IOA
  829+    X      .if true, PHX
  830+    X       .if true, ...XBUS0|...XBUS1|...XBUS2|...XBUS3
  831+    X     static void xbus_irq(void) {
  832+    X         int which;
  833+    X         which = *(VU32 *)(XBUS_SLOT0+4);
  834+    X       .if true, ...XBUS0
  835+    X         if (!(which&1)) xbus0_irq();
  836+    X       .endc
  837+    X       .if true, ...XBUS1
  838+    X         if (!(which&2)) xbus1_irq();
  839+    X       .endc
  840+    X       .if true, ...XBUS2
  841+    X         if (!(which&4)) xbus2_irq();
  842+    X       .endc
  843+    X       .if true, ...XBUS3
  844+    X         if (!(which&8)) xbus3_irq();
  845+    X       .endc
  846+    X         return;
  847+    X     }
  848+    X       .endc
  849+    X      .endc		; PHX
  850+    X     void prc_init_vecs(void) {
  851+    X     	.macro VDF cond, name, softvec, intern, installer, notes, physical, default, comments
  852+    X     	.condit cond	
  853+    X     .if dif,<default>,<0>
  854+    X      .if true, PHX
  855+    X       .if idn,<name>,<XBUS0>
  856+    X        .iif true, ...XBUS0 == 0, .mexit
  857+    X       .endc
  858+    X       .if idn,<name>,<XBUS1>
  859+    X        .iif true, ...XBUS1 == 0, .mexit
  860+    X       .endc
  861+    X       .if idn,<name>,<XBUS2>
  862+    X        .iif true, ...XBUS2 == 0, .mexit
  863+    X       .endc
  864+    X       .if idn,<name>,<XBUS3>
  865+    X        .iif true, ...XBUS3 == 0, .mexit
  866+    X       .endc
  867+    X       .if idn,<name>,<XBUS>
  868+    X        .iif true, (...XBUS0|...XBUS1|...XBUS2|...XBUS3) == 0, .mexit
  869+    X       .endc
  870+    X      .endc	; PHX
  871+    X      .if idn,<name>,<INT0>
  872+    X       .iif true, ...INT0 == 0, .mexit
  873+    X      .endc
  874+    X      .if idn,<name>,<INT1>
  875+    X       .iif true, ...INT1 == 0, .mexit
dispatch.c                               Atari Games Corp. macpp v9.12   "Oct 16 1997 13:26:41"


  876+    X      .endc
  877+    X      .if idn,<name>,<INT2>
  878+    X       .iif true, ...INT2 == 0, .mexit
  879+    X      .endc
  880+    X      .if idn,<name>,<INT3>
  881+    X       .iif true, ...INT3 == 0, .mexit
  882+    X      .endc
  883+    X      .if idn,<name>,<INT4>
  884+    X       .iif true, ...INT4 == 0, .mexit
  885+    X      .endc
  886+    X      .if idn,<name>,<INT5>
  887+    X       .iif true, ...INT5 == 0, .mexit
  888+    X      .endc
  889+    X      .if idn,<name>,<IOA>
  890+    X       .iif true, ...IOA == 0, .mexit
  891+    X      .endc
  892+    X         prc_set_vec('name'_INTVEC, default);
  893+    X     .endc
  894+    X     	.endm
  895+    X     	.include phx_vecs.mac
  896+          
  897+    X     /* Map the Phoenix interrupts */
  898+          
  899+    X     .if df, INTCTL_MAPA_INIT
  900+    X         BLABF(("\ndispatch: Mapping the A interrupts: 0x%08lX...", INTCTL_MAPA_INIT));
  901+    X         *((VU32 *)(INTCTL_MAPA)) = INTCTL_MAPA_INIT;
  902+    X     .endc
  903+    X     .if df, INTCTL_MAPB_INIT
  904+    X         BLABF(("\ndispatch: Mapping the B interrupts: 0x%08lX...", INTCTL_MAPB_INIT));
  905+    X         *((VU32 *)(INTCTL_MAPB)) = INTCTL_MAPB_INIT;
  906+    X     .endc
  907+          
  908+    X     .if defined, ANNOUNCE_BOOT_ACTIONS
  909+    X      .if true, ANNOUNCE_BOOT_ACTIONS
  910+    X         {
  911+    X     	int jj;
  912+    X     	extern int prc_get_cause(void), prc_get_ipl(void);
  913+    X     	jj = prc_get_cause();
  914+    X     	if (jj&0xFF00) BLABF(("\ndispatch: CPU cause reg: %08lX, CPU SR reg: %08lX", jj, prc_get_ipl()));
  915+    X     	if (jj&0x0400) {
  916+    X       .if true, ...INT0
  917+    X     	.macro VDF cond, name, softvec, intern, installer, notes, physical, default, comments
  918+    X     	.condit cond	
  919+    X        .iif idn,<name>,<INT0>,.mexit
  920+    X        .iif idn,<softvec>,<0>,.mexit
  921+    X        .if true, physical == INT0_LVL
  922+    X     	    if (!softvec) BLAB("\ndispatch: Warning, IRQ 0 pending \"'comments'\"");
  923+    X        .endc
  924+    X     	.endm
  925+    X     	.include phx_vecs.mac		; pickup all vectors assigned to IRQ 0
  926+    X       .iff
  927+    X     	    BLAB("\ndispatch: Warning, IRQ 0 pending with no vector assigned");
  928+    X       .endc		; ...INT0
  929+    X     	}
  930+    X     	if (jj&0x0800) {
  931+    X       .if true, ...INT1
  932+    X     	.macro VDF cond, name, softvec, intern, installer, notes, physical, default, comments
dispatch.c                               Atari Games Corp. macpp v9.12   "Oct 16 1997 13:26:41"


  933+    X     	.condit cond	
  934+    X        .iif idn,<name>,<INT1>,.mexit
  935+    X        .iif idn,<softvec>,<0>,.mexit
  936+    X        .if true, physical == INT1_LVL
  937+    X     	    if (!softvec) BLAB("\ndispatch: Warning, IRQ 1 pending \"'comments'\"");
  938+    X        .endc
  939+    X     	.endm
  940+    X     	.include phx_vecs.mac		; pickup all vectors assigned to IRQ 1
  941+    X       .iff
  942+    X     	    BLAB("\ndispatch: Warning, IRQ 1 pending with no vector assigned");
  943+    X       .endc		; ...INT1
  944+    X     	}
  945+    X     	if (jj&0x1000) {
  946+    X       .if true, ...INT2
  947+    X     	.macro VDF cond, name, softvec, intern, installer, notes, physical, default, comments
  948+    X     	.condit cond	
  949+    X        .iif idn,<name>,<INT2>,.mexit
  950+    X        .iif idn,<softvec>,<0>,.mexit
  951+    X        .if true, physical == INT2_LVL
  952+    X     	    if (!softvec) BLAB("\ndispatch: Warning, IRQ 2 pending \"'comments'\"");
  953+    X        .endc
  954+    X     	.endm
  955+    X     	.include phx_vecs.mac		; pickup all vectors assigned to IRQ 2
  956+    X       .iff
  957+    X     	    BLAB("\ndispatch: Warning, IRQ 2 pending with no vector assigned");
  958+    X       .endc		; ...INT2
  959+    X     	}
  960+    X     	if (jj&0x2000) {
  961+    X       .if true, ...INT3
  962+    X     	.macro VDF cond, name, softvec, intern, installer, notes, physical, default, comments
  963+    X     	.condit cond	
  964+    X        .iif idn,<name>,<INT3>,.mexit
  965+    X        .iif idn,<softvec>,<0>,.mexit
  966+    X        .if true, physical == INT3_LVL
  967+    X     	    if (!softvec) BLAB("\ndispatch: Warning, IRQ 3 pending \"'comments'\"");
  968+    X        .endc
  969+    X     	.endm
  970+    X     	.include phx_vecs.mac		; pickup all vectors assigned to IRQ 3
  971+    X       .iff
  972+    X     	    BLAB("\ndispatch: Warning, IRQ 3 pending with no vector assigned");
  973+    X       .endc		; ...INT3
  974+    X     	}
  975+    X     	if (jj&0x4000) {
  976+    X       .if true, ...INT4
  977+    X     	.macro VDF cond, name, softvec, intern, installer, notes, physical, default, comments
  978+    X     	.condit cond	
  979+    X        .iif idn,<name>,<INT4>,.mexit
  980+    X        .iif idn,<softvec>,<0>,.mexit
  981+    X        .if true, physical == INT4_LVL
  982+    X     	    if (!softvec) BLAB("\ndispatch: Warning, IRQ 4 pending \"'comments'\"");
  983+    X        .endc
  984+    X     	.endm
  985+    X     	.include phx_vecs.mac		; pickup all vectors assigned to IRQ 4
  986+    X       .iff
  987+    X     	    BLAB("\ndispatch: Warning, IRQ 4 pending with no vector assigned");
  988+    X       .endc		; ...INT4
  989+    X     	}
dispatch.c                               Atari Games Corp. macpp v9.12   "Oct 16 1997 13:26:41"


  990+    X     	if (jj&0x8000) {
  991+    X       .if true, ...INT5
  992+    X     	.macro VDF cond, name, softvec, intern, installer, notes, physical, default, comments
  993+    X     	.condit cond	
  994+    X        .iif idn,<name>,<INT5>,.mexit
  995+    X        .iif idn,<softvec>,<0>,.mexit
  996+    X        .if true, physical == INT5_LVL
  997+    X     	    if (!softvec) BLAB("\ndispatch: Warning, IRQ 5 pending \"'comments'\"");
  998+    X        .endc
  999+    X     	.endm
 1000+    X     	.include phx_vecs.mac		; pickup all vectors assigned to IRQ 5
 1001+    X       .iff
 1002+    X     	    BLAB("\ndispatch: Warning, IRQ 5 pending with no vector assigned");
 1003+    X       .endc		; ...INT5
 1004+    X     	}
 1005+    X         }
 1006+    X      .endc		; true, ANNOUNCE_BOOT_ACTIONS
 1007+    X     .endc		; defined, ANNOUNCE_BOOT_ACTIONS
 1008+    X         return;
 1009+    X     }
 1010+   (2)    .endc		; _DISPATCH_MAC_ == 0
  780               return;
  781           }
  782           
  783    (1)     .endc		; ...INT3
  784    (1)     .if true, ...INT4
  785           static void int4_irq(void) {
  786           	.macro VDF cond, name, softvec, intern, installer, notes, physical, default, comments
  787           	.condit cond	
  788             .iif idn,<name>,<INT4>,.mexit
  789             .iif idn,<softvec>,<0>,.mexit
  790             .if true, physical == INT4_LVL
  791               if (softvec) softvec();
  792             .endc
  793           	.endm
  794           	.include phx_vecs.mac		; pickup all vectors assigned to IRQ 4
    1+          ;/*		phx_vecs.mac
    2+          ; *
    3+          ; *		Copyright 1996 Atari Games Corporation
    4+          ; *	Unauthorized reproduction, adaptation, distribution, performance or 
    5+          ; *	display of this computer program or the associated audiovisual work
    6+          ; *	is strictly prohibited.
    7+          ; *
    8+          ; *	This file is processed by MACPP to produce dispatch.c and intvecs.h.
    9+          ; *
   10+          ; *	The definitions placed in intvecs.h declare virtual vector numbers
   11+          ; *	in the form of xxx_INTVEC and a cross reference table(s) so the
   12+          ; *	dispatcher can call the appropriate functions.
   13+          ; *
   14+          ; *	intvecs.h should be #include'd by any module that uses prc_set_vec().
   15+          ; */
   16+          ;
   17+          ; This file recursivley '.includes' itself to succesively build up the approprate
   18+          ; tables and functions in C and places the results in one of two files (the
   19+          ; first -out=file supplied on the MACPP command line is expected to be dispatch.c
   20+          ; and the second -out=file is expected to be intvecs.h and the third is expected to
   21+          ; be /dev/null). If you don't speak fluent MACPP, then you probably shouldn't be
dispatch.c                               Atari Games Corp. macpp v9.12   "Oct 16 1997 13:26:41"


   22+          ; changing anything in this file other than the VDF table listed below.
   23+          ;
   24+   (2)    .if not_defined, _DISPATCH_MAC_		;1 +++++
   25+    X     _DISPATCH_MAC_ == 0			;2 Don't move ...
   26+    X     OUTPUT_LANG == 5 ;LANG_NONE		;3 ... or change ... 
   27+    X     	.outfile 2			;4 ... anything on ...
   28+    X     	.include config.mac		;5 ... these ...
   29+    X     	.outfile 0			;6 ... nine  ...
   30+   (2)    .endc					;7 ... lines ...
   31+   (2)    .if true, (_DISPATCH_MAC_&1) != 0	;8
   32+   (3)     .if true, 0				;9 -----
   33+          
   34+    X     You are free to add or remove entries from this table according to your
   35+    X     requirements. There are 10 fields used on each line in this table. The
   36+    X     description of each field follows:
   37+          
   38+    X     Field 1 = macro call
   39+          
   40+    X     It must always be the keyword VDF (case is not significant).
   41+          
   42+    X     Field 2 = condition
   43+          
   44+    X     This is a dual operand field, so the two operands together must be enclosed in
   45+    X     <>'s. The first operand is one of T, F, D or N representing True, False,
   46+    X     Defined or Not_defined respectively. Case is significant, use uppercase only
   47+    X     please. For the conditions T or F the second operand must be an expression
   48+    X     which must resolve to non-$0 (True) or $0 (False) in order for the macro
   49+    X     to be processed (else it is ignored). The expression can contain no embedded
   50+    X     spaces. For the conditions D and N, the second operand must only be a symbol
   51+    X     which must be Defined or Not-defined respectively in order for the macro to be
   52+    X     processed. Some short cut expressions have been preprocessed to make using the
   53+    X     expressions a little more concise. These are:
   54+          
   55+    X     	PHX = not $0 if HOST_BOARD == PHOENIX
   56+    X     	PAD = not $0 if HOST_BOARD == PHOENIX_AD
   57+    X     	FLG = not $0 if HOST_BOARD == FLAGSTAFF
   58+    X     	SEA = not $0 if HOST_BOARD == SEATTLE
   59+    X     	VEG = not $0 if HOST_BOARD == VEGAS
   60+          
   61+    X     Field 3 = vector name
   62+          
   63+    X     The NAME field is the name of the virtual vector. An _INTVEC will be appended
   64+    X     to it in the C definitions in intvecs.h, but otherwise the name is unmolested.
   65+    X     Case is significant only if you want it to be. The R3K/R4K has an option where
   66+    X     a number of vectors are maintained in an array of pointers rather than each
   67+    X     one having its own name. The index into the array is same as the number
   68+    X     returned in the processor's CAUSE register for that particluar interrupt. This
   69+    X     procedure is done simply for performance reasons. The option is selected by
   70+    X     using a 0 for this field and using an installer function with the vector index
   71+    X     as the parameter to the installer.
   72+          
   73+    X     Field 4 = Vector pointer
   74+          
   75+    X     This field identifies the name of a variable in BSS that contains a pointer
   76+    X     to the function to call at interrupt (or will be set by the prc_set_vec()
   77+    X     function). This is the name of the "soft" or logical vector and is either
   78+    X     declared in dispatch.c or externally according to the INT/EXT field described
dispatch.c                               Atari Games Corp. macpp v9.12   "Oct 16 1997 13:26:41"


   79+    X     next.
   80+          
   81+    X     Field 5 = INTernal or EXTernal vector
   82+          
   83+    X     This field contains the keywords INT, EXT, VINT or VEXT identifying the vector
   84+    X     in field 4 as being defined INTernally, EXTernally, Volatile INTernally or
   85+    X     Volatile Externally to dispatch.c respectively.
   86+          
   87+    X     Field 6 = name of vector installer
   88+          
   89+    X     This field identifies the name of a function that prc_set_vec() will call to
   90+    X     actually install the vector or 0 if there is no special stuff that needs to
   91+    X     be performed during vector installation.
   92+          
   93+    X     Field 7 = Notes for the installer.
   94+          
   95+    X     The Notes field is a parameter that is passed to the installer if there is one.
   96+          
   97+    X     Field 8 = Physical vector attachment.
   98+          
   99+    X     A dispatch routine is constructed for each of the 4 XBUS interrupts and for each of
  100+    X     the 6 CPU interrupts.  This field instructs phx_vecs.mac into which of the XBUS or
  101+    X     INTx dispatchers a caller to this vector belongs.  If this vector is not associated
  102+    X     with an XBUS or an INTx interrupt, it needs to be -1.  Place the interrupt routines
  103+    X     in this table in the order in which you want them executed.
  104+          
  105+    X     Field 9 = Default function.
  106+          
  107+    X     Name of default routine to install in the vector, or 0 if none.  phx_vecs.mac builds
  108+    X     a function called prc_init_vecs(void) which, when called, will perform a string of
  109+    X     prc_set_vec()'s for all the vectors having this field non-zero.  After the vectors
  110+    X     have been loaded, prc_init_vecs(void) will map the phoenix and galileo interrupts as
  111+    X     specified in phoenix.mac.
  112+          
  113+    X     Field 10 = Comments.
  114+          
  115+    X     The Comments field is placed on selected lines in intvecs.h and/or dispatch.c
  116+    X     as simple 'C' comments.
  117+          
  118+   (3)     .endc				; Don't move this line
  119+          ;
  120+          ;   Condit	Name	   Vector   I/E	Installer   Notes      Phys	Default	Comments
  121+          ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  122+          VDF <T,1>	GAMEVB,	   gameint, EXT	0,          0,		-1,	0,	< post-wierdness Vblank >
  123+          VDF <T,1>	MS4,       ms4vec,  EXT	0,          0,		-1,	0,	< 4 Millisecond timer >
  124+          VDF <T,1>	PRC_DELAY, prc_delay_vec, EXT 0,    0,		-1,	sst_prc_delay, < prc_delay soft vector >
  125+          VDF <T,1>	PRC_SET_IPL, set_ipl_vec, INT 0,    0,		-1,	0,	< prc_set_ipl soft vector >
  126+          VDF <T,1>	SAVE,      savintp, EXT 0,          0,		-1,	0,	< context save soft vector >
  127+          VDF <T,1>	RESTORE,   restintp,EXT 0,          0,		-1,	0,	< context restore soft vector >
  128+          VDF <T,1>	SW0,	   0,	    INT hwvinst,    VN_IRQ0,    -1,	0,	< Software interrupt 0 >
  129+          VDF <T,1>	SW1,	   0,       INT hwvinst,    VN_IRQ1,    -1,	0,	< Software interrupt 0 >
  130+          VDF <T,1>	INT0,	   0,       INT hwvinst,    VN_IRQ2,    -1,	int0_irq, < Hardware interrupt 0 >
  131+          VDF <T,1>	INT1,	   0,	    INT hwvinst,    VN_IRQ3,    -1,	int1_irq, < Hardware interrupt 1 >
  132+          VDF <T,PHX>	INT2,	   0,	    INT hwvinst,    VN_IRQ4,    -1,	int2_irq, < Hardware interrupt 2 >
  133+          VDF <T,1>	INT3,	   0,       INT hwvinst,    VN_IRQ5,    -1,	int3_irq, < Hardware interrupt 3 >
  134+          VDF <T,1>	INT4,	   0,	    INT hwvinst,    VN_IRQ6,    -1,	int4_irq, < Hardware interrupt 4 >
  135+          VDF <T,1>	INT5,	   0,	    INT hwvinst,    VN_IRQ7,    -1,	int5_irq, < Hardware interrupt 5 >
dispatch.c                               Atari Games Corp. macpp v9.12   "Oct 16 1997 13:26:41"


  136+          VDF <T,1>	TLBMOD,	   0,	    INT hwvinst,    VN_TLBM,    -1,	0,	< TLB modification >
  137+          VDF <T,1>	TLBLOAD,   0,	    INT hwvinst,    VN_TLBL,    -1,	0,	< TLB miss on I or D fetch >
  138+          VDF <T,1>	TLBSTORE,  0,	    INT hwvinst,    VN_TLBS,    -1,	0,	< TLB miss on store >
  139+          VDF <T,1>	ADDRERRL,  0,	    INT hwvinst,    VN_ADDRL,   -1,	0,	< Address error on I or D fetch >
  140+          VDF <T,1>	ADDRERRS,  0,	    INT hwvinst,    VN_ADDRS,   -1,	0,	< Address error on store >
  141+          VDF <T,1>	BUSERRI,   0,	    INT hwvinst,    VN_BUSERRI, -1,	0,	< Bus error on I-fetch >
  142+          VDF <T,1>	BUSERRD,   0,	    INT hwvinst,    VN_BUSERRD, -1,	0,	< Bus error on D-fetch >
  143+          VDF <T,1>	SYSCALL,   0,       INT hwvinst,    VN_SYSCALL, -1,	0,	< SYSCALL instruction >
  144+          VDF <T,1>	BREAK,     0,       INT hwvinst,    VN_BREAK,   -1,	0,	< Breakpoint instruction >
  145+          VDF <T,1>	RESERV,    0,       INT hwvinst,    VN_RESERV,  -1,	0,	< Reserved instruction >
  146+          VDF <T,1>	COPROC,    0,       INT hwvinst,    VN_COPROC,  -1,	0,	< Coprocessor unusable >
  147+          VDF <T,1>	OVRFLOW,   0,       INT hwvinst,    VN_OVERFL,  -1,	0,	< Integer Arithmetic Overflow >
  148+          VDF <T,1>	TRAP,      0,       INT hwvinst,    VN_TRAPV,   -1,	0,	< TRAP exception >
  149+          VDF <T,1>	FLOAT,     0,       INT hwvinst,    VN_FPE,     -1,	0,	< FLoating point exception >
  150+          VDF <T,1>	TIMER,	   timervec, INT 0,	    0,          -1,	0,	< Soft Timer interrupt >
  151+          VDF <T,1>	TIMERPLL,  tpllvec, VEXT 0,	    0,		-1,	0,	<Adjust 1MS timer>
  152+          VDF <T,1>	GAMEFRAME, framevec,INT 0,	    0,		-1,	0,	< Frame complete >
  153+   (3)    .if true, PHX
  154+    X     VDF <D,NET_LVL>	NET,       netintp, INT 0,          0,		NET_LVL,0,	< network int soft vector >
  155+    X     VDF <D,XBUS>	XBUS,	   xbusintp, INT pvinst,    XBUS_NOTES,	XBUS_LVL,xbus_irq, < Any XBUS interrupt >
  156+    X     VDF <T,XS0>	XS0,       xs0intp, INT pvinst,	    XS0_NOTES,	XS0_LVL,0,	< Expansion Slot 0 interrupt >
  157+    X     VDF <T,XS1>	XS1,       xs1intp, INT pvinst,	    XS1_NOTES,	XS1_LVL,0,	< Expansion Slot 1 interrupt >
  158+    X     VDF <T,XS2>	XS2,       xs2intp, INT pvinst,	    XS2_NOTES,	XS2_LVL,0,	< Expansion Slot 2 interrupt >
  159+    X     VDF <T,XS3>	XS3,       xs3intp, INT pvinst,	    XS3_NOTES,	XS3_LVL,0,	< Expansion Slot 3 interrupt >
  160+    X     VDF <T,MIO>	MIO,       miointp, INT pvinst,	    MIO_NOTES,	MIO_LVL,0,	< Miscellaneous I/O interrupt >
  161+    X     VDF <T,CU1>	CU1,       cu1intp, INT pvinst,	    CU1_NOTES,	CU1_LVL,0,	< Combo UART 1 interrupt >
  162+    X     VDF <T,CU2>	CU2,       cu2intp, INT pvinst,	    CU2_NOTES,	CU2_LVL,0,	< Combo UART 2 interrupt >
  163+    X     VDF <T,CPP>	CPP,       cppintp, INT pvinst,	    CPP_NOTES,	CPP_LVL,0,	< Combo Parallel Port interrupt >
  164+    X     VDF <T,PCA>	PCA,       pcaintp, INT pvinst,	    PCA_NOTES,	PCA_LVL,0,	< PCI A interrupt >
  165+    X     VDF <T,PCB>	PCB,       pcbintp, INT pvinst,	    PCB_NOTES,	PCB_LVL,0,	< PCI B interrupt >
  166+    X     VDF <T,PCC>	PCC,       pccintp, INT pvinst,	    PCC_NOTES,	PCC_LVL,0,	< PCI C interrupt >
  167+    X     VDF <T,VSY>	VSY,       vsyintp, INT pvinst,	    VSY_NOTES,	VSY_LVL,0,	< PCI D (VSYNC) interrupt >
  168+    X     VDF <T,IDE>	IDE,	   ideintp, INT pvinst,	    IDE_NOTES,	IDE_LVL,0,	< IDE interrupt >
  169+    X     VDF <T,IOA>	IOA,	   ioaintp, INT pvinst,	    IOA_NOTES,	IOA_LVL,ioa_irq,< I/O Asic interrupt >
  170+    X     VDF <T,ADC>	ADC,	   adcintp, INT pvinst,	    ADC_NOTES,	ADC_LVL,0,	< A/D Converter interrupt >
  171+    X     VDF <D,SND_I>	CAGE,      cagevec, INT 0,          0,		CAGE_LVL,aud_irq, < CAGE interrupt >
  172+   (3)    .endc
  173+   (3)    .if true, PAD || FLG || SEA || VEG
  174+          ;VDF <T,1>	IOA,	   0,	    INT hwvinst,    VN_IRQ3,	-1,	0,	< I/O Asic interrupt >
  175+          VDF <T,1>	IDE,	   0,	    INT hwvinst,    VN_IRQ4,    -1,	0,	< IDE interrupt >
  176+          VDF <T,EXP>	EXP,       expintp, INT pvinst,	    EXP_NOTES,	EXP_LVL,0,	< Expansion Slot interrupt >
  177+   (4)     .if true, PAD || SEA
  178+          VDF <T,NSS>	NSS,	   nssintp, INT pvinst,	    NSS_NOTES,  NSS_LVL,0,	< NSS/Hi-Link interrupt>
  179+   (4)     .endc
  180+   (4)     .if true, FLG
  181+    X     VDF <T,ETH>	ETH,	   ethintp, INT pvinst,     ETH_NOTES,  ETH_LVL,0,	< ethernet interrupt >
  182+    X     VDF <D,SND_I>	CAGE,	   cagevec, INT ioainst,    CAGE_NOTES, CAGE_LVL,aud_irq, < CAGE interrupt >
  183+   (4)     .endc
  184+          VDF <T,WD1>	WD1,	   wd1intp, INT pvinst,	    WD1_NOTES,  WD1_LVL,0,	< Widget interrupt 1>
  185+          VDF <T,PCI>	PCI,       pciintp, INT pvinst,	    PCI_NOTES,	PCI_LVL,0,	< PCI interrupt >
  186+          VDF <T,ADC>	ADC,	   adcintp, INT pvinst,	    ADC_NOTES,	ADC_LVL,0,	< A/D Converter interrupt >
  187+          VDF <T,WD2>	WD2,	   wd2intp, INT pvinst,	    WD2_NOTES,  WD2_LVL,0,	< Widget interrupt 2>
  188+          VDF <T,DBG>	DBG,	   dbgintp, INT pvinst,	    DBG_NOTES,	DBG_LVL,0,	< Debug switch interrupt >
  189+          VDF <T,VSY>	VSY,	   vsyintp, INT pvinst,	    VSY_NOTES,	VSY_LVL,0,	< VSYNC interrupt >
  190+   (3)    .endc
  191+          VDF <T,GAL>	GAL,	   0,       INT gvinst,	    GAL_NOTES,  GAL_LVL,galileoint, < Any Galileo Error Interrupt >
  192+          VDF <T,MOE>	MOE,	   moeintp, INT gvinst,	    MOE_NOTES,	MOE_LVL,0,	< Galileo MemOut >
dispatch.c                               Atari Games Corp. macpp v9.12   "Oct 16 1997 13:26:41"


  193+          VDF <T,DOE>	DOE,	   doeintp, INT gvinst,	    DOE_NOTES,	DOE_LVL,0,	< Galileo DMAOut >
  194+          VDF <T,COE>	COE,	   coeintp, INT gvinst,	    COE_NOTES,	COE_LVL,0,	< Galileo CPUOut >
  195+          VDF <T,DM0>	DM0,	   dm0intp, INT gvinst,	    DM0_NOTES,	DM0_LVL,0,	< Galileo DMA0Comp >
  196+          VDF <T,DM1>	DM1,	   dm1intp, INT gvinst,	    DM1_NOTES,	DM1_LVL,0,	< Galileo DMA1Comp >
  197+          VDF <T,DM2>	DM2,	   dm2intp, INT gvinst,	    DM2_NOTES,	DM2_LVL,0,	< Galileo DMA2Comp >
  198+          VDF <T,DM3>	DM3,	   dm3intp, INT gvinst,	    DM3_NOTES,	DM3_LVL,0,	< Galileo DMA3Comp >
  199+          VDF <T,TM0>	TM0,	   tm0intp, INT gvinst,	    TM0_NOTES,	TM0_LVL,0,	< Galileo T0Exp >
  200+          VDF <T,TM1>	TM1,	   tm1intp, INT gvinst,	    TM1_NOTES,	TM1_LVL,0,	< Galileo T1Exp >
  201+          VDF <T,TM2>	TM2,	   tm2intp, INT gvinst,	    TM2_NOTES,	TM2_LVL,0,	< Galileo T2Exp >
  202+          VDF <T,TM3>	TM3,	   tm3intp, INT gvinst,	    TM3_NOTES,	TM3_LVL,cputimerint, < Galileo T3EXP timer interrupt >
  203+          VDF <T,MRE>	MRE,	   mreintp, INT gvinst,	    MRE_NOTES,	MRE_LVL,0,	< Galileo MasRdErr >
  204+          VDF <T,SWE>	SWE,	   sweintp, INT gvinst,	    SWE_NOTES,	SWE_LVL,0,	< Galileo SlvWrErr >
  205+          VDF <T,MWE>	MWE,	   mweintp, INT gvinst,	    MWE_NOTES,	MWE_LVL,0,	< Galileo MasWrErr >
  206+          VDF <T,SRE>	SRE,	   sreintp, INT gvinst,	    SRE_NOTES,	SRE_LVL,0,	< Galileo SlvRdErr >
  207+          VDF <T,AEP>	AEP,	   aepintp, INT gvinst,	    AEP_NOTES,	AEP_LVL,0,	< Galileo AddrErr >
  208+          VDF <T,MEP>	MEP,	   mepintp, INT gvinst,	    MEP_NOTES,	MEP_LVL,0,	< Galileo MemErr >
  209+          VDF <T,MAS>	MAS,	   masintp, INT gvinst,	    MAS_NOTES,	MAS_LVL,0,	< Galileo MasAbort >
  210+          VDF <T,TAR>	TAR,	   tarintp, INT gvinst,	    TAR_NOTES,	TAR_LVL,0,	< Galileo TarAbort >
  211+          VDF <T,RTY>	RTY,	   rtyintp, INT gvinst,	    RTY_NOTES,	RTY_LVL,0,	< Galileo RetryCtr >
  212+          VDF <T,PC0>	PC0,	   pc0intp, INT gvinst,	    PC0_NOTES,	PC0_LVL,0,	< Galileo PCI Interrupt >
  213+          VDF <T,PC1>	PC1,	   pc1intp, INT gvinst,	    PC1_NOTES,	PC1_LVL,0,	< Galileo PCI Interrupt >
  214+          VDF <T,PC2>	PC2,	   pc2intp, INT gvinst,	    PC2_NOTES,	PC2_LVL,0,	< Galileo PCI Interrupt >
  215+          VDF <T,PC3>	PC3,	   pc3intp, INT gvinst,	    PC3_NOTES,	PC3_LVL,0,	< Galileo PCI Interrupt >
  216+          VDF <D,UART_LVL> UART,	   uartintp,INT ioainst,    UART_NOTES,	UART_LVL,0,	< I/O ASIC UART interrupts >
  217+          VDF <D,SND_LVL>	SND,	   sndintp, INT ioainst,    SND_NOTES,	SND_LVL, 0,	< I/O ASIC Sound interrupts >
  218+          VDF <D,MC_LVL>	MC,	   mcintp,  INT ioainst,    MC_NOTES,	MC_LVL,	0,	< I/O ASIC Microcontroller interrupt >
  219+          ;
  220+   (2)    .endc			; (_DISPATCH_MAC_&1) != 0 *** DON'T MOVE THIS LINE EITHER ***
  221+          ;
  222+          ;+++++++ From here on, there are few user servicable parts inside. ++++
  223+          ;
  224+          ; This is sortof how it works:
  225+          ; The first pass through, _DISPATCH_MAC_ will be 0 (set above by the .if not_defined).
  226+          ; First the copyright boilerplate is inserted into both output files and the macro VDF
  227+          ; is defined to create externs. Some struct definitions and unique externs are depositied
  228+          ; into the .h file. Next _DISPATCH_MAC_ is set to 1 and this file is .included
  229+          ; again. This will cause MACPP to read the VDF table above and output the appropriate
  230+          ; information in the .h file but ignore the rest of the file. The VDF macro is redefined,
  231+          ; and the procedure is repeated causing the creation of different items according to what
  232+          ; is needed. Once the whole .h file is built, the procedure repeats for the building of the
  233+          ; .c file.
  234+          ;
  235+   (2)    .if true, _DISPATCH_MAC_ == 0		; First (main) pass
  236+    X      PHX == 0
  237+    X      PAD == 0
  238+    X      FLG == 0
  239+    X      SEA == 0
  240+    X      VEG == 0
  241+    X      .iif true, HOST_BOARD == PHOENIX, PHX == 1 ;set the appropriate ones true as desired
  242+    X      .iif true, HOST_BOARD == PHOENIX_AD, PAD == 1 ;set the appropriate ones true as desired
  243+    X      .iif true, HOST_BOARD == FLAGSTAFF, FLG == 1 ;set the appropriate ones true as desired
  244+    X      .iif true, HOST_BOARD == SEATTLE, SEA == 1 ;set the appropriate ones true as desired
  245+    X      .iif true, HOST_BOARD == VEGAS, VEG == 1 ;set the appropriate ones true as desired
  246+          ;
  247+    X     	.macro .condit flag,exp		; The .condit macro does an expression test ...
  248+    X     	.if identical,<flag>,<T>
  249+    X     		.iif false,exp,.mexit 10 ; ... and aborts higher level macros if false
dispatch.c                               Atari Games Corp. macpp v9.12   "Oct 16 1997 13:26:41"


  250+    X     		.mexit
  251+    X     	.endc
  252+    X     	.if identical,<flag>,<F>
  253+    X     		.iif true,exp,.mexit 10	; ... etc.
  254+    X     		.mexit
  255+    X     	.endc
  256+    X     	.if identical,<flag>,<D>
  257+    X     		.iif not_defined,exp,.mexit 10
  258+    X     		.mexit
  259+    X     	.endc
  260+    X     	.if identical,<flag>,<N>
  261+    X     		.iif defined,exp,.mexit 10
  262+    X     		.mexit
  263+    X     	.endc
  264+    X     	.endm
  265+          ;	
  266+    X     	.macro boilerplate file_name
  267+    X     /*		file_name
  268+    X      *
  269+    X      *		Copyright 1996 Atari Games Corporation
  270+    X      *	Unauthorized reproduction, adaptation, distribution, performance or 
  271+    X      *	display of this computer program or the associated audiovisual work
  272+    X      *	is strictly prohibited.
  273+    X      *
  274+    X      * ++++++ WARNING WARNING WARNING WARNING WARNING +++++
  275+    X      * This file is machine generated. Any changes you put in here will be lost
  276+    X      * the next time phx_vecs.mac is touched. You need to make your changes to
  277+    X      * phx_vecs.mac instead of this file.
  278+    X      */
  279+    X     	.endm
  280+    X     	boilerplate dispatch.c
  281+    X     	.outfile	1		;The externs go into the .h file
  282+    X     	boilerplate intvecs.h
  283+    X     #if !defined(_INTVECS_H_)
  284+    X     #define _INTVECS_H_
  285+          
  286+    X     struct irq_tab {
  287+    X     	void 	(**softvec)();
  288+    X     	void    (*(*installer)(const struct irq_tab *, void(*new)()))();
  289+    X     	int	notes;
  290+    X     };
  291+          ;
  292+    X     	.macro VDF cond, name, softvec, intern, installer, notes, physical, default, comments
  293+    X     	.condit cond	
  294+    X      .if dif,<softvec>,<0>
  295+    X       ...1 == 0
  296+    X       .iif idn,<intern>,<VINT>,...1 == 1
  297+    X       .iif idn,<intern>,<VEXT>,...1 == 1
  298+    X       .if true, ...1
  299+    X     extern	void (* volatile softvec)();	/* comments */
  300+    X       .iff
  301+    X     extern  void (*softvec)();	/* comments */
  302+    X       .endc
  303+    X      .endc
  304+    X     	.endm
  305+          ;
  306+    X     	_DISPATCH_MAC_ == 1		;next time we process the IRQ table
dispatch.c                               Atari Games Corp. macpp v9.12   "Oct 16 1997 13:26:41"


  307+    X     	.include phx_vecs.mac		;Make the externs
  308+          
  309+    X     enum vecs {
  310+    X     	.macro VDF cond, name, softvec, intern, installer, notes, physical, default, comments
  311+    X     	.condit cond	
  312+    X         name'_INTVEC,
  313+    X     	.endm
  314+    X     	.include phx_vecs.mac		;Make the enums
  315+    X         N_INTVECS
  316+    X     };
  317+          
  318+    X     void (*prc_set_vec (unsigned int vecnum, void (*routine)() ))();
  319+    X     void prc_init_vecs(void);		/* set the default vectors */
  320+          ;
  321+          ; Add a prototype for an as yet unused function
  322+    X     .if true, 0
  323+          
  324+    X     /*		prc_set_vecp(which, what)
  325+    X      *	Sets a special vector for the interrupt identified by <which>
  326+    X      *	to call the routine specified by <what>. <what> is
  327+    X      *	a struct that contains both a pointer to the code
  328+    X      *	to execute and an optional pointer to the private
  329+    X      *	variables for that routine. This is a change from the
  330+    X      *	behavior of prc_set_vec, and is intended to allow
  331+    X      *	multiple incarnations of a given device to share code.
  332+    X      */
  333+          
  334+    X     struct opaque;
  335+    X     extern struct VECP_vector {
  336+    X         void (*function)(struct opaque *);	/* Who you gonna call */
  337+    X         struct opaque *cookie;		/* a magic cookie to hand him */
  338+    X     } prc_set_vecp (
  339+    X         int __which,			/* one of xxx_INTVEC */
  340+    X         struct IRQ_vector __what		/* BY VALUE!!! */
  341+    X     );
  342+    X     .endc
  343+    X     #endif		/* _INTVECS_H_ */
  344+          ;
  345+          ; At this point, we have completed all processing of the .h file
  346+          ; so switch back to the .c file
  347+          ;
  348+    X     	.outfile	0		;switch back to dispatch.c
  349+          ;
  350+    X     #include <config.h>			/* begining of dispatch.c */
  351+    X     #include <os_proto.h>
  352+    X     #include <intvecs.h>
  353+          
  354+    X     #ifndef BLABF
  355+    X     # define BLABF(x)
  356+    X     #endif
  357+          
  358+    X     #ifndef BLAB
  359+    X     # define BLAB(x)
  360+    X     #endif
  361+          
  362+    X      .if true, 1
  363+    X     	.macro VDF cond, name, softvec, intern, installer, notes, physical, default, comments
dispatch.c                               Atari Games Corp. macpp v9.12   "Oct 16 1997 13:26:41"


  364+    X     	.condit cond	
  365+    X       .iif idn,<name>,<XBUS0>,.mexit
  366+    X       .iif idn,<name>,<XBUS1>,.mexit
  367+    X       .iif idn,<name>,<XBUS2>,.mexit
  368+    X       .iif idn,<name>,<XBUS3>,.mexit
  369+    X       .iif idn,<name>,<INT0>,.mexit
  370+    X       .iif idn,<name>,<INT1>,.mexit
  371+    X       .iif idn,<name>,<INT2>,.mexit
  372+    X       .iif idn,<name>,<INT3>,.mexit
  373+    X       .iif idn,<name>,<INT4>,.mexit
  374+    X       .iif idn,<name>,<INT5>,.mexit
  375+    X       .if true, PHX
  376+    X         .if true, physical == XBUS0_LVL
  377+    X     	  ...XBUS0 == ...XBUS0 + 1
  378+    X     	  .mexit
  379+    X         .endc
  380+    X         .if true, physical == XBUS1_LVL
  381+    X     	  ...XBUS1 == ...XBUS1 + 1
  382+    X     	  .mexit
  383+    X         .endc
  384+    X         .if true, physical == XBUS2_LVL
  385+    X     	  ...XBUS2 == ...XBUS2 + 1
  386+    X     	  .mexit
  387+    X         .endc
  388+    X         .if true, physical == XBUS3_LVL
  389+    X     	  ...XBUS3 == ...XBUS3 + 1
  390+    X     	  .mexit
  391+    X         .endc
  392+    X       .endc
  393+    X       .if true, physical == INT0_LVL
  394+    X         	...INT0 == ...INT0 + 1
  395+    X     	.mexit
  396+    X       .endc
  397+    X       .if true, physical == INT1_LVL
  398+    X         	...INT1 == ...INT1 + 1
  399+    X        .if true, PAD || FLG || SEA || VEG
  400+    X     	...IOA == ...IOA + 1
  401+    X         .if ndf, notes
  402+    X     #define notes IO_MAIN_GLOBAL_INT
  403+    X         .endc
  404+    X        .endc
  405+    X     	.mexit
  406+    X       .endc
  407+    X       .if true, physical == INT2_LVL
  408+    X         	...INT2 == ...INT2 + 1
  409+    X     	.mexit
  410+    X       .endc
  411+    X       .if true, physical == INT3_LVL
  412+    X         	...INT3 == ...INT3 + 1
  413+    X     	.mexit
  414+    X       .endc
  415+    X       .if true, physical == INT4_LVL
  416+    X         	...INT4 == ...INT4 + 1
  417+    X     	.mexit
  418+    X       .endc
  419+    X       .if true, physical == INT5_LVL
  420+    X         	...INT5 == ...INT5 + 1
dispatch.c                               Atari Games Corp. macpp v9.12   "Oct 16 1997 13:26:41"


  421+    X     	.mexit
  422+    X       .endc
  423+    X       .if true, physical == IOASIC_LVL
  424+    X         	...IOA == ...IOA + 1
  425+    X        .if ndf, notes
  426+    X     #define notes IO_MAIN_GLOBAL_INT
  427+    X        .endc
  428+    X     	.mexit
  429+    X       .endc
  430+    X     	.endm
  431+    X     ...XBUS0 == 0
  432+    X     ...XBUS1 == 0
  433+    X     ...XBUS2 == 0
  434+    X     ...XBUS3 == 0
  435+    X     ...INT0 == 0
  436+    X     ...INT1 == 0
  437+    X     ...INT2 == 0
  438+    X     ...INT3 == 0
  439+    X     ...INT4 == 0
  440+    X     ...INT5 == 0
  441+    X     ...IOA == 0
  442+    X     	.include phx_vecs.mac	; count vectors requiring dispatch
  443+    X      .endc
  444+          ; 
  445+    X     .macro VDF cond, name, softvec, intern, installer, notes, physical, default, comments
  446+    X      .condit cond	
  447+    X      .if dif,<softvec>,<0>
  448+    X       .if idn,<intern>,<INT>
  449+    X     void (*softvec)();	/* comments */
  450+    X       .endc
  451+    X       .if idn,<intern>,<VINT>
  452+    X     void (* volatile softvec)();	/* comments */
  453+    X       .endc
  454+    X      .endc
  455+    X      .if dif,<default>,<0>
  456+    X       .if idn,<name>,<INT0>
  457+    X        .if true, ...INT0
  458+    X     static void 'default'(void);	/* comments */
  459+    X        .endc
  460+    X        .mexit
  461+    X       .endc
  462+    X       .if idn,<name>,<INT1>
  463+    X        .if true, ...INT1
  464+    X     static void 'default'(void);	/* comments */
  465+    X        .endc
  466+    X        .mexit
  467+    X       .endc
  468+    X       .if idn,<name>,<INT2>
  469+    X        .if true, ...INT2
  470+    X     static void 'default'(void);	/* comments */
  471+    X        .endc
  472+    X        .mexit
  473+    X       .endc
  474+    X       .if idn,<name>,<INT3>
  475+    X        .if true, ...INT3
  476+    X     static void 'default'(void);	/* comments */
  477+    X        .endc
dispatch.c                               Atari Games Corp. macpp v9.12   "Oct 16 1997 13:26:41"


  478+    X        .mexit
  479+    X       .endc
  480+    X       .if idn,<name>,<INT4>
  481+    X        .if true, ...INT4
  482+    X     static void 'default'(void);	/* comments */
  483+    X        .endc
  484+    X        .mexit
  485+    X       .endc
  486+    X       .if idn,<name>,<INT5>
  487+    X        .if true, ...INT5
  488+    X     static void 'default'(void);	/* comments */
  489+    X        .endc
  490+    X        .mexit
  491+    X       .endc
  492+    X       .if idn,<name>,<INT6>
  493+    X        .if true, ...INT6
  494+    X     static void 'default'(void);	/* comments */
  495+    X        .endc
  496+    X        .mexit
  497+    X       .endc
  498+    X       .if idn,<name>,<INT7>
  499+    X        .if true, ...INT7
  500+    X     static void 'default'(void);	/* comments */
  501+    X        .endc
  502+    X        .mexit
  503+    X       .endc
  504+    X       .if true, PHX
  505+    X        .if idn,<name>,<XBUS>
  506+    X         .if true, ...XBUS0|...XBUS1|...XBUS2|...XBUS3
  507+    X     static void 'default'(void);
  508+    X         .endc
  509+    X         .mexit
  510+    X        .endc
  511+    X        .if idn,<name>,<XBUS0>
  512+    X         .if true, ...XBUS0
  513+    X     static void 'default'(void);
  514+    X         .endc
  515+    X         .mexit
  516+    X        .endc
  517+    X        .if idn,<name>,<XBUS1>
  518+    X         .if true, ...XBUS1
  519+    X     static void 'default'(void);
  520+    X         .endc
  521+    X         .mexit
  522+    X        .endc
  523+    X        .if idn,<name>,<XBUS2>
  524+    X         .if true, ...XBUS2
  525+    X     static void 'default'(void);
  526+    X         .endc
  527+    X         .mexit
  528+    X        .endc
  529+    X        .if idn,<name>,<XBUS3>
  530+    X         .if true, ...XBUS3
  531+    X     static void 'default'(void);
  532+    X         .endc
  533+    X         .mexit
  534+    X        .endc
dispatch.c                               Atari Games Corp. macpp v9.12   "Oct 16 1997 13:26:41"


  535+    X       .endc			; PHX
  536+    X       .if idn,<name>,<IOA>
  537+    X        .if true, ...IOA
  538+    X     static void 'default'(void);
  539+    X        .endc
  540+    X        .mexit
  541+    X       .endc
  542+    X     extern void 'default'(void);
  543+    X      .endc
  544+    X     .endm
  545+    X     	.include phx_vecs.mac		;Declare the non-extern vectors
  546+          ;
  547+    X      .if true, ((PROCESSOR&-16) == MIPS3000) || ((PROCESSOR&-16) == MIPS4000)
  548+    X     static void (*hwvinst(const struct irq_tab *, void (*)()))();
  549+    X      .endc
  550+          ;
  551+    X     .if df, PHOENIX_INTCTL_MASK
  552+    X     static void (*pvinst(const struct irq_tab *, void (*)()))();
  553+    X     .endc
  554+          ;
  555+    X     .if df, GALILEO_INTCTL_MASK
  556+    X     static void (*gvinst(const struct irq_tab *, void (*)()))();
  557+    X     .endc
  558+          ;
  559+    X     .if true, ...IOA
  560+    X     static void (*ioainst(const struct irq_tab *, void (*)()))();
  561+    X     .endc
  562+          ;
  563+    X     static const struct irq_tab irq_inits[] = {
  564+    X     	.macro VDF cond, name, softvec, intern, installer, notes, physical, default, comments
  565+    X     	.condit cond	
  566+    X      .if dif,<softvec>,<0>
  567+    X      { (void (**)())&softvec, installer, notes },	/* comments */
  568+    X      .iff
  569+    X      { 0, installer, notes },	/* comments */
  570+    X      .endc
  571+    X     	.endm
  572+    X     	.include phx_vecs.mac		;Build the irq_inits array
  573+    X      { 0, 0, 0} };
  574+          ;
  575+    X     .if true, ((PROCESSOR&-16) == MIPS3000) || ((PROCESSOR&-16) == MIPS4000)
  576+          
  577+    X     extern void (*ramv_tbl[])();
  578+          
  579+    X     static void (*hwvinst(const struct irq_tab *it, void (*new)()))() {
  580+    X         int indx;
  581+    X         void (*old_rtn)();
  582+          
  583+    X         indx = it->notes;
  584+    X         if (indx >= VN_MAX) return 0;
  585+    X         old_rtn = ramv_tbl[indx];
  586+    X         ramv_tbl[indx] = new;
  587+    X         return old_rtn;
  588+    X     }
  589+          
  590+    X      .if df, PHOENIX_INTCTL_MASK
  591+    X     static void (*pvinst(const struct irq_tab *it, void (*new)()))() {
dispatch.c                               Atari Games Corp. macpp v9.12   "Oct 16 1997 13:26:41"


  592+          
  593+    X         if (it->notes) {
  594+    X     	BLABF(("\ndispatch: Adding 0x%08lX to main INTCTL (0x%08lX)...", it->notes, *(VU32*)INTCTL_IE));
  595+    X     	*((VU32 *)(INTCTL_IE)) |= it->notes;
  596+    X         }
  597+    X         return 0;
  598+    X     }
  599+    X      .endc
  600+          
  601+    X      .if df, GALILEO_INTCTL_MASK
  602+    X     static void (*gvinst(const struct irq_tab *it, void (*new)()))() {
  603+          
  604+    X         if (it->notes) {
  605+    X     	BLABF(("\ndispatch: Adding 0x%08lX to Galileo INTCTL (0x%08lX)...", it->notes, \
  606+    X     			*(VU32*)GALILEO_CPU_I_ENA));
  607+    X     	*((VU32 *)(GALILEO_CPU_I_ENA)) |= it->notes;
  608+    X         }
  609+    X         return 0;
  610+    X     }
  611+    X      .endc
  612+          
  613+    X      .if true, ...IOA
  614+    X     static void (*ioainst(const struct irq_tab *it, void (*new)()))() {
  615+    X     extern void prc_wait_n_usecs( int );
  616+    X         if (it->notes)
  617+    X         {
  618+    X          BLABF(("\ndispatch: Adding 0x%04X to IOASIC INTCTL: (0x%04X)...", (int)it->notes, \
  619+    X     		*(VU32*)IO_MAIN_CTL&0xFFFF));
  620+    X          while ( ( *((VU32 *)IO_MAIN_CTL) & it->notes ) != it->notes )
  621+    X          {
  622+    X     #ifdef LED_OUT
  623+    X           *(VU32 *)LED_OUT = ~( 1 << B_LED_RED );
  624+    X     #endif
  625+    X           do
  626+    X           {
  627+    X            *((VU32 *)IO_MAIN_CTL) |= it->notes;
  628+    X            prc_wait_n_usecs( 1000 );
  629+    X           } while ( ( *((VU32 *)IO_MAIN_CTL) & it->notes ) != it->notes );
  630+    X           prc_wait_n_usecs( 1000 );
  631+    X     #ifdef LED_OUT
  632+    X           *(VU32 *)LED_OUT |= ( 1 << B_LED_RED );
  633+    X     #endif
  634+    X          }
  635+    X         }
  636+    X         return 0;
  637+    X     }
  638+    X      .endc
  639+    X     .endc
  640+          
  641+    X     void (*prc_set_vec (unsigned int vecnum, void (*routine)() ))()
  642+    X     {
  643+    X         void (*old_rtn)();
  644+    X         void (**softvec)();
  645+    X         const struct irq_tab *tbp;
  646+    X         int old_ipl;
  647+          
  648+    X         if ( vecnum >= N_INTVECS ) return 0;
dispatch.c                               Atari Games Corp. macpp v9.12   "Oct 16 1997 13:26:41"


  649+    X         tbp = irq_inits+vecnum;
  650+    X         softvec = tbp->softvec;
  651+    X         old_rtn = 0;
  652+    X         old_ipl = prc_set_ipl(INTS_OFF);
  653+    X         if ( tbp->installer ) old_rtn = tbp->installer(tbp, routine);
  654+    X         if ( softvec ) {
  655+    X     	if (!old_rtn) old_rtn = *softvec;
  656+    X     	*softvec = routine;
  657+    X         }
  658+    X         prc_set_ipl(old_ipl);
  659+    X         return old_rtn;
  660+    X     }
  661+          
  662+    X      .if true, PHX
  663+    X       .if true, ...XBUS0
  664+    X     static void xbus0_irq(void) {
  665+    X     	.macro VDF cond, name, softvec, intern, installer, notes, physical, default, comments
  666+    X     	.condit cond	
  667+    X       .iif idn,<name>,<XBUS0>,.mexit
  668+    X       .iif idn,<softvec>,<0>,.mexit
  669+    X       .if true, physical == XBUS0_LVL
  670+    X         if (softvec) softvec();
  671+    X       .endc
  672+    X     	.endm
  673+    X     	.include phx_vecs.mac		; pickup all vectors assigned to XBUS0_LVL
  674+    X         return;
  675+    X     }
  676+          
  677+    X       .endc		; ...XBUS0
  678+    X       .if true, ...XBUS1
  679+    X     static void xbus1_irq(void) {
  680+    X     	.macro VDF cond, name, softvec, intern, installer, notes, physical, default, comments
  681+    X     	.condit cond	
  682+    X       .iif idn,<name>,<XBUS1>,.mexit
  683+    X       .iif idn,<softvec>,<0>,.mexit
  684+    X       .if true, physical == XBUS1_LVL
  685+    X         if (softvec) softvec();
  686+    X       .endc
  687+    X     	.endm
  688+    X     	.include phx_vecs.mac		; pickup all vectors assigned to XBUS1_LVL
  689+    X         return;
  690+    X     }
  691+          
  692+    X       .endc		; ...XBUS1
  693+    X       .if true, ...XBUS2
  694+    X     static void xbus2_irq(void) {
  695+    X     	.macro VDF cond, name, softvec, intern, installer, notes, physical, default, comments
  696+    X     	.condit cond	
  697+    X       .iif idn,<name>,<XBUS2>,.mexit
  698+    X       .iif idn,<softvec>,<0>,.mexit
  699+    X       .if true, physical == XBUS2_LVL
  700+    X         if (softvec) softvec();
  701+    X       .endc
  702+    X     	.endm
  703+    X     	.include phx_vecs.mac		; pickup all vectors assigned to XBUS2_LVL
  704+    X         return;
  705+    X     }
dispatch.c                               Atari Games Corp. macpp v9.12   "Oct 16 1997 13:26:41"


  706+          
  707+    X       .endc		; ...XBUS2
  708+    X       .if true, ...XBUS3
  709+    X     static void xbus3_irq(void) {
  710+    X     	.macro VDF cond, name, softvec, intern, installer, notes, physical, default, comments
  711+    X     	.condit cond	
  712+    X       .iif idn,<name>,<XBUS3>,.mexit
  713+    X       .iif idn,<softvec>,<0>,.mexit
  714+    X       .if true, physical == XBUS3_LVL
  715+    X         if (softvec) softvec();
  716+    X       .endc
  717+    X     	.endm
  718+    X     	.include phx_vecs.mac		; pickup all vectors assigned to XBUS3_LVL
  719+    X         return;
  720+    X     }
  721+          
  722+    X       .endc		; ...XBUS3
  723+    X      .endc		; PHX
  724+    X      .if true, ...INT0
  725+    X     static void int0_irq(void) {
  726+    X     	.macro VDF cond, name, softvec, intern, installer, notes, physical, default, comments
  727+    X     	.condit cond	
  728+    X       .iif idn,<name>,<INT0>,.mexit
  729+    X       .iif idn,<softvec>,<0>,.mexit
  730+    X       .if true, physical == INT0_LVL
  731+    X         if (softvec) softvec();
  732+    X       .endc
  733+    X     	.endm
  734+    X     	.include phx_vecs.mac		; pickup all vectors assigned to IRQ 0
  735+    X         return;
  736+    X     }
  737+          
  738+    X      .endc		; ...INT0
  739+    X      .if true, ...INT1
  740+    X     static void int1_irq(void) {
  741+    X     	.macro VDF cond, name, softvec, intern, installer, notes, physical, default, comments
  742+    X     	.condit cond	
  743+    X       .iif idn,<name>,<INT1>,.mexit
  744+    X       .iif idn,<softvec>,<0>,.mexit
  745+    X       .if true, physical == INT1_LVL
  746+    X         if (softvec) softvec();
  747+    X       .endc
  748+    X     	.endm
  749+    X     	.include phx_vecs.mac		; pickup all vectors assigned to IRQ 1
  750+    X         return;
  751+    X     }
  752+          
  753+    X      .endc		; ...INT1
  754+    X      .if true, ...INT2
  755+    X     static void int2_irq(void) {
  756+    X     	.macro VDF cond, name, softvec, intern, installer, notes, physical, default, comments
  757+    X     	.condit cond	
  758+    X       .iif idn,<name>,<INT2>,.mexit
  759+    X       .iif idn,<softvec>,<0>,.mexit
  760+    X       .if true, physical == INT2_LVL
  761+    X         if (softvec) softvec();
  762+    X       .endc
dispatch.c                               Atari Games Corp. macpp v9.12   "Oct 16 1997 13:26:41"


  763+    X     	.endm
  764+    X     	.include phx_vecs.mac		; pickup all vectors assigned to IRQ 2
  765+    X         return;
  766+    X     }
  767+          
  768+    X      .endc		; ...INT2
  769+    X      .if true, ...INT3
  770+    X     static void int3_irq(void) {
  771+    X     	.macro VDF cond, name, softvec, intern, installer, notes, physical, default, comments
  772+    X     	.condit cond	
  773+    X       .iif idn,<name>,<INT3>,.mexit
  774+    X       .iif idn,<softvec>,<0>,.mexit
  775+    X       .if true, physical == INT3_LVL
  776+    X         if (softvec) softvec();
  777+    X       .endc
  778+    X     	.endm
  779+    X     	.include phx_vecs.mac		; pickup all vectors assigned to IRQ 3
  780+    X         return;
  781+    X     }
  782+          
  783+    X      .endc		; ...INT3
  784+    X      .if true, ...INT4
  785+    X     static void int4_irq(void) {
  786+    X     	.macro VDF cond, name, softvec, intern, installer, notes, physical, default, comments
  787+    X     	.condit cond	
  788+    X       .iif idn,<name>,<INT4>,.mexit
  789+    X       .iif idn,<softvec>,<0>,.mexit
  790+    X       .if true, physical == INT4_LVL
  791+    X         if (softvec) softvec();
  792+    X       .endc
  793+    X     	.endm
  794+    X     	.include phx_vecs.mac		; pickup all vectors assigned to IRQ 4
  795+    X         return;
  796+    X     }
  797+          
  798+    X      .endc		; ...INT4
  799+    X      .if true, ...INT5
  800+    X     static void int5_irq(void) {
  801+    X     	.macro VDF cond, name, softvec, intern, installer, notes, physical, default, comments
  802+    X     	.condit cond	
  803+    X       .iif idn,<name>,<INT5>,.mexit
  804+    X       .iif idn,<softvec>,<0>,.mexit
  805+    X       .if true, physical == INT5_LVL
  806+    X         if (softvec) softvec();
  807+    X       .endc
  808+    X     	.endm
  809+    X     	.include phx_vecs.mac		; pickup all vectors assigned to IRQ 5
  810+    X         return;
  811+    X     }
  812+          
  813+    X      .endc		; ...INT5
  814+    X      .if true, ...IOA && PHX
  815+    X     static void ioa_irq(void) {
  816+    X     	.macro VDF cond, name, softvec, intern, installer, notes, physical, default, comments
  817+    X     	.condit cond	
  818+    X       .iif idn,<name>,<IOA>,.mexit
  819+    X       .iif idn,<softvec>,<0>,.mexit
dispatch.c                               Atari Games Corp. macpp v9.12   "Oct 16 1997 13:26:41"


  820+    X       .if true, physical == IOASIC_LVL
  821+    X         if (softvec) softvec();
  822+    X       .endc
  823+    X     	.endm
  824+    X     	.include phx_vecs.mac		; pickup all vectors assigned to IRQ 5
  825+    X         return;
  826+    X     }
  827+          
  828+    X      .endc		; ...IOA
  829+    X      .if true, PHX
  830+    X       .if true, ...XBUS0|...XBUS1|...XBUS2|...XBUS3
  831+    X     static void xbus_irq(void) {
  832+    X         int which;
  833+    X         which = *(VU32 *)(XBUS_SLOT0+4);
  834+    X       .if true, ...XBUS0
  835+    X         if (!(which&1)) xbus0_irq();
  836+    X       .endc
  837+    X       .if true, ...XBUS1
  838+    X         if (!(which&2)) xbus1_irq();
  839+    X       .endc
  840+    X       .if true, ...XBUS2
  841+    X         if (!(which&4)) xbus2_irq();
  842+    X       .endc
  843+    X       .if true, ...XBUS3
  844+    X         if (!(which&8)) xbus3_irq();
  845+    X       .endc
  846+    X         return;
  847+    X     }
  848+    X       .endc
  849+    X      .endc		; PHX
  850+    X     void prc_init_vecs(void) {
  851+    X     	.macro VDF cond, name, softvec, intern, installer, notes, physical, default, comments
  852+    X     	.condit cond	
  853+    X     .if dif,<default>,<0>
  854+    X      .if true, PHX
  855+    X       .if idn,<name>,<XBUS0>
  856+    X        .iif true, ...XBUS0 == 0, .mexit
  857+    X       .endc
  858+    X       .if idn,<name>,<XBUS1>
  859+    X        .iif true, ...XBUS1 == 0, .mexit
  860+    X       .endc
  861+    X       .if idn,<name>,<XBUS2>
  862+    X        .iif true, ...XBUS2 == 0, .mexit
  863+    X       .endc
  864+    X       .if idn,<name>,<XBUS3>
  865+    X        .iif true, ...XBUS3 == 0, .mexit
  866+    X       .endc
  867+    X       .if idn,<name>,<XBUS>
  868+    X        .iif true, (...XBUS0|...XBUS1|...XBUS2|...XBUS3) == 0, .mexit
  869+    X       .endc
  870+    X      .endc	; PHX
  871+    X      .if idn,<name>,<INT0>
  872+    X       .iif true, ...INT0 == 0, .mexit
  873+    X      .endc
  874+    X      .if idn,<name>,<INT1>
  875+    X       .iif true, ...INT1 == 0, .mexit
  876+    X      .endc
dispatch.c                               Atari Games Corp. macpp v9.12   "Oct 16 1997 13:26:41"


  877+    X      .if idn,<name>,<INT2>
  878+    X       .iif true, ...INT2 == 0, .mexit
  879+    X      .endc
  880+    X      .if idn,<name>,<INT3>
  881+    X       .iif true, ...INT3 == 0, .mexit
  882+    X      .endc
  883+    X      .if idn,<name>,<INT4>
  884+    X       .iif true, ...INT4 == 0, .mexit
  885+    X      .endc
  886+    X      .if idn,<name>,<INT5>
  887+    X       .iif true, ...INT5 == 0, .mexit
  888+    X      .endc
  889+    X      .if idn,<name>,<IOA>
  890+    X       .iif true, ...IOA == 0, .mexit
  891+    X      .endc
  892+    X         prc_set_vec('name'_INTVEC, default);
  893+    X     .endc
  894+    X     	.endm
  895+    X     	.include phx_vecs.mac
  896+          
  897+    X     /* Map the Phoenix interrupts */
  898+          
  899+    X     .if df, INTCTL_MAPA_INIT
  900+    X         BLABF(("\ndispatch: Mapping the A interrupts: 0x%08lX...", INTCTL_MAPA_INIT));
  901+    X         *((VU32 *)(INTCTL_MAPA)) = INTCTL_MAPA_INIT;
  902+    X     .endc
  903+    X     .if df, INTCTL_MAPB_INIT
  904+    X         BLABF(("\ndispatch: Mapping the B interrupts: 0x%08lX...", INTCTL_MAPB_INIT));
  905+    X         *((VU32 *)(INTCTL_MAPB)) = INTCTL_MAPB_INIT;
  906+    X     .endc
  907+          
  908+    X     .if defined, ANNOUNCE_BOOT_ACTIONS
  909+    X      .if true, ANNOUNCE_BOOT_ACTIONS
  910+    X         {
  911+    X     	int jj;
  912+    X     	extern int prc_get_cause(void), prc_get_ipl(void);
  913+    X     	jj = prc_get_cause();
  914+    X     	if (jj&0xFF00) BLABF(("\ndispatch: CPU cause reg: %08lX, CPU SR reg: %08lX", jj, prc_get_ipl()));
  915+    X     	if (jj&0x0400) {
  916+    X       .if true, ...INT0
  917+    X     	.macro VDF cond, name, softvec, intern, installer, notes, physical, default, comments
  918+    X     	.condit cond	
  919+    X        .iif idn,<name>,<INT0>,.mexit
  920+    X        .iif idn,<softvec>,<0>,.mexit
  921+    X        .if true, physical == INT0_LVL
  922+    X     	    if (!softvec) BLAB("\ndispatch: Warning, IRQ 0 pending \"'comments'\"");
  923+    X        .endc
  924+    X     	.endm
  925+    X     	.include phx_vecs.mac		; pickup all vectors assigned to IRQ 0
  926+    X       .iff
  927+    X     	    BLAB("\ndispatch: Warning, IRQ 0 pending with no vector assigned");
  928+    X       .endc		; ...INT0
  929+    X     	}
  930+    X     	if (jj&0x0800) {
  931+    X       .if true, ...INT1
  932+    X     	.macro VDF cond, name, softvec, intern, installer, notes, physical, default, comments
  933+    X     	.condit cond	
dispatch.c                               Atari Games Corp. macpp v9.12   "Oct 16 1997 13:26:41"


  934+    X        .iif idn,<name>,<INT1>,.mexit
  935+    X        .iif idn,<softvec>,<0>,.mexit
  936+    X        .if true, physical == INT1_LVL
  937+    X     	    if (!softvec) BLAB("\ndispatch: Warning, IRQ 1 pending \"'comments'\"");
  938+    X        .endc
  939+    X     	.endm
  940+    X     	.include phx_vecs.mac		; pickup all vectors assigned to IRQ 1
  941+    X       .iff
  942+    X     	    BLAB("\ndispatch: Warning, IRQ 1 pending with no vector assigned");
  943+    X       .endc		; ...INT1
  944+    X     	}
  945+    X     	if (jj&0x1000) {
  946+    X       .if true, ...INT2
  947+    X     	.macro VDF cond, name, softvec, intern, installer, notes, physical, default, comments
  948+    X     	.condit cond	
  949+    X        .iif idn,<name>,<INT2>,.mexit
  950+    X        .iif idn,<softvec>,<0>,.mexit
  951+    X        .if true, physical == INT2_LVL
  952+    X     	    if (!softvec) BLAB("\ndispatch: Warning, IRQ 2 pending \"'comments'\"");
  953+    X        .endc
  954+    X     	.endm
  955+    X     	.include phx_vecs.mac		; pickup all vectors assigned to IRQ 2
  956+    X       .iff
  957+    X     	    BLAB("\ndispatch: Warning, IRQ 2 pending with no vector assigned");
  958+    X       .endc		; ...INT2
  959+    X     	}
  960+    X     	if (jj&0x2000) {
  961+    X       .if true, ...INT3
  962+    X     	.macro VDF cond, name, softvec, intern, installer, notes, physical, default, comments
  963+    X     	.condit cond	
  964+    X        .iif idn,<name>,<INT3>,.mexit
  965+    X        .iif idn,<softvec>,<0>,.mexit
  966+    X        .if true, physical == INT3_LVL
  967+    X     	    if (!softvec) BLAB("\ndispatch: Warning, IRQ 3 pending \"'comments'\"");
  968+    X        .endc
  969+    X     	.endm
  970+    X     	.include phx_vecs.mac		; pickup all vectors assigned to IRQ 3
  971+    X       .iff
  972+    X     	    BLAB("\ndispatch: Warning, IRQ 3 pending with no vector assigned");
  973+    X       .endc		; ...INT3
  974+    X     	}
  975+    X     	if (jj&0x4000) {
  976+    X       .if true, ...INT4
  977+    X     	.macro VDF cond, name, softvec, intern, installer, notes, physical, default, comments
  978+    X     	.condit cond	
  979+    X        .iif idn,<name>,<INT4>,.mexit
  980+    X        .iif idn,<softvec>,<0>,.mexit
  981+    X        .if true, physical == INT4_LVL
  982+    X     	    if (!softvec) BLAB("\ndispatch: Warning, IRQ 4 pending \"'comments'\"");
  983+    X        .endc
  984+    X     	.endm
  985+    X     	.include phx_vecs.mac		; pickup all vectors assigned to IRQ 4
  986+    X       .iff
  987+    X     	    BLAB("\ndispatch: Warning, IRQ 4 pending with no vector assigned");
  988+    X       .endc		; ...INT4
  989+    X     	}
  990+    X     	if (jj&0x8000) {
dispatch.c                               Atari Games Corp. macpp v9.12   "Oct 16 1997 13:26:41"


  991+    X       .if true, ...INT5
  992+    X     	.macro VDF cond, name, softvec, intern, installer, notes, physical, default, comments
  993+    X     	.condit cond	
  994+    X        .iif idn,<name>,<INT5>,.mexit
  995+    X        .iif idn,<softvec>,<0>,.mexit
  996+    X        .if true, physical == INT5_LVL
  997+    X     	    if (!softvec) BLAB("\ndispatch: Warning, IRQ 5 pending \"'comments'\"");
  998+    X        .endc
  999+    X     	.endm
 1000+    X     	.include phx_vecs.mac		; pickup all vectors assigned to IRQ 5
 1001+    X       .iff
 1002+    X     	    BLAB("\ndispatch: Warning, IRQ 5 pending with no vector assigned");
 1003+    X       .endc		; ...INT5
 1004+    X     	}
 1005+    X         }
 1006+    X      .endc		; true, ANNOUNCE_BOOT_ACTIONS
 1007+    X     .endc		; defined, ANNOUNCE_BOOT_ACTIONS
 1008+    X         return;
 1009+    X     }
 1010+   (2)    .endc		; _DISPATCH_MAC_ == 0
  795               return;
  796           }
  797           
  798    (1)     .endc		; ...INT4
  799    (1)     .if true, ...INT5
  800           static void int5_irq(void) {
  801           	.macro VDF cond, name, softvec, intern, installer, notes, physical, default, comments
  802           	.condit cond	
  803             .iif idn,<name>,<INT5>,.mexit
  804             .iif idn,<softvec>,<0>,.mexit
  805             .if true, physical == INT5_LVL
  806               if (softvec) softvec();
  807             .endc
  808           	.endm
  809           	.include phx_vecs.mac		; pickup all vectors assigned to IRQ 5
    1+          ;/*		phx_vecs.mac
    2+          ; *
    3+          ; *		Copyright 1996 Atari Games Corporation
    4+          ; *	Unauthorized reproduction, adaptation, distribution, performance or 
    5+          ; *	display of this computer program or the associated audiovisual work
    6+          ; *	is strictly prohibited.
    7+          ; *
    8+          ; *	This file is processed by MACPP to produce dispatch.c and intvecs.h.
    9+          ; *
   10+          ; *	The definitions placed in intvecs.h declare virtual vector numbers
   11+          ; *	in the form of xxx_INTVEC and a cross reference table(s) so the
   12+          ; *	dispatcher can call the appropriate functions.
   13+          ; *
   14+          ; *	intvecs.h should be #include'd by any module that uses prc_set_vec().
   15+          ; */
   16+          ;
   17+          ; This file recursivley '.includes' itself to succesively build up the approprate
   18+          ; tables and functions in C and places the results in one of two files (the
   19+          ; first -out=file supplied on the MACPP command line is expected to be dispatch.c
   20+          ; and the second -out=file is expected to be intvecs.h and the third is expected to
   21+          ; be /dev/null). If you don't speak fluent MACPP, then you probably shouldn't be
   22+          ; changing anything in this file other than the VDF table listed below.
dispatch.c                               Atari Games Corp. macpp v9.12   "Oct 16 1997 13:26:41"


   23+          ;
   24+   (2)    .if not_defined, _DISPATCH_MAC_		;1 +++++
   25+    X     _DISPATCH_MAC_ == 0			;2 Don't move ...
   26+    X     OUTPUT_LANG == 5 ;LANG_NONE		;3 ... or change ... 
   27+    X     	.outfile 2			;4 ... anything on ...
   28+    X     	.include config.mac		;5 ... these ...
   29+    X     	.outfile 0			;6 ... nine  ...
   30+   (2)    .endc					;7 ... lines ...
   31+   (2)    .if true, (_DISPATCH_MAC_&1) != 0	;8
   32+   (3)     .if true, 0				;9 -----
   33+          
   34+    X     You are free to add or remove entries from this table according to your
   35+    X     requirements. There are 10 fields used on each line in this table. The
   36+    X     description of each field follows:
   37+          
   38+    X     Field 1 = macro call
   39+          
   40+    X     It must always be the keyword VDF (case is not significant).
   41+          
   42+    X     Field 2 = condition
   43+          
   44+    X     This is a dual operand field, so the two operands together must be enclosed in
   45+    X     <>'s. The first operand is one of T, F, D or N representing True, False,
   46+    X     Defined or Not_defined respectively. Case is significant, use uppercase only
   47+    X     please. For the conditions T or F the second operand must be an expression
   48+    X     which must resolve to non-$0 (True) or $0 (False) in order for the macro
   49+    X     to be processed (else it is ignored). The expression can contain no embedded
   50+    X     spaces. For the conditions D and N, the second operand must only be a symbol
   51+    X     which must be Defined or Not-defined respectively in order for the macro to be
   52+    X     processed. Some short cut expressions have been preprocessed to make using the
   53+    X     expressions a little more concise. These are:
   54+          
   55+    X     	PHX = not $0 if HOST_BOARD == PHOENIX
   56+    X     	PAD = not $0 if HOST_BOARD == PHOENIX_AD
   57+    X     	FLG = not $0 if HOST_BOARD == FLAGSTAFF
   58+    X     	SEA = not $0 if HOST_BOARD == SEATTLE
   59+    X     	VEG = not $0 if HOST_BOARD == VEGAS
   60+          
   61+    X     Field 3 = vector name
   62+          
   63+    X     The NAME field is the name of the virtual vector. An _INTVEC will be appended
   64+    X     to it in the C definitions in intvecs.h, but otherwise the name is unmolested.
   65+    X     Case is significant only if you want it to be. The R3K/R4K has an option where
   66+    X     a number of vectors are maintained in an array of pointers rather than each
   67+    X     one having its own name. The index into the array is same as the number
   68+    X     returned in the processor's CAUSE register for that particluar interrupt. This
   69+    X     procedure is done simply for performance reasons. The option is selected by
   70+    X     using a 0 for this field and using an installer function with the vector index
   71+    X     as the parameter to the installer.
   72+          
   73+    X     Field 4 = Vector pointer
   74+          
   75+    X     This field identifies the name of a variable in BSS that contains a pointer
   76+    X     to the function to call at interrupt (or will be set by the prc_set_vec()
   77+    X     function). This is the name of the "soft" or logical vector and is either
   78+    X     declared in dispatch.c or externally according to the INT/EXT field described
   79+    X     next.
dispatch.c                               Atari Games Corp. macpp v9.12   "Oct 16 1997 13:26:41"


   80+          
   81+    X     Field 5 = INTernal or EXTernal vector
   82+          
   83+    X     This field contains the keywords INT, EXT, VINT or VEXT identifying the vector
   84+    X     in field 4 as being defined INTernally, EXTernally, Volatile INTernally or
   85+    X     Volatile Externally to dispatch.c respectively.
   86+          
   87+    X     Field 6 = name of vector installer
   88+          
   89+    X     This field identifies the name of a function that prc_set_vec() will call to
   90+    X     actually install the vector or 0 if there is no special stuff that needs to
   91+    X     be performed during vector installation.
   92+          
   93+    X     Field 7 = Notes for the installer.
   94+          
   95+    X     The Notes field is a parameter that is passed to the installer if there is one.
   96+          
   97+    X     Field 8 = Physical vector attachment.
   98+          
   99+    X     A dispatch routine is constructed for each of the 4 XBUS interrupts and for each of
  100+    X     the 6 CPU interrupts.  This field instructs phx_vecs.mac into which of the XBUS or
  101+    X     INTx dispatchers a caller to this vector belongs.  If this vector is not associated
  102+    X     with an XBUS or an INTx interrupt, it needs to be -1.  Place the interrupt routines
  103+    X     in this table in the order in which you want them executed.
  104+          
  105+    X     Field 9 = Default function.
  106+          
  107+    X     Name of default routine to install in the vector, or 0 if none.  phx_vecs.mac builds
  108+    X     a function called prc_init_vecs(void) which, when called, will perform a string of
  109+    X     prc_set_vec()'s for all the vectors having this field non-zero.  After the vectors
  110+    X     have been loaded, prc_init_vecs(void) will map the phoenix and galileo interrupts as
  111+    X     specified in phoenix.mac.
  112+          
  113+    X     Field 10 = Comments.
  114+          
  115+    X     The Comments field is placed on selected lines in intvecs.h and/or dispatch.c
  116+    X     as simple 'C' comments.
  117+          
  118+   (3)     .endc				; Don't move this line
  119+          ;
  120+          ;   Condit	Name	   Vector   I/E	Installer   Notes      Phys	Default	Comments
  121+          ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  122+          VDF <T,1>	GAMEVB,	   gameint, EXT	0,          0,		-1,	0,	< post-wierdness Vblank >
  123+          VDF <T,1>	MS4,       ms4vec,  EXT	0,          0,		-1,	0,	< 4 Millisecond timer >
  124+          VDF <T,1>	PRC_DELAY, prc_delay_vec, EXT 0,    0,		-1,	sst_prc_delay, < prc_delay soft vector >
  125+          VDF <T,1>	PRC_SET_IPL, set_ipl_vec, INT 0,    0,		-1,	0,	< prc_set_ipl soft vector >
  126+          VDF <T,1>	SAVE,      savintp, EXT 0,          0,		-1,	0,	< context save soft vector >
  127+          VDF <T,1>	RESTORE,   restintp,EXT 0,          0,		-1,	0,	< context restore soft vector >
  128+          VDF <T,1>	SW0,	   0,	    INT hwvinst,    VN_IRQ0,    -1,	0,	< Software interrupt 0 >
  129+          VDF <T,1>	SW1,	   0,       INT hwvinst,    VN_IRQ1,    -1,	0,	< Software interrupt 0 >
  130+          VDF <T,1>	INT0,	   0,       INT hwvinst,    VN_IRQ2,    -1,	int0_irq, < Hardware interrupt 0 >
  131+          VDF <T,1>	INT1,	   0,	    INT hwvinst,    VN_IRQ3,    -1,	int1_irq, < Hardware interrupt 1 >
  132+          VDF <T,PHX>	INT2,	   0,	    INT hwvinst,    VN_IRQ4,    -1,	int2_irq, < Hardware interrupt 2 >
  133+          VDF <T,1>	INT3,	   0,       INT hwvinst,    VN_IRQ5,    -1,	int3_irq, < Hardware interrupt 3 >
  134+          VDF <T,1>	INT4,	   0,	    INT hwvinst,    VN_IRQ6,    -1,	int4_irq, < Hardware interrupt 4 >
  135+          VDF <T,1>	INT5,	   0,	    INT hwvinst,    VN_IRQ7,    -1,	int5_irq, < Hardware interrupt 5 >
  136+          VDF <T,1>	TLBMOD,	   0,	    INT hwvinst,    VN_TLBM,    -1,	0,	< TLB modification >
dispatch.c                               Atari Games Corp. macpp v9.12   "Oct 16 1997 13:26:41"


  137+          VDF <T,1>	TLBLOAD,   0,	    INT hwvinst,    VN_TLBL,    -1,	0,	< TLB miss on I or D fetch >
  138+          VDF <T,1>	TLBSTORE,  0,	    INT hwvinst,    VN_TLBS,    -1,	0,	< TLB miss on store >
  139+          VDF <T,1>	ADDRERRL,  0,	    INT hwvinst,    VN_ADDRL,   -1,	0,	< Address error on I or D fetch >
  140+          VDF <T,1>	ADDRERRS,  0,	    INT hwvinst,    VN_ADDRS,   -1,	0,	< Address error on store >
  141+          VDF <T,1>	BUSERRI,   0,	    INT hwvinst,    VN_BUSERRI, -1,	0,	< Bus error on I-fetch >
  142+          VDF <T,1>	BUSERRD,   0,	    INT hwvinst,    VN_BUSERRD, -1,	0,	< Bus error on D-fetch >
  143+          VDF <T,1>	SYSCALL,   0,       INT hwvinst,    VN_SYSCALL, -1,	0,	< SYSCALL instruction >
  144+          VDF <T,1>	BREAK,     0,       INT hwvinst,    VN_BREAK,   -1,	0,	< Breakpoint instruction >
  145+          VDF <T,1>	RESERV,    0,       INT hwvinst,    VN_RESERV,  -1,	0,	< Reserved instruction >
  146+          VDF <T,1>	COPROC,    0,       INT hwvinst,    VN_COPROC,  -1,	0,	< Coprocessor unusable >
  147+          VDF <T,1>	OVRFLOW,   0,       INT hwvinst,    VN_OVERFL,  -1,	0,	< Integer Arithmetic Overflow >
  148+          VDF <T,1>	TRAP,      0,       INT hwvinst,    VN_TRAPV,   -1,	0,	< TRAP exception >
  149+          VDF <T,1>	FLOAT,     0,       INT hwvinst,    VN_FPE,     -1,	0,	< FLoating point exception >
  150+          VDF <T,1>	TIMER,	   timervec, INT 0,	    0,          -1,	0,	< Soft Timer interrupt >
  151+          VDF <T,1>	TIMERPLL,  tpllvec, VEXT 0,	    0,		-1,	0,	<Adjust 1MS timer>
  152+          VDF <T,1>	GAMEFRAME, framevec,INT 0,	    0,		-1,	0,	< Frame complete >
  153+   (3)    .if true, PHX
  154+    X     VDF <D,NET_LVL>	NET,       netintp, INT 0,          0,		NET_LVL,0,	< network int soft vector >
  155+    X     VDF <D,XBUS>	XBUS,	   xbusintp, INT pvinst,    XBUS_NOTES,	XBUS_LVL,xbus_irq, < Any XBUS interrupt >
  156+    X     VDF <T,XS0>	XS0,       xs0intp, INT pvinst,	    XS0_NOTES,	XS0_LVL,0,	< Expansion Slot 0 interrupt >
  157+    X     VDF <T,XS1>	XS1,       xs1intp, INT pvinst,	    XS1_NOTES,	XS1_LVL,0,	< Expansion Slot 1 interrupt >
  158+    X     VDF <T,XS2>	XS2,       xs2intp, INT pvinst,	    XS2_NOTES,	XS2_LVL,0,	< Expansion Slot 2 interrupt >
  159+    X     VDF <T,XS3>	XS3,       xs3intp, INT pvinst,	    XS3_NOTES,	XS3_LVL,0,	< Expansion Slot 3 interrupt >
  160+    X     VDF <T,MIO>	MIO,       miointp, INT pvinst,	    MIO_NOTES,	MIO_LVL,0,	< Miscellaneous I/O interrupt >
  161+    X     VDF <T,CU1>	CU1,       cu1intp, INT pvinst,	    CU1_NOTES,	CU1_LVL,0,	< Combo UART 1 interrupt >
  162+    X     VDF <T,CU2>	CU2,       cu2intp, INT pvinst,	    CU2_NOTES,	CU2_LVL,0,	< Combo UART 2 interrupt >
  163+    X     VDF <T,CPP>	CPP,       cppintp, INT pvinst,	    CPP_NOTES,	CPP_LVL,0,	< Combo Parallel Port interrupt >
  164+    X     VDF <T,PCA>	PCA,       pcaintp, INT pvinst,	    PCA_NOTES,	PCA_LVL,0,	< PCI A interrupt >
  165+    X     VDF <T,PCB>	PCB,       pcbintp, INT pvinst,	    PCB_NOTES,	PCB_LVL,0,	< PCI B interrupt >
  166+    X     VDF <T,PCC>	PCC,       pccintp, INT pvinst,	    PCC_NOTES,	PCC_LVL,0,	< PCI C interrupt >
  167+    X     VDF <T,VSY>	VSY,       vsyintp, INT pvinst,	    VSY_NOTES,	VSY_LVL,0,	< PCI D (VSYNC) interrupt >
  168+    X     VDF <T,IDE>	IDE,	   ideintp, INT pvinst,	    IDE_NOTES,	IDE_LVL,0,	< IDE interrupt >
  169+    X     VDF <T,IOA>	IOA,	   ioaintp, INT pvinst,	    IOA_NOTES,	IOA_LVL,ioa_irq,< I/O Asic interrupt >
  170+    X     VDF <T,ADC>	ADC,	   adcintp, INT pvinst,	    ADC_NOTES,	ADC_LVL,0,	< A/D Converter interrupt >
  171+    X     VDF <D,SND_I>	CAGE,      cagevec, INT 0,          0,		CAGE_LVL,aud_irq, < CAGE interrupt >
  172+   (3)    .endc
  173+   (3)    .if true, PAD || FLG || SEA || VEG
  174+          ;VDF <T,1>	IOA,	   0,	    INT hwvinst,    VN_IRQ3,	-1,	0,	< I/O Asic interrupt >
  175+          VDF <T,1>	IDE,	   0,	    INT hwvinst,    VN_IRQ4,    -1,	0,	< IDE interrupt >
  176+          VDF <T,EXP>	EXP,       expintp, INT pvinst,	    EXP_NOTES,	EXP_LVL,0,	< Expansion Slot interrupt >
  177+   (4)     .if true, PAD || SEA
  178+          VDF <T,NSS>	NSS,	   nssintp, INT pvinst,	    NSS_NOTES,  NSS_LVL,0,	< NSS/Hi-Link interrupt>
  179+   (4)     .endc
  180+   (4)     .if true, FLG
  181+    X     VDF <T,ETH>	ETH,	   ethintp, INT pvinst,     ETH_NOTES,  ETH_LVL,0,	< ethernet interrupt >
  182+    X     VDF <D,SND_I>	CAGE,	   cagevec, INT ioainst,    CAGE_NOTES, CAGE_LVL,aud_irq, < CAGE interrupt >
  183+   (4)     .endc
  184+          VDF <T,WD1>	WD1,	   wd1intp, INT pvinst,	    WD1_NOTES,  WD1_LVL,0,	< Widget interrupt 1>
  185+          VDF <T,PCI>	PCI,       pciintp, INT pvinst,	    PCI_NOTES,	PCI_LVL,0,	< PCI interrupt >
  186+          VDF <T,ADC>	ADC,	   adcintp, INT pvinst,	    ADC_NOTES,	ADC_LVL,0,	< A/D Converter interrupt >
  187+          VDF <T,WD2>	WD2,	   wd2intp, INT pvinst,	    WD2_NOTES,  WD2_LVL,0,	< Widget interrupt 2>
  188+          VDF <T,DBG>	DBG,	   dbgintp, INT pvinst,	    DBG_NOTES,	DBG_LVL,0,	< Debug switch interrupt >
  189+          VDF <T,VSY>	VSY,	   vsyintp, INT pvinst,	    VSY_NOTES,	VSY_LVL,0,	< VSYNC interrupt >
  190+   (3)    .endc
  191+          VDF <T,GAL>	GAL,	   0,       INT gvinst,	    GAL_NOTES,  GAL_LVL,galileoint, < Any Galileo Error Interrupt >
  192+          VDF <T,MOE>	MOE,	   moeintp, INT gvinst,	    MOE_NOTES,	MOE_LVL,0,	< Galileo MemOut >
  193+          VDF <T,DOE>	DOE,	   doeintp, INT gvinst,	    DOE_NOTES,	DOE_LVL,0,	< Galileo DMAOut >
dispatch.c                               Atari Games Corp. macpp v9.12   "Oct 16 1997 13:26:41"


  194+          VDF <T,COE>	COE,	   coeintp, INT gvinst,	    COE_NOTES,	COE_LVL,0,	< Galileo CPUOut >
  195+          VDF <T,DM0>	DM0,	   dm0intp, INT gvinst,	    DM0_NOTES,	DM0_LVL,0,	< Galileo DMA0Comp >
  196+          VDF <T,DM1>	DM1,	   dm1intp, INT gvinst,	    DM1_NOTES,	DM1_LVL,0,	< Galileo DMA1Comp >
  197+          VDF <T,DM2>	DM2,	   dm2intp, INT gvinst,	    DM2_NOTES,	DM2_LVL,0,	< Galileo DMA2Comp >
  198+          VDF <T,DM3>	DM3,	   dm3intp, INT gvinst,	    DM3_NOTES,	DM3_LVL,0,	< Galileo DMA3Comp >
  199+          VDF <T,TM0>	TM0,	   tm0intp, INT gvinst,	    TM0_NOTES,	TM0_LVL,0,	< Galileo T0Exp >
  200+          VDF <T,TM1>	TM1,	   tm1intp, INT gvinst,	    TM1_NOTES,	TM1_LVL,0,	< Galileo T1Exp >
  201+          VDF <T,TM2>	TM2,	   tm2intp, INT gvinst,	    TM2_NOTES,	TM2_LVL,0,	< Galileo T2Exp >
  202+          VDF <T,TM3>	TM3,	   tm3intp, INT gvinst,	    TM3_NOTES,	TM3_LVL,cputimerint, < Galileo T3EXP timer interrupt >
  203+          VDF <T,MRE>	MRE,	   mreintp, INT gvinst,	    MRE_NOTES,	MRE_LVL,0,	< Galileo MasRdErr >
  204+          VDF <T,SWE>	SWE,	   sweintp, INT gvinst,	    SWE_NOTES,	SWE_LVL,0,	< Galileo SlvWrErr >
  205+          VDF <T,MWE>	MWE,	   mweintp, INT gvinst,	    MWE_NOTES,	MWE_LVL,0,	< Galileo MasWrErr >
  206+          VDF <T,SRE>	SRE,	   sreintp, INT gvinst,	    SRE_NOTES,	SRE_LVL,0,	< Galileo SlvRdErr >
  207+          VDF <T,AEP>	AEP,	   aepintp, INT gvinst,	    AEP_NOTES,	AEP_LVL,0,	< Galileo AddrErr >
  208+          VDF <T,MEP>	MEP,	   mepintp, INT gvinst,	    MEP_NOTES,	MEP_LVL,0,	< Galileo MemErr >
  209+          VDF <T,MAS>	MAS,	   masintp, INT gvinst,	    MAS_NOTES,	MAS_LVL,0,	< Galileo MasAbort >
  210+          VDF <T,TAR>	TAR,	   tarintp, INT gvinst,	    TAR_NOTES,	TAR_LVL,0,	< Galileo TarAbort >
  211+          VDF <T,RTY>	RTY,	   rtyintp, INT gvinst,	    RTY_NOTES,	RTY_LVL,0,	< Galileo RetryCtr >
  212+          VDF <T,PC0>	PC0,	   pc0intp, INT gvinst,	    PC0_NOTES,	PC0_LVL,0,	< Galileo PCI Interrupt >
  213+          VDF <T,PC1>	PC1,	   pc1intp, INT gvinst,	    PC1_NOTES,	PC1_LVL,0,	< Galileo PCI Interrupt >
  214+          VDF <T,PC2>	PC2,	   pc2intp, INT gvinst,	    PC2_NOTES,	PC2_LVL,0,	< Galileo PCI Interrupt >
  215+          VDF <T,PC3>	PC3,	   pc3intp, INT gvinst,	    PC3_NOTES,	PC3_LVL,0,	< Galileo PCI Interrupt >
  216+          VDF <D,UART_LVL> UART,	   uartintp,INT ioainst,    UART_NOTES,	UART_LVL,0,	< I/O ASIC UART interrupts >
  217+          VDF <D,SND_LVL>	SND,	   sndintp, INT ioainst,    SND_NOTES,	SND_LVL, 0,	< I/O ASIC Sound interrupts >
  218+          VDF <D,MC_LVL>	MC,	   mcintp,  INT ioainst,    MC_NOTES,	MC_LVL,	0,	< I/O ASIC Microcontroller interrupt >
  219+          ;
  220+   (2)    .endc			; (_DISPATCH_MAC_&1) != 0 *** DON'T MOVE THIS LINE EITHER ***
  221+          ;
  222+          ;+++++++ From here on, there are few user servicable parts inside. ++++
  223+          ;
  224+          ; This is sortof how it works:
  225+          ; The first pass through, _DISPATCH_MAC_ will be 0 (set above by the .if not_defined).
  226+          ; First the copyright boilerplate is inserted into both output files and the macro VDF
  227+          ; is defined to create externs. Some struct definitions and unique externs are depositied
  228+          ; into the .h file. Next _DISPATCH_MAC_ is set to 1 and this file is .included
  229+          ; again. This will cause MACPP to read the VDF table above and output the appropriate
  230+          ; information in the .h file but ignore the rest of the file. The VDF macro is redefined,
  231+          ; and the procedure is repeated causing the creation of different items according to what
  232+          ; is needed. Once the whole .h file is built, the procedure repeats for the building of the
  233+          ; .c file.
  234+          ;
  235+   (2)    .if true, _DISPATCH_MAC_ == 0		; First (main) pass
  236+    X      PHX == 0
  237+    X      PAD == 0
  238+    X      FLG == 0
  239+    X      SEA == 0
  240+    X      VEG == 0
  241+    X      .iif true, HOST_BOARD == PHOENIX, PHX == 1 ;set the appropriate ones true as desired
  242+    X      .iif true, HOST_BOARD == PHOENIX_AD, PAD == 1 ;set the appropriate ones true as desired
  243+    X      .iif true, HOST_BOARD == FLAGSTAFF, FLG == 1 ;set the appropriate ones true as desired
  244+    X      .iif true, HOST_BOARD == SEATTLE, SEA == 1 ;set the appropriate ones true as desired
  245+    X      .iif true, HOST_BOARD == VEGAS, VEG == 1 ;set the appropriate ones true as desired
  246+          ;
  247+    X     	.macro .condit flag,exp		; The .condit macro does an expression test ...
  248+    X     	.if identical,<flag>,<T>
  249+    X     		.iif false,exp,.mexit 10 ; ... and aborts higher level macros if false
  250+    X     		.mexit
dispatch.c                               Atari Games Corp. macpp v9.12   "Oct 16 1997 13:26:41"


  251+    X     	.endc
  252+    X     	.if identical,<flag>,<F>
  253+    X     		.iif true,exp,.mexit 10	; ... etc.
  254+    X     		.mexit
  255+    X     	.endc
  256+    X     	.if identical,<flag>,<D>
  257+    X     		.iif not_defined,exp,.mexit 10
  258+    X     		.mexit
  259+    X     	.endc
  260+    X     	.if identical,<flag>,<N>
  261+    X     		.iif defined,exp,.mexit 10
  262+    X     		.mexit
  263+    X     	.endc
  264+    X     	.endm
  265+          ;	
  266+    X     	.macro boilerplate file_name
  267+    X     /*		file_name
  268+    X      *
  269+    X      *		Copyright 1996 Atari Games Corporation
  270+    X      *	Unauthorized reproduction, adaptation, distribution, performance or 
  271+    X      *	display of this computer program or the associated audiovisual work
  272+    X      *	is strictly prohibited.
  273+    X      *
  274+    X      * ++++++ WARNING WARNING WARNING WARNING WARNING +++++
  275+    X      * This file is machine generated. Any changes you put in here will be lost
  276+    X      * the next time phx_vecs.mac is touched. You need to make your changes to
  277+    X      * phx_vecs.mac instead of this file.
  278+    X      */
  279+    X     	.endm
  280+    X     	boilerplate dispatch.c
  281+    X     	.outfile	1		;The externs go into the .h file
  282+    X     	boilerplate intvecs.h
  283+    X     #if !defined(_INTVECS_H_)
  284+    X     #define _INTVECS_H_
  285+          
  286+    X     struct irq_tab {
  287+    X     	void 	(**softvec)();
  288+    X     	void    (*(*installer)(const struct irq_tab *, void(*new)()))();
  289+    X     	int	notes;
  290+    X     };
  291+          ;
  292+    X     	.macro VDF cond, name, softvec, intern, installer, notes, physical, default, comments
  293+    X     	.condit cond	
  294+    X      .if dif,<softvec>,<0>
  295+    X       ...1 == 0
  296+    X       .iif idn,<intern>,<VINT>,...1 == 1
  297+    X       .iif idn,<intern>,<VEXT>,...1 == 1
  298+    X       .if true, ...1
  299+    X     extern	void (* volatile softvec)();	/* comments */
  300+    X       .iff
  301+    X     extern  void (*softvec)();	/* comments */
  302+    X       .endc
  303+    X      .endc
  304+    X     	.endm
  305+          ;
  306+    X     	_DISPATCH_MAC_ == 1		;next time we process the IRQ table
  307+    X     	.include phx_vecs.mac		;Make the externs
dispatch.c                               Atari Games Corp. macpp v9.12   "Oct 16 1997 13:26:41"


  308+          
  309+    X     enum vecs {
  310+    X     	.macro VDF cond, name, softvec, intern, installer, notes, physical, default, comments
  311+    X     	.condit cond	
  312+    X         name'_INTVEC,
  313+    X     	.endm
  314+    X     	.include phx_vecs.mac		;Make the enums
  315+    X         N_INTVECS
  316+    X     };
  317+          
  318+    X     void (*prc_set_vec (unsigned int vecnum, void (*routine)() ))();
  319+    X     void prc_init_vecs(void);		/* set the default vectors */
  320+          ;
  321+          ; Add a prototype for an as yet unused function
  322+    X     .if true, 0
  323+          
  324+    X     /*		prc_set_vecp(which, what)
  325+    X      *	Sets a special vector for the interrupt identified by <which>
  326+    X      *	to call the routine specified by <what>. <what> is
  327+    X      *	a struct that contains both a pointer to the code
  328+    X      *	to execute and an optional pointer to the private
  329+    X      *	variables for that routine. This is a change from the
  330+    X      *	behavior of prc_set_vec, and is intended to allow
  331+    X      *	multiple incarnations of a given device to share code.
  332+    X      */
  333+          
  334+    X     struct opaque;
  335+    X     extern struct VECP_vector {
  336+    X         void (*function)(struct opaque *);	/* Who you gonna call */
  337+    X         struct opaque *cookie;		/* a magic cookie to hand him */
  338+    X     } prc_set_vecp (
  339+    X         int __which,			/* one of xxx_INTVEC */
  340+    X         struct IRQ_vector __what		/* BY VALUE!!! */
  341+    X     );
  342+    X     .endc
  343+    X     #endif		/* _INTVECS_H_ */
  344+          ;
  345+          ; At this point, we have completed all processing of the .h file
  346+          ; so switch back to the .c file
  347+          ;
  348+    X     	.outfile	0		;switch back to dispatch.c
  349+          ;
  350+    X     #include <config.h>			/* begining of dispatch.c */
  351+    X     #include <os_proto.h>
  352+    X     #include <intvecs.h>
  353+          
  354+    X     #ifndef BLABF
  355+    X     # define BLABF(x)
  356+    X     #endif
  357+          
  358+    X     #ifndef BLAB
  359+    X     # define BLAB(x)
  360+    X     #endif
  361+          
  362+    X      .if true, 1
  363+    X     	.macro VDF cond, name, softvec, intern, installer, notes, physical, default, comments
  364+    X     	.condit cond	
dispatch.c                               Atari Games Corp. macpp v9.12   "Oct 16 1997 13:26:41"


  365+    X       .iif idn,<name>,<XBUS0>,.mexit
  366+    X       .iif idn,<name>,<XBUS1>,.mexit
  367+    X       .iif idn,<name>,<XBUS2>,.mexit
  368+    X       .iif idn,<name>,<XBUS3>,.mexit
  369+    X       .iif idn,<name>,<INT0>,.mexit
  370+    X       .iif idn,<name>,<INT1>,.mexit
  371+    X       .iif idn,<name>,<INT2>,.mexit
  372+    X       .iif idn,<name>,<INT3>,.mexit
  373+    X       .iif idn,<name>,<INT4>,.mexit
  374+    X       .iif idn,<name>,<INT5>,.mexit
  375+    X       .if true, PHX
  376+    X         .if true, physical == XBUS0_LVL
  377+    X     	  ...XBUS0 == ...XBUS0 + 1
  378+    X     	  .mexit
  379+    X         .endc
  380+    X         .if true, physical == XBUS1_LVL
  381+    X     	  ...XBUS1 == ...XBUS1 + 1
  382+    X     	  .mexit
  383+    X         .endc
  384+    X         .if true, physical == XBUS2_LVL
  385+    X     	  ...XBUS2 == ...XBUS2 + 1
  386+    X     	  .mexit
  387+    X         .endc
  388+    X         .if true, physical == XBUS3_LVL
  389+    X     	  ...XBUS3 == ...XBUS3 + 1
  390+    X     	  .mexit
  391+    X         .endc
  392+    X       .endc
  393+    X       .if true, physical == INT0_LVL
  394+    X         	...INT0 == ...INT0 + 1
  395+    X     	.mexit
  396+    X       .endc
  397+    X       .if true, physical == INT1_LVL
  398+    X         	...INT1 == ...INT1 + 1
  399+    X        .if true, PAD || FLG || SEA || VEG
  400+    X     	...IOA == ...IOA + 1
  401+    X         .if ndf, notes
  402+    X     #define notes IO_MAIN_GLOBAL_INT
  403+    X         .endc
  404+    X        .endc
  405+    X     	.mexit
  406+    X       .endc
  407+    X       .if true, physical == INT2_LVL
  408+    X         	...INT2 == ...INT2 + 1
  409+    X     	.mexit
  410+    X       .endc
  411+    X       .if true, physical == INT3_LVL
  412+    X         	...INT3 == ...INT3 + 1
  413+    X     	.mexit
  414+    X       .endc
  415+    X       .if true, physical == INT4_LVL
  416+    X         	...INT4 == ...INT4 + 1
  417+    X     	.mexit
  418+    X       .endc
  419+    X       .if true, physical == INT5_LVL
  420+    X         	...INT5 == ...INT5 + 1
  421+    X     	.mexit
dispatch.c                               Atari Games Corp. macpp v9.12   "Oct 16 1997 13:26:41"


  422+    X       .endc
  423+    X       .if true, physical == IOASIC_LVL
  424+    X         	...IOA == ...IOA + 1
  425+    X        .if ndf, notes
  426+    X     #define notes IO_MAIN_GLOBAL_INT
  427+    X        .endc
  428+    X     	.mexit
  429+    X       .endc
  430+    X     	.endm
  431+    X     ...XBUS0 == 0
  432+    X     ...XBUS1 == 0
  433+    X     ...XBUS2 == 0
  434+    X     ...XBUS3 == 0
  435+    X     ...INT0 == 0
  436+    X     ...INT1 == 0
  437+    X     ...INT2 == 0
  438+    X     ...INT3 == 0
  439+    X     ...INT4 == 0
  440+    X     ...INT5 == 0
  441+    X     ...IOA == 0
  442+    X     	.include phx_vecs.mac	; count vectors requiring dispatch
  443+    X      .endc
  444+          ; 
  445+    X     .macro VDF cond, name, softvec, intern, installer, notes, physical, default, comments
  446+    X      .condit cond	
  447+    X      .if dif,<softvec>,<0>
  448+    X       .if idn,<intern>,<INT>
  449+    X     void (*softvec)();	/* comments */
  450+    X       .endc
  451+    X       .if idn,<intern>,<VINT>
  452+    X     void (* volatile softvec)();	/* comments */
  453+    X       .endc
  454+    X      .endc
  455+    X      .if dif,<default>,<0>
  456+    X       .if idn,<name>,<INT0>
  457+    X        .if true, ...INT0
  458+    X     static void 'default'(void);	/* comments */
  459+    X        .endc
  460+    X        .mexit
  461+    X       .endc
  462+    X       .if idn,<name>,<INT1>
  463+    X        .if true, ...INT1
  464+    X     static void 'default'(void);	/* comments */
  465+    X        .endc
  466+    X        .mexit
  467+    X       .endc
  468+    X       .if idn,<name>,<INT2>
  469+    X        .if true, ...INT2
  470+    X     static void 'default'(void);	/* comments */
  471+    X        .endc
  472+    X        .mexit
  473+    X       .endc
  474+    X       .if idn,<name>,<INT3>
  475+    X        .if true, ...INT3
  476+    X     static void 'default'(void);	/* comments */
  477+    X        .endc
  478+    X        .mexit
dispatch.c                               Atari Games Corp. macpp v9.12   "Oct 16 1997 13:26:41"


  479+    X       .endc
  480+    X       .if idn,<name>,<INT4>
  481+    X        .if true, ...INT4
  482+    X     static void 'default'(void);	/* comments */
  483+    X        .endc
  484+    X        .mexit
  485+    X       .endc
  486+    X       .if idn,<name>,<INT5>
  487+    X        .if true, ...INT5
  488+    X     static void 'default'(void);	/* comments */
  489+    X        .endc
  490+    X        .mexit
  491+    X       .endc
  492+    X       .if idn,<name>,<INT6>
  493+    X        .if true, ...INT6
  494+    X     static void 'default'(void);	/* comments */
  495+    X        .endc
  496+    X        .mexit
  497+    X       .endc
  498+    X       .if idn,<name>,<INT7>
  499+    X        .if true, ...INT7
  500+    X     static void 'default'(void);	/* comments */
  501+    X        .endc
  502+    X        .mexit
  503+    X       .endc
  504+    X       .if true, PHX
  505+    X        .if idn,<name>,<XBUS>
  506+    X         .if true, ...XBUS0|...XBUS1|...XBUS2|...XBUS3
  507+    X     static void 'default'(void);
  508+    X         .endc
  509+    X         .mexit
  510+    X        .endc
  511+    X        .if idn,<name>,<XBUS0>
  512+    X         .if true, ...XBUS0
  513+    X     static void 'default'(void);
  514+    X         .endc
  515+    X         .mexit
  516+    X        .endc
  517+    X        .if idn,<name>,<XBUS1>
  518+    X         .if true, ...XBUS1
  519+    X     static void 'default'(void);
  520+    X         .endc
  521+    X         .mexit
  522+    X        .endc
  523+    X        .if idn,<name>,<XBUS2>
  524+    X         .if true, ...XBUS2
  525+    X     static void 'default'(void);
  526+    X         .endc
  527+    X         .mexit
  528+    X        .endc
  529+    X        .if idn,<name>,<XBUS3>
  530+    X         .if true, ...XBUS3
  531+    X     static void 'default'(void);
  532+    X         .endc
  533+    X         .mexit
  534+    X        .endc
  535+    X       .endc			; PHX
dispatch.c                               Atari Games Corp. macpp v9.12   "Oct 16 1997 13:26:41"


  536+    X       .if idn,<name>,<IOA>
  537+    X        .if true, ...IOA
  538+    X     static void 'default'(void);
  539+    X        .endc
  540+    X        .mexit
  541+    X       .endc
  542+    X     extern void 'default'(void);
  543+    X      .endc
  544+    X     .endm
  545+    X     	.include phx_vecs.mac		;Declare the non-extern vectors
  546+          ;
  547+    X      .if true, ((PROCESSOR&-16) == MIPS3000) || ((PROCESSOR&-16) == MIPS4000)
  548+    X     static void (*hwvinst(const struct irq_tab *, void (*)()))();
  549+    X      .endc
  550+          ;
  551+    X     .if df, PHOENIX_INTCTL_MASK
  552+    X     static void (*pvinst(const struct irq_tab *, void (*)()))();
  553+    X     .endc
  554+          ;
  555+    X     .if df, GALILEO_INTCTL_MASK
  556+    X     static void (*gvinst(const struct irq_tab *, void (*)()))();
  557+    X     .endc
  558+          ;
  559+    X     .if true, ...IOA
  560+    X     static void (*ioainst(const struct irq_tab *, void (*)()))();
  561+    X     .endc
  562+          ;
  563+    X     static const struct irq_tab irq_inits[] = {
  564+    X     	.macro VDF cond, name, softvec, intern, installer, notes, physical, default, comments
  565+    X     	.condit cond	
  566+    X      .if dif,<softvec>,<0>
  567+    X      { (void (**)())&softvec, installer, notes },	/* comments */
  568+    X      .iff
  569+    X      { 0, installer, notes },	/* comments */
  570+    X      .endc
  571+    X     	.endm
  572+    X     	.include phx_vecs.mac		;Build the irq_inits array
  573+    X      { 0, 0, 0} };
  574+          ;
  575+    X     .if true, ((PROCESSOR&-16) == MIPS3000) || ((PROCESSOR&-16) == MIPS4000)
  576+          
  577+    X     extern void (*ramv_tbl[])();
  578+          
  579+    X     static void (*hwvinst(const struct irq_tab *it, void (*new)()))() {
  580+    X         int indx;
  581+    X         void (*old_rtn)();
  582+          
  583+    X         indx = it->notes;
  584+    X         if (indx >= VN_MAX) return 0;
  585+    X         old_rtn = ramv_tbl[indx];
  586+    X         ramv_tbl[indx] = new;
  587+    X         return old_rtn;
  588+    X     }
  589+          
  590+    X      .if df, PHOENIX_INTCTL_MASK
  591+    X     static void (*pvinst(const struct irq_tab *it, void (*new)()))() {
  592+          
dispatch.c                               Atari Games Corp. macpp v9.12   "Oct 16 1997 13:26:41"


  593+    X         if (it->notes) {
  594+    X     	BLABF(("\ndispatch: Adding 0x%08lX to main INTCTL (0x%08lX)...", it->notes, *(VU32*)INTCTL_IE));
  595+    X     	*((VU32 *)(INTCTL_IE)) |= it->notes;
  596+    X         }
  597+    X         return 0;
  598+    X     }
  599+    X      .endc
  600+          
  601+    X      .if df, GALILEO_INTCTL_MASK
  602+    X     static void (*gvinst(const struct irq_tab *it, void (*new)()))() {
  603+          
  604+    X         if (it->notes) {
  605+    X     	BLABF(("\ndispatch: Adding 0x%08lX to Galileo INTCTL (0x%08lX)...", it->notes, \
  606+    X     			*(VU32*)GALILEO_CPU_I_ENA));
  607+    X     	*((VU32 *)(GALILEO_CPU_I_ENA)) |= it->notes;
  608+    X         }
  609+    X         return 0;
  610+    X     }
  611+    X      .endc
  612+          
  613+    X      .if true, ...IOA
  614+    X     static void (*ioainst(const struct irq_tab *it, void (*new)()))() {
  615+    X     extern void prc_wait_n_usecs( int );
  616+    X         if (it->notes)
  617+    X         {
  618+    X          BLABF(("\ndispatch: Adding 0x%04X to IOASIC INTCTL: (0x%04X)...", (int)it->notes, \
  619+    X     		*(VU32*)IO_MAIN_CTL&0xFFFF));
  620+    X          while ( ( *((VU32 *)IO_MAIN_CTL) & it->notes ) != it->notes )
  621+    X          {
  622+    X     #ifdef LED_OUT
  623+    X           *(VU32 *)LED_OUT = ~( 1 << B_LED_RED );
  624+    X     #endif
  625+    X           do
  626+    X           {
  627+    X            *((VU32 *)IO_MAIN_CTL) |= it->notes;
  628+    X            prc_wait_n_usecs( 1000 );
  629+    X           } while ( ( *((VU32 *)IO_MAIN_CTL) & it->notes ) != it->notes );
  630+    X           prc_wait_n_usecs( 1000 );
  631+    X     #ifdef LED_OUT
  632+    X           *(VU32 *)LED_OUT |= ( 1 << B_LED_RED );
  633+    X     #endif
  634+    X          }
  635+    X         }
  636+    X         return 0;
  637+    X     }
  638+    X      .endc
  639+    X     .endc
  640+          
  641+    X     void (*prc_set_vec (unsigned int vecnum, void (*routine)() ))()
  642+    X     {
  643+    X         void (*old_rtn)();
  644+    X         void (**softvec)();
  645+    X         const struct irq_tab *tbp;
  646+    X         int old_ipl;
  647+          
  648+    X         if ( vecnum >= N_INTVECS ) return 0;
  649+    X         tbp = irq_inits+vecnum;
dispatch.c                               Atari Games Corp. macpp v9.12   "Oct 16 1997 13:26:41"


  650+    X         softvec = tbp->softvec;
  651+    X         old_rtn = 0;
  652+    X         old_ipl = prc_set_ipl(INTS_OFF);
  653+    X         if ( tbp->installer ) old_rtn = tbp->installer(tbp, routine);
  654+    X         if ( softvec ) {
  655+    X     	if (!old_rtn) old_rtn = *softvec;
  656+    X     	*softvec = routine;
  657+    X         }
  658+    X         prc_set_ipl(old_ipl);
  659+    X         return old_rtn;
  660+    X     }
  661+          
  662+    X      .if true, PHX
  663+    X       .if true, ...XBUS0
  664+    X     static void xbus0_irq(void) {
  665+    X     	.macro VDF cond, name, softvec, intern, installer, notes, physical, default, comments
  666+    X     	.condit cond	
  667+    X       .iif idn,<name>,<XBUS0>,.mexit
  668+    X       .iif idn,<softvec>,<0>,.mexit
  669+    X       .if true, physical == XBUS0_LVL
  670+    X         if (softvec) softvec();
  671+    X       .endc
  672+    X     	.endm
  673+    X     	.include phx_vecs.mac		; pickup all vectors assigned to XBUS0_LVL
  674+    X         return;
  675+    X     }
  676+          
  677+    X       .endc		; ...XBUS0
  678+    X       .if true, ...XBUS1
  679+    X     static void xbus1_irq(void) {
  680+    X     	.macro VDF cond, name, softvec, intern, installer, notes, physical, default, comments
  681+    X     	.condit cond	
  682+    X       .iif idn,<name>,<XBUS1>,.mexit
  683+    X       .iif idn,<softvec>,<0>,.mexit
  684+    X       .if true, physical == XBUS1_LVL
  685+    X         if (softvec) softvec();
  686+    X       .endc
  687+    X     	.endm
  688+    X     	.include phx_vecs.mac		; pickup all vectors assigned to XBUS1_LVL
  689+    X         return;
  690+    X     }
  691+          
  692+    X       .endc		; ...XBUS1
  693+    X       .if true, ...XBUS2
  694+    X     static void xbus2_irq(void) {
  695+    X     	.macro VDF cond, name, softvec, intern, installer, notes, physical, default, comments
  696+    X     	.condit cond	
  697+    X       .iif idn,<name>,<XBUS2>,.mexit
  698+    X       .iif idn,<softvec>,<0>,.mexit
  699+    X       .if true, physical == XBUS2_LVL
  700+    X         if (softvec) softvec();
  701+    X       .endc
  702+    X     	.endm
  703+    X     	.include phx_vecs.mac		; pickup all vectors assigned to XBUS2_LVL
  704+    X         return;
  705+    X     }
  706+          
dispatch.c                               Atari Games Corp. macpp v9.12   "Oct 16 1997 13:26:41"


  707+    X       .endc		; ...XBUS2
  708+    X       .if true, ...XBUS3
  709+    X     static void xbus3_irq(void) {
  710+    X     	.macro VDF cond, name, softvec, intern, installer, notes, physical, default, comments
  711+    X     	.condit cond	
  712+    X       .iif idn,<name>,<XBUS3>,.mexit
  713+    X       .iif idn,<softvec>,<0>,.mexit
  714+    X       .if true, physical == XBUS3_LVL
  715+    X         if (softvec) softvec();
  716+    X       .endc
  717+    X     	.endm
  718+    X     	.include phx_vecs.mac		; pickup all vectors assigned to XBUS3_LVL
  719+    X         return;
  720+    X     }
  721+          
  722+    X       .endc		; ...XBUS3
  723+    X      .endc		; PHX
  724+    X      .if true, ...INT0
  725+    X     static void int0_irq(void) {
  726+    X     	.macro VDF cond, name, softvec, intern, installer, notes, physical, default, comments
  727+    X     	.condit cond	
  728+    X       .iif idn,<name>,<INT0>,.mexit
  729+    X       .iif idn,<softvec>,<0>,.mexit
  730+    X       .if true, physical == INT0_LVL
  731+    X         if (softvec) softvec();
  732+    X       .endc
  733+    X     	.endm
  734+    X     	.include phx_vecs.mac		; pickup all vectors assigned to IRQ 0
  735+    X         return;
  736+    X     }
  737+          
  738+    X      .endc		; ...INT0
  739+    X      .if true, ...INT1
  740+    X     static void int1_irq(void) {
  741+    X     	.macro VDF cond, name, softvec, intern, installer, notes, physical, default, comments
  742+    X     	.condit cond	
  743+    X       .iif idn,<name>,<INT1>,.mexit
  744+    X       .iif idn,<softvec>,<0>,.mexit
  745+    X       .if true, physical == INT1_LVL
  746+    X         if (softvec) softvec();
  747+    X       .endc
  748+    X     	.endm
  749+    X     	.include phx_vecs.mac		; pickup all vectors assigned to IRQ 1
  750+    X         return;
  751+    X     }
  752+          
  753+    X      .endc		; ...INT1
  754+    X      .if true, ...INT2
  755+    X     static void int2_irq(void) {
  756+    X     	.macro VDF cond, name, softvec, intern, installer, notes, physical, default, comments
  757+    X     	.condit cond	
  758+    X       .iif idn,<name>,<INT2>,.mexit
  759+    X       .iif idn,<softvec>,<0>,.mexit
  760+    X       .if true, physical == INT2_LVL
  761+    X         if (softvec) softvec();
  762+    X       .endc
  763+    X     	.endm
dispatch.c                               Atari Games Corp. macpp v9.12   "Oct 16 1997 13:26:41"


  764+    X     	.include phx_vecs.mac		; pickup all vectors assigned to IRQ 2
  765+    X         return;
  766+    X     }
  767+          
  768+    X      .endc		; ...INT2
  769+    X      .if true, ...INT3
  770+    X     static void int3_irq(void) {
  771+    X     	.macro VDF cond, name, softvec, intern, installer, notes, physical, default, comments
  772+    X     	.condit cond	
  773+    X       .iif idn,<name>,<INT3>,.mexit
  774+    X       .iif idn,<softvec>,<0>,.mexit
  775+    X       .if true, physical == INT3_LVL
  776+    X         if (softvec) softvec();
  777+    X       .endc
  778+    X     	.endm
  779+    X     	.include phx_vecs.mac		; pickup all vectors assigned to IRQ 3
  780+    X         return;
  781+    X     }
  782+          
  783+    X      .endc		; ...INT3
  784+    X      .if true, ...INT4
  785+    X     static void int4_irq(void) {
  786+    X     	.macro VDF cond, name, softvec, intern, installer, notes, physical, default, comments
  787+    X     	.condit cond	
  788+    X       .iif idn,<name>,<INT4>,.mexit
  789+    X       .iif idn,<softvec>,<0>,.mexit
  790+    X       .if true, physical == INT4_LVL
  791+    X         if (softvec) softvec();
  792+    X       .endc
  793+    X     	.endm
  794+    X     	.include phx_vecs.mac		; pickup all vectors assigned to IRQ 4
  795+    X         return;
  796+    X     }
  797+          
  798+    X      .endc		; ...INT4
  799+    X      .if true, ...INT5
  800+    X     static void int5_irq(void) {
  801+    X     	.macro VDF cond, name, softvec, intern, installer, notes, physical, default, comments
  802+    X     	.condit cond	
  803+    X       .iif idn,<name>,<INT5>,.mexit
  804+    X       .iif idn,<softvec>,<0>,.mexit
  805+    X       .if true, physical == INT5_LVL
  806+    X         if (softvec) softvec();
  807+    X       .endc
  808+    X     	.endm
  809+    X     	.include phx_vecs.mac		; pickup all vectors assigned to IRQ 5
  810+    X         return;
  811+    X     }
  812+          
  813+    X      .endc		; ...INT5
  814+    X      .if true, ...IOA && PHX
  815+    X     static void ioa_irq(void) {
  816+    X     	.macro VDF cond, name, softvec, intern, installer, notes, physical, default, comments
  817+    X     	.condit cond	
  818+    X       .iif idn,<name>,<IOA>,.mexit
  819+    X       .iif idn,<softvec>,<0>,.mexit
  820+    X       .if true, physical == IOASIC_LVL
dispatch.c                               Atari Games Corp. macpp v9.12   "Oct 16 1997 13:26:41"


  821+    X         if (softvec) softvec();
  822+    X       .endc
  823+    X     	.endm
  824+    X     	.include phx_vecs.mac		; pickup all vectors assigned to IRQ 5
  825+    X         return;
  826+    X     }
  827+          
  828+    X      .endc		; ...IOA
  829+    X      .if true, PHX
  830+    X       .if true, ...XBUS0|...XBUS1|...XBUS2|...XBUS3
  831+    X     static void xbus_irq(void) {
  832+    X         int which;
  833+    X         which = *(VU32 *)(XBUS_SLOT0+4);
  834+    X       .if true, ...XBUS0
  835+    X         if (!(which&1)) xbus0_irq();
  836+    X       .endc
  837+    X       .if true, ...XBUS1
  838+    X         if (!(which&2)) xbus1_irq();
  839+    X       .endc
  840+    X       .if true, ...XBUS2
  841+    X         if (!(which&4)) xbus2_irq();
  842+    X       .endc
  843+    X       .if true, ...XBUS3
  844+    X         if (!(which&8)) xbus3_irq();
  845+    X       .endc
  846+    X         return;
  847+    X     }
  848+    X       .endc
  849+    X      .endc		; PHX
  850+    X     void prc_init_vecs(void) {
  851+    X     	.macro VDF cond, name, softvec, intern, installer, notes, physical, default, comments
  852+    X     	.condit cond	
  853+    X     .if dif,<default>,<0>
  854+    X      .if true, PHX
  855+    X       .if idn,<name>,<XBUS0>
  856+    X        .iif true, ...XBUS0 == 0, .mexit
  857+    X       .endc
  858+    X       .if idn,<name>,<XBUS1>
  859+    X        .iif true, ...XBUS1 == 0, .mexit
  860+    X       .endc
  861+    X       .if idn,<name>,<XBUS2>
  862+    X        .iif true, ...XBUS2 == 0, .mexit
  863+    X       .endc
  864+    X       .if idn,<name>,<XBUS3>
  865+    X        .iif true, ...XBUS3 == 0, .mexit
  866+    X       .endc
  867+    X       .if idn,<name>,<XBUS>
  868+    X        .iif true, (...XBUS0|...XBUS1|...XBUS2|...XBUS3) == 0, .mexit
  869+    X       .endc
  870+    X      .endc	; PHX
  871+    X      .if idn,<name>,<INT0>
  872+    X       .iif true, ...INT0 == 0, .mexit
  873+    X      .endc
  874+    X      .if idn,<name>,<INT1>
  875+    X       .iif true, ...INT1 == 0, .mexit
  876+    X      .endc
  877+    X      .if idn,<name>,<INT2>
dispatch.c                               Atari Games Corp. macpp v9.12   "Oct 16 1997 13:26:41"


  878+    X       .iif true, ...INT2 == 0, .mexit
  879+    X      .endc
  880+    X      .if idn,<name>,<INT3>
  881+    X       .iif true, ...INT3 == 0, .mexit
  882+    X      .endc
  883+    X      .if idn,<name>,<INT4>
  884+    X       .iif true, ...INT4 == 0, .mexit
  885+    X      .endc
  886+    X      .if idn,<name>,<INT5>
  887+    X       .iif true, ...INT5 == 0, .mexit
  888+    X      .endc
  889+    X      .if idn,<name>,<IOA>
  890+    X       .iif true, ...IOA == 0, .mexit
  891+    X      .endc
  892+    X         prc_set_vec('name'_INTVEC, default);
  893+    X     .endc
  894+    X     	.endm
  895+    X     	.include phx_vecs.mac
  896+          
  897+    X     /* Map the Phoenix interrupts */
  898+          
  899+    X     .if df, INTCTL_MAPA_INIT
  900+    X         BLABF(("\ndispatch: Mapping the A interrupts: 0x%08lX...", INTCTL_MAPA_INIT));
  901+    X         *((VU32 *)(INTCTL_MAPA)) = INTCTL_MAPA_INIT;
  902+    X     .endc
  903+    X     .if df, INTCTL_MAPB_INIT
  904+    X         BLABF(("\ndispatch: Mapping the B interrupts: 0x%08lX...", INTCTL_MAPB_INIT));
  905+    X         *((VU32 *)(INTCTL_MAPB)) = INTCTL_MAPB_INIT;
  906+    X     .endc
  907+          
  908+    X     .if defined, ANNOUNCE_BOOT_ACTIONS
  909+    X      .if true, ANNOUNCE_BOOT_ACTIONS
  910+    X         {
  911+    X     	int jj;
  912+    X     	extern int prc_get_cause(void), prc_get_ipl(void);
  913+    X     	jj = prc_get_cause();
  914+    X     	if (jj&0xFF00) BLABF(("\ndispatch: CPU cause reg: %08lX, CPU SR reg: %08lX", jj, prc_get_ipl()));
  915+    X     	if (jj&0x0400) {
  916+    X       .if true, ...INT0
  917+    X     	.macro VDF cond, name, softvec, intern, installer, notes, physical, default, comments
  918+    X     	.condit cond	
  919+    X        .iif idn,<name>,<INT0>,.mexit
  920+    X        .iif idn,<softvec>,<0>,.mexit
  921+    X        .if true, physical == INT0_LVL
  922+    X     	    if (!softvec) BLAB("\ndispatch: Warning, IRQ 0 pending \"'comments'\"");
  923+    X        .endc
  924+    X     	.endm
  925+    X     	.include phx_vecs.mac		; pickup all vectors assigned to IRQ 0
  926+    X       .iff
  927+    X     	    BLAB("\ndispatch: Warning, IRQ 0 pending with no vector assigned");
  928+    X       .endc		; ...INT0
  929+    X     	}
  930+    X     	if (jj&0x0800) {
  931+    X       .if true, ...INT1
  932+    X     	.macro VDF cond, name, softvec, intern, installer, notes, physical, default, comments
  933+    X     	.condit cond	
  934+    X        .iif idn,<name>,<INT1>,.mexit
dispatch.c                               Atari Games Corp. macpp v9.12   "Oct 16 1997 13:26:41"


  935+    X        .iif idn,<softvec>,<0>,.mexit
  936+    X        .if true, physical == INT1_LVL
  937+    X     	    if (!softvec) BLAB("\ndispatch: Warning, IRQ 1 pending \"'comments'\"");
  938+    X        .endc
  939+    X     	.endm
  940+    X     	.include phx_vecs.mac		; pickup all vectors assigned to IRQ 1
  941+    X       .iff
  942+    X     	    BLAB("\ndispatch: Warning, IRQ 1 pending with no vector assigned");
  943+    X       .endc		; ...INT1
  944+    X     	}
  945+    X     	if (jj&0x1000) {
  946+    X       .if true, ...INT2
  947+    X     	.macro VDF cond, name, softvec, intern, installer, notes, physical, default, comments
  948+    X     	.condit cond	
  949+    X        .iif idn,<name>,<INT2>,.mexit
  950+    X        .iif idn,<softvec>,<0>,.mexit
  951+    X        .if true, physical == INT2_LVL
  952+    X     	    if (!softvec) BLAB("\ndispatch: Warning, IRQ 2 pending \"'comments'\"");
  953+    X        .endc
  954+    X     	.endm
  955+    X     	.include phx_vecs.mac		; pickup all vectors assigned to IRQ 2
  956+    X       .iff
  957+    X     	    BLAB("\ndispatch: Warning, IRQ 2 pending with no vector assigned");
  958+    X       .endc		; ...INT2
  959+    X     	}
  960+    X     	if (jj&0x2000) {
  961+    X       .if true, ...INT3
  962+    X     	.macro VDF cond, name, softvec, intern, installer, notes, physical, default, comments
  963+    X     	.condit cond	
  964+    X        .iif idn,<name>,<INT3>,.mexit
  965+    X        .iif idn,<softvec>,<0>,.mexit
  966+    X        .if true, physical == INT3_LVL
  967+    X     	    if (!softvec) BLAB("\ndispatch: Warning, IRQ 3 pending \"'comments'\"");
  968+    X        .endc
  969+    X     	.endm
  970+    X     	.include phx_vecs.mac		; pickup all vectors assigned to IRQ 3
  971+    X       .iff
  972+    X     	    BLAB("\ndispatch: Warning, IRQ 3 pending with no vector assigned");
  973+    X       .endc		; ...INT3
  974+    X     	}
  975+    X     	if (jj&0x4000) {
  976+    X       .if true, ...INT4
  977+    X     	.macro VDF cond, name, softvec, intern, installer, notes, physical, default, comments
  978+    X     	.condit cond	
  979+    X        .iif idn,<name>,<INT4>,.mexit
  980+    X        .iif idn,<softvec>,<0>,.mexit
  981+    X        .if true, physical == INT4_LVL
  982+    X     	    if (!softvec) BLAB("\ndispatch: Warning, IRQ 4 pending \"'comments'\"");
  983+    X        .endc
  984+    X     	.endm
  985+    X     	.include phx_vecs.mac		; pickup all vectors assigned to IRQ 4
  986+    X       .iff
  987+    X     	    BLAB("\ndispatch: Warning, IRQ 4 pending with no vector assigned");
  988+    X       .endc		; ...INT4
  989+    X     	}
  990+    X     	if (jj&0x8000) {
  991+    X       .if true, ...INT5
dispatch.c                               Atari Games Corp. macpp v9.12   "Oct 16 1997 13:26:41"


  992+    X     	.macro VDF cond, name, softvec, intern, installer, notes, physical, default, comments
  993+    X     	.condit cond	
  994+    X        .iif idn,<name>,<INT5>,.mexit
  995+    X        .iif idn,<softvec>,<0>,.mexit
  996+    X        .if true, physical == INT5_LVL
  997+    X     	    if (!softvec) BLAB("\ndispatch: Warning, IRQ 5 pending \"'comments'\"");
  998+    X        .endc
  999+    X     	.endm
 1000+    X     	.include phx_vecs.mac		; pickup all vectors assigned to IRQ 5
 1001+    X       .iff
 1002+    X     	    BLAB("\ndispatch: Warning, IRQ 5 pending with no vector assigned");
 1003+    X       .endc		; ...INT5
 1004+    X     	}
 1005+    X         }
 1006+    X      .endc		; true, ANNOUNCE_BOOT_ACTIONS
 1007+    X     .endc		; defined, ANNOUNCE_BOOT_ACTIONS
 1008+    X         return;
 1009+    X     }
 1010+   (2)    .endc		; _DISPATCH_MAC_ == 0
  810               return;
  811           }
  812           
  813    (1)     .endc		; ...INT5
  814    (1)     .if true, ...IOA && PHX
  815     X     static void ioa_irq(void) {
  816     X     	.macro VDF cond, name, softvec, intern, installer, notes, physical, default, comments
  817     X     	.condit cond	
  818     X       .iif idn,<name>,<IOA>,.mexit
  819     X       .iif idn,<softvec>,<0>,.mexit
  820     X       .if true, physical == IOASIC_LVL
  821     X         if (softvec) softvec();
  822     X       .endc
  823     X     	.endm
  824     X     	.include phx_vecs.mac		; pickup all vectors assigned to IRQ 5
  825     X         return;
  826     X     }
  827           
  828    (1)     .endc		; ...IOA
  829    (1)     .if true, PHX
  830     X       .if true, ...XBUS0|...XBUS1|...XBUS2|...XBUS3
  831     X     static void xbus_irq(void) {
  832     X         int which;
  833     X         which = *(VU32 *)(XBUS_SLOT0+4);
  834     X       .if true, ...XBUS0
  835     X         if (!(which&1)) xbus0_irq();
  836     X       .endc
  837     X       .if true, ...XBUS1
  838     X         if (!(which&2)) xbus1_irq();
  839     X       .endc
  840     X       .if true, ...XBUS2
  841     X         if (!(which&4)) xbus2_irq();
  842     X       .endc
  843     X       .if true, ...XBUS3
  844     X         if (!(which&8)) xbus3_irq();
  845     X       .endc
  846     X         return;
  847     X     }
dispatch.c                               Atari Games Corp. macpp v9.12   "Oct 16 1997 13:26:41"


  848     X       .endc
  849    (1)     .endc		; PHX
  850           void prc_init_vecs(void) {
  851           	.macro VDF cond, name, softvec, intern, installer, notes, physical, default, comments
  852           	.condit cond	
  853           .if dif,<default>,<0>
  854            .if true, PHX
  855             .if idn,<name>,<XBUS0>
  856              .iif true, ...XBUS0 == 0, .mexit
  857             .endc
  858             .if idn,<name>,<XBUS1>
  859              .iif true, ...XBUS1 == 0, .mexit
  860             .endc
  861             .if idn,<name>,<XBUS2>
  862              .iif true, ...XBUS2 == 0, .mexit
  863             .endc
  864             .if idn,<name>,<XBUS3>
  865              .iif true, ...XBUS3 == 0, .mexit
  866             .endc
  867             .if idn,<name>,<XBUS>
  868              .iif true, (...XBUS0|...XBUS1|...XBUS2|...XBUS3) == 0, .mexit
  869             .endc
  870            .endc	; PHX
  871            .if idn,<name>,<INT0>
  872             .iif true, ...INT0 == 0, .mexit
  873            .endc
  874            .if idn,<name>,<INT1>
  875             .iif true, ...INT1 == 0, .mexit
  876            .endc
  877            .if idn,<name>,<INT2>
  878             .iif true, ...INT2 == 0, .mexit
  879            .endc
  880            .if idn,<name>,<INT3>
  881             .iif true, ...INT3 == 0, .mexit
  882            .endc
  883            .if idn,<name>,<INT4>
  884             .iif true, ...INT4 == 0, .mexit
  885            .endc
  886            .if idn,<name>,<INT5>
  887             .iif true, ...INT5 == 0, .mexit
  888            .endc
  889            .if idn,<name>,<IOA>
  890             .iif true, ...IOA == 0, .mexit
  891            .endc
  892               prc_set_vec('name'_INTVEC, default);
  893           .endc
  894           	.endm
  895           	.include phx_vecs.mac
    1+          ;/*		phx_vecs.mac
    2+          ; *
    3+          ; *		Copyright 1996 Atari Games Corporation
    4+          ; *	Unauthorized reproduction, adaptation, distribution, performance or 
    5+          ; *	display of this computer program or the associated audiovisual work
    6+          ; *	is strictly prohibited.
    7+          ; *
    8+          ; *	This file is processed by MACPP to produce dispatch.c and intvecs.h.
    9+          ; *
dispatch.c                               Atari Games Corp. macpp v9.12   "Oct 16 1997 13:26:41"


   10+          ; *	The definitions placed in intvecs.h declare virtual vector numbers
   11+          ; *	in the form of xxx_INTVEC and a cross reference table(s) so the
   12+          ; *	dispatcher can call the appropriate functions.
   13+          ; *
   14+          ; *	intvecs.h should be #include'd by any module that uses prc_set_vec().
   15+          ; */
   16+          ;
   17+          ; This file recursivley '.includes' itself to succesively build up the approprate
   18+          ; tables and functions in C and places the results in one of two files (the
   19+          ; first -out=file supplied on the MACPP command line is expected to be dispatch.c
   20+          ; and the second -out=file is expected to be intvecs.h and the third is expected to
   21+          ; be /dev/null). If you don't speak fluent MACPP, then you probably shouldn't be
   22+          ; changing anything in this file other than the VDF table listed below.
   23+          ;
   24+   (1)    .if not_defined, _DISPATCH_MAC_		;1 +++++
   25+    X     _DISPATCH_MAC_ == 0			;2 Don't move ...
   26+    X     OUTPUT_LANG == 5 ;LANG_NONE		;3 ... or change ... 
   27+    X     	.outfile 2			;4 ... anything on ...
   28+    X     	.include config.mac		;5 ... these ...
   29+    X     	.outfile 0			;6 ... nine  ...
   30+   (1)    .endc					;7 ... lines ...
   31+   (1)    .if true, (_DISPATCH_MAC_&1) != 0	;8
   32+   (2)     .if true, 0				;9 -----
   33+          
   34+    X     You are free to add or remove entries from this table according to your
   35+    X     requirements. There are 10 fields used on each line in this table. The
   36+    X     description of each field follows:
   37+          
   38+    X     Field 1 = macro call
   39+          
   40+    X     It must always be the keyword VDF (case is not significant).
   41+          
   42+    X     Field 2 = condition
   43+          
   44+    X     This is a dual operand field, so the two operands together must be enclosed in
   45+    X     <>'s. The first operand is one of T, F, D or N representing True, False,
   46+    X     Defined or Not_defined respectively. Case is significant, use uppercase only
   47+    X     please. For the conditions T or F the second operand must be an expression
   48+    X     which must resolve to non-$0 (True) or $0 (False) in order for the macro
   49+    X     to be processed (else it is ignored). The expression can contain no embedded
   50+    X     spaces. For the conditions D and N, the second operand must only be a symbol
   51+    X     which must be Defined or Not-defined respectively in order for the macro to be
   52+    X     processed. Some short cut expressions have been preprocessed to make using the
   53+    X     expressions a little more concise. These are:
   54+          
   55+    X     	PHX = not $0 if HOST_BOARD == PHOENIX
   56+    X     	PAD = not $0 if HOST_BOARD == PHOENIX_AD
   57+    X     	FLG = not $0 if HOST_BOARD == FLAGSTAFF
   58+    X     	SEA = not $0 if HOST_BOARD == SEATTLE
   59+    X     	VEG = not $0 if HOST_BOARD == VEGAS
   60+          
   61+    X     Field 3 = vector name
   62+          
   63+    X     The NAME field is the name of the virtual vector. An _INTVEC will be appended
   64+    X     to it in the C definitions in intvecs.h, but otherwise the name is unmolested.
   65+    X     Case is significant only if you want it to be. The R3K/R4K has an option where
   66+    X     a number of vectors are maintained in an array of pointers rather than each
dispatch.c                               Atari Games Corp. macpp v9.12   "Oct 16 1997 13:26:41"


   67+    X     one having its own name. The index into the array is same as the number
   68+    X     returned in the processor's CAUSE register for that particluar interrupt. This
   69+    X     procedure is done simply for performance reasons. The option is selected by
   70+    X     using a 0 for this field and using an installer function with the vector index
   71+    X     as the parameter to the installer.
   72+          
   73+    X     Field 4 = Vector pointer
   74+          
   75+    X     This field identifies the name of a variable in BSS that contains a pointer
   76+    X     to the function to call at interrupt (or will be set by the prc_set_vec()
   77+    X     function). This is the name of the "soft" or logical vector and is either
   78+    X     declared in dispatch.c or externally according to the INT/EXT field described
   79+    X     next.
   80+          
   81+    X     Field 5 = INTernal or EXTernal vector
   82+          
   83+    X     This field contains the keywords INT, EXT, VINT or VEXT identifying the vector
   84+    X     in field 4 as being defined INTernally, EXTernally, Volatile INTernally or
   85+    X     Volatile Externally to dispatch.c respectively.
   86+          
   87+    X     Field 6 = name of vector installer
   88+          
   89+    X     This field identifies the name of a function that prc_set_vec() will call to
   90+    X     actually install the vector or 0 if there is no special stuff that needs to
   91+    X     be performed during vector installation.
   92+          
   93+    X     Field 7 = Notes for the installer.
   94+          
   95+    X     The Notes field is a parameter that is passed to the installer if there is one.
   96+          
   97+    X     Field 8 = Physical vector attachment.
   98+          
   99+    X     A dispatch routine is constructed for each of the 4 XBUS interrupts and for each of
  100+    X     the 6 CPU interrupts.  This field instructs phx_vecs.mac into which of the XBUS or
  101+    X     INTx dispatchers a caller to this vector belongs.  If this vector is not associated
  102+    X     with an XBUS or an INTx interrupt, it needs to be -1.  Place the interrupt routines
  103+    X     in this table in the order in which you want them executed.
  104+          
  105+    X     Field 9 = Default function.
  106+          
  107+    X     Name of default routine to install in the vector, or 0 if none.  phx_vecs.mac builds
  108+    X     a function called prc_init_vecs(void) which, when called, will perform a string of
  109+    X     prc_set_vec()'s for all the vectors having this field non-zero.  After the vectors
  110+    X     have been loaded, prc_init_vecs(void) will map the phoenix and galileo interrupts as
  111+    X     specified in phoenix.mac.
  112+          
  113+    X     Field 10 = Comments.
  114+          
  115+    X     The Comments field is placed on selected lines in intvecs.h and/or dispatch.c
  116+    X     as simple 'C' comments.
  117+          
  118+   (2)     .endc				; Don't move this line
  119+          ;
  120+          ;   Condit	Name	   Vector   I/E	Installer   Notes      Phys	Default	Comments
  121+          ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  122+          VDF <T,1>	GAMEVB,	   gameint, EXT	0,          0,		-1,	0,	< post-wierdness Vblank >
  123+          VDF <T,1>	MS4,       ms4vec,  EXT	0,          0,		-1,	0,	< 4 Millisecond timer >
dispatch.c                               Atari Games Corp. macpp v9.12   "Oct 16 1997 13:26:41"


  124+          VDF <T,1>	PRC_DELAY, prc_delay_vec, EXT 0,    0,		-1,	sst_prc_delay, < prc_delay soft vector >
  125+          VDF <T,1>	PRC_SET_IPL, set_ipl_vec, INT 0,    0,		-1,	0,	< prc_set_ipl soft vector >
  126+          VDF <T,1>	SAVE,      savintp, EXT 0,          0,		-1,	0,	< context save soft vector >
  127+          VDF <T,1>	RESTORE,   restintp,EXT 0,          0,		-1,	0,	< context restore soft vector >
  128+          VDF <T,1>	SW0,	   0,	    INT hwvinst,    VN_IRQ0,    -1,	0,	< Software interrupt 0 >
  129+          VDF <T,1>	SW1,	   0,       INT hwvinst,    VN_IRQ1,    -1,	0,	< Software interrupt 0 >
  130+          VDF <T,1>	INT0,	   0,       INT hwvinst,    VN_IRQ2,    -1,	int0_irq, < Hardware interrupt 0 >
  131+          VDF <T,1>	INT1,	   0,	    INT hwvinst,    VN_IRQ3,    -1,	int1_irq, < Hardware interrupt 1 >
  132+          VDF <T,PHX>	INT2,	   0,	    INT hwvinst,    VN_IRQ4,    -1,	int2_irq, < Hardware interrupt 2 >
  133+          VDF <T,1>	INT3,	   0,       INT hwvinst,    VN_IRQ5,    -1,	int3_irq, < Hardware interrupt 3 >
  134+          VDF <T,1>	INT4,	   0,	    INT hwvinst,    VN_IRQ6,    -1,	int4_irq, < Hardware interrupt 4 >
  135+          VDF <T,1>	INT5,	   0,	    INT hwvinst,    VN_IRQ7,    -1,	int5_irq, < Hardware interrupt 5 >
  136+          VDF <T,1>	TLBMOD,	   0,	    INT hwvinst,    VN_TLBM,    -1,	0,	< TLB modification >
  137+          VDF <T,1>	TLBLOAD,   0,	    INT hwvinst,    VN_TLBL,    -1,	0,	< TLB miss on I or D fetch >
  138+          VDF <T,1>	TLBSTORE,  0,	    INT hwvinst,    VN_TLBS,    -1,	0,	< TLB miss on store >
  139+          VDF <T,1>	ADDRERRL,  0,	    INT hwvinst,    VN_ADDRL,   -1,	0,	< Address error on I or D fetch >
  140+          VDF <T,1>	ADDRERRS,  0,	    INT hwvinst,    VN_ADDRS,   -1,	0,	< Address error on store >
  141+          VDF <T,1>	BUSERRI,   0,	    INT hwvinst,    VN_BUSERRI, -1,	0,	< Bus error on I-fetch >
  142+          VDF <T,1>	BUSERRD,   0,	    INT hwvinst,    VN_BUSERRD, -1,	0,	< Bus error on D-fetch >
  143+          VDF <T,1>	SYSCALL,   0,       INT hwvinst,    VN_SYSCALL, -1,	0,	< SYSCALL instruction >
  144+          VDF <T,1>	BREAK,     0,       INT hwvinst,    VN_BREAK,   -1,	0,	< Breakpoint instruction >
  145+          VDF <T,1>	RESERV,    0,       INT hwvinst,    VN_RESERV,  -1,	0,	< Reserved instruction >
  146+          VDF <T,1>	COPROC,    0,       INT hwvinst,    VN_COPROC,  -1,	0,	< Coprocessor unusable >
  147+          VDF <T,1>	OVRFLOW,   0,       INT hwvinst,    VN_OVERFL,  -1,	0,	< Integer Arithmetic Overflow >
  148+          VDF <T,1>	TRAP,      0,       INT hwvinst,    VN_TRAPV,   -1,	0,	< TRAP exception >
  149+          VDF <T,1>	FLOAT,     0,       INT hwvinst,    VN_FPE,     -1,	0,	< FLoating point exception >
  150+          VDF <T,1>	TIMER,	   timervec, INT 0,	    0,          -1,	0,	< Soft Timer interrupt >
  151+          VDF <T,1>	TIMERPLL,  tpllvec, VEXT 0,	    0,		-1,	0,	<Adjust 1MS timer>
  152+          VDF <T,1>	GAMEFRAME, framevec,INT 0,	    0,		-1,	0,	< Frame complete >
  153+   (2)    .if true, PHX
  154+    X     VDF <D,NET_LVL>	NET,       netintp, INT 0,          0,		NET_LVL,0,	< network int soft vector >
  155+    X     VDF <D,XBUS>	XBUS,	   xbusintp, INT pvinst,    XBUS_NOTES,	XBUS_LVL,xbus_irq, < Any XBUS interrupt >
  156+    X     VDF <T,XS0>	XS0,       xs0intp, INT pvinst,	    XS0_NOTES,	XS0_LVL,0,	< Expansion Slot 0 interrupt >
  157+    X     VDF <T,XS1>	XS1,       xs1intp, INT pvinst,	    XS1_NOTES,	XS1_LVL,0,	< Expansion Slot 1 interrupt >
  158+    X     VDF <T,XS2>	XS2,       xs2intp, INT pvinst,	    XS2_NOTES,	XS2_LVL,0,	< Expansion Slot 2 interrupt >
  159+    X     VDF <T,XS3>	XS3,       xs3intp, INT pvinst,	    XS3_NOTES,	XS3_LVL,0,	< Expansion Slot 3 interrupt >
  160+    X     VDF <T,MIO>	MIO,       miointp, INT pvinst,	    MIO_NOTES,	MIO_LVL,0,	< Miscellaneous I/O interrupt >
  161+    X     VDF <T,CU1>	CU1,       cu1intp, INT pvinst,	    CU1_NOTES,	CU1_LVL,0,	< Combo UART 1 interrupt >
  162+    X     VDF <T,CU2>	CU2,       cu2intp, INT pvinst,	    CU2_NOTES,	CU2_LVL,0,	< Combo UART 2 interrupt >
  163+    X     VDF <T,CPP>	CPP,       cppintp, INT pvinst,	    CPP_NOTES,	CPP_LVL,0,	< Combo Parallel Port interrupt >
  164+    X     VDF <T,PCA>	PCA,       pcaintp, INT pvinst,	    PCA_NOTES,	PCA_LVL,0,	< PCI A interrupt >
  165+    X     VDF <T,PCB>	PCB,       pcbintp, INT pvinst,	    PCB_NOTES,	PCB_LVL,0,	< PCI B interrupt >
  166+    X     VDF <T,PCC>	PCC,       pccintp, INT pvinst,	    PCC_NOTES,	PCC_LVL,0,	< PCI C interrupt >
  167+    X     VDF <T,VSY>	VSY,       vsyintp, INT pvinst,	    VSY_NOTES,	VSY_LVL,0,	< PCI D (VSYNC) interrupt >
  168+    X     VDF <T,IDE>	IDE,	   ideintp, INT pvinst,	    IDE_NOTES,	IDE_LVL,0,	< IDE interrupt >
  169+    X     VDF <T,IOA>	IOA,	   ioaintp, INT pvinst,	    IOA_NOTES,	IOA_LVL,ioa_irq,< I/O Asic interrupt >
  170+    X     VDF <T,ADC>	ADC,	   adcintp, INT pvinst,	    ADC_NOTES,	ADC_LVL,0,	< A/D Converter interrupt >
  171+    X     VDF <D,SND_I>	CAGE,      cagevec, INT 0,          0,		CAGE_LVL,aud_irq, < CAGE interrupt >
  172+   (2)    .endc
  173+   (2)    .if true, PAD || FLG || SEA || VEG
  174+          ;VDF <T,1>	IOA,	   0,	    INT hwvinst,    VN_IRQ3,	-1,	0,	< I/O Asic interrupt >
  175+          VDF <T,1>	IDE,	   0,	    INT hwvinst,    VN_IRQ4,    -1,	0,	< IDE interrupt >
  176+          VDF <T,EXP>	EXP,       expintp, INT pvinst,	    EXP_NOTES,	EXP_LVL,0,	< Expansion Slot interrupt >
  177+   (3)     .if true, PAD || SEA
  178+          VDF <T,NSS>	NSS,	   nssintp, INT pvinst,	    NSS_NOTES,  NSS_LVL,0,	< NSS/Hi-Link interrupt>
  179+   (3)     .endc
  180+   (3)     .if true, FLG
dispatch.c                               Atari Games Corp. macpp v9.12   "Oct 16 1997 13:26:41"


  181+    X     VDF <T,ETH>	ETH,	   ethintp, INT pvinst,     ETH_NOTES,  ETH_LVL,0,	< ethernet interrupt >
  182+    X     VDF <D,SND_I>	CAGE,	   cagevec, INT ioainst,    CAGE_NOTES, CAGE_LVL,aud_irq, < CAGE interrupt >
  183+   (3)     .endc
  184+          VDF <T,WD1>	WD1,	   wd1intp, INT pvinst,	    WD1_NOTES,  WD1_LVL,0,	< Widget interrupt 1>
  185+          VDF <T,PCI>	PCI,       pciintp, INT pvinst,	    PCI_NOTES,	PCI_LVL,0,	< PCI interrupt >
  186+          VDF <T,ADC>	ADC,	   adcintp, INT pvinst,	    ADC_NOTES,	ADC_LVL,0,	< A/D Converter interrupt >
  187+          VDF <T,WD2>	WD2,	   wd2intp, INT pvinst,	    WD2_NOTES,  WD2_LVL,0,	< Widget interrupt 2>
  188+          VDF <T,DBG>	DBG,	   dbgintp, INT pvinst,	    DBG_NOTES,	DBG_LVL,0,	< Debug switch interrupt >
  189+          VDF <T,VSY>	VSY,	   vsyintp, INT pvinst,	    VSY_NOTES,	VSY_LVL,0,	< VSYNC interrupt >
  190+   (2)    .endc
  191+          VDF <T,GAL>	GAL,	   0,       INT gvinst,	    GAL_NOTES,  GAL_LVL,galileoint, < Any Galileo Error Interrupt >
  192+          VDF <T,MOE>	MOE,	   moeintp, INT gvinst,	    MOE_NOTES,	MOE_LVL,0,	< Galileo MemOut >
  193+          VDF <T,DOE>	DOE,	   doeintp, INT gvinst,	    DOE_NOTES,	DOE_LVL,0,	< Galileo DMAOut >
  194+          VDF <T,COE>	COE,	   coeintp, INT gvinst,	    COE_NOTES,	COE_LVL,0,	< Galileo CPUOut >
  195+          VDF <T,DM0>	DM0,	   dm0intp, INT gvinst,	    DM0_NOTES,	DM0_LVL,0,	< Galileo DMA0Comp >
  196+          VDF <T,DM1>	DM1,	   dm1intp, INT gvinst,	    DM1_NOTES,	DM1_LVL,0,	< Galileo DMA1Comp >
  197+          VDF <T,DM2>	DM2,	   dm2intp, INT gvinst,	    DM2_NOTES,	DM2_LVL,0,	< Galileo DMA2Comp >
  198+          VDF <T,DM3>	DM3,	   dm3intp, INT gvinst,	    DM3_NOTES,	DM3_LVL,0,	< Galileo DMA3Comp >
  199+          VDF <T,TM0>	TM0,	   tm0intp, INT gvinst,	    TM0_NOTES,	TM0_LVL,0,	< Galileo T0Exp >
  200+          VDF <T,TM1>	TM1,	   tm1intp, INT gvinst,	    TM1_NOTES,	TM1_LVL,0,	< Galileo T1Exp >
  201+          VDF <T,TM2>	TM2,	   tm2intp, INT gvinst,	    TM2_NOTES,	TM2_LVL,0,	< Galileo T2Exp >
  202+          VDF <T,TM3>	TM3,	   tm3intp, INT gvinst,	    TM3_NOTES,	TM3_LVL,cputimerint, < Galileo T3EXP timer interrupt >
  203+          VDF <T,MRE>	MRE,	   mreintp, INT gvinst,	    MRE_NOTES,	MRE_LVL,0,	< Galileo MasRdErr >
  204+          VDF <T,SWE>	SWE,	   sweintp, INT gvinst,	    SWE_NOTES,	SWE_LVL,0,	< Galileo SlvWrErr >
  205+          VDF <T,MWE>	MWE,	   mweintp, INT gvinst,	    MWE_NOTES,	MWE_LVL,0,	< Galileo MasWrErr >
  206+          VDF <T,SRE>	SRE,	   sreintp, INT gvinst,	    SRE_NOTES,	SRE_LVL,0,	< Galileo SlvRdErr >
  207+          VDF <T,AEP>	AEP,	   aepintp, INT gvinst,	    AEP_NOTES,	AEP_LVL,0,	< Galileo AddrErr >
  208+          VDF <T,MEP>	MEP,	   mepintp, INT gvinst,	    MEP_NOTES,	MEP_LVL,0,	< Galileo MemErr >
  209+          VDF <T,MAS>	MAS,	   masintp, INT gvinst,	    MAS_NOTES,	MAS_LVL,0,	< Galileo MasAbort >
  210+          VDF <T,TAR>	TAR,	   tarintp, INT gvinst,	    TAR_NOTES,	TAR_LVL,0,	< Galileo TarAbort >
  211+          VDF <T,RTY>	RTY,	   rtyintp, INT gvinst,	    RTY_NOTES,	RTY_LVL,0,	< Galileo RetryCtr >
  212+          VDF <T,PC0>	PC0,	   pc0intp, INT gvinst,	    PC0_NOTES,	PC0_LVL,0,	< Galileo PCI Interrupt >
  213+          VDF <T,PC1>	PC1,	   pc1intp, INT gvinst,	    PC1_NOTES,	PC1_LVL,0,	< Galileo PCI Interrupt >
  214+          VDF <T,PC2>	PC2,	   pc2intp, INT gvinst,	    PC2_NOTES,	PC2_LVL,0,	< Galileo PCI Interrupt >
  215+          VDF <T,PC3>	PC3,	   pc3intp, INT gvinst,	    PC3_NOTES,	PC3_LVL,0,	< Galileo PCI Interrupt >
  216+          VDF <D,UART_LVL> UART,	   uartintp,INT ioainst,    UART_NOTES,	UART_LVL,0,	< I/O ASIC UART interrupts >
  217+          VDF <D,SND_LVL>	SND,	   sndintp, INT ioainst,    SND_NOTES,	SND_LVL, 0,	< I/O ASIC Sound interrupts >
  218+          VDF <D,MC_LVL>	MC,	   mcintp,  INT ioainst,    MC_NOTES,	MC_LVL,	0,	< I/O ASIC Microcontroller interrupt >
  219+          ;
  220+   (1)    .endc			; (_DISPATCH_MAC_&1) != 0 *** DON'T MOVE THIS LINE EITHER ***
  221+          ;
  222+          ;+++++++ From here on, there are few user servicable parts inside. ++++
  223+          ;
  224+          ; This is sortof how it works:
  225+          ; The first pass through, _DISPATCH_MAC_ will be 0 (set above by the .if not_defined).
  226+          ; First the copyright boilerplate is inserted into both output files and the macro VDF
  227+          ; is defined to create externs. Some struct definitions and unique externs are depositied
  228+          ; into the .h file. Next _DISPATCH_MAC_ is set to 1 and this file is .included
  229+          ; again. This will cause MACPP to read the VDF table above and output the appropriate
  230+          ; information in the .h file but ignore the rest of the file. The VDF macro is redefined,
  231+          ; and the procedure is repeated causing the creation of different items according to what
  232+          ; is needed. Once the whole .h file is built, the procedure repeats for the building of the
  233+          ; .c file.
  234+          ;
  235+   (1)    .if true, _DISPATCH_MAC_ == 0		; First (main) pass
  236+    X      PHX == 0
  237+    X      PAD == 0
dispatch.c                               Atari Games Corp. macpp v9.12   "Oct 16 1997 13:26:41"


  238+    X      FLG == 0
  239+    X      SEA == 0
  240+    X      VEG == 0
  241+    X      .iif true, HOST_BOARD == PHOENIX, PHX == 1 ;set the appropriate ones true as desired
  242+    X      .iif true, HOST_BOARD == PHOENIX_AD, PAD == 1 ;set the appropriate ones true as desired
  243+    X      .iif true, HOST_BOARD == FLAGSTAFF, FLG == 1 ;set the appropriate ones true as desired
  244+    X      .iif true, HOST_BOARD == SEATTLE, SEA == 1 ;set the appropriate ones true as desired
  245+    X      .iif true, HOST_BOARD == VEGAS, VEG == 1 ;set the appropriate ones true as desired
  246+          ;
  247+    X     	.macro .condit flag,exp		; The .condit macro does an expression test ...
  248+    X     	.if identical,<flag>,<T>
  249+    X     		.iif false,exp,.mexit 10 ; ... and aborts higher level macros if false
  250+    X     		.mexit
  251+    X     	.endc
  252+    X     	.if identical,<flag>,<F>
  253+    X     		.iif true,exp,.mexit 10	; ... etc.
  254+    X     		.mexit
  255+    X     	.endc
  256+    X     	.if identical,<flag>,<D>
  257+    X     		.iif not_defined,exp,.mexit 10
  258+    X     		.mexit
  259+    X     	.endc
  260+    X     	.if identical,<flag>,<N>
  261+    X     		.iif defined,exp,.mexit 10
  262+    X     		.mexit
  263+    X     	.endc
  264+    X     	.endm
  265+          ;	
  266+    X     	.macro boilerplate file_name
  267+    X     /*		file_name
  268+    X      *
  269+    X      *		Copyright 1996 Atari Games Corporation
  270+    X      *	Unauthorized reproduction, adaptation, distribution, performance or 
  271+    X      *	display of this computer program or the associated audiovisual work
  272+    X      *	is strictly prohibited.
  273+    X      *
  274+    X      * ++++++ WARNING WARNING WARNING WARNING WARNING +++++
  275+    X      * This file is machine generated. Any changes you put in here will be lost
  276+    X      * the next time phx_vecs.mac is touched. You need to make your changes to
  277+    X      * phx_vecs.mac instead of this file.
  278+    X      */
  279+    X     	.endm
  280+    X     	boilerplate dispatch.c
  281+    X     	.outfile	1		;The externs go into the .h file
  282+    X     	boilerplate intvecs.h
  283+    X     #if !defined(_INTVECS_H_)
  284+    X     #define _INTVECS_H_
  285+          
  286+    X     struct irq_tab {
  287+    X     	void 	(**softvec)();
  288+    X     	void    (*(*installer)(const struct irq_tab *, void(*new)()))();
  289+    X     	int	notes;
  290+    X     };
  291+          ;
  292+    X     	.macro VDF cond, name, softvec, intern, installer, notes, physical, default, comments
  293+    X     	.condit cond	
  294+    X      .if dif,<softvec>,<0>
dispatch.c                               Atari Games Corp. macpp v9.12   "Oct 16 1997 13:26:41"


  295+    X       ...1 == 0
  296+    X       .iif idn,<intern>,<VINT>,...1 == 1
  297+    X       .iif idn,<intern>,<VEXT>,...1 == 1
  298+    X       .if true, ...1
  299+    X     extern	void (* volatile softvec)();	/* comments */
  300+    X       .iff
  301+    X     extern  void (*softvec)();	/* comments */
  302+    X       .endc
  303+    X      .endc
  304+    X     	.endm
  305+          ;
  306+    X     	_DISPATCH_MAC_ == 1		;next time we process the IRQ table
  307+    X     	.include phx_vecs.mac		;Make the externs
  308+          
  309+    X     enum vecs {
  310+    X     	.macro VDF cond, name, softvec, intern, installer, notes, physical, default, comments
  311+    X     	.condit cond	
  312+    X         name'_INTVEC,
  313+    X     	.endm
  314+    X     	.include phx_vecs.mac		;Make the enums
  315+    X         N_INTVECS
  316+    X     };
  317+          
  318+    X     void (*prc_set_vec (unsigned int vecnum, void (*routine)() ))();
  319+    X     void prc_init_vecs(void);		/* set the default vectors */
  320+          ;
  321+          ; Add a prototype for an as yet unused function
  322+    X     .if true, 0
  323+          
  324+    X     /*		prc_set_vecp(which, what)
  325+    X      *	Sets a special vector for the interrupt identified by <which>
  326+    X      *	to call the routine specified by <what>. <what> is
  327+    X      *	a struct that contains both a pointer to the code
  328+    X      *	to execute and an optional pointer to the private
  329+    X      *	variables for that routine. This is a change from the
  330+    X      *	behavior of prc_set_vec, and is intended to allow
  331+    X      *	multiple incarnations of a given device to share code.
  332+    X      */
  333+          
  334+    X     struct opaque;
  335+    X     extern struct VECP_vector {
  336+    X         void (*function)(struct opaque *);	/* Who you gonna call */
  337+    X         struct opaque *cookie;		/* a magic cookie to hand him */
  338+    X     } prc_set_vecp (
  339+    X         int __which,			/* one of xxx_INTVEC */
  340+    X         struct IRQ_vector __what		/* BY VALUE!!! */
  341+    X     );
  342+    X     .endc
  343+    X     #endif		/* _INTVECS_H_ */
  344+          ;
  345+          ; At this point, we have completed all processing of the .h file
  346+          ; so switch back to the .c file
  347+          ;
  348+    X     	.outfile	0		;switch back to dispatch.c
  349+          ;
  350+    X     #include <config.h>			/* begining of dispatch.c */
  351+    X     #include <os_proto.h>
dispatch.c                               Atari Games Corp. macpp v9.12   "Oct 16 1997 13:26:41"


  352+    X     #include <intvecs.h>
  353+          
  354+    X     #ifndef BLABF
  355+    X     # define BLABF(x)
  356+    X     #endif
  357+          
  358+    X     #ifndef BLAB
  359+    X     # define BLAB(x)
  360+    X     #endif
  361+          
  362+    X      .if true, 1
  363+    X     	.macro VDF cond, name, softvec, intern, installer, notes, physical, default, comments
  364+    X     	.condit cond	
  365+    X       .iif idn,<name>,<XBUS0>,.mexit
  366+    X       .iif idn,<name>,<XBUS1>,.mexit
  367+    X       .iif idn,<name>,<XBUS2>,.mexit
  368+    X       .iif idn,<name>,<XBUS3>,.mexit
  369+    X       .iif idn,<name>,<INT0>,.mexit
  370+    X       .iif idn,<name>,<INT1>,.mexit
  371+    X       .iif idn,<name>,<INT2>,.mexit
  372+    X       .iif idn,<name>,<INT3>,.mexit
  373+    X       .iif idn,<name>,<INT4>,.mexit
  374+    X       .iif idn,<name>,<INT5>,.mexit
  375+    X       .if true, PHX
  376+    X         .if true, physical == XBUS0_LVL
  377+    X     	  ...XBUS0 == ...XBUS0 + 1
  378+    X     	  .mexit
  379+    X         .endc
  380+    X         .if true, physical == XBUS1_LVL
  381+    X     	  ...XBUS1 == ...XBUS1 + 1
  382+    X     	  .mexit
  383+    X         .endc
  384+    X         .if true, physical == XBUS2_LVL
  385+    X     	  ...XBUS2 == ...XBUS2 + 1
  386+    X     	  .mexit
  387+    X         .endc
  388+    X         .if true, physical == XBUS3_LVL
  389+    X     	  ...XBUS3 == ...XBUS3 + 1
  390+    X     	  .mexit
  391+    X         .endc
  392+    X       .endc
  393+    X       .if true, physical == INT0_LVL
  394+    X         	...INT0 == ...INT0 + 1
  395+    X     	.mexit
  396+    X       .endc
  397+    X       .if true, physical == INT1_LVL
  398+    X         	...INT1 == ...INT1 + 1
  399+    X        .if true, PAD || FLG || SEA || VEG
  400+    X     	...IOA == ...IOA + 1
  401+    X         .if ndf, notes
  402+    X     #define notes IO_MAIN_GLOBAL_INT
  403+    X         .endc
  404+    X        .endc
  405+    X     	.mexit
  406+    X       .endc
  407+    X       .if true, physical == INT2_LVL
  408+    X         	...INT2 == ...INT2 + 1
dispatch.c                               Atari Games Corp. macpp v9.12   "Oct 16 1997 13:26:41"


  409+    X     	.mexit
  410+    X       .endc
  411+    X       .if true, physical == INT3_LVL
  412+    X         	...INT3 == ...INT3 + 1
  413+    X     	.mexit
  414+    X       .endc
  415+    X       .if true, physical == INT4_LVL
  416+    X         	...INT4 == ...INT4 + 1
  417+    X     	.mexit
  418+    X       .endc
  419+    X       .if true, physical == INT5_LVL
  420+    X         	...INT5 == ...INT5 + 1
  421+    X     	.mexit
  422+    X       .endc
  423+    X       .if true, physical == IOASIC_LVL
  424+    X         	...IOA == ...IOA + 1
  425+    X        .if ndf, notes
  426+    X     #define notes IO_MAIN_GLOBAL_INT
  427+    X        .endc
  428+    X     	.mexit
  429+    X       .endc
  430+    X     	.endm
  431+    X     ...XBUS0 == 0
  432+    X     ...XBUS1 == 0
  433+    X     ...XBUS2 == 0
  434+    X     ...XBUS3 == 0
  435+    X     ...INT0 == 0
  436+    X     ...INT1 == 0
  437+    X     ...INT2 == 0
  438+    X     ...INT3 == 0
  439+    X     ...INT4 == 0
  440+    X     ...INT5 == 0
  441+    X     ...IOA == 0
  442+    X     	.include phx_vecs.mac	; count vectors requiring dispatch
  443+    X      .endc
  444+          ; 
  445+    X     .macro VDF cond, name, softvec, intern, installer, notes, physical, default, comments
  446+    X      .condit cond	
  447+    X      .if dif,<softvec>,<0>
  448+    X       .if idn,<intern>,<INT>
  449+    X     void (*softvec)();	/* comments */
  450+    X       .endc
  451+    X       .if idn,<intern>,<VINT>
  452+    X     void (* volatile softvec)();	/* comments */
  453+    X       .endc
  454+    X      .endc
  455+    X      .if dif,<default>,<0>
  456+    X       .if idn,<name>,<INT0>
  457+    X        .if true, ...INT0
  458+    X     static void 'default'(void);	/* comments */
  459+    X        .endc
  460+    X        .mexit
  461+    X       .endc
  462+    X       .if idn,<name>,<INT1>
  463+    X        .if true, ...INT1
  464+    X     static void 'default'(void);	/* comments */
  465+    X        .endc
dispatch.c                               Atari Games Corp. macpp v9.12   "Oct 16 1997 13:26:41"


  466+    X        .mexit
  467+    X       .endc
  468+    X       .if idn,<name>,<INT2>
  469+    X        .if true, ...INT2
  470+    X     static void 'default'(void);	/* comments */
  471+    X        .endc
  472+    X        .mexit
  473+    X       .endc
  474+    X       .if idn,<name>,<INT3>
  475+    X        .if true, ...INT3
  476+    X     static void 'default'(void);	/* comments */
  477+    X        .endc
  478+    X        .mexit
  479+    X       .endc
  480+    X       .if idn,<name>,<INT4>
  481+    X        .if true, ...INT4
  482+    X     static void 'default'(void);	/* comments */
  483+    X        .endc
  484+    X        .mexit
  485+    X       .endc
  486+    X       .if idn,<name>,<INT5>
  487+    X        .if true, ...INT5
  488+    X     static void 'default'(void);	/* comments */
  489+    X        .endc
  490+    X        .mexit
  491+    X       .endc
  492+    X       .if idn,<name>,<INT6>
  493+    X        .if true, ...INT6
  494+    X     static void 'default'(void);	/* comments */
  495+    X        .endc
  496+    X        .mexit
  497+    X       .endc
  498+    X       .if idn,<name>,<INT7>
  499+    X        .if true, ...INT7
  500+    X     static void 'default'(void);	/* comments */
  501+    X        .endc
  502+    X        .mexit
  503+    X       .endc
  504+    X       .if true, PHX
  505+    X        .if idn,<name>,<XBUS>
  506+    X         .if true, ...XBUS0|...XBUS1|...XBUS2|...XBUS3
  507+    X     static void 'default'(void);
  508+    X         .endc
  509+    X         .mexit
  510+    X        .endc
  511+    X        .if idn,<name>,<XBUS0>
  512+    X         .if true, ...XBUS0
  513+    X     static void 'default'(void);
  514+    X         .endc
  515+    X         .mexit
  516+    X        .endc
  517+    X        .if idn,<name>,<XBUS1>
  518+    X         .if true, ...XBUS1
  519+    X     static void 'default'(void);
  520+    X         .endc
  521+    X         .mexit
  522+    X        .endc
dispatch.c                               Atari Games Corp. macpp v9.12   "Oct 16 1997 13:26:41"


  523+    X        .if idn,<name>,<XBUS2>
  524+    X         .if true, ...XBUS2
  525+    X     static void 'default'(void);
  526+    X         .endc
  527+    X         .mexit
  528+    X        .endc
  529+    X        .if idn,<name>,<XBUS3>
  530+    X         .if true, ...XBUS3
  531+    X     static void 'default'(void);
  532+    X         .endc
  533+    X         .mexit
  534+    X        .endc
  535+    X       .endc			; PHX
  536+    X       .if idn,<name>,<IOA>
  537+    X        .if true, ...IOA
  538+    X     static void 'default'(void);
  539+    X        .endc
  540+    X        .mexit
  541+    X       .endc
  542+    X     extern void 'default'(void);
  543+    X      .endc
  544+    X     .endm
  545+    X     	.include phx_vecs.mac		;Declare the non-extern vectors
  546+          ;
  547+    X      .if true, ((PROCESSOR&-16) == MIPS3000) || ((PROCESSOR&-16) == MIPS4000)
  548+    X     static void (*hwvinst(const struct irq_tab *, void (*)()))();
  549+    X      .endc
  550+          ;
  551+    X     .if df, PHOENIX_INTCTL_MASK
  552+    X     static void (*pvinst(const struct irq_tab *, void (*)()))();
  553+    X     .endc
  554+          ;
  555+    X     .if df, GALILEO_INTCTL_MASK
  556+    X     static void (*gvinst(const struct irq_tab *, void (*)()))();
  557+    X     .endc
  558+          ;
  559+    X     .if true, ...IOA
  560+    X     static void (*ioainst(const struct irq_tab *, void (*)()))();
  561+    X     .endc
  562+          ;
  563+    X     static const struct irq_tab irq_inits[] = {
  564+    X     	.macro VDF cond, name, softvec, intern, installer, notes, physical, default, comments
  565+    X     	.condit cond	
  566+    X      .if dif,<softvec>,<0>
  567+    X      { (void (**)())&softvec, installer, notes },	/* comments */
  568+    X      .iff
  569+    X      { 0, installer, notes },	/* comments */
  570+    X      .endc
  571+    X     	.endm
  572+    X     	.include phx_vecs.mac		;Build the irq_inits array
  573+    X      { 0, 0, 0} };
  574+          ;
  575+    X     .if true, ((PROCESSOR&-16) == MIPS3000) || ((PROCESSOR&-16) == MIPS4000)
  576+          
  577+    X     extern void (*ramv_tbl[])();
  578+          
  579+    X     static void (*hwvinst(const struct irq_tab *it, void (*new)()))() {
dispatch.c                               Atari Games Corp. macpp v9.12   "Oct 16 1997 13:26:41"


  580+    X         int indx;
  581+    X         void (*old_rtn)();
  582+          
  583+    X         indx = it->notes;
  584+    X         if (indx >= VN_MAX) return 0;
  585+    X         old_rtn = ramv_tbl[indx];
  586+    X         ramv_tbl[indx] = new;
  587+    X         return old_rtn;
  588+    X     }
  589+          
  590+    X      .if df, PHOENIX_INTCTL_MASK
  591+    X     static void (*pvinst(const struct irq_tab *it, void (*new)()))() {
  592+          
  593+    X         if (it->notes) {
  594+    X     	BLABF(("\ndispatch: Adding 0x%08lX to main INTCTL (0x%08lX)...", it->notes, *(VU32*)INTCTL_IE));
  595+    X     	*((VU32 *)(INTCTL_IE)) |= it->notes;
  596+    X         }
  597+    X         return 0;
  598+    X     }
  599+    X      .endc
  600+          
  601+    X      .if df, GALILEO_INTCTL_MASK
  602+    X     static void (*gvinst(const struct irq_tab *it, void (*new)()))() {
  603+          
  604+    X         if (it->notes) {
  605+    X     	BLABF(("\ndispatch: Adding 0x%08lX to Galileo INTCTL (0x%08lX)...", it->notes, \
  606+    X     			*(VU32*)GALILEO_CPU_I_ENA));
  607+    X     	*((VU32 *)(GALILEO_CPU_I_ENA)) |= it->notes;
  608+    X         }
  609+    X         return 0;
  610+    X     }
  611+    X      .endc
  612+          
  613+    X      .if true, ...IOA
  614+    X     static void (*ioainst(const struct irq_tab *it, void (*new)()))() {
  615+    X     extern void prc_wait_n_usecs( int );
  616+    X         if (it->notes)
  617+    X         {
  618+    X          BLABF(("\ndispatch: Adding 0x%04X to IOASIC INTCTL: (0x%04X)...", (int)it->notes, \
  619+    X     		*(VU32*)IO_MAIN_CTL&0xFFFF));
  620+    X          while ( ( *((VU32 *)IO_MAIN_CTL) & it->notes ) != it->notes )
  621+    X          {
  622+    X     #ifdef LED_OUT
  623+    X           *(VU32 *)LED_OUT = ~( 1 << B_LED_RED );
  624+    X     #endif
  625+    X           do
  626+    X           {
  627+    X            *((VU32 *)IO_MAIN_CTL) |= it->notes;
  628+    X            prc_wait_n_usecs( 1000 );
  629+    X           } while ( ( *((VU32 *)IO_MAIN_CTL) & it->notes ) != it->notes );
  630+    X           prc_wait_n_usecs( 1000 );
  631+    X     #ifdef LED_OUT
  632+    X           *(VU32 *)LED_OUT |= ( 1 << B_LED_RED );
  633+    X     #endif
  634+    X          }
  635+    X         }
  636+    X         return 0;
dispatch.c                               Atari Games Corp. macpp v9.12   "Oct 16 1997 13:26:41"


  637+    X     }
  638+    X      .endc
  639+    X     .endc
  640+          
  641+    X     void (*prc_set_vec (unsigned int vecnum, void (*routine)() ))()
  642+    X     {
  643+    X         void (*old_rtn)();
  644+    X         void (**softvec)();
  645+    X         const struct irq_tab *tbp;
  646+    X         int old_ipl;
  647+          
  648+    X         if ( vecnum >= N_INTVECS ) return 0;
  649+    X         tbp = irq_inits+vecnum;
  650+    X         softvec = tbp->softvec;
  651+    X         old_rtn = 0;
  652+    X         old_ipl = prc_set_ipl(INTS_OFF);
  653+    X         if ( tbp->installer ) old_rtn = tbp->installer(tbp, routine);
  654+    X         if ( softvec ) {
  655+    X     	if (!old_rtn) old_rtn = *softvec;
  656+    X     	*softvec = routine;
  657+    X         }
  658+    X         prc_set_ipl(old_ipl);
  659+    X         return old_rtn;
  660+    X     }
  661+          
  662+    X      .if true, PHX
  663+    X       .if true, ...XBUS0
  664+    X     static void xbus0_irq(void) {
  665+    X     	.macro VDF cond, name, softvec, intern, installer, notes, physical, default, comments
  666+    X     	.condit cond	
  667+    X       .iif idn,<name>,<XBUS0>,.mexit
  668+    X       .iif idn,<softvec>,<0>,.mexit
  669+    X       .if true, physical == XBUS0_LVL
  670+    X         if (softvec) softvec();
  671+    X       .endc
  672+    X     	.endm
  673+    X     	.include phx_vecs.mac		; pickup all vectors assigned to XBUS0_LVL
  674+    X         return;
  675+    X     }
  676+          
  677+    X       .endc		; ...XBUS0
  678+    X       .if true, ...XBUS1
  679+    X     static void xbus1_irq(void) {
  680+    X     	.macro VDF cond, name, softvec, intern, installer, notes, physical, default, comments
  681+    X     	.condit cond	
  682+    X       .iif idn,<name>,<XBUS1>,.mexit
  683+    X       .iif idn,<softvec>,<0>,.mexit
  684+    X       .if true, physical == XBUS1_LVL
  685+    X         if (softvec) softvec();
  686+    X       .endc
  687+    X     	.endm
  688+    X     	.include phx_vecs.mac		; pickup all vectors assigned to XBUS1_LVL
  689+    X         return;
  690+    X     }
  691+          
  692+    X       .endc		; ...XBUS1
  693+    X       .if true, ...XBUS2
dispatch.c                               Atari Games Corp. macpp v9.12   "Oct 16 1997 13:26:41"


  694+    X     static void xbus2_irq(void) {
  695+    X     	.macro VDF cond, name, softvec, intern, installer, notes, physical, default, comments
  696+    X     	.condit cond	
  697+    X       .iif idn,<name>,<XBUS2>,.mexit
  698+    X       .iif idn,<softvec>,<0>,.mexit
  699+    X       .if true, physical == XBUS2_LVL
  700+    X         if (softvec) softvec();
  701+    X       .endc
  702+    X     	.endm
  703+    X     	.include phx_vecs.mac		; pickup all vectors assigned to XBUS2_LVL
  704+    X         return;
  705+    X     }
  706+          
  707+    X       .endc		; ...XBUS2
  708+    X       .if true, ...XBUS3
  709+    X     static void xbus3_irq(void) {
  710+    X     	.macro VDF cond, name, softvec, intern, installer, notes, physical, default, comments
  711+    X     	.condit cond	
  712+    X       .iif idn,<name>,<XBUS3>,.mexit
  713+    X       .iif idn,<softvec>,<0>,.mexit
  714+    X       .if true, physical == XBUS3_LVL
  715+    X         if (softvec) softvec();
  716+    X       .endc
  717+    X     	.endm
  718+    X     	.include phx_vecs.mac		; pickup all vectors assigned to XBUS3_LVL
  719+    X         return;
  720+    X     }
  721+          
  722+    X       .endc		; ...XBUS3
  723+    X      .endc		; PHX
  724+    X      .if true, ...INT0
  725+    X     static void int0_irq(void) {
  726+    X     	.macro VDF cond, name, softvec, intern, installer, notes, physical, default, comments
  727+    X     	.condit cond	
  728+    X       .iif idn,<name>,<INT0>,.mexit
  729+    X       .iif idn,<softvec>,<0>,.mexit
  730+    X       .if true, physical == INT0_LVL
  731+    X         if (softvec) softvec();
  732+    X       .endc
  733+    X     	.endm
  734+    X     	.include phx_vecs.mac		; pickup all vectors assigned to IRQ 0
  735+    X         return;
  736+    X     }
  737+          
  738+    X      .endc		; ...INT0
  739+    X      .if true, ...INT1
  740+    X     static void int1_irq(void) {
  741+    X     	.macro VDF cond, name, softvec, intern, installer, notes, physical, default, comments
  742+    X     	.condit cond	
  743+    X       .iif idn,<name>,<INT1>,.mexit
  744+    X       .iif idn,<softvec>,<0>,.mexit
  745+    X       .if true, physical == INT1_LVL
  746+    X         if (softvec) softvec();
  747+    X       .endc
  748+    X     	.endm
  749+    X     	.include phx_vecs.mac		; pickup all vectors assigned to IRQ 1
  750+    X         return;
dispatch.c                               Atari Games Corp. macpp v9.12   "Oct 16 1997 13:26:41"


  751+    X     }
  752+          
  753+    X      .endc		; ...INT1
  754+    X      .if true, ...INT2
  755+    X     static void int2_irq(void) {
  756+    X     	.macro VDF cond, name, softvec, intern, installer, notes, physical, default, comments
  757+    X     	.condit cond	
  758+    X       .iif idn,<name>,<INT2>,.mexit
  759+    X       .iif idn,<softvec>,<0>,.mexit
  760+    X       .if true, physical == INT2_LVL
  761+    X         if (softvec) softvec();
  762+    X       .endc
  763+    X     	.endm
  764+    X     	.include phx_vecs.mac		; pickup all vectors assigned to IRQ 2
  765+    X         return;
  766+    X     }
  767+          
  768+    X      .endc		; ...INT2
  769+    X      .if true, ...INT3
  770+    X     static void int3_irq(void) {
  771+    X     	.macro VDF cond, name, softvec, intern, installer, notes, physical, default, comments
  772+    X     	.condit cond	
  773+    X       .iif idn,<name>,<INT3>,.mexit
  774+    X       .iif idn,<softvec>,<0>,.mexit
  775+    X       .if true, physical == INT3_LVL
  776+    X         if (softvec) softvec();
  777+    X       .endc
  778+    X     	.endm
  779+    X     	.include phx_vecs.mac		; pickup all vectors assigned to IRQ 3
  780+    X         return;
  781+    X     }
  782+          
  783+    X      .endc		; ...INT3
  784+    X      .if true, ...INT4
  785+    X     static void int4_irq(void) {
  786+    X     	.macro VDF cond, name, softvec, intern, installer, notes, physical, default, comments
  787+    X     	.condit cond	
  788+    X       .iif idn,<name>,<INT4>,.mexit
  789+    X       .iif idn,<softvec>,<0>,.mexit
  790+    X       .if true, physical == INT4_LVL
  791+    X         if (softvec) softvec();
  792+    X       .endc
  793+    X     	.endm
  794+    X     	.include phx_vecs.mac		; pickup all vectors assigned to IRQ 4
  795+    X         return;
  796+    X     }
  797+          
  798+    X      .endc		; ...INT4
  799+    X      .if true, ...INT5
  800+    X     static void int5_irq(void) {
  801+    X     	.macro VDF cond, name, softvec, intern, installer, notes, physical, default, comments
  802+    X     	.condit cond	
  803+    X       .iif idn,<name>,<INT5>,.mexit
  804+    X       .iif idn,<softvec>,<0>,.mexit
  805+    X       .if true, physical == INT5_LVL
  806+    X         if (softvec) softvec();
  807+    X       .endc
dispatch.c                               Atari Games Corp. macpp v9.12   "Oct 16 1997 13:26:41"


  808+    X     	.endm
  809+    X     	.include phx_vecs.mac		; pickup all vectors assigned to IRQ 5
  810+    X         return;
  811+    X     }
  812+          
  813+    X      .endc		; ...INT5
  814+    X      .if true, ...IOA && PHX
  815+    X     static void ioa_irq(void) {
  816+    X     	.macro VDF cond, name, softvec, intern, installer, notes, physical, default, comments
  817+    X     	.condit cond	
  818+    X       .iif idn,<name>,<IOA>,.mexit
  819+    X       .iif idn,<softvec>,<0>,.mexit
  820+    X       .if true, physical == IOASIC_LVL
  821+    X         if (softvec) softvec();
  822+    X       .endc
  823+    X     	.endm
  824+    X     	.include phx_vecs.mac		; pickup all vectors assigned to IRQ 5
  825+    X         return;
  826+    X     }
  827+          
  828+    X      .endc		; ...IOA
  829+    X      .if true, PHX
  830+    X       .if true, ...XBUS0|...XBUS1|...XBUS2|...XBUS3
  831+    X     static void xbus_irq(void) {
  832+    X         int which;
  833+    X         which = *(VU32 *)(XBUS_SLOT0+4);
  834+    X       .if true, ...XBUS0
  835+    X         if (!(which&1)) xbus0_irq();
  836+    X       .endc
  837+    X       .if true, ...XBUS1
  838+    X         if (!(which&2)) xbus1_irq();
  839+    X       .endc
  840+    X       .if true, ...XBUS2
  841+    X         if (!(which&4)) xbus2_irq();
  842+    X       .endc
  843+    X       .if true, ...XBUS3
  844+    X         if (!(which&8)) xbus3_irq();
  845+    X       .endc
  846+    X         return;
  847+    X     }
  848+    X       .endc
  849+    X      .endc		; PHX
  850+    X     void prc_init_vecs(void) {
  851+    X     	.macro VDF cond, name, softvec, intern, installer, notes, physical, default, comments
  852+    X     	.condit cond	
  853+    X     .if dif,<default>,<0>
  854+    X      .if true, PHX
  855+    X       .if idn,<name>,<XBUS0>
  856+    X        .iif true, ...XBUS0 == 0, .mexit
  857+    X       .endc
  858+    X       .if idn,<name>,<XBUS1>
  859+    X        .iif true, ...XBUS1 == 0, .mexit
  860+    X       .endc
  861+    X       .if idn,<name>,<XBUS2>
  862+    X        .iif true, ...XBUS2 == 0, .mexit
  863+    X       .endc
  864+    X       .if idn,<name>,<XBUS3>
dispatch.c                               Atari Games Corp. macpp v9.12   "Oct 16 1997 13:26:41"


  865+    X        .iif true, ...XBUS3 == 0, .mexit
  866+    X       .endc
  867+    X       .if idn,<name>,<XBUS>
  868+    X        .iif true, (...XBUS0|...XBUS1|...XBUS2|...XBUS3) == 0, .mexit
  869+    X       .endc
  870+    X      .endc	; PHX
  871+    X      .if idn,<name>,<INT0>
  872+    X       .iif true, ...INT0 == 0, .mexit
  873+    X      .endc
  874+    X      .if idn,<name>,<INT1>
  875+    X       .iif true, ...INT1 == 0, .mexit
  876+    X      .endc
  877+    X      .if idn,<name>,<INT2>
  878+    X       .iif true, ...INT2 == 0, .mexit
  879+    X      .endc
  880+    X      .if idn,<name>,<INT3>
  881+    X       .iif true, ...INT3 == 0, .mexit
  882+    X      .endc
  883+    X      .if idn,<name>,<INT4>
  884+    X       .iif true, ...INT4 == 0, .mexit
  885+    X      .endc
  886+    X      .if idn,<name>,<INT5>
  887+    X       .iif true, ...INT5 == 0, .mexit
  888+    X      .endc
  889+    X      .if idn,<name>,<IOA>
  890+    X       .iif true, ...IOA == 0, .mexit
  891+    X      .endc
  892+    X         prc_set_vec('name'_INTVEC, default);
  893+    X     .endc
  894+    X     	.endm
  895+    X     	.include phx_vecs.mac
  896+          
  897+    X     /* Map the Phoenix interrupts */
  898+          
  899+    X     .if df, INTCTL_MAPA_INIT
  900+    X         BLABF(("\ndispatch: Mapping the A interrupts: 0x%08lX...", INTCTL_MAPA_INIT));
  901+    X         *((VU32 *)(INTCTL_MAPA)) = INTCTL_MAPA_INIT;
  902+    X     .endc
  903+    X     .if df, INTCTL_MAPB_INIT
  904+    X         BLABF(("\ndispatch: Mapping the B interrupts: 0x%08lX...", INTCTL_MAPB_INIT));
  905+    X         *((VU32 *)(INTCTL_MAPB)) = INTCTL_MAPB_INIT;
  906+    X     .endc
  907+          
  908+    X     .if defined, ANNOUNCE_BOOT_ACTIONS
  909+    X      .if true, ANNOUNCE_BOOT_ACTIONS
  910+    X         {
  911+    X     	int jj;
  912+    X     	extern int prc_get_cause(void), prc_get_ipl(void);
  913+    X     	jj = prc_get_cause();
  914+    X     	if (jj&0xFF00) BLABF(("\ndispatch: CPU cause reg: %08lX, CPU SR reg: %08lX", jj, prc_get_ipl()));
  915+    X     	if (jj&0x0400) {
  916+    X       .if true, ...INT0
  917+    X     	.macro VDF cond, name, softvec, intern, installer, notes, physical, default, comments
  918+    X     	.condit cond	
  919+    X        .iif idn,<name>,<INT0>,.mexit
  920+    X        .iif idn,<softvec>,<0>,.mexit
  921+    X        .if true, physical == INT0_LVL
dispatch.c                               Atari Games Corp. macpp v9.12   "Oct 16 1997 13:26:41"


  922+    X     	    if (!softvec) BLAB("\ndispatch: Warning, IRQ 0 pending \"'comments'\"");
  923+    X        .endc
  924+    X     	.endm
  925+    X     	.include phx_vecs.mac		; pickup all vectors assigned to IRQ 0
  926+    X       .iff
  927+    X     	    BLAB("\ndispatch: Warning, IRQ 0 pending with no vector assigned");
  928+    X       .endc		; ...INT0
  929+    X     	}
  930+    X     	if (jj&0x0800) {
  931+    X       .if true, ...INT1
  932+    X     	.macro VDF cond, name, softvec, intern, installer, notes, physical, default, comments
  933+    X     	.condit cond	
  934+    X        .iif idn,<name>,<INT1>,.mexit
  935+    X        .iif idn,<softvec>,<0>,.mexit
  936+    X        .if true, physical == INT1_LVL
  937+    X     	    if (!softvec) BLAB("\ndispatch: Warning, IRQ 1 pending \"'comments'\"");
  938+    X        .endc
  939+    X     	.endm
  940+    X     	.include phx_vecs.mac		; pickup all vectors assigned to IRQ 1
  941+    X       .iff
  942+    X     	    BLAB("\ndispatch: Warning, IRQ 1 pending with no vector assigned");
  943+    X       .endc		; ...INT1
  944+    X     	}
  945+    X     	if (jj&0x1000) {
  946+    X       .if true, ...INT2
  947+    X     	.macro VDF cond, name, softvec, intern, installer, notes, physical, default, comments
  948+    X     	.condit cond	
  949+    X        .iif idn,<name>,<INT2>,.mexit
  950+    X        .iif idn,<softvec>,<0>,.mexit
  951+    X        .if true, physical == INT2_LVL
  952+    X     	    if (!softvec) BLAB("\ndispatch: Warning, IRQ 2 pending \"'comments'\"");
  953+    X        .endc
  954+    X     	.endm
  955+    X     	.include phx_vecs.mac		; pickup all vectors assigned to IRQ 2
  956+    X       .iff
  957+    X     	    BLAB("\ndispatch: Warning, IRQ 2 pending with no vector assigned");
  958+    X       .endc		; ...INT2
  959+    X     	}
  960+    X     	if (jj&0x2000) {
  961+    X       .if true, ...INT3
  962+    X     	.macro VDF cond, name, softvec, intern, installer, notes, physical, default, comments
  963+    X     	.condit cond	
  964+    X        .iif idn,<name>,<INT3>,.mexit
  965+    X        .iif idn,<softvec>,<0>,.mexit
  966+    X        .if true, physical == INT3_LVL
  967+    X     	    if (!softvec) BLAB("\ndispatch: Warning, IRQ 3 pending \"'comments'\"");
  968+    X        .endc
  969+    X     	.endm
  970+    X     	.include phx_vecs.mac		; pickup all vectors assigned to IRQ 3
  971+    X       .iff
  972+    X     	    BLAB("\ndispatch: Warning, IRQ 3 pending with no vector assigned");
  973+    X       .endc		; ...INT3
  974+    X     	}
  975+    X     	if (jj&0x4000) {
  976+    X       .if true, ...INT4
  977+    X     	.macro VDF cond, name, softvec, intern, installer, notes, physical, default, comments
  978+    X     	.condit cond	
dispatch.c                               Atari Games Corp. macpp v9.12   "Oct 16 1997 13:26:41"


  979+    X        .iif idn,<name>,<INT4>,.mexit
  980+    X        .iif idn,<softvec>,<0>,.mexit
  981+    X        .if true, physical == INT4_LVL
  982+    X     	    if (!softvec) BLAB("\ndispatch: Warning, IRQ 4 pending \"'comments'\"");
  983+    X        .endc
  984+    X     	.endm
  985+    X     	.include phx_vecs.mac		; pickup all vectors assigned to IRQ 4
  986+    X       .iff
  987+    X     	    BLAB("\ndispatch: Warning, IRQ 4 pending with no vector assigned");
  988+    X       .endc		; ...INT4
  989+    X     	}
  990+    X     	if (jj&0x8000) {
  991+    X       .if true, ...INT5
  992+    X     	.macro VDF cond, name, softvec, intern, installer, notes, physical, default, comments
  993+    X     	.condit cond	
  994+    X        .iif idn,<name>,<INT5>,.mexit
  995+    X        .iif idn,<softvec>,<0>,.mexit
  996+    X        .if true, physical == INT5_LVL
  997+    X     	    if (!softvec) BLAB("\ndispatch: Warning, IRQ 5 pending \"'comments'\"");
  998+    X        .endc
  999+    X     	.endm
 1000+    X     	.include phx_vecs.mac		; pickup all vectors assigned to IRQ 5
 1001+    X       .iff
 1002+    X     	    BLAB("\ndispatch: Warning, IRQ 5 pending with no vector assigned");
 1003+    X       .endc		; ...INT5
 1004+    X     	}
 1005+    X         }
 1006+    X      .endc		; true, ANNOUNCE_BOOT_ACTIONS
 1007+    X     .endc		; defined, ANNOUNCE_BOOT_ACTIONS
 1008+    X         return;
 1009+    X     }
 1010+   (1)    .endc		; _DISPATCH_MAC_ == 0
  896           
  897           /* Map the Phoenix interrupts */
  898           
  899    (1)    .if df, INTCTL_MAPA_INIT
  900               BLABF(("\ndispatch: Mapping the A interrupts: 0x%08lX...", INTCTL_MAPA_INIT));
  901               *((VU32 *)(INTCTL_MAPA)) = INTCTL_MAPA_INIT;
  902    (1)    .endc
  903    (1)    .if df, INTCTL_MAPB_INIT
  904     X         BLABF(("\ndispatch: Mapping the B interrupts: 0x%08lX...", INTCTL_MAPB_INIT));
  905     X         *((VU32 *)(INTCTL_MAPB)) = INTCTL_MAPB_INIT;
  906    (1)    .endc
  907           
  908    (1)    .if defined, ANNOUNCE_BOOT_ACTIONS
  909    (2)     .if true, ANNOUNCE_BOOT_ACTIONS
  910               {
  911           	int jj;
  912           	extern int prc_get_cause(void), prc_get_ipl(void);
  913           	jj = prc_get_cause();
  914           	if (jj&0xFF00) BLABF(("\ndispatch: CPU cause reg: %08lX, CPU SR reg: %08lX", jj, prc_get_ipl()));
  915           	if (jj&0x0400) {
  916    (3)      .if true, ...INT0
  917           	.macro VDF cond, name, softvec, intern, installer, notes, physical, default, comments
  918           	.condit cond	
  919              .iif idn,<name>,<INT0>,.mexit
  920              .iif idn,<softvec>,<0>,.mexit
dispatch.c                               Atari Games Corp. macpp v9.12   "Oct 16 1997 13:26:41"


  921              .if true, physical == INT0_LVL
  922           	    if (!softvec) BLAB("\ndispatch: Warning, IRQ 0 pending \"'comments'\"");
  923              .endc
  924           	.endm
  925           	.include phx_vecs.mac		; pickup all vectors assigned to IRQ 0
    1+          ;/*		phx_vecs.mac
    2+          ; *
    3+          ; *		Copyright 1996 Atari Games Corporation
    4+          ; *	Unauthorized reproduction, adaptation, distribution, performance or 
    5+          ; *	display of this computer program or the associated audiovisual work
    6+          ; *	is strictly prohibited.
    7+          ; *
    8+          ; *	This file is processed by MACPP to produce dispatch.c and intvecs.h.
    9+          ; *
   10+          ; *	The definitions placed in intvecs.h declare virtual vector numbers
   11+          ; *	in the form of xxx_INTVEC and a cross reference table(s) so the
   12+          ; *	dispatcher can call the appropriate functions.
   13+          ; *
   14+          ; *	intvecs.h should be #include'd by any module that uses prc_set_vec().
   15+          ; */
   16+          ;
   17+          ; This file recursivley '.includes' itself to succesively build up the approprate
   18+          ; tables and functions in C and places the results in one of two files (the
   19+          ; first -out=file supplied on the MACPP command line is expected to be dispatch.c
   20+          ; and the second -out=file is expected to be intvecs.h and the third is expected to
   21+          ; be /dev/null). If you don't speak fluent MACPP, then you probably shouldn't be
   22+          ; changing anything in this file other than the VDF table listed below.
   23+          ;
   24+   (4)    .if not_defined, _DISPATCH_MAC_		;1 +++++
   25+    X     _DISPATCH_MAC_ == 0			;2 Don't move ...
   26+    X     OUTPUT_LANG == 5 ;LANG_NONE		;3 ... or change ... 
   27+    X     	.outfile 2			;4 ... anything on ...
   28+    X     	.include config.mac		;5 ... these ...
   29+    X     	.outfile 0			;6 ... nine  ...
   30+   (4)    .endc					;7 ... lines ...
   31+   (4)    .if true, (_DISPATCH_MAC_&1) != 0	;8
   32+   (5)     .if true, 0				;9 -----
   33+          
   34+    X     You are free to add or remove entries from this table according to your
   35+    X     requirements. There are 10 fields used on each line in this table. The
   36+    X     description of each field follows:
   37+          
   38+    X     Field 1 = macro call
   39+          
   40+    X     It must always be the keyword VDF (case is not significant).
   41+          
   42+    X     Field 2 = condition
   43+          
   44+    X     This is a dual operand field, so the two operands together must be enclosed in
   45+    X     <>'s. The first operand is one of T, F, D or N representing True, False,
   46+    X     Defined or Not_defined respectively. Case is significant, use uppercase only
   47+    X     please. For the conditions T or F the second operand must be an expression
   48+    X     which must resolve to non-$0 (True) or $0 (False) in order for the macro
   49+    X     to be processed (else it is ignored). The expression can contain no embedded
   50+    X     spaces. For the conditions D and N, the second operand must only be a symbol
   51+    X     which must be Defined or Not-defined respectively in order for the macro to be
   52+    X     processed. Some short cut expressions have been preprocessed to make using the
dispatch.c                               Atari Games Corp. macpp v9.12   "Oct 16 1997 13:26:41"


   53+    X     expressions a little more concise. These are:
   54+          
   55+    X     	PHX = not $0 if HOST_BOARD == PHOENIX
   56+    X     	PAD = not $0 if HOST_BOARD == PHOENIX_AD
   57+    X     	FLG = not $0 if HOST_BOARD == FLAGSTAFF
   58+    X     	SEA = not $0 if HOST_BOARD == SEATTLE
   59+    X     	VEG = not $0 if HOST_BOARD == VEGAS
   60+          
   61+    X     Field 3 = vector name
   62+          
   63+    X     The NAME field is the name of the virtual vector. An _INTVEC will be appended
   64+    X     to it in the C definitions in intvecs.h, but otherwise the name is unmolested.
   65+    X     Case is significant only if you want it to be. The R3K/R4K has an option where
   66+    X     a number of vectors are maintained in an array of pointers rather than each
   67+    X     one having its own name. The index into the array is same as the number
   68+    X     returned in the processor's CAUSE register for that particluar interrupt. This
   69+    X     procedure is done simply for performance reasons. The option is selected by
   70+    X     using a 0 for this field and using an installer function with the vector index
   71+    X     as the parameter to the installer.
   72+          
   73+    X     Field 4 = Vector pointer
   74+          
   75+    X     This field identifies the name of a variable in BSS that contains a pointer
   76+    X     to the function to call at interrupt (or will be set by the prc_set_vec()
   77+    X     function). This is the name of the "soft" or logical vector and is either
   78+    X     declared in dispatch.c or externally according to the INT/EXT field described
   79+    X     next.
   80+          
   81+    X     Field 5 = INTernal or EXTernal vector
   82+          
   83+    X     This field contains the keywords INT, EXT, VINT or VEXT identifying the vector
   84+    X     in field 4 as being defined INTernally, EXTernally, Volatile INTernally or
   85+    X     Volatile Externally to dispatch.c respectively.
   86+          
   87+    X     Field 6 = name of vector installer
   88+          
   89+    X     This field identifies the name of a function that prc_set_vec() will call to
   90+    X     actually install the vector or 0 if there is no special stuff that needs to
   91+    X     be performed during vector installation.
   92+          
   93+    X     Field 7 = Notes for the installer.
   94+          
   95+    X     The Notes field is a parameter that is passed to the installer if there is one.
   96+          
   97+    X     Field 8 = Physical vector attachment.
   98+          
   99+    X     A dispatch routine is constructed for each of the 4 XBUS interrupts and for each of
  100+    X     the 6 CPU interrupts.  This field instructs phx_vecs.mac into which of the XBUS or
  101+    X     INTx dispatchers a caller to this vector belongs.  If this vector is not associated
  102+    X     with an XBUS or an INTx interrupt, it needs to be -1.  Place the interrupt routines
  103+    X     in this table in the order in which you want them executed.
  104+          
  105+    X     Field 9 = Default function.
  106+          
  107+    X     Name of default routine to install in the vector, or 0 if none.  phx_vecs.mac builds
  108+    X     a function called prc_init_vecs(void) which, when called, will perform a string of
  109+    X     prc_set_vec()'s for all the vectors having this field non-zero.  After the vectors
dispatch.c                               Atari Games Corp. macpp v9.12   "Oct 16 1997 13:26:41"


  110+    X     have been loaded, prc_init_vecs(void) will map the phoenix and galileo interrupts as
  111+    X     specified in phoenix.mac.
  112+          
  113+    X     Field 10 = Comments.
  114+          
  115+    X     The Comments field is placed on selected lines in intvecs.h and/or dispatch.c
  116+    X     as simple 'C' comments.
  117+          
  118+   (5)     .endc				; Don't move this line
  119+          ;
  120+          ;   Condit	Name	   Vector   I/E	Installer   Notes      Phys	Default	Comments
  121+          ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  122+          VDF <T,1>	GAMEVB,	   gameint, EXT	0,          0,		-1,	0,	< post-wierdness Vblank >
  123+          VDF <T,1>	MS4,       ms4vec,  EXT	0,          0,		-1,	0,	< 4 Millisecond timer >
  124+          VDF <T,1>	PRC_DELAY, prc_delay_vec, EXT 0,    0,		-1,	sst_prc_delay, < prc_delay soft vector >
  125+          VDF <T,1>	PRC_SET_IPL, set_ipl_vec, INT 0,    0,		-1,	0,	< prc_set_ipl soft vector >
  126+          VDF <T,1>	SAVE,      savintp, EXT 0,          0,		-1,	0,	< context save soft vector >
  127+          VDF <T,1>	RESTORE,   restintp,EXT 0,          0,		-1,	0,	< context restore soft vector >
  128+          VDF <T,1>	SW0,	   0,	    INT hwvinst,    VN_IRQ0,    -1,	0,	< Software interrupt 0 >
  129+          VDF <T,1>	SW1,	   0,       INT hwvinst,    VN_IRQ1,    -1,	0,	< Software interrupt 0 >
  130+          VDF <T,1>	INT0,	   0,       INT hwvinst,    VN_IRQ2,    -1,	int0_irq, < Hardware interrupt 0 >
  131+          VDF <T,1>	INT1,	   0,	    INT hwvinst,    VN_IRQ3,    -1,	int1_irq, < Hardware interrupt 1 >
  132+          VDF <T,PHX>	INT2,	   0,	    INT hwvinst,    VN_IRQ4,    -1,	int2_irq, < Hardware interrupt 2 >
  133+          VDF <T,1>	INT3,	   0,       INT hwvinst,    VN_IRQ5,    -1,	int3_irq, < Hardware interrupt 3 >
  134+          VDF <T,1>	INT4,	   0,	    INT hwvinst,    VN_IRQ6,    -1,	int4_irq, < Hardware interrupt 4 >
  135+          VDF <T,1>	INT5,	   0,	    INT hwvinst,    VN_IRQ7,    -1,	int5_irq, < Hardware interrupt 5 >
  136+          VDF <T,1>	TLBMOD,	   0,	    INT hwvinst,    VN_TLBM,    -1,	0,	< TLB modification >
  137+          VDF <T,1>	TLBLOAD,   0,	    INT hwvinst,    VN_TLBL,    -1,	0,	< TLB miss on I or D fetch >
  138+          VDF <T,1>	TLBSTORE,  0,	    INT hwvinst,    VN_TLBS,    -1,	0,	< TLB miss on store >
  139+          VDF <T,1>	ADDRERRL,  0,	    INT hwvinst,    VN_ADDRL,   -1,	0,	< Address error on I or D fetch >
  140+          VDF <T,1>	ADDRERRS,  0,	    INT hwvinst,    VN_ADDRS,   -1,	0,	< Address error on store >
  141+          VDF <T,1>	BUSERRI,   0,	    INT hwvinst,    VN_BUSERRI, -1,	0,	< Bus error on I-fetch >
  142+          VDF <T,1>	BUSERRD,   0,	    INT hwvinst,    VN_BUSERRD, -1,	0,	< Bus error on D-fetch >
  143+          VDF <T,1>	SYSCALL,   0,       INT hwvinst,    VN_SYSCALL, -1,	0,	< SYSCALL instruction >
  144+          VDF <T,1>	BREAK,     0,       INT hwvinst,    VN_BREAK,   -1,	0,	< Breakpoint instruction >
  145+          VDF <T,1>	RESERV,    0,       INT hwvinst,    VN_RESERV,  -1,	0,	< Reserved instruction >
  146+          VDF <T,1>	COPROC,    0,       INT hwvinst,    VN_COPROC,  -1,	0,	< Coprocessor unusable >
  147+          VDF <T,1>	OVRFLOW,   0,       INT hwvinst,    VN_OVERFL,  -1,	0,	< Integer Arithmetic Overflow >
  148+          VDF <T,1>	TRAP,      0,       INT hwvinst,    VN_TRAPV,   -1,	0,	< TRAP exception >
  149+          VDF <T,1>	FLOAT,     0,       INT hwvinst,    VN_FPE,     -1,	0,	< FLoating point exception >
  150+          VDF <T,1>	TIMER,	   timervec, INT 0,	    0,          -1,	0,	< Soft Timer interrupt >
  151+          VDF <T,1>	TIMERPLL,  tpllvec, VEXT 0,	    0,		-1,	0,	<Adjust 1MS timer>
  152+          VDF <T,1>	GAMEFRAME, framevec,INT 0,	    0,		-1,	0,	< Frame complete >
  153+   (5)    .if true, PHX
  154+    X     VDF <D,NET_LVL>	NET,       netintp, INT 0,          0,		NET_LVL,0,	< network int soft vector >
  155+    X     VDF <D,XBUS>	XBUS,	   xbusintp, INT pvinst,    XBUS_NOTES,	XBUS_LVL,xbus_irq, < Any XBUS interrupt >
  156+    X     VDF <T,XS0>	XS0,       xs0intp, INT pvinst,	    XS0_NOTES,	XS0_LVL,0,	< Expansion Slot 0 interrupt >
  157+    X     VDF <T,XS1>	XS1,       xs1intp, INT pvinst,	    XS1_NOTES,	XS1_LVL,0,	< Expansion Slot 1 interrupt >
  158+    X     VDF <T,XS2>	XS2,       xs2intp, INT pvinst,	    XS2_NOTES,	XS2_LVL,0,	< Expansion Slot 2 interrupt >
  159+    X     VDF <T,XS3>	XS3,       xs3intp, INT pvinst,	    XS3_NOTES,	XS3_LVL,0,	< Expansion Slot 3 interrupt >
  160+    X     VDF <T,MIO>	MIO,       miointp, INT pvinst,	    MIO_NOTES,	MIO_LVL,0,	< Miscellaneous I/O interrupt >
  161+    X     VDF <T,CU1>	CU1,       cu1intp, INT pvinst,	    CU1_NOTES,	CU1_LVL,0,	< Combo UART 1 interrupt >
  162+    X     VDF <T,CU2>	CU2,       cu2intp, INT pvinst,	    CU2_NOTES,	CU2_LVL,0,	< Combo UART 2 interrupt >
  163+    X     VDF <T,CPP>	CPP,       cppintp, INT pvinst,	    CPP_NOTES,	CPP_LVL,0,	< Combo Parallel Port interrupt >
  164+    X     VDF <T,PCA>	PCA,       pcaintp, INT pvinst,	    PCA_NOTES,	PCA_LVL,0,	< PCI A interrupt >
  165+    X     VDF <T,PCB>	PCB,       pcbintp, INT pvinst,	    PCB_NOTES,	PCB_LVL,0,	< PCI B interrupt >
  166+    X     VDF <T,PCC>	PCC,       pccintp, INT pvinst,	    PCC_NOTES,	PCC_LVL,0,	< PCI C interrupt >
dispatch.c                               Atari Games Corp. macpp v9.12   "Oct 16 1997 13:26:41"


  167+    X     VDF <T,VSY>	VSY,       vsyintp, INT pvinst,	    VSY_NOTES,	VSY_LVL,0,	< PCI D (VSYNC) interrupt >
  168+    X     VDF <T,IDE>	IDE,	   ideintp, INT pvinst,	    IDE_NOTES,	IDE_LVL,0,	< IDE interrupt >
  169+    X     VDF <T,IOA>	IOA,	   ioaintp, INT pvinst,	    IOA_NOTES,	IOA_LVL,ioa_irq,< I/O Asic interrupt >
  170+    X     VDF <T,ADC>	ADC,	   adcintp, INT pvinst,	    ADC_NOTES,	ADC_LVL,0,	< A/D Converter interrupt >
  171+    X     VDF <D,SND_I>	CAGE,      cagevec, INT 0,          0,		CAGE_LVL,aud_irq, < CAGE interrupt >
  172+   (5)    .endc
  173+   (5)    .if true, PAD || FLG || SEA || VEG
  174+          ;VDF <T,1>	IOA,	   0,	    INT hwvinst,    VN_IRQ3,	-1,	0,	< I/O Asic interrupt >
  175+          VDF <T,1>	IDE,	   0,	    INT hwvinst,    VN_IRQ4,    -1,	0,	< IDE interrupt >
  176+          VDF <T,EXP>	EXP,       expintp, INT pvinst,	    EXP_NOTES,	EXP_LVL,0,	< Expansion Slot interrupt >
  177+   (6)     .if true, PAD || SEA
  178+          VDF <T,NSS>	NSS,	   nssintp, INT pvinst,	    NSS_NOTES,  NSS_LVL,0,	< NSS/Hi-Link interrupt>
  179+   (6)     .endc
  180+   (6)     .if true, FLG
  181+    X     VDF <T,ETH>	ETH,	   ethintp, INT pvinst,     ETH_NOTES,  ETH_LVL,0,	< ethernet interrupt >
  182+    X     VDF <D,SND_I>	CAGE,	   cagevec, INT ioainst,    CAGE_NOTES, CAGE_LVL,aud_irq, < CAGE interrupt >
  183+   (6)     .endc
  184+          VDF <T,WD1>	WD1,	   wd1intp, INT pvinst,	    WD1_NOTES,  WD1_LVL,0,	< Widget interrupt 1>
  185+          VDF <T,PCI>	PCI,       pciintp, INT pvinst,	    PCI_NOTES,	PCI_LVL,0,	< PCI interrupt >
  186+          VDF <T,ADC>	ADC,	   adcintp, INT pvinst,	    ADC_NOTES,	ADC_LVL,0,	< A/D Converter interrupt >
  187+          VDF <T,WD2>	WD2,	   wd2intp, INT pvinst,	    WD2_NOTES,  WD2_LVL,0,	< Widget interrupt 2>
  188+          VDF <T,DBG>	DBG,	   dbgintp, INT pvinst,	    DBG_NOTES,	DBG_LVL,0,	< Debug switch interrupt >
  189+          VDF <T,VSY>	VSY,	   vsyintp, INT pvinst,	    VSY_NOTES,	VSY_LVL,0,	< VSYNC interrupt >
  190+   (5)    .endc
  191+          VDF <T,GAL>	GAL,	   0,       INT gvinst,	    GAL_NOTES,  GAL_LVL,galileoint, < Any Galileo Error Interrupt >
  192+          VDF <T,MOE>	MOE,	   moeintp, INT gvinst,	    MOE_NOTES,	MOE_LVL,0,	< Galileo MemOut >
  193+          VDF <T,DOE>	DOE,	   doeintp, INT gvinst,	    DOE_NOTES,	DOE_LVL,0,	< Galileo DMAOut >
  194+          VDF <T,COE>	COE,	   coeintp, INT gvinst,	    COE_NOTES,	COE_LVL,0,	< Galileo CPUOut >
  195+          VDF <T,DM0>	DM0,	   dm0intp, INT gvinst,	    DM0_NOTES,	DM0_LVL,0,	< Galileo DMA0Comp >
  196+          VDF <T,DM1>	DM1,	   dm1intp, INT gvinst,	    DM1_NOTES,	DM1_LVL,0,	< Galileo DMA1Comp >
  197+          VDF <T,DM2>	DM2,	   dm2intp, INT gvinst,	    DM2_NOTES,	DM2_LVL,0,	< Galileo DMA2Comp >
  198+          VDF <T,DM3>	DM3,	   dm3intp, INT gvinst,	    DM3_NOTES,	DM3_LVL,0,	< Galileo DMA3Comp >
  199+          VDF <T,TM0>	TM0,	   tm0intp, INT gvinst,	    TM0_NOTES,	TM0_LVL,0,	< Galileo T0Exp >
  200+          VDF <T,TM1>	TM1,	   tm1intp, INT gvinst,	    TM1_NOTES,	TM1_LVL,0,	< Galileo T1Exp >
  201+          VDF <T,TM2>	TM2,	   tm2intp, INT gvinst,	    TM2_NOTES,	TM2_LVL,0,	< Galileo T2Exp >
  202+          VDF <T,TM3>	TM3,	   tm3intp, INT gvinst,	    TM3_NOTES,	TM3_LVL,cputimerint, < Galileo T3EXP timer interrupt >
  203+          VDF <T,MRE>	MRE,	   mreintp, INT gvinst,	    MRE_NOTES,	MRE_LVL,0,	< Galileo MasRdErr >
  204+          VDF <T,SWE>	SWE,	   sweintp, INT gvinst,	    SWE_NOTES,	SWE_LVL,0,	< Galileo SlvWrErr >
  205+          VDF <T,MWE>	MWE,	   mweintp, INT gvinst,	    MWE_NOTES,	MWE_LVL,0,	< Galileo MasWrErr >
  206+          VDF <T,SRE>	SRE,	   sreintp, INT gvinst,	    SRE_NOTES,	SRE_LVL,0,	< Galileo SlvRdErr >
  207+          VDF <T,AEP>	AEP,	   aepintp, INT gvinst,	    AEP_NOTES,	AEP_LVL,0,	< Galileo AddrErr >
  208+          VDF <T,MEP>	MEP,	   mepintp, INT gvinst,	    MEP_NOTES,	MEP_LVL,0,	< Galileo MemErr >
  209+          VDF <T,MAS>	MAS,	   masintp, INT gvinst,	    MAS_NOTES,	MAS_LVL,0,	< Galileo MasAbort >
  210+          VDF <T,TAR>	TAR,	   tarintp, INT gvinst,	    TAR_NOTES,	TAR_LVL,0,	< Galileo TarAbort >
  211+          VDF <T,RTY>	RTY,	   rtyintp, INT gvinst,	    RTY_NOTES,	RTY_LVL,0,	< Galileo RetryCtr >
  212+          VDF <T,PC0>	PC0,	   pc0intp, INT gvinst,	    PC0_NOTES,	PC0_LVL,0,	< Galileo PCI Interrupt >
  213+          VDF <T,PC1>	PC1,	   pc1intp, INT gvinst,	    PC1_NOTES,	PC1_LVL,0,	< Galileo PCI Interrupt >
  214+          VDF <T,PC2>	PC2,	   pc2intp, INT gvinst,	    PC2_NOTES,	PC2_LVL,0,	< Galileo PCI Interrupt >
  215+          VDF <T,PC3>	PC3,	   pc3intp, INT gvinst,	    PC3_NOTES,	PC3_LVL,0,	< Galileo PCI Interrupt >
  216+          VDF <D,UART_LVL> UART,	   uartintp,INT ioainst,    UART_NOTES,	UART_LVL,0,	< I/O ASIC UART interrupts >
  217+          VDF <D,SND_LVL>	SND,	   sndintp, INT ioainst,    SND_NOTES,	SND_LVL, 0,	< I/O ASIC Sound interrupts >
  218+          VDF <D,MC_LVL>	MC,	   mcintp,  INT ioainst,    MC_NOTES,	MC_LVL,	0,	< I/O ASIC Microcontroller interrupt >
  219+          ;
  220+   (4)    .endc			; (_DISPATCH_MAC_&1) != 0 *** DON'T MOVE THIS LINE EITHER ***
  221+          ;
  222+          ;+++++++ From here on, there are few user servicable parts inside. ++++
  223+          ;
dispatch.c                               Atari Games Corp. macpp v9.12   "Oct 16 1997 13:26:41"


  224+          ; This is sortof how it works:
  225+          ; The first pass through, _DISPATCH_MAC_ will be 0 (set above by the .if not_defined).
  226+          ; First the copyright boilerplate is inserted into both output files and the macro VDF
  227+          ; is defined to create externs. Some struct definitions and unique externs are depositied
  228+          ; into the .h file. Next _DISPATCH_MAC_ is set to 1 and this file is .included
  229+          ; again. This will cause MACPP to read the VDF table above and output the appropriate
  230+          ; information in the .h file but ignore the rest of the file. The VDF macro is redefined,
  231+          ; and the procedure is repeated causing the creation of different items according to what
  232+          ; is needed. Once the whole .h file is built, the procedure repeats for the building of the
  233+          ; .c file.
  234+          ;
  235+   (4)    .if true, _DISPATCH_MAC_ == 0		; First (main) pass
  236+    X      PHX == 0
  237+    X      PAD == 0
  238+    X      FLG == 0
  239+    X      SEA == 0
  240+    X      VEG == 0
  241+    X      .iif true, HOST_BOARD == PHOENIX, PHX == 1 ;set the appropriate ones true as desired
  242+    X      .iif true, HOST_BOARD == PHOENIX_AD, PAD == 1 ;set the appropriate ones true as desired
  243+    X      .iif true, HOST_BOARD == FLAGSTAFF, FLG == 1 ;set the appropriate ones true as desired
  244+    X      .iif true, HOST_BOARD == SEATTLE, SEA == 1 ;set the appropriate ones true as desired
  245+    X      .iif true, HOST_BOARD == VEGAS, VEG == 1 ;set the appropriate ones true as desired
  246+          ;
  247+    X     	.macro .condit flag,exp		; The .condit macro does an expression test ...
  248+    X     	.if identical,<flag>,<T>
  249+    X     		.iif false,exp,.mexit 10 ; ... and aborts higher level macros if false
  250+    X     		.mexit
  251+    X     	.endc
  252+    X     	.if identical,<flag>,<F>
  253+    X     		.iif true,exp,.mexit 10	; ... etc.
  254+    X     		.mexit
  255+    X     	.endc
  256+    X     	.if identical,<flag>,<D>
  257+    X     		.iif not_defined,exp,.mexit 10
  258+    X     		.mexit
  259+    X     	.endc
  260+    X     	.if identical,<flag>,<N>
  261+    X     		.iif defined,exp,.mexit 10
  262+    X     		.mexit
  263+    X     	.endc
  264+    X     	.endm
  265+          ;	
  266+    X     	.macro boilerplate file_name
  267+    X     /*		file_name
  268+    X      *
  269+    X      *		Copyright 1996 Atari Games Corporation
  270+    X      *	Unauthorized reproduction, adaptation, distribution, performance or 
  271+    X      *	display of this computer program or the associated audiovisual work
  272+    X      *	is strictly prohibited.
  273+    X      *
  274+    X      * ++++++ WARNING WARNING WARNING WARNING WARNING +++++
  275+    X      * This file is machine generated. Any changes you put in here will be lost
  276+    X      * the next time phx_vecs.mac is touched. You need to make your changes to
  277+    X      * phx_vecs.mac instead of this file.
  278+    X      */
  279+    X     	.endm
  280+    X     	boilerplate dispatch.c
dispatch.c                               Atari Games Corp. macpp v9.12   "Oct 16 1997 13:26:41"


  281+    X     	.outfile	1		;The externs go into the .h file
  282+    X     	boilerplate intvecs.h
  283+    X     #if !defined(_INTVECS_H_)
  284+    X     #define _INTVECS_H_
  285+          
  286+    X     struct irq_tab {
  287+    X     	void 	(**softvec)();
  288+    X     	void    (*(*installer)(const struct irq_tab *, void(*new)()))();
  289+    X     	int	notes;
  290+    X     };
  291+          ;
  292+    X     	.macro VDF cond, name, softvec, intern, installer, notes, physical, default, comments
  293+    X     	.condit cond	
  294+    X      .if dif,<softvec>,<0>
  295+    X       ...1 == 0
  296+    X       .iif idn,<intern>,<VINT>,...1 == 1
  297+    X       .iif idn,<intern>,<VEXT>,...1 == 1
  298+    X       .if true, ...1
  299+    X     extern	void (* volatile softvec)();	/* comments */
  300+    X       .iff
  301+    X     extern  void (*softvec)();	/* comments */
  302+    X       .endc
  303+    X      .endc
  304+    X     	.endm
  305+          ;
  306+    X     	_DISPATCH_MAC_ == 1		;next time we process the IRQ table
  307+    X     	.include phx_vecs.mac		;Make the externs
  308+          
  309+    X     enum vecs {
  310+    X     	.macro VDF cond, name, softvec, intern, installer, notes, physical, default, comments
  311+    X     	.condit cond	
  312+    X         name'_INTVEC,
  313+    X     	.endm
  314+    X     	.include phx_vecs.mac		;Make the enums
  315+    X         N_INTVECS
  316+    X     };
  317+          
  318+    X     void (*prc_set_vec (unsigned int vecnum, void (*routine)() ))();
  319+    X     void prc_init_vecs(void);		/* set the default vectors */
  320+          ;
  321+          ; Add a prototype for an as yet unused function
  322+    X     .if true, 0
  323+          
  324+    X     /*		prc_set_vecp(which, what)
  325+    X      *	Sets a special vector for the interrupt identified by <which>
  326+    X      *	to call the routine specified by <what>. <what> is
  327+    X      *	a struct that contains both a pointer to the code
  328+    X      *	to execute and an optional pointer to the private
  329+    X      *	variables for that routine. This is a change from the
  330+    X      *	behavior of prc_set_vec, and is intended to allow
  331+    X      *	multiple incarnations of a given device to share code.
  332+    X      */
  333+          
  334+    X     struct opaque;
  335+    X     extern struct VECP_vector {
  336+    X         void (*function)(struct opaque *);	/* Who you gonna call */
  337+    X         struct opaque *cookie;		/* a magic cookie to hand him */
dispatch.c                               Atari Games Corp. macpp v9.12   "Oct 16 1997 13:26:41"


  338+    X     } prc_set_vecp (
  339+    X         int __which,			/* one of xxx_INTVEC */
  340+    X         struct IRQ_vector __what		/* BY VALUE!!! */
  341+    X     );
  342+    X     .endc
  343+    X     #endif		/* _INTVECS_H_ */
  344+          ;
  345+          ; At this point, we have completed all processing of the .h file
  346+          ; so switch back to the .c file
  347+          ;
  348+    X     	.outfile	0		;switch back to dispatch.c
  349+          ;
  350+    X     #include <config.h>			/* begining of dispatch.c */
  351+    X     #include <os_proto.h>
  352+    X     #include <intvecs.h>
  353+          
  354+    X     #ifndef BLABF
  355+    X     # define BLABF(x)
  356+    X     #endif
  357+          
  358+    X     #ifndef BLAB
  359+    X     # define BLAB(x)
  360+    X     #endif
  361+          
  362+    X      .if true, 1
  363+    X     	.macro VDF cond, name, softvec, intern, installer, notes, physical, default, comments
  364+    X     	.condit cond	
  365+    X       .iif idn,<name>,<XBUS0>,.mexit
  366+    X       .iif idn,<name>,<XBUS1>,.mexit
  367+    X       .iif idn,<name>,<XBUS2>,.mexit
  368+    X       .iif idn,<name>,<XBUS3>,.mexit
  369+    X       .iif idn,<name>,<INT0>,.mexit
  370+    X       .iif idn,<name>,<INT1>,.mexit
  371+    X       .iif idn,<name>,<INT2>,.mexit
  372+    X       .iif idn,<name>,<INT3>,.mexit
  373+    X       .iif idn,<name>,<INT4>,.mexit
  374+    X       .iif idn,<name>,<INT5>,.mexit
  375+    X       .if true, PHX
  376+    X         .if true, physical == XBUS0_LVL
  377+    X     	  ...XBUS0 == ...XBUS0 + 1
  378+    X     	  .mexit
  379+    X         .endc
  380+    X         .if true, physical == XBUS1_LVL
  381+    X     	  ...XBUS1 == ...XBUS1 + 1
  382+    X     	  .mexit
  383+    X         .endc
  384+    X         .if true, physical == XBUS2_LVL
  385+    X     	  ...XBUS2 == ...XBUS2 + 1
  386+    X     	  .mexit
  387+    X         .endc
  388+    X         .if true, physical == XBUS3_LVL
  389+    X     	  ...XBUS3 == ...XBUS3 + 1
  390+    X     	  .mexit
  391+    X         .endc
  392+    X       .endc
  393+    X       .if true, physical == INT0_LVL
  394+    X         	...INT0 == ...INT0 + 1
dispatch.c                               Atari Games Corp. macpp v9.12   "Oct 16 1997 13:26:41"


  395+    X     	.mexit
  396+    X       .endc
  397+    X       .if true, physical == INT1_LVL
  398+    X         	...INT1 == ...INT1 + 1
  399+    X        .if true, PAD || FLG || SEA || VEG
  400+    X     	...IOA == ...IOA + 1
  401+    X         .if ndf, notes
  402+    X     #define notes IO_MAIN_GLOBAL_INT
  403+    X         .endc
  404+    X        .endc
  405+    X     	.mexit
  406+    X       .endc
  407+    X       .if true, physical == INT2_LVL
  408+    X         	...INT2 == ...INT2 + 1
  409+    X     	.mexit
  410+    X       .endc
  411+    X       .if true, physical == INT3_LVL
  412+    X         	...INT3 == ...INT3 + 1
  413+    X     	.mexit
  414+    X       .endc
  415+    X       .if true, physical == INT4_LVL
  416+    X         	...INT4 == ...INT4 + 1
  417+    X     	.mexit
  418+    X       .endc
  419+    X       .if true, physical == INT5_LVL
  420+    X         	...INT5 == ...INT5 + 1
  421+    X     	.mexit
  422+    X       .endc
  423+    X       .if true, physical == IOASIC_LVL
  424+    X         	...IOA == ...IOA + 1
  425+    X        .if ndf, notes
  426+    X     #define notes IO_MAIN_GLOBAL_INT
  427+    X        .endc
  428+    X     	.mexit
  429+    X       .endc
  430+    X     	.endm
  431+    X     ...XBUS0 == 0
  432+    X     ...XBUS1 == 0
  433+    X     ...XBUS2 == 0
  434+    X     ...XBUS3 == 0
  435+    X     ...INT0 == 0
  436+    X     ...INT1 == 0
  437+    X     ...INT2 == 0
  438+    X     ...INT3 == 0
  439+    X     ...INT4 == 0
  440+    X     ...INT5 == 0
  441+    X     ...IOA == 0
  442+    X     	.include phx_vecs.mac	; count vectors requiring dispatch
  443+    X      .endc
  444+          ; 
  445+    X     .macro VDF cond, name, softvec, intern, installer, notes, physical, default, comments
  446+    X      .condit cond	
  447+    X      .if dif,<softvec>,<0>
  448+    X       .if idn,<intern>,<INT>
  449+    X     void (*softvec)();	/* comments */
  450+    X       .endc
  451+    X       .if idn,<intern>,<VINT>
dispatch.c                               Atari Games Corp. macpp v9.12   "Oct 16 1997 13:26:41"


  452+    X     void (* volatile softvec)();	/* comments */
  453+    X       .endc
  454+    X      .endc
  455+    X      .if dif,<default>,<0>
  456+    X       .if idn,<name>,<INT0>
  457+    X        .if true, ...INT0
  458+    X     static void 'default'(void);	/* comments */
  459+    X        .endc
  460+    X        .mexit
  461+    X       .endc
  462+    X       .if idn,<name>,<INT1>
  463+    X        .if true, ...INT1
  464+    X     static void 'default'(void);	/* comments */
  465+    X        .endc
  466+    X        .mexit
  467+    X       .endc
  468+    X       .if idn,<name>,<INT2>
  469+    X        .if true, ...INT2
  470+    X     static void 'default'(void);	/* comments */
  471+    X        .endc
  472+    X        .mexit
  473+    X       .endc
  474+    X       .if idn,<name>,<INT3>
  475+    X        .if true, ...INT3
  476+    X     static void 'default'(void);	/* comments */
  477+    X        .endc
  478+    X        .mexit
  479+    X       .endc
  480+    X       .if idn,<name>,<INT4>
  481+    X        .if true, ...INT4
  482+    X     static void 'default'(void);	/* comments */
  483+    X        .endc
  484+    X        .mexit
  485+    X       .endc
  486+    X       .if idn,<name>,<INT5>
  487+    X        .if true, ...INT5
  488+    X     static void 'default'(void);	/* comments */
  489+    X        .endc
  490+    X        .mexit
  491+    X       .endc
  492+    X       .if idn,<name>,<INT6>
  493+    X        .if true, ...INT6
  494+    X     static void 'default'(void);	/* comments */
  495+    X        .endc
  496+    X        .mexit
  497+    X       .endc
  498+    X       .if idn,<name>,<INT7>
  499+    X        .if true, ...INT7
  500+    X     static void 'default'(void);	/* comments */
  501+    X        .endc
  502+    X        .mexit
  503+    X       .endc
  504+    X       .if true, PHX
  505+    X        .if idn,<name>,<XBUS>
  506+    X         .if true, ...XBUS0|...XBUS1|...XBUS2|...XBUS3
  507+    X     static void 'default'(void);
  508+    X         .endc
dispatch.c                               Atari Games Corp. macpp v9.12   "Oct 16 1997 13:26:41"


  509+    X         .mexit
  510+    X        .endc
  511+    X        .if idn,<name>,<XBUS0>
  512+    X         .if true, ...XBUS0
  513+    X     static void 'default'(void);
  514+    X         .endc
  515+    X         .mexit
  516+    X        .endc
  517+    X        .if idn,<name>,<XBUS1>
  518+    X         .if true, ...XBUS1
  519+    X     static void 'default'(void);
  520+    X         .endc
  521+    X         .mexit
  522+    X        .endc
  523+    X        .if idn,<name>,<XBUS2>
  524+    X         .if true, ...XBUS2
  525+    X     static void 'default'(void);
  526+    X         .endc
  527+    X         .mexit
  528+    X        .endc
  529+    X        .if idn,<name>,<XBUS3>
  530+    X         .if true, ...XBUS3
  531+    X     static void 'default'(void);
  532+    X         .endc
  533+    X         .mexit
  534+    X        .endc
  535+    X       .endc			; PHX
  536+    X       .if idn,<name>,<IOA>
  537+    X        .if true, ...IOA
  538+    X     static void 'default'(void);
  539+    X        .endc
  540+    X        .mexit
  541+    X       .endc
  542+    X     extern void 'default'(void);
  543+    X      .endc
  544+    X     .endm
  545+    X     	.include phx_vecs.mac		;Declare the non-extern vectors
  546+          ;
  547+    X      .if true, ((PROCESSOR&-16) == MIPS3000) || ((PROCESSOR&-16) == MIPS4000)
  548+    X     static void (*hwvinst(const struct irq_tab *, void (*)()))();
  549+    X      .endc
  550+          ;
  551+    X     .if df, PHOENIX_INTCTL_MASK
  552+    X     static void (*pvinst(const struct irq_tab *, void (*)()))();
  553+    X     .endc
  554+          ;
  555+    X     .if df, GALILEO_INTCTL_MASK
  556+    X     static void (*gvinst(const struct irq_tab *, void (*)()))();
  557+    X     .endc
  558+          ;
  559+    X     .if true, ...IOA
  560+    X     static void (*ioainst(const struct irq_tab *, void (*)()))();
  561+    X     .endc
  562+          ;
  563+    X     static const struct irq_tab irq_inits[] = {
  564+    X     	.macro VDF cond, name, softvec, intern, installer, notes, physical, default, comments
  565+    X     	.condit cond	
dispatch.c                               Atari Games Corp. macpp v9.12   "Oct 16 1997 13:26:41"


  566+    X      .if dif,<softvec>,<0>
  567+    X      { (void (**)())&softvec, installer, notes },	/* comments */
  568+    X      .iff
  569+    X      { 0, installer, notes },	/* comments */
  570+    X      .endc
  571+    X     	.endm
  572+    X     	.include phx_vecs.mac		;Build the irq_inits array
  573+    X      { 0, 0, 0} };
  574+          ;
  575+    X     .if true, ((PROCESSOR&-16) == MIPS3000) || ((PROCESSOR&-16) == MIPS4000)
  576+          
  577+    X     extern void (*ramv_tbl[])();
  578+          
  579+    X     static void (*hwvinst(const struct irq_tab *it, void (*new)()))() {
  580+    X         int indx;
  581+    X         void (*old_rtn)();
  582+          
  583+    X         indx = it->notes;
  584+    X         if (indx >= VN_MAX) return 0;
  585+    X         old_rtn = ramv_tbl[indx];
  586+    X         ramv_tbl[indx] = new;
  587+    X         return old_rtn;
  588+    X     }
  589+          
  590+    X      .if df, PHOENIX_INTCTL_MASK
  591+    X     static void (*pvinst(const struct irq_tab *it, void (*new)()))() {
  592+          
  593+    X         if (it->notes) {
  594+    X     	BLABF(("\ndispatch: Adding 0x%08lX to main INTCTL (0x%08lX)...", it->notes, *(VU32*)INTCTL_IE));
  595+    X     	*((VU32 *)(INTCTL_IE)) |= it->notes;
  596+    X         }
  597+    X         return 0;
  598+    X     }
  599+    X      .endc
  600+          
  601+    X      .if df, GALILEO_INTCTL_MASK
  602+    X     static void (*gvinst(const struct irq_tab *it, void (*new)()))() {
  603+          
  604+    X         if (it->notes) {
  605+    X     	BLABF(("\ndispatch: Adding 0x%08lX to Galileo INTCTL (0x%08lX)...", it->notes, \
  606+    X     			*(VU32*)GALILEO_CPU_I_ENA));
  607+    X     	*((VU32 *)(GALILEO_CPU_I_ENA)) |= it->notes;
  608+    X         }
  609+    X         return 0;
  610+    X     }
  611+    X      .endc
  612+          
  613+    X      .if true, ...IOA
  614+    X     static void (*ioainst(const struct irq_tab *it, void (*new)()))() {
  615+    X     extern void prc_wait_n_usecs( int );
  616+    X         if (it->notes)
  617+    X         {
  618+    X          BLABF(("\ndispatch: Adding 0x%04X to IOASIC INTCTL: (0x%04X)...", (int)it->notes, \
  619+    X     		*(VU32*)IO_MAIN_CTL&0xFFFF));
  620+    X          while ( ( *((VU32 *)IO_MAIN_CTL) & it->notes ) != it->notes )
  621+    X          {
  622+    X     #ifdef LED_OUT
dispatch.c                               Atari Games Corp. macpp v9.12   "Oct 16 1997 13:26:41"


  623+    X           *(VU32 *)LED_OUT = ~( 1 << B_LED_RED );
  624+    X     #endif
  625+    X           do
  626+    X           {
  627+    X            *((VU32 *)IO_MAIN_CTL) |= it->notes;
  628+    X            prc_wait_n_usecs( 1000 );
  629+    X           } while ( ( *((VU32 *)IO_MAIN_CTL) & it->notes ) != it->notes );
  630+    X           prc_wait_n_usecs( 1000 );
  631+    X     #ifdef LED_OUT
  632+    X           *(VU32 *)LED_OUT |= ( 1 << B_LED_RED );
  633+    X     #endif
  634+    X          }
  635+    X         }
  636+    X         return 0;
  637+    X     }
  638+    X      .endc
  639+    X     .endc
  640+          
  641+    X     void (*prc_set_vec (unsigned int vecnum, void (*routine)() ))()
  642+    X     {
  643+    X         void (*old_rtn)();
  644+    X         void (**softvec)();
  645+    X         const struct irq_tab *tbp;
  646+    X         int old_ipl;
  647+          
  648+    X         if ( vecnum >= N_INTVECS ) return 0;
  649+    X         tbp = irq_inits+vecnum;
  650+    X         softvec = tbp->softvec;
  651+    X         old_rtn = 0;
  652+    X         old_ipl = prc_set_ipl(INTS_OFF);
  653+    X         if ( tbp->installer ) old_rtn = tbp->installer(tbp, routine);
  654+    X         if ( softvec ) {
  655+    X     	if (!old_rtn) old_rtn = *softvec;
  656+    X     	*softvec = routine;
  657+    X         }
  658+    X         prc_set_ipl(old_ipl);
  659+    X         return old_rtn;
  660+    X     }
  661+          
  662+    X      .if true, PHX
  663+    X       .if true, ...XBUS0
  664+    X     static void xbus0_irq(void) {
  665+    X     	.macro VDF cond, name, softvec, intern, installer, notes, physical, default, comments
  666+    X     	.condit cond	
  667+    X       .iif idn,<name>,<XBUS0>,.mexit
  668+    X       .iif idn,<softvec>,<0>,.mexit
  669+    X       .if true, physical == XBUS0_LVL
  670+    X         if (softvec) softvec();
  671+    X       .endc
  672+    X     	.endm
  673+    X     	.include phx_vecs.mac		; pickup all vectors assigned to XBUS0_LVL
  674+    X         return;
  675+    X     }
  676+          
  677+    X       .endc		; ...XBUS0
  678+    X       .if true, ...XBUS1
  679+    X     static void xbus1_irq(void) {
dispatch.c                               Atari Games Corp. macpp v9.12   "Oct 16 1997 13:26:41"


  680+    X     	.macro VDF cond, name, softvec, intern, installer, notes, physical, default, comments
  681+    X     	.condit cond	
  682+    X       .iif idn,<name>,<XBUS1>,.mexit
  683+    X       .iif idn,<softvec>,<0>,.mexit
  684+    X       .if true, physical == XBUS1_LVL
  685+    X         if (softvec) softvec();
  686+    X       .endc
  687+    X     	.endm
  688+    X     	.include phx_vecs.mac		; pickup all vectors assigned to XBUS1_LVL
  689+    X         return;
  690+    X     }
  691+          
  692+    X       .endc		; ...XBUS1
  693+    X       .if true, ...XBUS2
  694+    X     static void xbus2_irq(void) {
  695+    X     	.macro VDF cond, name, softvec, intern, installer, notes, physical, default, comments
  696+    X     	.condit cond	
  697+    X       .iif idn,<name>,<XBUS2>,.mexit
  698+    X       .iif idn,<softvec>,<0>,.mexit
  699+    X       .if true, physical == XBUS2_LVL
  700+    X         if (softvec) softvec();
  701+    X       .endc
  702+    X     	.endm
  703+    X     	.include phx_vecs.mac		; pickup all vectors assigned to XBUS2_LVL
  704+    X         return;
  705+    X     }
  706+          
  707+    X       .endc		; ...XBUS2
  708+    X       .if true, ...XBUS3
  709+    X     static void xbus3_irq(void) {
  710+    X     	.macro VDF cond, name, softvec, intern, installer, notes, physical, default, comments
  711+    X     	.condit cond	
  712+    X       .iif idn,<name>,<XBUS3>,.mexit
  713+    X       .iif idn,<softvec>,<0>,.mexit
  714+    X       .if true, physical == XBUS3_LVL
  715+    X         if (softvec) softvec();
  716+    X       .endc
  717+    X     	.endm
  718+    X     	.include phx_vecs.mac		; pickup all vectors assigned to XBUS3_LVL
  719+    X         return;
  720+    X     }
  721+          
  722+    X       .endc		; ...XBUS3
  723+    X      .endc		; PHX
  724+    X      .if true, ...INT0
  725+    X     static void int0_irq(void) {
  726+    X     	.macro VDF cond, name, softvec, intern, installer, notes, physical, default, comments
  727+    X     	.condit cond	
  728+    X       .iif idn,<name>,<INT0>,.mexit
  729+    X       .iif idn,<softvec>,<0>,.mexit
  730+    X       .if true, physical == INT0_LVL
  731+    X         if (softvec) softvec();
  732+    X       .endc
  733+    X     	.endm
  734+    X     	.include phx_vecs.mac		; pickup all vectors assigned to IRQ 0
  735+    X         return;
  736+    X     }
dispatch.c                               Atari Games Corp. macpp v9.12   "Oct 16 1997 13:26:41"


  737+          
  738+    X      .endc		; ...INT0
  739+    X      .if true, ...INT1
  740+    X     static void int1_irq(void) {
  741+    X     	.macro VDF cond, name, softvec, intern, installer, notes, physical, default, comments
  742+    X     	.condit cond	
  743+    X       .iif idn,<name>,<INT1>,.mexit
  744+    X       .iif idn,<softvec>,<0>,.mexit
  745+    X       .if true, physical == INT1_LVL
  746+    X         if (softvec) softvec();
  747+    X       .endc
  748+    X     	.endm
  749+    X     	.include phx_vecs.mac		; pickup all vectors assigned to IRQ 1
  750+    X         return;
  751+    X     }
  752+          
  753+    X      .endc		; ...INT1
  754+    X      .if true, ...INT2
  755+    X     static void int2_irq(void) {
  756+    X     	.macro VDF cond, name, softvec, intern, installer, notes, physical, default, comments
  757+    X     	.condit cond	
  758+    X       .iif idn,<name>,<INT2>,.mexit
  759+    X       .iif idn,<softvec>,<0>,.mexit
  760+    X       .if true, physical == INT2_LVL
  761+    X         if (softvec) softvec();
  762+    X       .endc
  763+    X     	.endm
  764+    X     	.include phx_vecs.mac		; pickup all vectors assigned to IRQ 2
  765+    X         return;
  766+    X     }
  767+          
  768+    X      .endc		; ...INT2
  769+    X      .if true, ...INT3
  770+    X     static void int3_irq(void) {
  771+    X     	.macro VDF cond, name, softvec, intern, installer, notes, physical, default, comments
  772+    X     	.condit cond	
  773+    X       .iif idn,<name>,<INT3>,.mexit
  774+    X       .iif idn,<softvec>,<0>,.mexit
  775+    X       .if true, physical == INT3_LVL
  776+    X         if (softvec) softvec();
  777+    X       .endc
  778+    X     	.endm
  779+    X     	.include phx_vecs.mac		; pickup all vectors assigned to IRQ 3
  780+    X         return;
  781+    X     }
  782+          
  783+    X      .endc		; ...INT3
  784+    X      .if true, ...INT4
  785+    X     static void int4_irq(void) {
  786+    X     	.macro VDF cond, name, softvec, intern, installer, notes, physical, default, comments
  787+    X     	.condit cond	
  788+    X       .iif idn,<name>,<INT4>,.mexit
  789+    X       .iif idn,<softvec>,<0>,.mexit
  790+    X       .if true, physical == INT4_LVL
  791+    X         if (softvec) softvec();
  792+    X       .endc
  793+    X     	.endm
dispatch.c                               Atari Games Corp. macpp v9.12   "Oct 16 1997 13:26:41"


  794+    X     	.include phx_vecs.mac		; pickup all vectors assigned to IRQ 4
  795+    X         return;
  796+    X     }
  797+          
  798+    X      .endc		; ...INT4
  799+    X      .if true, ...INT5
  800+    X     static void int5_irq(void) {
  801+    X     	.macro VDF cond, name, softvec, intern, installer, notes, physical, default, comments
  802+    X     	.condit cond	
  803+    X       .iif idn,<name>,<INT5>,.mexit
  804+    X       .iif idn,<softvec>,<0>,.mexit
  805+    X       .if true, physical == INT5_LVL
  806+    X         if (softvec) softvec();
  807+    X       .endc
  808+    X     	.endm
  809+    X     	.include phx_vecs.mac		; pickup all vectors assigned to IRQ 5
  810+    X         return;
  811+    X     }
  812+          
  813+    X      .endc		; ...INT5
  814+    X      .if true, ...IOA && PHX
  815+    X     static void ioa_irq(void) {
  816+    X     	.macro VDF cond, name, softvec, intern, installer, notes, physical, default, comments
  817+    X     	.condit cond	
  818+    X       .iif idn,<name>,<IOA>,.mexit
  819+    X       .iif idn,<softvec>,<0>,.mexit
  820+    X       .if true, physical == IOASIC_LVL
  821+    X         if (softvec) softvec();
  822+    X       .endc
  823+    X     	.endm
  824+    X     	.include phx_vecs.mac		; pickup all vectors assigned to IRQ 5
  825+    X         return;
  826+    X     }
  827+          
  828+    X      .endc		; ...IOA
  829+    X      .if true, PHX
  830+    X       .if true, ...XBUS0|...XBUS1|...XBUS2|...XBUS3
  831+    X     static void xbus_irq(void) {
  832+    X         int which;
  833+    X         which = *(VU32 *)(XBUS_SLOT0+4);
  834+    X       .if true, ...XBUS0
  835+    X         if (!(which&1)) xbus0_irq();
  836+    X       .endc
  837+    X       .if true, ...XBUS1
  838+    X         if (!(which&2)) xbus1_irq();
  839+    X       .endc
  840+    X       .if true, ...XBUS2
  841+    X         if (!(which&4)) xbus2_irq();
  842+    X       .endc
  843+    X       .if true, ...XBUS3
  844+    X         if (!(which&8)) xbus3_irq();
  845+    X       .endc
  846+    X         return;
  847+    X     }
  848+    X       .endc
  849+    X      .endc		; PHX
  850+    X     void prc_init_vecs(void) {
dispatch.c                               Atari Games Corp. macpp v9.12   "Oct 16 1997 13:26:41"


  851+    X     	.macro VDF cond, name, softvec, intern, installer, notes, physical, default, comments
  852+    X     	.condit cond	
  853+    X     .if dif,<default>,<0>
  854+    X      .if true, PHX
  855+    X       .if idn,<name>,<XBUS0>
  856+    X        .iif true, ...XBUS0 == 0, .mexit
  857+    X       .endc
  858+    X       .if idn,<name>,<XBUS1>
  859+    X        .iif true, ...XBUS1 == 0, .mexit
  860+    X       .endc
  861+    X       .if idn,<name>,<XBUS2>
  862+    X        .iif true, ...XBUS2 == 0, .mexit
  863+    X       .endc
  864+    X       .if idn,<name>,<XBUS3>
  865+    X        .iif true, ...XBUS3 == 0, .mexit
  866+    X       .endc
  867+    X       .if idn,<name>,<XBUS>
  868+    X        .iif true, (...XBUS0|...XBUS1|...XBUS2|...XBUS3) == 0, .mexit
  869+    X       .endc
  870+    X      .endc	; PHX
  871+    X      .if idn,<name>,<INT0>
  872+    X       .iif true, ...INT0 == 0, .mexit
  873+    X      .endc
  874+    X      .if idn,<name>,<INT1>
  875+    X       .iif true, ...INT1 == 0, .mexit
  876+    X      .endc
  877+    X      .if idn,<name>,<INT2>
  878+    X       .iif true, ...INT2 == 0, .mexit
  879+    X      .endc
  880+    X      .if idn,<name>,<INT3>
  881+    X       .iif true, ...INT3 == 0, .mexit
  882+    X      .endc
  883+    X      .if idn,<name>,<INT4>
  884+    X       .iif true, ...INT4 == 0, .mexit
  885+    X      .endc
  886+    X      .if idn,<name>,<INT5>
  887+    X       .iif true, ...INT5 == 0, .mexit
  888+    X      .endc
  889+    X      .if idn,<name>,<IOA>
  890+    X       .iif true, ...IOA == 0, .mexit
  891+    X      .endc
  892+    X         prc_set_vec('name'_INTVEC, default);
  893+    X     .endc
  894+    X     	.endm
  895+    X     	.include phx_vecs.mac
  896+          
  897+    X     /* Map the Phoenix interrupts */
  898+          
  899+    X     .if df, INTCTL_MAPA_INIT
  900+    X         BLABF(("\ndispatch: Mapping the A interrupts: 0x%08lX...", INTCTL_MAPA_INIT));
  901+    X         *((VU32 *)(INTCTL_MAPA)) = INTCTL_MAPA_INIT;
  902+    X     .endc
  903+    X     .if df, INTCTL_MAPB_INIT
  904+    X         BLABF(("\ndispatch: Mapping the B interrupts: 0x%08lX...", INTCTL_MAPB_INIT));
  905+    X         *((VU32 *)(INTCTL_MAPB)) = INTCTL_MAPB_INIT;
  906+    X     .endc
  907+          
dispatch.c                               Atari Games Corp. macpp v9.12   "Oct 16 1997 13:26:41"


  908+    X     .if defined, ANNOUNCE_BOOT_ACTIONS
  909+    X      .if true, ANNOUNCE_BOOT_ACTIONS
  910+    X         {
  911+    X     	int jj;
  912+    X     	extern int prc_get_cause(void), prc_get_ipl(void);
  913+    X     	jj = prc_get_cause();
  914+    X     	if (jj&0xFF00) BLABF(("\ndispatch: CPU cause reg: %08lX, CPU SR reg: %08lX", jj, prc_get_ipl()));
  915+    X     	if (jj&0x0400) {
  916+    X       .if true, ...INT0
  917+    X     	.macro VDF cond, name, softvec, intern, installer, notes, physical, default, comments
  918+    X     	.condit cond	
  919+    X        .iif idn,<name>,<INT0>,.mexit
  920+    X        .iif idn,<softvec>,<0>,.mexit
  921+    X        .if true, physical == INT0_LVL
  922+    X     	    if (!softvec) BLAB("\ndispatch: Warning, IRQ 0 pending \"'comments'\"");
  923+    X        .endc
  924+    X     	.endm
  925+    X     	.include phx_vecs.mac		; pickup all vectors assigned to IRQ 0
  926+    X       .iff
  927+    X     	    BLAB("\ndispatch: Warning, IRQ 0 pending with no vector assigned");
  928+    X       .endc		; ...INT0
  929+    X     	}
  930+    X     	if (jj&0x0800) {
  931+    X       .if true, ...INT1
  932+    X     	.macro VDF cond, name, softvec, intern, installer, notes, physical, default, comments
  933+    X     	.condit cond	
  934+    X        .iif idn,<name>,<INT1>,.mexit
  935+    X        .iif idn,<softvec>,<0>,.mexit
  936+    X        .if true, physical == INT1_LVL
  937+    X     	    if (!softvec) BLAB("\ndispatch: Warning, IRQ 1 pending \"'comments'\"");
  938+    X        .endc
  939+    X     	.endm
  940+    X     	.include phx_vecs.mac		; pickup all vectors assigned to IRQ 1
  941+    X       .iff
  942+    X     	    BLAB("\ndispatch: Warning, IRQ 1 pending with no vector assigned");
  943+    X       .endc		; ...INT1
  944+    X     	}
  945+    X     	if (jj&0x1000) {
  946+    X       .if true, ...INT2
  947+    X     	.macro VDF cond, name, softvec, intern, installer, notes, physical, default, comments
  948+    X     	.condit cond	
  949+    X        .iif idn,<name>,<INT2>,.mexit
  950+    X        .iif idn,<softvec>,<0>,.mexit
  951+    X        .if true, physical == INT2_LVL
  952+    X     	    if (!softvec) BLAB("\ndispatch: Warning, IRQ 2 pending \"'comments'\"");
  953+    X        .endc
  954+    X     	.endm
  955+    X     	.include phx_vecs.mac		; pickup all vectors assigned to IRQ 2
  956+    X       .iff
  957+    X     	    BLAB("\ndispatch: Warning, IRQ 2 pending with no vector assigned");
  958+    X       .endc		; ...INT2
  959+    X     	}
  960+    X     	if (jj&0x2000) {
  961+    X       .if true, ...INT3
  962+    X     	.macro VDF cond, name, softvec, intern, installer, notes, physical, default, comments
  963+    X     	.condit cond	
  964+    X        .iif idn,<name>,<INT3>,.mexit
dispatch.c                               Atari Games Corp. macpp v9.12   "Oct 16 1997 13:26:41"


  965+    X        .iif idn,<softvec>,<0>,.mexit
  966+    X        .if true, physical == INT3_LVL
  967+    X     	    if (!softvec) BLAB("\ndispatch: Warning, IRQ 3 pending \"'comments'\"");
  968+    X        .endc
  969+    X     	.endm
  970+    X     	.include phx_vecs.mac		; pickup all vectors assigned to IRQ 3
  971+    X       .iff
  972+    X     	    BLAB("\ndispatch: Warning, IRQ 3 pending with no vector assigned");
  973+    X       .endc		; ...INT3
  974+    X     	}
  975+    X     	if (jj&0x4000) {
  976+    X       .if true, ...INT4
  977+    X     	.macro VDF cond, name, softvec, intern, installer, notes, physical, default, comments
  978+    X     	.condit cond	
  979+    X        .iif idn,<name>,<INT4>,.mexit
  980+    X        .iif idn,<softvec>,<0>,.mexit
  981+    X        .if true, physical == INT4_LVL
  982+    X     	    if (!softvec) BLAB("\ndispatch: Warning, IRQ 4 pending \"'comments'\"");
  983+    X        .endc
  984+    X     	.endm
  985+    X     	.include phx_vecs.mac		; pickup all vectors assigned to IRQ 4
  986+    X       .iff
  987+    X     	    BLAB("\ndispatch: Warning, IRQ 4 pending with no vector assigned");
  988+    X       .endc		; ...INT4
  989+    X     	}
  990+    X     	if (jj&0x8000) {
  991+    X       .if true, ...INT5
  992+    X     	.macro VDF cond, name, softvec, intern, installer, notes, physical, default, comments
  993+    X     	.condit cond	
  994+    X        .iif idn,<name>,<INT5>,.mexit
  995+    X        .iif idn,<softvec>,<0>,.mexit
  996+    X        .if true, physical == INT5_LVL
  997+    X     	    if (!softvec) BLAB("\ndispatch: Warning, IRQ 5 pending \"'comments'\"");
  998+    X        .endc
  999+    X     	.endm
 1000+    X     	.include phx_vecs.mac		; pickup all vectors assigned to IRQ 5
 1001+    X       .iff
 1002+    X     	    BLAB("\ndispatch: Warning, IRQ 5 pending with no vector assigned");
 1003+    X       .endc		; ...INT5
 1004+    X     	}
 1005+    X         }
 1006+    X      .endc		; true, ANNOUNCE_BOOT_ACTIONS
 1007+    X     .endc		; defined, ANNOUNCE_BOOT_ACTIONS
 1008+    X         return;
 1009+    X     }
 1010+   (4)    .endc		; _DISPATCH_MAC_ == 0
  926    (3)      .iff
  927     X     	    BLAB("\ndispatch: Warning, IRQ 0 pending with no vector assigned");
  928    (3)      .endc		; ...INT0
  929           	}
  930           	if (jj&0x0800) {
  931    (3)      .if true, ...INT1
  932           	.macro VDF cond, name, softvec, intern, installer, notes, physical, default, comments
  933           	.condit cond	
  934              .iif idn,<name>,<INT1>,.mexit
  935              .iif idn,<softvec>,<0>,.mexit
  936              .if true, physical == INT1_LVL
dispatch.c                               Atari Games Corp. macpp v9.12   "Oct 16 1997 13:26:41"


  937           	    if (!softvec) BLAB("\ndispatch: Warning, IRQ 1 pending \"'comments'\"");
  938              .endc
  939           	.endm
  940           	.include phx_vecs.mac		; pickup all vectors assigned to IRQ 1
    1+          ;/*		phx_vecs.mac
    2+          ; *
    3+          ; *		Copyright 1996 Atari Games Corporation
    4+          ; *	Unauthorized reproduction, adaptation, distribution, performance or 
    5+          ; *	display of this computer program or the associated audiovisual work
    6+          ; *	is strictly prohibited.
    7+          ; *
    8+          ; *	This file is processed by MACPP to produce dispatch.c and intvecs.h.
    9+          ; *
   10+          ; *	The definitions placed in intvecs.h declare virtual vector numbers
   11+          ; *	in the form of xxx_INTVEC and a cross reference table(s) so the
   12+          ; *	dispatcher can call the appropriate functions.
   13+          ; *
   14+          ; *	intvecs.h should be #include'd by any module that uses prc_set_vec().
   15+          ; */
   16+          ;
   17+          ; This file recursivley '.includes' itself to succesively build up the approprate
   18+          ; tables and functions in C and places the results in one of two files (the
   19+          ; first -out=file supplied on the MACPP command line is expected to be dispatch.c
   20+          ; and the second -out=file is expected to be intvecs.h and the third is expected to
   21+          ; be /dev/null). If you don't speak fluent MACPP, then you probably shouldn't be
   22+          ; changing anything in this file other than the VDF table listed below.
   23+          ;
   24+   (4)    .if not_defined, _DISPATCH_MAC_		;1 +++++
   25+    X     _DISPATCH_MAC_ == 0			;2 Don't move ...
   26+    X     OUTPUT_LANG == 5 ;LANG_NONE		;3 ... or change ... 
   27+    X     	.outfile 2			;4 ... anything on ...
   28+    X     	.include config.mac		;5 ... these ...
   29+    X     	.outfile 0			;6 ... nine  ...
   30+   (4)    .endc					;7 ... lines ...
   31+   (4)    .if true, (_DISPATCH_MAC_&1) != 0	;8
   32+   (5)     .if true, 0				;9 -----
   33+          
   34+    X     You are free to add or remove entries from this table according to your
   35+    X     requirements. There are 10 fields used on each line in this table. The
   36+    X     description of each field follows:
   37+          
   38+    X     Field 1 = macro call
   39+          
   40+    X     It must always be the keyword VDF (case is not significant).
   41+          
   42+    X     Field 2 = condition
   43+          
   44+    X     This is a dual operand field, so the two operands together must be enclosed in
   45+    X     <>'s. The first operand is one of T, F, D or N representing True, False,
   46+    X     Defined or Not_defined respectively. Case is significant, use uppercase only
   47+    X     please. For the conditions T or F the second operand must be an expression
   48+    X     which must resolve to non-$0 (True) or $0 (False) in order for the macro
   49+    X     to be processed (else it is ignored). The expression can contain no embedded
   50+    X     spaces. For the conditions D and N, the second operand must only be a symbol
   51+    X     which must be Defined or Not-defined respectively in order for the macro to be
   52+    X     processed. Some short cut expressions have been preprocessed to make using the
   53+    X     expressions a little more concise. These are:
dispatch.c                               Atari Games Corp. macpp v9.12   "Oct 16 1997 13:26:41"


   54+          
   55+    X     	PHX = not $0 if HOST_BOARD == PHOENIX
   56+    X     	PAD = not $0 if HOST_BOARD == PHOENIX_AD
   57+    X     	FLG = not $0 if HOST_BOARD == FLAGSTAFF
   58+    X     	SEA = not $0 if HOST_BOARD == SEATTLE
   59+    X     	VEG = not $0 if HOST_BOARD == VEGAS
   60+          
   61+    X     Field 3 = vector name
   62+          
   63+    X     The NAME field is the name of the virtual vector. An _INTVEC will be appended
   64+    X     to it in the C definitions in intvecs.h, but otherwise the name is unmolested.
   65+    X     Case is significant only if you want it to be. The R3K/R4K has an option where
   66+    X     a number of vectors are maintained in an array of pointers rather than each
   67+    X     one having its own name. The index into the array is same as the number
   68+    X     returned in the processor's CAUSE register for that particluar interrupt. This
   69+    X     procedure is done simply for performance reasons. The option is selected by
   70+    X     using a 0 for this field and using an installer function with the vector index
   71+    X     as the parameter to the installer.
   72+          
   73+    X     Field 4 = Vector pointer
   74+          
   75+    X     This field identifies the name of a variable in BSS that contains a pointer
   76+    X     to the function to call at interrupt (or will be set by the prc_set_vec()
   77+    X     function). This is the name of the "soft" or logical vector and is either
   78+    X     declared in dispatch.c or externally according to the INT/EXT field described
   79+    X     next.
   80+          
   81+    X     Field 5 = INTernal or EXTernal vector
   82+          
   83+    X     This field contains the keywords INT, EXT, VINT or VEXT identifying the vector
   84+    X     in field 4 as being defined INTernally, EXTernally, Volatile INTernally or
   85+    X     Volatile Externally to dispatch.c respectively.
   86+          
   87+    X     Field 6 = name of vector installer
   88+          
   89+    X     This field identifies the name of a function that prc_set_vec() will call to
   90+    X     actually install the vector or 0 if there is no special stuff that needs to
   91+    X     be performed during vector installation.
   92+          
   93+    X     Field 7 = Notes for the installer.
   94+          
   95+    X     The Notes field is a parameter that is passed to the installer if there is one.
   96+          
   97+    X     Field 8 = Physical vector attachment.
   98+          
   99+    X     A dispatch routine is constructed for each of the 4 XBUS interrupts and for each of
  100+    X     the 6 CPU interrupts.  This field instructs phx_vecs.mac into which of the XBUS or
  101+    X     INTx dispatchers a caller to this vector belongs.  If this vector is not associated
  102+    X     with an XBUS or an INTx interrupt, it needs to be -1.  Place the interrupt routines
  103+    X     in this table in the order in which you want them executed.
  104+          
  105+    X     Field 9 = Default function.
  106+          
  107+    X     Name of default routine to install in the vector, or 0 if none.  phx_vecs.mac builds
  108+    X     a function called prc_init_vecs(void) which, when called, will perform a string of
  109+    X     prc_set_vec()'s for all the vectors having this field non-zero.  After the vectors
  110+    X     have been loaded, prc_init_vecs(void) will map the phoenix and galileo interrupts as
dispatch.c                               Atari Games Corp. macpp v9.12   "Oct 16 1997 13:26:41"


  111+    X     specified in phoenix.mac.
  112+          
  113+    X     Field 10 = Comments.
  114+          
  115+    X     The Comments field is placed on selected lines in intvecs.h and/or dispatch.c
  116+    X     as simple 'C' comments.
  117+          
  118+   (5)     .endc				; Don't move this line
  119+          ;
  120+          ;   Condit	Name	   Vector   I/E	Installer   Notes      Phys	Default	Comments
  121+          ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  122+          VDF <T,1>	GAMEVB,	   gameint, EXT	0,          0,		-1,	0,	< post-wierdness Vblank >
  123+          VDF <T,1>	MS4,       ms4vec,  EXT	0,          0,		-1,	0,	< 4 Millisecond timer >
  124+          VDF <T,1>	PRC_DELAY, prc_delay_vec, EXT 0,    0,		-1,	sst_prc_delay, < prc_delay soft vector >
  125+          VDF <T,1>	PRC_SET_IPL, set_ipl_vec, INT 0,    0,		-1,	0,	< prc_set_ipl soft vector >
  126+          VDF <T,1>	SAVE,      savintp, EXT 0,          0,		-1,	0,	< context save soft vector >
  127+          VDF <T,1>	RESTORE,   restintp,EXT 0,          0,		-1,	0,	< context restore soft vector >
  128+          VDF <T,1>	SW0,	   0,	    INT hwvinst,    VN_IRQ0,    -1,	0,	< Software interrupt 0 >
  129+          VDF <T,1>	SW1,	   0,       INT hwvinst,    VN_IRQ1,    -1,	0,	< Software interrupt 0 >
  130+          VDF <T,1>	INT0,	   0,       INT hwvinst,    VN_IRQ2,    -1,	int0_irq, < Hardware interrupt 0 >
  131+          VDF <T,1>	INT1,	   0,	    INT hwvinst,    VN_IRQ3,    -1,	int1_irq, < Hardware interrupt 1 >
  132+          VDF <T,PHX>	INT2,	   0,	    INT hwvinst,    VN_IRQ4,    -1,	int2_irq, < Hardware interrupt 2 >
  133+          VDF <T,1>	INT3,	   0,       INT hwvinst,    VN_IRQ5,    -1,	int3_irq, < Hardware interrupt 3 >
  134+          VDF <T,1>	INT4,	   0,	    INT hwvinst,    VN_IRQ6,    -1,	int4_irq, < Hardware interrupt 4 >
  135+          VDF <T,1>	INT5,	   0,	    INT hwvinst,    VN_IRQ7,    -1,	int5_irq, < Hardware interrupt 5 >
  136+          VDF <T,1>	TLBMOD,	   0,	    INT hwvinst,    VN_TLBM,    -1,	0,	< TLB modification >
  137+          VDF <T,1>	TLBLOAD,   0,	    INT hwvinst,    VN_TLBL,    -1,	0,	< TLB miss on I or D fetch >
  138+          VDF <T,1>	TLBSTORE,  0,	    INT hwvinst,    VN_TLBS,    -1,	0,	< TLB miss on store >
  139+          VDF <T,1>	ADDRERRL,  0,	    INT hwvinst,    VN_ADDRL,   -1,	0,	< Address error on I or D fetch >
  140+          VDF <T,1>	ADDRERRS,  0,	    INT hwvinst,    VN_ADDRS,   -1,	0,	< Address error on store >
  141+          VDF <T,1>	BUSERRI,   0,	    INT hwvinst,    VN_BUSERRI, -1,	0,	< Bus error on I-fetch >
  142+          VDF <T,1>	BUSERRD,   0,	    INT hwvinst,    VN_BUSERRD, -1,	0,	< Bus error on D-fetch >
  143+          VDF <T,1>	SYSCALL,   0,       INT hwvinst,    VN_SYSCALL, -1,	0,	< SYSCALL instruction >
  144+          VDF <T,1>	BREAK,     0,       INT hwvinst,    VN_BREAK,   -1,	0,	< Breakpoint instruction >
  145+          VDF <T,1>	RESERV,    0,       INT hwvinst,    VN_RESERV,  -1,	0,	< Reserved instruction >
  146+          VDF <T,1>	COPROC,    0,       INT hwvinst,    VN_COPROC,  -1,	0,	< Coprocessor unusable >
  147+          VDF <T,1>	OVRFLOW,   0,       INT hwvinst,    VN_OVERFL,  -1,	0,	< Integer Arithmetic Overflow >
  148+          VDF <T,1>	TRAP,      0,       INT hwvinst,    VN_TRAPV,   -1,	0,	< TRAP exception >
  149+          VDF <T,1>	FLOAT,     0,       INT hwvinst,    VN_FPE,     -1,	0,	< FLoating point exception >
  150+          VDF <T,1>	TIMER,	   timervec, INT 0,	    0,          -1,	0,	< Soft Timer interrupt >
  151+          VDF <T,1>	TIMERPLL,  tpllvec, VEXT 0,	    0,		-1,	0,	<Adjust 1MS timer>
  152+          VDF <T,1>	GAMEFRAME, framevec,INT 0,	    0,		-1,	0,	< Frame complete >
  153+   (5)    .if true, PHX
  154+    X     VDF <D,NET_LVL>	NET,       netintp, INT 0,          0,		NET_LVL,0,	< network int soft vector >
  155+    X     VDF <D,XBUS>	XBUS,	   xbusintp, INT pvinst,    XBUS_NOTES,	XBUS_LVL,xbus_irq, < Any XBUS interrupt >
  156+    X     VDF <T,XS0>	XS0,       xs0intp, INT pvinst,	    XS0_NOTES,	XS0_LVL,0,	< Expansion Slot 0 interrupt >
  157+    X     VDF <T,XS1>	XS1,       xs1intp, INT pvinst,	    XS1_NOTES,	XS1_LVL,0,	< Expansion Slot 1 interrupt >
  158+    X     VDF <T,XS2>	XS2,       xs2intp, INT pvinst,	    XS2_NOTES,	XS2_LVL,0,	< Expansion Slot 2 interrupt >
  159+    X     VDF <T,XS3>	XS3,       xs3intp, INT pvinst,	    XS3_NOTES,	XS3_LVL,0,	< Expansion Slot 3 interrupt >
  160+    X     VDF <T,MIO>	MIO,       miointp, INT pvinst,	    MIO_NOTES,	MIO_LVL,0,	< Miscellaneous I/O interrupt >
  161+    X     VDF <T,CU1>	CU1,       cu1intp, INT pvinst,	    CU1_NOTES,	CU1_LVL,0,	< Combo UART 1 interrupt >
  162+    X     VDF <T,CU2>	CU2,       cu2intp, INT pvinst,	    CU2_NOTES,	CU2_LVL,0,	< Combo UART 2 interrupt >
  163+    X     VDF <T,CPP>	CPP,       cppintp, INT pvinst,	    CPP_NOTES,	CPP_LVL,0,	< Combo Parallel Port interrupt >
  164+    X     VDF <T,PCA>	PCA,       pcaintp, INT pvinst,	    PCA_NOTES,	PCA_LVL,0,	< PCI A interrupt >
  165+    X     VDF <T,PCB>	PCB,       pcbintp, INT pvinst,	    PCB_NOTES,	PCB_LVL,0,	< PCI B interrupt >
  166+    X     VDF <T,PCC>	PCC,       pccintp, INT pvinst,	    PCC_NOTES,	PCC_LVL,0,	< PCI C interrupt >
  167+    X     VDF <T,VSY>	VSY,       vsyintp, INT pvinst,	    VSY_NOTES,	VSY_LVL,0,	< PCI D (VSYNC) interrupt >
dispatch.c                               Atari Games Corp. macpp v9.12   "Oct 16 1997 13:26:41"


  168+    X     VDF <T,IDE>	IDE,	   ideintp, INT pvinst,	    IDE_NOTES,	IDE_LVL,0,	< IDE interrupt >
  169+    X     VDF <T,IOA>	IOA,	   ioaintp, INT pvinst,	    IOA_NOTES,	IOA_LVL,ioa_irq,< I/O Asic interrupt >
  170+    X     VDF <T,ADC>	ADC,	   adcintp, INT pvinst,	    ADC_NOTES,	ADC_LVL,0,	< A/D Converter interrupt >
  171+    X     VDF <D,SND_I>	CAGE,      cagevec, INT 0,          0,		CAGE_LVL,aud_irq, < CAGE interrupt >
  172+   (5)    .endc
  173+   (5)    .if true, PAD || FLG || SEA || VEG
  174+          ;VDF <T,1>	IOA,	   0,	    INT hwvinst,    VN_IRQ3,	-1,	0,	< I/O Asic interrupt >
  175+          VDF <T,1>	IDE,	   0,	    INT hwvinst,    VN_IRQ4,    -1,	0,	< IDE interrupt >
  176+          VDF <T,EXP>	EXP,       expintp, INT pvinst,	    EXP_NOTES,	EXP_LVL,0,	< Expansion Slot interrupt >
  177+   (6)     .if true, PAD || SEA
  178+          VDF <T,NSS>	NSS,	   nssintp, INT pvinst,	    NSS_NOTES,  NSS_LVL,0,	< NSS/Hi-Link interrupt>
  179+   (6)     .endc
  180+   (6)     .if true, FLG
  181+    X     VDF <T,ETH>	ETH,	   ethintp, INT pvinst,     ETH_NOTES,  ETH_LVL,0,	< ethernet interrupt >
  182+    X     VDF <D,SND_I>	CAGE,	   cagevec, INT ioainst,    CAGE_NOTES, CAGE_LVL,aud_irq, < CAGE interrupt >
  183+   (6)     .endc
  184+          VDF <T,WD1>	WD1,	   wd1intp, INT pvinst,	    WD1_NOTES,  WD1_LVL,0,	< Widget interrupt 1>
  185+          VDF <T,PCI>	PCI,       pciintp, INT pvinst,	    PCI_NOTES,	PCI_LVL,0,	< PCI interrupt >
  186+          VDF <T,ADC>	ADC,	   adcintp, INT pvinst,	    ADC_NOTES,	ADC_LVL,0,	< A/D Converter interrupt >
  187+          VDF <T,WD2>	WD2,	   wd2intp, INT pvinst,	    WD2_NOTES,  WD2_LVL,0,	< Widget interrupt 2>
  188+          VDF <T,DBG>	DBG,	   dbgintp, INT pvinst,	    DBG_NOTES,	DBG_LVL,0,	< Debug switch interrupt >
  189+          VDF <T,VSY>	VSY,	   vsyintp, INT pvinst,	    VSY_NOTES,	VSY_LVL,0,	< VSYNC interrupt >
  190+   (5)    .endc
  191+          VDF <T,GAL>	GAL,	   0,       INT gvinst,	    GAL_NOTES,  GAL_LVL,galileoint, < Any Galileo Error Interrupt >
  192+          VDF <T,MOE>	MOE,	   moeintp, INT gvinst,	    MOE_NOTES,	MOE_LVL,0,	< Galileo MemOut >
  193+          VDF <T,DOE>	DOE,	   doeintp, INT gvinst,	    DOE_NOTES,	DOE_LVL,0,	< Galileo DMAOut >
  194+          VDF <T,COE>	COE,	   coeintp, INT gvinst,	    COE_NOTES,	COE_LVL,0,	< Galileo CPUOut >
  195+          VDF <T,DM0>	DM0,	   dm0intp, INT gvinst,	    DM0_NOTES,	DM0_LVL,0,	< Galileo DMA0Comp >
  196+          VDF <T,DM1>	DM1,	   dm1intp, INT gvinst,	    DM1_NOTES,	DM1_LVL,0,	< Galileo DMA1Comp >
  197+          VDF <T,DM2>	DM2,	   dm2intp, INT gvinst,	    DM2_NOTES,	DM2_LVL,0,	< Galileo DMA2Comp >
  198+          VDF <T,DM3>	DM3,	   dm3intp, INT gvinst,	    DM3_NOTES,	DM3_LVL,0,	< Galileo DMA3Comp >
  199+          VDF <T,TM0>	TM0,	   tm0intp, INT gvinst,	    TM0_NOTES,	TM0_LVL,0,	< Galileo T0Exp >
  200+          VDF <T,TM1>	TM1,	   tm1intp, INT gvinst,	    TM1_NOTES,	TM1_LVL,0,	< Galileo T1Exp >
  201+          VDF <T,TM2>	TM2,	   tm2intp, INT gvinst,	    TM2_NOTES,	TM2_LVL,0,	< Galileo T2Exp >
  202+          VDF <T,TM3>	TM3,	   tm3intp, INT gvinst,	    TM3_NOTES,	TM3_LVL,cputimerint, < Galileo T3EXP timer interrupt >
  203+          VDF <T,MRE>	MRE,	   mreintp, INT gvinst,	    MRE_NOTES,	MRE_LVL,0,	< Galileo MasRdErr >
  204+          VDF <T,SWE>	SWE,	   sweintp, INT gvinst,	    SWE_NOTES,	SWE_LVL,0,	< Galileo SlvWrErr >
  205+          VDF <T,MWE>	MWE,	   mweintp, INT gvinst,	    MWE_NOTES,	MWE_LVL,0,	< Galileo MasWrErr >
  206+          VDF <T,SRE>	SRE,	   sreintp, INT gvinst,	    SRE_NOTES,	SRE_LVL,0,	< Galileo SlvRdErr >
  207+          VDF <T,AEP>	AEP,	   aepintp, INT gvinst,	    AEP_NOTES,	AEP_LVL,0,	< Galileo AddrErr >
  208+          VDF <T,MEP>	MEP,	   mepintp, INT gvinst,	    MEP_NOTES,	MEP_LVL,0,	< Galileo MemErr >
  209+          VDF <T,MAS>	MAS,	   masintp, INT gvinst,	    MAS_NOTES,	MAS_LVL,0,	< Galileo MasAbort >
  210+          VDF <T,TAR>	TAR,	   tarintp, INT gvinst,	    TAR_NOTES,	TAR_LVL,0,	< Galileo TarAbort >
  211+          VDF <T,RTY>	RTY,	   rtyintp, INT gvinst,	    RTY_NOTES,	RTY_LVL,0,	< Galileo RetryCtr >
  212+          VDF <T,PC0>	PC0,	   pc0intp, INT gvinst,	    PC0_NOTES,	PC0_LVL,0,	< Galileo PCI Interrupt >
  213+          VDF <T,PC1>	PC1,	   pc1intp, INT gvinst,	    PC1_NOTES,	PC1_LVL,0,	< Galileo PCI Interrupt >
  214+          VDF <T,PC2>	PC2,	   pc2intp, INT gvinst,	    PC2_NOTES,	PC2_LVL,0,	< Galileo PCI Interrupt >
  215+          VDF <T,PC3>	PC3,	   pc3intp, INT gvinst,	    PC3_NOTES,	PC3_LVL,0,	< Galileo PCI Interrupt >
  216+          VDF <D,UART_LVL> UART,	   uartintp,INT ioainst,    UART_NOTES,	UART_LVL,0,	< I/O ASIC UART interrupts >
  217+          VDF <D,SND_LVL>	SND,	   sndintp, INT ioainst,    SND_NOTES,	SND_LVL, 0,	< I/O ASIC Sound interrupts >
  218+          VDF <D,MC_LVL>	MC,	   mcintp,  INT ioainst,    MC_NOTES,	MC_LVL,	0,	< I/O ASIC Microcontroller interrupt >
  219+          ;
  220+   (4)    .endc			; (_DISPATCH_MAC_&1) != 0 *** DON'T MOVE THIS LINE EITHER ***
  221+          ;
  222+          ;+++++++ From here on, there are few user servicable parts inside. ++++
  223+          ;
  224+          ; This is sortof how it works:
dispatch.c                               Atari Games Corp. macpp v9.12   "Oct 16 1997 13:26:41"


  225+          ; The first pass through, _DISPATCH_MAC_ will be 0 (set above by the .if not_defined).
  226+          ; First the copyright boilerplate is inserted into both output files and the macro VDF
  227+          ; is defined to create externs. Some struct definitions and unique externs are depositied
  228+          ; into the .h file. Next _DISPATCH_MAC_ is set to 1 and this file is .included
  229+          ; again. This will cause MACPP to read the VDF table above and output the appropriate
  230+          ; information in the .h file but ignore the rest of the file. The VDF macro is redefined,
  231+          ; and the procedure is repeated causing the creation of different items according to what
  232+          ; is needed. Once the whole .h file is built, the procedure repeats for the building of the
  233+          ; .c file.
  234+          ;
  235+   (4)    .if true, _DISPATCH_MAC_ == 0		; First (main) pass
  236+    X      PHX == 0
  237+    X      PAD == 0
  238+    X      FLG == 0
  239+    X      SEA == 0
  240+    X      VEG == 0
  241+    X      .iif true, HOST_BOARD == PHOENIX, PHX == 1 ;set the appropriate ones true as desired
  242+    X      .iif true, HOST_BOARD == PHOENIX_AD, PAD == 1 ;set the appropriate ones true as desired
  243+    X      .iif true, HOST_BOARD == FLAGSTAFF, FLG == 1 ;set the appropriate ones true as desired
  244+    X      .iif true, HOST_BOARD == SEATTLE, SEA == 1 ;set the appropriate ones true as desired
  245+    X      .iif true, HOST_BOARD == VEGAS, VEG == 1 ;set the appropriate ones true as desired
  246+          ;
  247+    X     	.macro .condit flag,exp		; The .condit macro does an expression test ...
  248+    X     	.if identical,<flag>,<T>
  249+    X     		.iif false,exp,.mexit 10 ; ... and aborts higher level macros if false
  250+    X     		.mexit
  251+    X     	.endc
  252+    X     	.if identical,<flag>,<F>
  253+    X     		.iif true,exp,.mexit 10	; ... etc.
  254+    X     		.mexit
  255+    X     	.endc
  256+    X     	.if identical,<flag>,<D>
  257+    X     		.iif not_defined,exp,.mexit 10
  258+    X     		.mexit
  259+    X     	.endc
  260+    X     	.if identical,<flag>,<N>
  261+    X     		.iif defined,exp,.mexit 10
  262+    X     		.mexit
  263+    X     	.endc
  264+    X     	.endm
  265+          ;	
  266+    X     	.macro boilerplate file_name
  267+    X     /*		file_name
  268+    X      *
  269+    X      *		Copyright 1996 Atari Games Corporation
  270+    X      *	Unauthorized reproduction, adaptation, distribution, performance or 
  271+    X      *	display of this computer program or the associated audiovisual work
  272+    X      *	is strictly prohibited.
  273+    X      *
  274+    X      * ++++++ WARNING WARNING WARNING WARNING WARNING +++++
  275+    X      * This file is machine generated. Any changes you put in here will be lost
  276+    X      * the next time phx_vecs.mac is touched. You need to make your changes to
  277+    X      * phx_vecs.mac instead of this file.
  278+    X      */
  279+    X     	.endm
  280+    X     	boilerplate dispatch.c
  281+    X     	.outfile	1		;The externs go into the .h file
dispatch.c                               Atari Games Corp. macpp v9.12   "Oct 16 1997 13:26:41"


  282+    X     	boilerplate intvecs.h
  283+    X     #if !defined(_INTVECS_H_)
  284+    X     #define _INTVECS_H_
  285+          
  286+    X     struct irq_tab {
  287+    X     	void 	(**softvec)();
  288+    X     	void    (*(*installer)(const struct irq_tab *, void(*new)()))();
  289+    X     	int	notes;
  290+    X     };
  291+          ;
  292+    X     	.macro VDF cond, name, softvec, intern, installer, notes, physical, default, comments
  293+    X     	.condit cond	
  294+    X      .if dif,<softvec>,<0>
  295+    X       ...1 == 0
  296+    X       .iif idn,<intern>,<VINT>,...1 == 1
  297+    X       .iif idn,<intern>,<VEXT>,...1 == 1
  298+    X       .if true, ...1
  299+    X     extern	void (* volatile softvec)();	/* comments */
  300+    X       .iff
  301+    X     extern  void (*softvec)();	/* comments */
  302+    X       .endc
  303+    X      .endc
  304+    X     	.endm
  305+          ;
  306+    X     	_DISPATCH_MAC_ == 1		;next time we process the IRQ table
  307+    X     	.include phx_vecs.mac		;Make the externs
  308+          
  309+    X     enum vecs {
  310+    X     	.macro VDF cond, name, softvec, intern, installer, notes, physical, default, comments
  311+    X     	.condit cond	
  312+    X         name'_INTVEC,
  313+    X     	.endm
  314+    X     	.include phx_vecs.mac		;Make the enums
  315+    X         N_INTVECS
  316+    X     };
  317+          
  318+    X     void (*prc_set_vec (unsigned int vecnum, void (*routine)() ))();
  319+    X     void prc_init_vecs(void);		/* set the default vectors */
  320+          ;
  321+          ; Add a prototype for an as yet unused function
  322+    X     .if true, 0
  323+          
  324+    X     /*		prc_set_vecp(which, what)
  325+    X      *	Sets a special vector for the interrupt identified by <which>
  326+    X      *	to call the routine specified by <what>. <what> is
  327+    X      *	a struct that contains both a pointer to the code
  328+    X      *	to execute and an optional pointer to the private
  329+    X      *	variables for that routine. This is a change from the
  330+    X      *	behavior of prc_set_vec, and is intended to allow
  331+    X      *	multiple incarnations of a given device to share code.
  332+    X      */
  333+          
  334+    X     struct opaque;
  335+    X     extern struct VECP_vector {
  336+    X         void (*function)(struct opaque *);	/* Who you gonna call */
  337+    X         struct opaque *cookie;		/* a magic cookie to hand him */
  338+    X     } prc_set_vecp (
dispatch.c                               Atari Games Corp. macpp v9.12   "Oct 16 1997 13:26:41"


  339+    X         int __which,			/* one of xxx_INTVEC */
  340+    X         struct IRQ_vector __what		/* BY VALUE!!! */
  341+    X     );
  342+    X     .endc
  343+    X     #endif		/* _INTVECS_H_ */
  344+          ;
  345+          ; At this point, we have completed all processing of the .h file
  346+          ; so switch back to the .c file
  347+          ;
  348+    X     	.outfile	0		;switch back to dispatch.c
  349+          ;
  350+    X     #include <config.h>			/* begining of dispatch.c */
  351+    X     #include <os_proto.h>
  352+    X     #include <intvecs.h>
  353+          
  354+    X     #ifndef BLABF
  355+    X     # define BLABF(x)
  356+    X     #endif
  357+          
  358+    X     #ifndef BLAB
  359+    X     # define BLAB(x)
  360+    X     #endif
  361+          
  362+    X      .if true, 1
  363+    X     	.macro VDF cond, name, softvec, intern, installer, notes, physical, default, comments
  364+    X     	.condit cond	
  365+    X       .iif idn,<name>,<XBUS0>,.mexit
  366+    X       .iif idn,<name>,<XBUS1>,.mexit
  367+    X       .iif idn,<name>,<XBUS2>,.mexit
  368+    X       .iif idn,<name>,<XBUS3>,.mexit
  369+    X       .iif idn,<name>,<INT0>,.mexit
  370+    X       .iif idn,<name>,<INT1>,.mexit
  371+    X       .iif idn,<name>,<INT2>,.mexit
  372+    X       .iif idn,<name>,<INT3>,.mexit
  373+    X       .iif idn,<name>,<INT4>,.mexit
  374+    X       .iif idn,<name>,<INT5>,.mexit
  375+    X       .if true, PHX
  376+    X         .if true, physical == XBUS0_LVL
  377+    X     	  ...XBUS0 == ...XBUS0 + 1
  378+    X     	  .mexit
  379+    X         .endc
  380+    X         .if true, physical == XBUS1_LVL
  381+    X     	  ...XBUS1 == ...XBUS1 + 1
  382+    X     	  .mexit
  383+    X         .endc
  384+    X         .if true, physical == XBUS2_LVL
  385+    X     	  ...XBUS2 == ...XBUS2 + 1
  386+    X     	  .mexit
  387+    X         .endc
  388+    X         .if true, physical == XBUS3_LVL
  389+    X     	  ...XBUS3 == ...XBUS3 + 1
  390+    X     	  .mexit
  391+    X         .endc
  392+    X       .endc
  393+    X       .if true, physical == INT0_LVL
  394+    X         	...INT0 == ...INT0 + 1
  395+    X     	.mexit
dispatch.c                               Atari Games Corp. macpp v9.12   "Oct 16 1997 13:26:41"


  396+    X       .endc
  397+    X       .if true, physical == INT1_LVL
  398+    X         	...INT1 == ...INT1 + 1
  399+    X        .if true, PAD || FLG || SEA || VEG
  400+    X     	...IOA == ...IOA + 1
  401+    X         .if ndf, notes
  402+    X     #define notes IO_MAIN_GLOBAL_INT
  403+    X         .endc
  404+    X        .endc
  405+    X     	.mexit
  406+    X       .endc
  407+    X       .if true, physical == INT2_LVL
  408+    X         	...INT2 == ...INT2 + 1
  409+    X     	.mexit
  410+    X       .endc
  411+    X       .if true, physical == INT3_LVL
  412+    X         	...INT3 == ...INT3 + 1
  413+    X     	.mexit
  414+    X       .endc
  415+    X       .if true, physical == INT4_LVL
  416+    X         	...INT4 == ...INT4 + 1
  417+    X     	.mexit
  418+    X       .endc
  419+    X       .if true, physical == INT5_LVL
  420+    X         	...INT5 == ...INT5 + 1
  421+    X     	.mexit
  422+    X       .endc
  423+    X       .if true, physical == IOASIC_LVL
  424+    X         	...IOA == ...IOA + 1
  425+    X        .if ndf, notes
  426+    X     #define notes IO_MAIN_GLOBAL_INT
  427+    X        .endc
  428+    X     	.mexit
  429+    X       .endc
  430+    X     	.endm
  431+    X     ...XBUS0 == 0
  432+    X     ...XBUS1 == 0
  433+    X     ...XBUS2 == 0
  434+    X     ...XBUS3 == 0
  435+    X     ...INT0 == 0
  436+    X     ...INT1 == 0
  437+    X     ...INT2 == 0
  438+    X     ...INT3 == 0
  439+    X     ...INT4 == 0
  440+    X     ...INT5 == 0
  441+    X     ...IOA == 0
  442+    X     	.include phx_vecs.mac	; count vectors requiring dispatch
  443+    X      .endc
  444+          ; 
  445+    X     .macro VDF cond, name, softvec, intern, installer, notes, physical, default, comments
  446+    X      .condit cond	
  447+    X      .if dif,<softvec>,<0>
  448+    X       .if idn,<intern>,<INT>
  449+    X     void (*softvec)();	/* comments */
  450+    X       .endc
  451+    X       .if idn,<intern>,<VINT>
  452+    X     void (* volatile softvec)();	/* comments */
dispatch.c                               Atari Games Corp. macpp v9.12   "Oct 16 1997 13:26:41"


  453+    X       .endc
  454+    X      .endc
  455+    X      .if dif,<default>,<0>
  456+    X       .if idn,<name>,<INT0>
  457+    X        .if true, ...INT0
  458+    X     static void 'default'(void);	/* comments */
  459+    X        .endc
  460+    X        .mexit
  461+    X       .endc
  462+    X       .if idn,<name>,<INT1>
  463+    X        .if true, ...INT1
  464+    X     static void 'default'(void);	/* comments */
  465+    X        .endc
  466+    X        .mexit
  467+    X       .endc
  468+    X       .if idn,<name>,<INT2>
  469+    X        .if true, ...INT2
  470+    X     static void 'default'(void);	/* comments */
  471+    X        .endc
  472+    X        .mexit
  473+    X       .endc
  474+    X       .if idn,<name>,<INT3>
  475+    X        .if true, ...INT3
  476+    X     static void 'default'(void);	/* comments */
  477+    X        .endc
  478+    X        .mexit
  479+    X       .endc
  480+    X       .if idn,<name>,<INT4>
  481+    X        .if true, ...INT4
  482+    X     static void 'default'(void);	/* comments */
  483+    X        .endc
  484+    X        .mexit
  485+    X       .endc
  486+    X       .if idn,<name>,<INT5>
  487+    X        .if true, ...INT5
  488+    X     static void 'default'(void);	/* comments */
  489+    X        .endc
  490+    X        .mexit
  491+    X       .endc
  492+    X       .if idn,<name>,<INT6>
  493+    X        .if true, ...INT6
  494+    X     static void 'default'(void);	/* comments */
  495+    X        .endc
  496+    X        .mexit
  497+    X       .endc
  498+    X       .if idn,<name>,<INT7>
  499+    X        .if true, ...INT7
  500+    X     static void 'default'(void);	/* comments */
  501+    X        .endc
  502+    X        .mexit
  503+    X       .endc
  504+    X       .if true, PHX
  505+    X        .if idn,<name>,<XBUS>
  506+    X         .if true, ...XBUS0|...XBUS1|...XBUS2|...XBUS3
  507+    X     static void 'default'(void);
  508+    X         .endc
  509+    X         .mexit
dispatch.c                               Atari Games Corp. macpp v9.12   "Oct 16 1997 13:26:41"


  510+    X        .endc
  511+    X        .if idn,<name>,<XBUS0>
  512+    X         .if true, ...XBUS0
  513+    X     static void 'default'(void);
  514+    X         .endc
  515+    X         .mexit
  516+    X        .endc
  517+    X        .if idn,<name>,<XBUS1>
  518+    X         .if true, ...XBUS1
  519+    X     static void 'default'(void);
  520+    X         .endc
  521+    X         .mexit
  522+    X        .endc
  523+    X        .if idn,<name>,<XBUS2>
  524+    X         .if true, ...XBUS2
  525+    X     static void 'default'(void);
  526+    X         .endc
  527+    X         .mexit
  528+    X        .endc
  529+    X        .if idn,<name>,<XBUS3>
  530+    X         .if true, ...XBUS3
  531+    X     static void 'default'(void);
  532+    X         .endc
  533+    X         .mexit
  534+    X        .endc
  535+    X       .endc			; PHX
  536+    X       .if idn,<name>,<IOA>
  537+    X        .if true, ...IOA
  538+    X     static void 'default'(void);
  539+    X        .endc
  540+    X        .mexit
  541+    X       .endc
  542+    X     extern void 'default'(void);
  543+    X      .endc
  544+    X     .endm
  545+    X     	.include phx_vecs.mac		;Declare the non-extern vectors
  546+          ;
  547+    X      .if true, ((PROCESSOR&-16) == MIPS3000) || ((PROCESSOR&-16) == MIPS4000)
  548+    X     static void (*hwvinst(const struct irq_tab *, void (*)()))();
  549+    X      .endc
  550+          ;
  551+    X     .if df, PHOENIX_INTCTL_MASK
  552+    X     static void (*pvinst(const struct irq_tab *, void (*)()))();
  553+    X     .endc
  554+          ;
  555+    X     .if df, GALILEO_INTCTL_MASK
  556+    X     static void (*gvinst(const struct irq_tab *, void (*)()))();
  557+    X     .endc
  558+          ;
  559+    X     .if true, ...IOA
  560+    X     static void (*ioainst(const struct irq_tab *, void (*)()))();
  561+    X     .endc
  562+          ;
  563+    X     static const struct irq_tab irq_inits[] = {
  564+    X     	.macro VDF cond, name, softvec, intern, installer, notes, physical, default, comments
  565+    X     	.condit cond	
  566+    X      .if dif,<softvec>,<0>
dispatch.c                               Atari Games Corp. macpp v9.12   "Oct 16 1997 13:26:41"


  567+    X      { (void (**)())&softvec, installer, notes },	/* comments */
  568+    X      .iff
  569+    X      { 0, installer, notes },	/* comments */
  570+    X      .endc
  571+    X     	.endm
  572+    X     	.include phx_vecs.mac		;Build the irq_inits array
  573+    X      { 0, 0, 0} };
  574+          ;
  575+    X     .if true, ((PROCESSOR&-16) == MIPS3000) || ((PROCESSOR&-16) == MIPS4000)
  576+          
  577+    X     extern void (*ramv_tbl[])();
  578+          
  579+    X     static void (*hwvinst(const struct irq_tab *it, void (*new)()))() {
  580+    X         int indx;
  581+    X         void (*old_rtn)();
  582+          
  583+    X         indx = it->notes;
  584+    X         if (indx >= VN_MAX) return 0;
  585+    X         old_rtn = ramv_tbl[indx];
  586+    X         ramv_tbl[indx] = new;
  587+    X         return old_rtn;
  588+    X     }
  589+          
  590+    X      .if df, PHOENIX_INTCTL_MASK
  591+    X     static void (*pvinst(const struct irq_tab *it, void (*new)()))() {
  592+          
  593+    X         if (it->notes) {
  594+    X     	BLABF(("\ndispatch: Adding 0x%08lX to main INTCTL (0x%08lX)...", it->notes, *(VU32*)INTCTL_IE));
  595+    X     	*((VU32 *)(INTCTL_IE)) |= it->notes;
  596+    X         }
  597+    X         return 0;
  598+    X     }
  599+    X      .endc
  600+          
  601+    X      .if df, GALILEO_INTCTL_MASK
  602+    X     static void (*gvinst(const struct irq_tab *it, void (*new)()))() {
  603+          
  604+    X         if (it->notes) {
  605+    X     	BLABF(("\ndispatch: Adding 0x%08lX to Galileo INTCTL (0x%08lX)...", it->notes, \
  606+    X     			*(VU32*)GALILEO_CPU_I_ENA));
  607+    X     	*((VU32 *)(GALILEO_CPU_I_ENA)) |= it->notes;
  608+    X         }
  609+    X         return 0;
  610+    X     }
  611+    X      .endc
  612+          
  613+    X      .if true, ...IOA
  614+    X     static void (*ioainst(const struct irq_tab *it, void (*new)()))() {
  615+    X     extern void prc_wait_n_usecs( int );
  616+    X         if (it->notes)
  617+    X         {
  618+    X          BLABF(("\ndispatch: Adding 0x%04X to IOASIC INTCTL: (0x%04X)...", (int)it->notes, \
  619+    X     		*(VU32*)IO_MAIN_CTL&0xFFFF));
  620+    X          while ( ( *((VU32 *)IO_MAIN_CTL) & it->notes ) != it->notes )
  621+    X          {
  622+    X     #ifdef LED_OUT
  623+    X           *(VU32 *)LED_OUT = ~( 1 << B_LED_RED );
dispatch.c                               Atari Games Corp. macpp v9.12   "Oct 16 1997 13:26:41"


  624+    X     #endif
  625+    X           do
  626+    X           {
  627+    X            *((VU32 *)IO_MAIN_CTL) |= it->notes;
  628+    X            prc_wait_n_usecs( 1000 );
  629+    X           } while ( ( *((VU32 *)IO_MAIN_CTL) & it->notes ) != it->notes );
  630+    X           prc_wait_n_usecs( 1000 );
  631+    X     #ifdef LED_OUT
  632+    X           *(VU32 *)LED_OUT |= ( 1 << B_LED_RED );
  633+    X     #endif
  634+    X          }
  635+    X         }
  636+    X         return 0;
  637+    X     }
  638+    X      .endc
  639+    X     .endc
  640+          
  641+    X     void (*prc_set_vec (unsigned int vecnum, void (*routine)() ))()
  642+    X     {
  643+    X         void (*old_rtn)();
  644+    X         void (**softvec)();
  645+    X         const struct irq_tab *tbp;
  646+    X         int old_ipl;
  647+          
  648+    X         if ( vecnum >= N_INTVECS ) return 0;
  649+    X         tbp = irq_inits+vecnum;
  650+    X         softvec = tbp->softvec;
  651+    X         old_rtn = 0;
  652+    X         old_ipl = prc_set_ipl(INTS_OFF);
  653+    X         if ( tbp->installer ) old_rtn = tbp->installer(tbp, routine);
  654+    X         if ( softvec ) {
  655+    X     	if (!old_rtn) old_rtn = *softvec;
  656+    X     	*softvec = routine;
  657+    X         }
  658+    X         prc_set_ipl(old_ipl);
  659+    X         return old_rtn;
  660+    X     }
  661+          
  662+    X      .if true, PHX
  663+    X       .if true, ...XBUS0
  664+    X     static void xbus0_irq(void) {
  665+    X     	.macro VDF cond, name, softvec, intern, installer, notes, physical, default, comments
  666+    X     	.condit cond	
  667+    X       .iif idn,<name>,<XBUS0>,.mexit
  668+    X       .iif idn,<softvec>,<0>,.mexit
  669+    X       .if true, physical == XBUS0_LVL
  670+    X         if (softvec) softvec();
  671+    X       .endc
  672+    X     	.endm
  673+    X     	.include phx_vecs.mac		; pickup all vectors assigned to XBUS0_LVL
  674+    X         return;
  675+    X     }
  676+          
  677+    X       .endc		; ...XBUS0
  678+    X       .if true, ...XBUS1
  679+    X     static void xbus1_irq(void) {
  680+    X     	.macro VDF cond, name, softvec, intern, installer, notes, physical, default, comments
dispatch.c                               Atari Games Corp. macpp v9.12   "Oct 16 1997 13:26:41"


  681+    X     	.condit cond	
  682+    X       .iif idn,<name>,<XBUS1>,.mexit
  683+    X       .iif idn,<softvec>,<0>,.mexit
  684+    X       .if true, physical == XBUS1_LVL
  685+    X         if (softvec) softvec();
  686+    X       .endc
  687+    X     	.endm
  688+    X     	.include phx_vecs.mac		; pickup all vectors assigned to XBUS1_LVL
  689+    X         return;
  690+    X     }
  691+          
  692+    X       .endc		; ...XBUS1
  693+    X       .if true, ...XBUS2
  694+    X     static void xbus2_irq(void) {
  695+    X     	.macro VDF cond, name, softvec, intern, installer, notes, physical, default, comments
  696+    X     	.condit cond	
  697+    X       .iif idn,<name>,<XBUS2>,.mexit
  698+    X       .iif idn,<softvec>,<0>,.mexit
  699+    X       .if true, physical == XBUS2_LVL
  700+    X         if (softvec) softvec();
  701+    X       .endc
  702+    X     	.endm
  703+    X     	.include phx_vecs.mac		; pickup all vectors assigned to XBUS2_LVL
  704+    X         return;
  705+    X     }
  706+          
  707+    X       .endc		; ...XBUS2
  708+    X       .if true, ...XBUS3
  709+    X     static void xbus3_irq(void) {
  710+    X     	.macro VDF cond, name, softvec, intern, installer, notes, physical, default, comments
  711+    X     	.condit cond	
  712+    X       .iif idn,<name>,<XBUS3>,.mexit
  713+    X       .iif idn,<softvec>,<0>,.mexit
  714+    X       .if true, physical == XBUS3_LVL
  715+    X         if (softvec) softvec();
  716+    X       .endc
  717+    X     	.endm
  718+    X     	.include phx_vecs.mac		; pickup all vectors assigned to XBUS3_LVL
  719+    X         return;
  720+    X     }
  721+          
  722+    X       .endc		; ...XBUS3
  723+    X      .endc		; PHX
  724+    X      .if true, ...INT0
  725+    X     static void int0_irq(void) {
  726+    X     	.macro VDF cond, name, softvec, intern, installer, notes, physical, default, comments
  727+    X     	.condit cond	
  728+    X       .iif idn,<name>,<INT0>,.mexit
  729+    X       .iif idn,<softvec>,<0>,.mexit
  730+    X       .if true, physical == INT0_LVL
  731+    X         if (softvec) softvec();
  732+    X       .endc
  733+    X     	.endm
  734+    X     	.include phx_vecs.mac		; pickup all vectors assigned to IRQ 0
  735+    X         return;
  736+    X     }
  737+          
dispatch.c                               Atari Games Corp. macpp v9.12   "Oct 16 1997 13:26:41"


  738+    X      .endc		; ...INT0
  739+    X      .if true, ...INT1
  740+    X     static void int1_irq(void) {
  741+    X     	.macro VDF cond, name, softvec, intern, installer, notes, physical, default, comments
  742+    X     	.condit cond	
  743+    X       .iif idn,<name>,<INT1>,.mexit
  744+    X       .iif idn,<softvec>,<0>,.mexit
  745+    X       .if true, physical == INT1_LVL
  746+    X         if (softvec) softvec();
  747+    X       .endc
  748+    X     	.endm
  749+    X     	.include phx_vecs.mac		; pickup all vectors assigned to IRQ 1
  750+    X         return;
  751+    X     }
  752+          
  753+    X      .endc		; ...INT1
  754+    X      .if true, ...INT2
  755+    X     static void int2_irq(void) {
  756+    X     	.macro VDF cond, name, softvec, intern, installer, notes, physical, default, comments
  757+    X     	.condit cond	
  758+    X       .iif idn,<name>,<INT2>,.mexit
  759+    X       .iif idn,<softvec>,<0>,.mexit
  760+    X       .if true, physical == INT2_LVL
  761+    X         if (softvec) softvec();
  762+    X       .endc
  763+    X     	.endm
  764+    X     	.include phx_vecs.mac		; pickup all vectors assigned to IRQ 2
  765+    X         return;
  766+    X     }
  767+          
  768+    X      .endc		; ...INT2
  769+    X      .if true, ...INT3
  770+    X     static void int3_irq(void) {
  771+    X     	.macro VDF cond, name, softvec, intern, installer, notes, physical, default, comments
  772+    X     	.condit cond	
  773+    X       .iif idn,<name>,<INT3>,.mexit
  774+    X       .iif idn,<softvec>,<0>,.mexit
  775+    X       .if true, physical == INT3_LVL
  776+    X         if (softvec) softvec();
  777+    X       .endc
  778+    X     	.endm
  779+    X     	.include phx_vecs.mac		; pickup all vectors assigned to IRQ 3
  780+    X         return;
  781+    X     }
  782+          
  783+    X      .endc		; ...INT3
  784+    X      .if true, ...INT4
  785+    X     static void int4_irq(void) {
  786+    X     	.macro VDF cond, name, softvec, intern, installer, notes, physical, default, comments
  787+    X     	.condit cond	
  788+    X       .iif idn,<name>,<INT4>,.mexit
  789+    X       .iif idn,<softvec>,<0>,.mexit
  790+    X       .if true, physical == INT4_LVL
  791+    X         if (softvec) softvec();
  792+    X       .endc
  793+    X     	.endm
  794+    X     	.include phx_vecs.mac		; pickup all vectors assigned to IRQ 4
dispatch.c                               Atari Games Corp. macpp v9.12   "Oct 16 1997 13:26:41"


  795+    X         return;
  796+    X     }
  797+          
  798+    X      .endc		; ...INT4
  799+    X      .if true, ...INT5
  800+    X     static void int5_irq(void) {
  801+    X     	.macro VDF cond, name, softvec, intern, installer, notes, physical, default, comments
  802+    X     	.condit cond	
  803+    X       .iif idn,<name>,<INT5>,.mexit
  804+    X       .iif idn,<softvec>,<0>,.mexit
  805+    X       .if true, physical == INT5_LVL
  806+    X         if (softvec) softvec();
  807+    X       .endc
  808+    X     	.endm
  809+    X     	.include phx_vecs.mac		; pickup all vectors assigned to IRQ 5
  810+    X         return;
  811+    X     }
  812+          
  813+    X      .endc		; ...INT5
  814+    X      .if true, ...IOA && PHX
  815+    X     static void ioa_irq(void) {
  816+    X     	.macro VDF cond, name, softvec, intern, installer, notes, physical, default, comments
  817+    X     	.condit cond	
  818+    X       .iif idn,<name>,<IOA>,.mexit
  819+    X       .iif idn,<softvec>,<0>,.mexit
  820+    X       .if true, physical == IOASIC_LVL
  821+    X         if (softvec) softvec();
  822+    X       .endc
  823+    X     	.endm
  824+    X     	.include phx_vecs.mac		; pickup all vectors assigned to IRQ 5
  825+    X         return;
  826+    X     }
  827+          
  828+    X      .endc		; ...IOA
  829+    X      .if true, PHX
  830+    X       .if true, ...XBUS0|...XBUS1|...XBUS2|...XBUS3
  831+    X     static void xbus_irq(void) {
  832+    X         int which;
  833+    X         which = *(VU32 *)(XBUS_SLOT0+4);
  834+    X       .if true, ...XBUS0
  835+    X         if (!(which&1)) xbus0_irq();
  836+    X       .endc
  837+    X       .if true, ...XBUS1
  838+    X         if (!(which&2)) xbus1_irq();
  839+    X       .endc
  840+    X       .if true, ...XBUS2
  841+    X         if (!(which&4)) xbus2_irq();
  842+    X       .endc
  843+    X       .if true, ...XBUS3
  844+    X         if (!(which&8)) xbus3_irq();
  845+    X       .endc
  846+    X         return;
  847+    X     }
  848+    X       .endc
  849+    X      .endc		; PHX
  850+    X     void prc_init_vecs(void) {
  851+    X     	.macro VDF cond, name, softvec, intern, installer, notes, physical, default, comments
dispatch.c                               Atari Games Corp. macpp v9.12   "Oct 16 1997 13:26:41"


  852+    X     	.condit cond	
  853+    X     .if dif,<default>,<0>
  854+    X      .if true, PHX
  855+    X       .if idn,<name>,<XBUS0>
  856+    X        .iif true, ...XBUS0 == 0, .mexit
  857+    X       .endc
  858+    X       .if idn,<name>,<XBUS1>
  859+    X        .iif true, ...XBUS1 == 0, .mexit
  860+    X       .endc
  861+    X       .if idn,<name>,<XBUS2>
  862+    X        .iif true, ...XBUS2 == 0, .mexit
  863+    X       .endc
  864+    X       .if idn,<name>,<XBUS3>
  865+    X        .iif true, ...XBUS3 == 0, .mexit
  866+    X       .endc
  867+    X       .if idn,<name>,<XBUS>
  868+    X        .iif true, (...XBUS0|...XBUS1|...XBUS2|...XBUS3) == 0, .mexit
  869+    X       .endc
  870+    X      .endc	; PHX
  871+    X      .if idn,<name>,<INT0>
  872+    X       .iif true, ...INT0 == 0, .mexit
  873+    X      .endc
  874+    X      .if idn,<name>,<INT1>
  875+    X       .iif true, ...INT1 == 0, .mexit
  876+    X      .endc
  877+    X      .if idn,<name>,<INT2>
  878+    X       .iif true, ...INT2 == 0, .mexit
  879+    X      .endc
  880+    X      .if idn,<name>,<INT3>
  881+    X       .iif true, ...INT3 == 0, .mexit
  882+    X      .endc
  883+    X      .if idn,<name>,<INT4>
  884+    X       .iif true, ...INT4 == 0, .mexit
  885+    X      .endc
  886+    X      .if idn,<name>,<INT5>
  887+    X       .iif true, ...INT5 == 0, .mexit
  888+    X      .endc
  889+    X      .if idn,<name>,<IOA>
  890+    X       .iif true, ...IOA == 0, .mexit
  891+    X      .endc
  892+    X         prc_set_vec('name'_INTVEC, default);
  893+    X     .endc
  894+    X     	.endm
  895+    X     	.include phx_vecs.mac
  896+          
  897+    X     /* Map the Phoenix interrupts */
  898+          
  899+    X     .if df, INTCTL_MAPA_INIT
  900+    X         BLABF(("\ndispatch: Mapping the A interrupts: 0x%08lX...", INTCTL_MAPA_INIT));
  901+    X         *((VU32 *)(INTCTL_MAPA)) = INTCTL_MAPA_INIT;
  902+    X     .endc
  903+    X     .if df, INTCTL_MAPB_INIT
  904+    X         BLABF(("\ndispatch: Mapping the B interrupts: 0x%08lX...", INTCTL_MAPB_INIT));
  905+    X         *((VU32 *)(INTCTL_MAPB)) = INTCTL_MAPB_INIT;
  906+    X     .endc
  907+          
  908+    X     .if defined, ANNOUNCE_BOOT_ACTIONS
dispatch.c                               Atari Games Corp. macpp v9.12   "Oct 16 1997 13:26:41"


  909+    X      .if true, ANNOUNCE_BOOT_ACTIONS
  910+    X         {
  911+    X     	int jj;
  912+    X     	extern int prc_get_cause(void), prc_get_ipl(void);
  913+    X     	jj = prc_get_cause();
  914+    X     	if (jj&0xFF00) BLABF(("\ndispatch: CPU cause reg: %08lX, CPU SR reg: %08lX", jj, prc_get_ipl()));
  915+    X     	if (jj&0x0400) {
  916+    X       .if true, ...INT0
  917+    X     	.macro VDF cond, name, softvec, intern, installer, notes, physical, default, comments
  918+    X     	.condit cond	
  919+    X        .iif idn,<name>,<INT0>,.mexit
  920+    X        .iif idn,<softvec>,<0>,.mexit
  921+    X        .if true, physical == INT0_LVL
  922+    X     	    if (!softvec) BLAB("\ndispatch: Warning, IRQ 0 pending \"'comments'\"");
  923+    X        .endc
  924+    X     	.endm
  925+    X     	.include phx_vecs.mac		; pickup all vectors assigned to IRQ 0
  926+    X       .iff
  927+    X     	    BLAB("\ndispatch: Warning, IRQ 0 pending with no vector assigned");
  928+    X       .endc		; ...INT0
  929+    X     	}
  930+    X     	if (jj&0x0800) {
  931+    X       .if true, ...INT1
  932+    X     	.macro VDF cond, name, softvec, intern, installer, notes, physical, default, comments
  933+    X     	.condit cond	
  934+    X        .iif idn,<name>,<INT1>,.mexit
  935+    X        .iif idn,<softvec>,<0>,.mexit
  936+    X        .if true, physical == INT1_LVL
  937+    X     	    if (!softvec) BLAB("\ndispatch: Warning, IRQ 1 pending \"'comments'\"");
  938+    X        .endc
  939+    X     	.endm
  940+    X     	.include phx_vecs.mac		; pickup all vectors assigned to IRQ 1
  941+    X       .iff
  942+    X     	    BLAB("\ndispatch: Warning, IRQ 1 pending with no vector assigned");
  943+    X       .endc		; ...INT1
  944+    X     	}
  945+    X     	if (jj&0x1000) {
  946+    X       .if true, ...INT2
  947+    X     	.macro VDF cond, name, softvec, intern, installer, notes, physical, default, comments
  948+    X     	.condit cond	
  949+    X        .iif idn,<name>,<INT2>,.mexit
  950+    X        .iif idn,<softvec>,<0>,.mexit
  951+    X        .if true, physical == INT2_LVL
  952+    X     	    if (!softvec) BLAB("\ndispatch: Warning, IRQ 2 pending \"'comments'\"");
  953+    X        .endc
  954+    X     	.endm
  955+    X     	.include phx_vecs.mac		; pickup all vectors assigned to IRQ 2
  956+    X       .iff
  957+    X     	    BLAB("\ndispatch: Warning, IRQ 2 pending with no vector assigned");
  958+    X       .endc		; ...INT2
  959+    X     	}
  960+    X     	if (jj&0x2000) {
  961+    X       .if true, ...INT3
  962+    X     	.macro VDF cond, name, softvec, intern, installer, notes, physical, default, comments
  963+    X     	.condit cond	
  964+    X        .iif idn,<name>,<INT3>,.mexit
  965+    X        .iif idn,<softvec>,<0>,.mexit
dispatch.c                               Atari Games Corp. macpp v9.12   "Oct 16 1997 13:26:41"


  966+    X        .if true, physical == INT3_LVL
  967+    X     	    if (!softvec) BLAB("\ndispatch: Warning, IRQ 3 pending \"'comments'\"");
  968+    X        .endc
  969+    X     	.endm
  970+    X     	.include phx_vecs.mac		; pickup all vectors assigned to IRQ 3
  971+    X       .iff
  972+    X     	    BLAB("\ndispatch: Warning, IRQ 3 pending with no vector assigned");
  973+    X       .endc		; ...INT3
  974+    X     	}
  975+    X     	if (jj&0x4000) {
  976+    X       .if true, ...INT4
  977+    X     	.macro VDF cond, name, softvec, intern, installer, notes, physical, default, comments
  978+    X     	.condit cond	
  979+    X        .iif idn,<name>,<INT4>,.mexit
  980+    X        .iif idn,<softvec>,<0>,.mexit
  981+    X        .if true, physical == INT4_LVL
  982+    X     	    if (!softvec) BLAB("\ndispatch: Warning, IRQ 4 pending \"'comments'\"");
  983+    X        .endc
  984+    X     	.endm
  985+    X     	.include phx_vecs.mac		; pickup all vectors assigned to IRQ 4
  986+    X       .iff
  987+    X     	    BLAB("\ndispatch: Warning, IRQ 4 pending with no vector assigned");
  988+    X       .endc		; ...INT4
  989+    X     	}
  990+    X     	if (jj&0x8000) {
  991+    X       .if true, ...INT5
  992+    X     	.macro VDF cond, name, softvec, intern, installer, notes, physical, default, comments
  993+    X     	.condit cond	
  994+    X        .iif idn,<name>,<INT5>,.mexit
  995+    X        .iif idn,<softvec>,<0>,.mexit
  996+    X        .if true, physical == INT5_LVL
  997+    X     	    if (!softvec) BLAB("\ndispatch: Warning, IRQ 5 pending \"'comments'\"");
  998+    X        .endc
  999+    X     	.endm
 1000+    X     	.include phx_vecs.mac		; pickup all vectors assigned to IRQ 5
 1001+    X       .iff
 1002+    X     	    BLAB("\ndispatch: Warning, IRQ 5 pending with no vector assigned");
 1003+    X       .endc		; ...INT5
 1004+    X     	}
 1005+    X         }
 1006+    X      .endc		; true, ANNOUNCE_BOOT_ACTIONS
 1007+    X     .endc		; defined, ANNOUNCE_BOOT_ACTIONS
 1008+    X         return;
 1009+    X     }
 1010+   (4)    .endc		; _DISPATCH_MAC_ == 0
  941    (3)      .iff
  942     X     	    BLAB("\ndispatch: Warning, IRQ 1 pending with no vector assigned");
  943    (3)      .endc		; ...INT1
  944           	}
  945           	if (jj&0x1000) {
  946    (3)      .if true, ...INT2
  947     X     	.macro VDF cond, name, softvec, intern, installer, notes, physical, default, comments
  948     X     	.condit cond	
  949     X        .iif idn,<name>,<INT2>,.mexit
  950     X        .iif idn,<softvec>,<0>,.mexit
  951     X        .if true, physical == INT2_LVL
  952     X     	    if (!softvec) BLAB("\ndispatch: Warning, IRQ 2 pending \"'comments'\"");
dispatch.c                               Atari Games Corp. macpp v9.12   "Oct 16 1997 13:26:41"


  953     X        .endc
  954     X     	.endm
  955     X     	.include phx_vecs.mac		; pickup all vectors assigned to IRQ 2
  956    (3)      .iff
  957           	    BLAB("\ndispatch: Warning, IRQ 2 pending with no vector assigned");
  958    (3)      .endc		; ...INT2
  959           	}
  960           	if (jj&0x2000) {
  961    (3)      .if true, ...INT3
  962           	.macro VDF cond, name, softvec, intern, installer, notes, physical, default, comments
  963           	.condit cond	
  964              .iif idn,<name>,<INT3>,.mexit
  965              .iif idn,<softvec>,<0>,.mexit
  966              .if true, physical == INT3_LVL
  967           	    if (!softvec) BLAB("\ndispatch: Warning, IRQ 3 pending \"'comments'\"");
  968              .endc
  969           	.endm
  970           	.include phx_vecs.mac		; pickup all vectors assigned to IRQ 3
    1+          ;/*		phx_vecs.mac
    2+          ; *
    3+          ; *		Copyright 1996 Atari Games Corporation
    4+          ; *	Unauthorized reproduction, adaptation, distribution, performance or 
    5+          ; *	display of this computer program or the associated audiovisual work
    6+          ; *	is strictly prohibited.
    7+          ; *
    8+          ; *	This file is processed by MACPP to produce dispatch.c and intvecs.h.
    9+          ; *
   10+          ; *	The definitions placed in intvecs.h declare virtual vector numbers
   11+          ; *	in the form of xxx_INTVEC and a cross reference table(s) so the
   12+          ; *	dispatcher can call the appropriate functions.
   13+          ; *
   14+          ; *	intvecs.h should be #include'd by any module that uses prc_set_vec().
   15+          ; */
   16+          ;
   17+          ; This file recursivley '.includes' itself to succesively build up the approprate
   18+          ; tables and functions in C and places the results in one of two files (the
   19+          ; first -out=file supplied on the MACPP command line is expected to be dispatch.c
   20+          ; and the second -out=file is expected to be intvecs.h and the third is expected to
   21+          ; be /dev/null). If you don't speak fluent MACPP, then you probably shouldn't be
   22+          ; changing anything in this file other than the VDF table listed below.
   23+          ;
   24+   (4)    .if not_defined, _DISPATCH_MAC_		;1 +++++
   25+    X     _DISPATCH_MAC_ == 0			;2 Don't move ...
   26+    X     OUTPUT_LANG == 5 ;LANG_NONE		;3 ... or change ... 
   27+    X     	.outfile 2			;4 ... anything on ...
   28+    X     	.include config.mac		;5 ... these ...
   29+    X     	.outfile 0			;6 ... nine  ...
   30+   (4)    .endc					;7 ... lines ...
   31+   (4)    .if true, (_DISPATCH_MAC_&1) != 0	;8
   32+   (5)     .if true, 0				;9 -----
   33+          
   34+    X     You are free to add or remove entries from this table according to your
   35+    X     requirements. There are 10 fields used on each line in this table. The
   36+    X     description of each field follows:
   37+          
   38+    X     Field 1 = macro call
   39+          
dispatch.c                               Atari Games Corp. macpp v9.12   "Oct 16 1997 13:26:41"


   40+    X     It must always be the keyword VDF (case is not significant).
   41+          
   42+    X     Field 2 = condition
   43+          
   44+    X     This is a dual operand field, so the two operands together must be enclosed in
   45+    X     <>'s. The first operand is one of T, F, D or N representing True, False,
   46+    X     Defined or Not_defined respectively. Case is significant, use uppercase only
   47+    X     please. For the conditions T or F the second operand must be an expression
   48+    X     which must resolve to non-$0 (True) or $0 (False) in order for the macro
   49+    X     to be processed (else it is ignored). The expression can contain no embedded
   50+    X     spaces. For the conditions D and N, the second operand must only be a symbol
   51+    X     which must be Defined or Not-defined respectively in order for the macro to be
   52+    X     processed. Some short cut expressions have been preprocessed to make using the
   53+    X     expressions a little more concise. These are:
   54+          
   55+    X     	PHX = not $0 if HOST_BOARD == PHOENIX
   56+    X     	PAD = not $0 if HOST_BOARD == PHOENIX_AD
   57+    X     	FLG = not $0 if HOST_BOARD == FLAGSTAFF
   58+    X     	SEA = not $0 if HOST_BOARD == SEATTLE
   59+    X     	VEG = not $0 if HOST_BOARD == VEGAS
   60+          
   61+    X     Field 3 = vector name
   62+          
   63+    X     The NAME field is the name of the virtual vector. An _INTVEC will be appended
   64+    X     to it in the C definitions in intvecs.h, but otherwise the name is unmolested.
   65+    X     Case is significant only if you want it to be. The R3K/R4K has an option where
   66+    X     a number of vectors are maintained in an array of pointers rather than each
   67+    X     one having its own name. The index into the array is same as the number
   68+    X     returned in the processor's CAUSE register for that particluar interrupt. This
   69+    X     procedure is done simply for performance reasons. The option is selected by
   70+    X     using a 0 for this field and using an installer function with the vector index
   71+    X     as the parameter to the installer.
   72+          
   73+    X     Field 4 = Vector pointer
   74+          
   75+    X     This field identifies the name of a variable in BSS that contains a pointer
   76+    X     to the function to call at interrupt (or will be set by the prc_set_vec()
   77+    X     function). This is the name of the "soft" or logical vector and is either
   78+    X     declared in dispatch.c or externally according to the INT/EXT field described
   79+    X     next.
   80+          
   81+    X     Field 5 = INTernal or EXTernal vector
   82+          
   83+    X     This field contains the keywords INT, EXT, VINT or VEXT identifying the vector
   84+    X     in field 4 as being defined INTernally, EXTernally, Volatile INTernally or
   85+    X     Volatile Externally to dispatch.c respectively.
   86+          
   87+    X     Field 6 = name of vector installer
   88+          
   89+    X     This field identifies the name of a function that prc_set_vec() will call to
   90+    X     actually install the vector or 0 if there is no special stuff that needs to
   91+    X     be performed during vector installation.
   92+          
   93+    X     Field 7 = Notes for the installer.
   94+          
   95+    X     The Notes field is a parameter that is passed to the installer if there is one.
   96+          
dispatch.c                               Atari Games Corp. macpp v9.12   "Oct 16 1997 13:26:41"


   97+    X     Field 8 = Physical vector attachment.
   98+          
   99+    X     A dispatch routine is constructed for each of the 4 XBUS interrupts and for each of
  100+    X     the 6 CPU interrupts.  This field instructs phx_vecs.mac into which of the XBUS or
  101+    X     INTx dispatchers a caller to this vector belongs.  If this vector is not associated
  102+    X     with an XBUS or an INTx interrupt, it needs to be -1.  Place the interrupt routines
  103+    X     in this table in the order in which you want them executed.
  104+          
  105+    X     Field 9 = Default function.
  106+          
  107+    X     Name of default routine to install in the vector, or 0 if none.  phx_vecs.mac builds
  108+    X     a function called prc_init_vecs(void) which, when called, will perform a string of
  109+    X     prc_set_vec()'s for all the vectors having this field non-zero.  After the vectors
  110+    X     have been loaded, prc_init_vecs(void) will map the phoenix and galileo interrupts as
  111+    X     specified in phoenix.mac.
  112+          
  113+    X     Field 10 = Comments.
  114+          
  115+    X     The Comments field is placed on selected lines in intvecs.h and/or dispatch.c
  116+    X     as simple 'C' comments.
  117+          
  118+   (5)     .endc				; Don't move this line
  119+          ;
  120+          ;   Condit	Name	   Vector   I/E	Installer   Notes      Phys	Default	Comments
  121+          ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  122+          VDF <T,1>	GAMEVB,	   gameint, EXT	0,          0,		-1,	0,	< post-wierdness Vblank >
  123+          VDF <T,1>	MS4,       ms4vec,  EXT	0,          0,		-1,	0,	< 4 Millisecond timer >
  124+          VDF <T,1>	PRC_DELAY, prc_delay_vec, EXT 0,    0,		-1,	sst_prc_delay, < prc_delay soft vector >
  125+          VDF <T,1>	PRC_SET_IPL, set_ipl_vec, INT 0,    0,		-1,	0,	< prc_set_ipl soft vector >
  126+          VDF <T,1>	SAVE,      savintp, EXT 0,          0,		-1,	0,	< context save soft vector >
  127+          VDF <T,1>	RESTORE,   restintp,EXT 0,          0,		-1,	0,	< context restore soft vector >
  128+          VDF <T,1>	SW0,	   0,	    INT hwvinst,    VN_IRQ0,    -1,	0,	< Software interrupt 0 >
  129+          VDF <T,1>	SW1,	   0,       INT hwvinst,    VN_IRQ1,    -1,	0,	< Software interrupt 0 >
  130+          VDF <T,1>	INT0,	   0,       INT hwvinst,    VN_IRQ2,    -1,	int0_irq, < Hardware interrupt 0 >
  131+          VDF <T,1>	INT1,	   0,	    INT hwvinst,    VN_IRQ3,    -1,	int1_irq, < Hardware interrupt 1 >
  132+          VDF <T,PHX>	INT2,	   0,	    INT hwvinst,    VN_IRQ4,    -1,	int2_irq, < Hardware interrupt 2 >
  133+          VDF <T,1>	INT3,	   0,       INT hwvinst,    VN_IRQ5,    -1,	int3_irq, < Hardware interrupt 3 >
  134+          VDF <T,1>	INT4,	   0,	    INT hwvinst,    VN_IRQ6,    -1,	int4_irq, < Hardware interrupt 4 >
  135+          VDF <T,1>	INT5,	   0,	    INT hwvinst,    VN_IRQ7,    -1,	int5_irq, < Hardware interrupt 5 >
  136+          VDF <T,1>	TLBMOD,	   0,	    INT hwvinst,    VN_TLBM,    -1,	0,	< TLB modification >
  137+          VDF <T,1>	TLBLOAD,   0,	    INT hwvinst,    VN_TLBL,    -1,	0,	< TLB miss on I or D fetch >
  138+          VDF <T,1>	TLBSTORE,  0,	    INT hwvinst,    VN_TLBS,    -1,	0,	< TLB miss on store >
  139+          VDF <T,1>	ADDRERRL,  0,	    INT hwvinst,    VN_ADDRL,   -1,	0,	< Address error on I or D fetch >
  140+          VDF <T,1>	ADDRERRS,  0,	    INT hwvinst,    VN_ADDRS,   -1,	0,	< Address error on store >
  141+          VDF <T,1>	BUSERRI,   0,	    INT hwvinst,    VN_BUSERRI, -1,	0,	< Bus error on I-fetch >
  142+          VDF <T,1>	BUSERRD,   0,	    INT hwvinst,    VN_BUSERRD, -1,	0,	< Bus error on D-fetch >
  143+          VDF <T,1>	SYSCALL,   0,       INT hwvinst,    VN_SYSCALL, -1,	0,	< SYSCALL instruction >
  144+          VDF <T,1>	BREAK,     0,       INT hwvinst,    VN_BREAK,   -1,	0,	< Breakpoint instruction >
  145+          VDF <T,1>	RESERV,    0,       INT hwvinst,    VN_RESERV,  -1,	0,	< Reserved instruction >
  146+          VDF <T,1>	COPROC,    0,       INT hwvinst,    VN_COPROC,  -1,	0,	< Coprocessor unusable >
  147+          VDF <T,1>	OVRFLOW,   0,       INT hwvinst,    VN_OVERFL,  -1,	0,	< Integer Arithmetic Overflow >
  148+          VDF <T,1>	TRAP,      0,       INT hwvinst,    VN_TRAPV,   -1,	0,	< TRAP exception >
  149+          VDF <T,1>	FLOAT,     0,       INT hwvinst,    VN_FPE,     -1,	0,	< FLoating point exception >
  150+          VDF <T,1>	TIMER,	   timervec, INT 0,	    0,          -1,	0,	< Soft Timer interrupt >
  151+          VDF <T,1>	TIMERPLL,  tpllvec, VEXT 0,	    0,		-1,	0,	<Adjust 1MS timer>
  152+          VDF <T,1>	GAMEFRAME, framevec,INT 0,	    0,		-1,	0,	< Frame complete >
  153+   (5)    .if true, PHX
dispatch.c                               Atari Games Corp. macpp v9.12   "Oct 16 1997 13:26:41"


  154+    X     VDF <D,NET_LVL>	NET,       netintp, INT 0,          0,		NET_LVL,0,	< network int soft vector >
  155+    X     VDF <D,XBUS>	XBUS,	   xbusintp, INT pvinst,    XBUS_NOTES,	XBUS_LVL,xbus_irq, < Any XBUS interrupt >
  156+    X     VDF <T,XS0>	XS0,       xs0intp, INT pvinst,	    XS0_NOTES,	XS0_LVL,0,	< Expansion Slot 0 interrupt >
  157+    X     VDF <T,XS1>	XS1,       xs1intp, INT pvinst,	    XS1_NOTES,	XS1_LVL,0,	< Expansion Slot 1 interrupt >
  158+    X     VDF <T,XS2>	XS2,       xs2intp, INT pvinst,	    XS2_NOTES,	XS2_LVL,0,	< Expansion Slot 2 interrupt >
  159+    X     VDF <T,XS3>	XS3,       xs3intp, INT pvinst,	    XS3_NOTES,	XS3_LVL,0,	< Expansion Slot 3 interrupt >
  160+    X     VDF <T,MIO>	MIO,       miointp, INT pvinst,	    MIO_NOTES,	MIO_LVL,0,	< Miscellaneous I/O interrupt >
  161+    X     VDF <T,CU1>	CU1,       cu1intp, INT pvinst,	    CU1_NOTES,	CU1_LVL,0,	< Combo UART 1 interrupt >
  162+    X     VDF <T,CU2>	CU2,       cu2intp, INT pvinst,	    CU2_NOTES,	CU2_LVL,0,	< Combo UART 2 interrupt >
  163+    X     VDF <T,CPP>	CPP,       cppintp, INT pvinst,	    CPP_NOTES,	CPP_LVL,0,	< Combo Parallel Port interrupt >
  164+    X     VDF <T,PCA>	PCA,       pcaintp, INT pvinst,	    PCA_NOTES,	PCA_LVL,0,	< PCI A interrupt >
  165+    X     VDF <T,PCB>	PCB,       pcbintp, INT pvinst,	    PCB_NOTES,	PCB_LVL,0,	< PCI B interrupt >
  166+    X     VDF <T,PCC>	PCC,       pccintp, INT pvinst,	    PCC_NOTES,	PCC_LVL,0,	< PCI C interrupt >
  167+    X     VDF <T,VSY>	VSY,       vsyintp, INT pvinst,	    VSY_NOTES,	VSY_LVL,0,	< PCI D (VSYNC) interrupt >
  168+    X     VDF <T,IDE>	IDE,	   ideintp, INT pvinst,	    IDE_NOTES,	IDE_LVL,0,	< IDE interrupt >
  169+    X     VDF <T,IOA>	IOA,	   ioaintp, INT pvinst,	    IOA_NOTES,	IOA_LVL,ioa_irq,< I/O Asic interrupt >
  170+    X     VDF <T,ADC>	ADC,	   adcintp, INT pvinst,	    ADC_NOTES,	ADC_LVL,0,	< A/D Converter interrupt >
  171+    X     VDF <D,SND_I>	CAGE,      cagevec, INT 0,          0,		CAGE_LVL,aud_irq, < CAGE interrupt >
  172+   (5)    .endc
  173+   (5)    .if true, PAD || FLG || SEA || VEG
  174+          ;VDF <T,1>	IOA,	   0,	    INT hwvinst,    VN_IRQ3,	-1,	0,	< I/O Asic interrupt >
  175+          VDF <T,1>	IDE,	   0,	    INT hwvinst,    VN_IRQ4,    -1,	0,	< IDE interrupt >
  176+          VDF <T,EXP>	EXP,       expintp, INT pvinst,	    EXP_NOTES,	EXP_LVL,0,	< Expansion Slot interrupt >
  177+   (6)     .if true, PAD || SEA
  178+          VDF <T,NSS>	NSS,	   nssintp, INT pvinst,	    NSS_NOTES,  NSS_LVL,0,	< NSS/Hi-Link interrupt>
  179+   (6)     .endc
  180+   (6)     .if true, FLG
  181+    X     VDF <T,ETH>	ETH,	   ethintp, INT pvinst,     ETH_NOTES,  ETH_LVL,0,	< ethernet interrupt >
  182+    X     VDF <D,SND_I>	CAGE,	   cagevec, INT ioainst,    CAGE_NOTES, CAGE_LVL,aud_irq, < CAGE interrupt >
  183+   (6)     .endc
  184+          VDF <T,WD1>	WD1,	   wd1intp, INT pvinst,	    WD1_NOTES,  WD1_LVL,0,	< Widget interrupt 1>
  185+          VDF <T,PCI>	PCI,       pciintp, INT pvinst,	    PCI_NOTES,	PCI_LVL,0,	< PCI interrupt >
  186+          VDF <T,ADC>	ADC,	   adcintp, INT pvinst,	    ADC_NOTES,	ADC_LVL,0,	< A/D Converter interrupt >
  187+          VDF <T,WD2>	WD2,	   wd2intp, INT pvinst,	    WD2_NOTES,  WD2_LVL,0,	< Widget interrupt 2>
  188+          VDF <T,DBG>	DBG,	   dbgintp, INT pvinst,	    DBG_NOTES,	DBG_LVL,0,	< Debug switch interrupt >
  189+          VDF <T,VSY>	VSY,	   vsyintp, INT pvinst,	    VSY_NOTES,	VSY_LVL,0,	< VSYNC interrupt >
  190+   (5)    .endc
  191+          VDF <T,GAL>	GAL,	   0,       INT gvinst,	    GAL_NOTES,  GAL_LVL,galileoint, < Any Galileo Error Interrupt >
  192+          VDF <T,MOE>	MOE,	   moeintp, INT gvinst,	    MOE_NOTES,	MOE_LVL,0,	< Galileo MemOut >
  193+          VDF <T,DOE>	DOE,	   doeintp, INT gvinst,	    DOE_NOTES,	DOE_LVL,0,	< Galileo DMAOut >
  194+          VDF <T,COE>	COE,	   coeintp, INT gvinst,	    COE_NOTES,	COE_LVL,0,	< Galileo CPUOut >
  195+          VDF <T,DM0>	DM0,	   dm0intp, INT gvinst,	    DM0_NOTES,	DM0_LVL,0,	< Galileo DMA0Comp >
  196+          VDF <T,DM1>	DM1,	   dm1intp, INT gvinst,	    DM1_NOTES,	DM1_LVL,0,	< Galileo DMA1Comp >
  197+          VDF <T,DM2>	DM2,	   dm2intp, INT gvinst,	    DM2_NOTES,	DM2_LVL,0,	< Galileo DMA2Comp >
  198+          VDF <T,DM3>	DM3,	   dm3intp, INT gvinst,	    DM3_NOTES,	DM3_LVL,0,	< Galileo DMA3Comp >
  199+          VDF <T,TM0>	TM0,	   tm0intp, INT gvinst,	    TM0_NOTES,	TM0_LVL,0,	< Galileo T0Exp >
  200+          VDF <T,TM1>	TM1,	   tm1intp, INT gvinst,	    TM1_NOTES,	TM1_LVL,0,	< Galileo T1Exp >
  201+          VDF <T,TM2>	TM2,	   tm2intp, INT gvinst,	    TM2_NOTES,	TM2_LVL,0,	< Galileo T2Exp >
  202+          VDF <T,TM3>	TM3,	   tm3intp, INT gvinst,	    TM3_NOTES,	TM3_LVL,cputimerint, < Galileo T3EXP timer interrupt >
  203+          VDF <T,MRE>	MRE,	   mreintp, INT gvinst,	    MRE_NOTES,	MRE_LVL,0,	< Galileo MasRdErr >
  204+          VDF <T,SWE>	SWE,	   sweintp, INT gvinst,	    SWE_NOTES,	SWE_LVL,0,	< Galileo SlvWrErr >
  205+          VDF <T,MWE>	MWE,	   mweintp, INT gvinst,	    MWE_NOTES,	MWE_LVL,0,	< Galileo MasWrErr >
  206+          VDF <T,SRE>	SRE,	   sreintp, INT gvinst,	    SRE_NOTES,	SRE_LVL,0,	< Galileo SlvRdErr >
  207+          VDF <T,AEP>	AEP,	   aepintp, INT gvinst,	    AEP_NOTES,	AEP_LVL,0,	< Galileo AddrErr >
  208+          VDF <T,MEP>	MEP,	   mepintp, INT gvinst,	    MEP_NOTES,	MEP_LVL,0,	< Galileo MemErr >
  209+          VDF <T,MAS>	MAS,	   masintp, INT gvinst,	    MAS_NOTES,	MAS_LVL,0,	< Galileo MasAbort >
  210+          VDF <T,TAR>	TAR,	   tarintp, INT gvinst,	    TAR_NOTES,	TAR_LVL,0,	< Galileo TarAbort >
dispatch.c                               Atari Games Corp. macpp v9.12   "Oct 16 1997 13:26:41"


  211+          VDF <T,RTY>	RTY,	   rtyintp, INT gvinst,	    RTY_NOTES,	RTY_LVL,0,	< Galileo RetryCtr >
  212+          VDF <T,PC0>	PC0,	   pc0intp, INT gvinst,	    PC0_NOTES,	PC0_LVL,0,	< Galileo PCI Interrupt >
  213+          VDF <T,PC1>	PC1,	   pc1intp, INT gvinst,	    PC1_NOTES,	PC1_LVL,0,	< Galileo PCI Interrupt >
  214+          VDF <T,PC2>	PC2,	   pc2intp, INT gvinst,	    PC2_NOTES,	PC2_LVL,0,	< Galileo PCI Interrupt >
  215+          VDF <T,PC3>	PC3,	   pc3intp, INT gvinst,	    PC3_NOTES,	PC3_LVL,0,	< Galileo PCI Interrupt >
  216+          VDF <D,UART_LVL> UART,	   uartintp,INT ioainst,    UART_NOTES,	UART_LVL,0,	< I/O ASIC UART interrupts >
  217+          VDF <D,SND_LVL>	SND,	   sndintp, INT ioainst,    SND_NOTES,	SND_LVL, 0,	< I/O ASIC Sound interrupts >
  218+          VDF <D,MC_LVL>	MC,	   mcintp,  INT ioainst,    MC_NOTES,	MC_LVL,	0,	< I/O ASIC Microcontroller interrupt >
  219+          ;
  220+   (4)    .endc			; (_DISPATCH_MAC_&1) != 0 *** DON'T MOVE THIS LINE EITHER ***
  221+          ;
  222+          ;+++++++ From here on, there are few user servicable parts inside. ++++
  223+          ;
  224+          ; This is sortof how it works:
  225+          ; The first pass through, _DISPATCH_MAC_ will be 0 (set above by the .if not_defined).
  226+          ; First the copyright boilerplate is inserted into both output files and the macro VDF
  227+          ; is defined to create externs. Some struct definitions and unique externs are depositied
  228+          ; into the .h file. Next _DISPATCH_MAC_ is set to 1 and this file is .included
  229+          ; again. This will cause MACPP to read the VDF table above and output the appropriate
  230+          ; information in the .h file but ignore the rest of the file. The VDF macro is redefined,
  231+          ; and the procedure is repeated causing the creation of different items according to what
  232+          ; is needed. Once the whole .h file is built, the procedure repeats for the building of the
  233+          ; .c file.
  234+          ;
  235+   (4)    .if true, _DISPATCH_MAC_ == 0		; First (main) pass
  236+    X      PHX == 0
  237+    X      PAD == 0
  238+    X      FLG == 0
  239+    X      SEA == 0
  240+    X      VEG == 0
  241+    X      .iif true, HOST_BOARD == PHOENIX, PHX == 1 ;set the appropriate ones true as desired
  242+    X      .iif true, HOST_BOARD == PHOENIX_AD, PAD == 1 ;set the appropriate ones true as desired
  243+    X      .iif true, HOST_BOARD == FLAGSTAFF, FLG == 1 ;set the appropriate ones true as desired
  244+    X      .iif true, HOST_BOARD == SEATTLE, SEA == 1 ;set the appropriate ones true as desired
  245+    X      .iif true, HOST_BOARD == VEGAS, VEG == 1 ;set the appropriate ones true as desired
  246+          ;
  247+    X     	.macro .condit flag,exp		; The .condit macro does an expression test ...
  248+    X     	.if identical,<flag>,<T>
  249+    X     		.iif false,exp,.mexit 10 ; ... and aborts higher level macros if false
  250+    X     		.mexit
  251+    X     	.endc
  252+    X     	.if identical,<flag>,<F>
  253+    X     		.iif true,exp,.mexit 10	; ... etc.
  254+    X     		.mexit
  255+    X     	.endc
  256+    X     	.if identical,<flag>,<D>
  257+    X     		.iif not_defined,exp,.mexit 10
  258+    X     		.mexit
  259+    X     	.endc
  260+    X     	.if identical,<flag>,<N>
  261+    X     		.iif defined,exp,.mexit 10
  262+    X     		.mexit
  263+    X     	.endc
  264+    X     	.endm
  265+          ;	
  266+    X     	.macro boilerplate file_name
  267+    X     /*		file_name
dispatch.c                               Atari Games Corp. macpp v9.12   "Oct 16 1997 13:26:41"


  268+    X      *
  269+    X      *		Copyright 1996 Atari Games Corporation
  270+    X      *	Unauthorized reproduction, adaptation, distribution, performance or 
  271+    X      *	display of this computer program or the associated audiovisual work
  272+    X      *	is strictly prohibited.
  273+    X      *
  274+    X      * ++++++ WARNING WARNING WARNING WARNING WARNING +++++
  275+    X      * This file is machine generated. Any changes you put in here will be lost
  276+    X      * the next time phx_vecs.mac is touched. You need to make your changes to
  277+    X      * phx_vecs.mac instead of this file.
  278+    X      */
  279+    X     	.endm
  280+    X     	boilerplate dispatch.c
  281+    X     	.outfile	1		;The externs go into the .h file
  282+    X     	boilerplate intvecs.h
  283+    X     #if !defined(_INTVECS_H_)
  284+    X     #define _INTVECS_H_
  285+          
  286+    X     struct irq_tab {
  287+    X     	void 	(**softvec)();
  288+    X     	void    (*(*installer)(const struct irq_tab *, void(*new)()))();
  289+    X     	int	notes;
  290+    X     };
  291+          ;
  292+    X     	.macro VDF cond, name, softvec, intern, installer, notes, physical, default, comments
  293+    X     	.condit cond	
  294+    X      .if dif,<softvec>,<0>
  295+    X       ...1 == 0
  296+    X       .iif idn,<intern>,<VINT>,...1 == 1
  297+    X       .iif idn,<intern>,<VEXT>,...1 == 1
  298+    X       .if true, ...1
  299+    X     extern	void (* volatile softvec)();	/* comments */
  300+    X       .iff
  301+    X     extern  void (*softvec)();	/* comments */
  302+    X       .endc
  303+    X      .endc
  304+    X     	.endm
  305+          ;
  306+    X     	_DISPATCH_MAC_ == 1		;next time we process the IRQ table
  307+    X     	.include phx_vecs.mac		;Make the externs
  308+          
  309+    X     enum vecs {
  310+    X     	.macro VDF cond, name, softvec, intern, installer, notes, physical, default, comments
  311+    X     	.condit cond	
  312+    X         name'_INTVEC,
  313+    X     	.endm
  314+    X     	.include phx_vecs.mac		;Make the enums
  315+    X         N_INTVECS
  316+    X     };
  317+          
  318+    X     void (*prc_set_vec (unsigned int vecnum, void (*routine)() ))();
  319+    X     void prc_init_vecs(void);		/* set the default vectors */
  320+          ;
  321+          ; Add a prototype for an as yet unused function
  322+    X     .if true, 0
  323+          
  324+    X     /*		prc_set_vecp(which, what)
dispatch.c                               Atari Games Corp. macpp v9.12   "Oct 16 1997 13:26:41"


  325+    X      *	Sets a special vector for the interrupt identified by <which>
  326+    X      *	to call the routine specified by <what>. <what> is
  327+    X      *	a struct that contains both a pointer to the code
  328+    X      *	to execute and an optional pointer to the private
  329+    X      *	variables for that routine. This is a change from the
  330+    X      *	behavior of prc_set_vec, and is intended to allow
  331+    X      *	multiple incarnations of a given device to share code.
  332+    X      */
  333+          
  334+    X     struct opaque;
  335+    X     extern struct VECP_vector {
  336+    X         void (*function)(struct opaque *);	/* Who you gonna call */
  337+    X         struct opaque *cookie;		/* a magic cookie to hand him */
  338+    X     } prc_set_vecp (
  339+    X         int __which,			/* one of xxx_INTVEC */
  340+    X         struct IRQ_vector __what		/* BY VALUE!!! */
  341+    X     );
  342+    X     .endc
  343+    X     #endif		/* _INTVECS_H_ */
  344+          ;
  345+          ; At this point, we have completed all processing of the .h file
  346+          ; so switch back to the .c file
  347+          ;
  348+    X     	.outfile	0		;switch back to dispatch.c
  349+          ;
  350+    X     #include <config.h>			/* begining of dispatch.c */
  351+    X     #include <os_proto.h>
  352+    X     #include <intvecs.h>
  353+          
  354+    X     #ifndef BLABF
  355+    X     # define BLABF(x)
  356+    X     #endif
  357+          
  358+    X     #ifndef BLAB
  359+    X     # define BLAB(x)
  360+    X     #endif
  361+          
  362+    X      .if true, 1
  363+    X     	.macro VDF cond, name, softvec, intern, installer, notes, physical, default, comments
  364+    X     	.condit cond	
  365+    X       .iif idn,<name>,<XBUS0>,.mexit
  366+    X       .iif idn,<name>,<XBUS1>,.mexit
  367+    X       .iif idn,<name>,<XBUS2>,.mexit
  368+    X       .iif idn,<name>,<XBUS3>,.mexit
  369+    X       .iif idn,<name>,<INT0>,.mexit
  370+    X       .iif idn,<name>,<INT1>,.mexit
  371+    X       .iif idn,<name>,<INT2>,.mexit
  372+    X       .iif idn,<name>,<INT3>,.mexit
  373+    X       .iif idn,<name>,<INT4>,.mexit
  374+    X       .iif idn,<name>,<INT5>,.mexit
  375+    X       .if true, PHX
  376+    X         .if true, physical == XBUS0_LVL
  377+    X     	  ...XBUS0 == ...XBUS0 + 1
  378+    X     	  .mexit
  379+    X         .endc
  380+    X         .if true, physical == XBUS1_LVL
  381+    X     	  ...XBUS1 == ...XBUS1 + 1
dispatch.c                               Atari Games Corp. macpp v9.12   "Oct 16 1997 13:26:41"


  382+    X     	  .mexit
  383+    X         .endc
  384+    X         .if true, physical == XBUS2_LVL
  385+    X     	  ...XBUS2 == ...XBUS2 + 1
  386+    X     	  .mexit
  387+    X         .endc
  388+    X         .if true, physical == XBUS3_LVL
  389+    X     	  ...XBUS3 == ...XBUS3 + 1
  390+    X     	  .mexit
  391+    X         .endc
  392+    X       .endc
  393+    X       .if true, physical == INT0_LVL
  394+    X         	...INT0 == ...INT0 + 1
  395+    X     	.mexit
  396+    X       .endc
  397+    X       .if true, physical == INT1_LVL
  398+    X         	...INT1 == ...INT1 + 1
  399+    X        .if true, PAD || FLG || SEA || VEG
  400+    X     	...IOA == ...IOA + 1
  401+    X         .if ndf, notes
  402+    X     #define notes IO_MAIN_GLOBAL_INT
  403+    X         .endc
  404+    X        .endc
  405+    X     	.mexit
  406+    X       .endc
  407+    X       .if true, physical == INT2_LVL
  408+    X         	...INT2 == ...INT2 + 1
  409+    X     	.mexit
  410+    X       .endc
  411+    X       .if true, physical == INT3_LVL
  412+    X         	...INT3 == ...INT3 + 1
  413+    X     	.mexit
  414+    X       .endc
  415+    X       .if true, physical == INT4_LVL
  416+    X         	...INT4 == ...INT4 + 1
  417+    X     	.mexit
  418+    X       .endc
  419+    X       .if true, physical == INT5_LVL
  420+    X         	...INT5 == ...INT5 + 1
  421+    X     	.mexit
  422+    X       .endc
  423+    X       .if true, physical == IOASIC_LVL
  424+    X         	...IOA == ...IOA + 1
  425+    X        .if ndf, notes
  426+    X     #define notes IO_MAIN_GLOBAL_INT
  427+    X        .endc
  428+    X     	.mexit
  429+    X       .endc
  430+    X     	.endm
  431+    X     ...XBUS0 == 0
  432+    X     ...XBUS1 == 0
  433+    X     ...XBUS2 == 0
  434+    X     ...XBUS3 == 0
  435+    X     ...INT0 == 0
  436+    X     ...INT1 == 0
  437+    X     ...INT2 == 0
  438+    X     ...INT3 == 0
dispatch.c                               Atari Games Corp. macpp v9.12   "Oct 16 1997 13:26:41"


  439+    X     ...INT4 == 0
  440+    X     ...INT5 == 0
  441+    X     ...IOA == 0
  442+    X     	.include phx_vecs.mac	; count vectors requiring dispatch
  443+    X      .endc
  444+          ; 
  445+    X     .macro VDF cond, name, softvec, intern, installer, notes, physical, default, comments
  446+    X      .condit cond	
  447+    X      .if dif,<softvec>,<0>
  448+    X       .if idn,<intern>,<INT>
  449+    X     void (*softvec)();	/* comments */
  450+    X       .endc
  451+    X       .if idn,<intern>,<VINT>
  452+    X     void (* volatile softvec)();	/* comments */
  453+    X       .endc
  454+    X      .endc
  455+    X      .if dif,<default>,<0>
  456+    X       .if idn,<name>,<INT0>
  457+    X        .if true, ...INT0
  458+    X     static void 'default'(void);	/* comments */
  459+    X        .endc
  460+    X        .mexit
  461+    X       .endc
  462+    X       .if idn,<name>,<INT1>
  463+    X        .if true, ...INT1
  464+    X     static void 'default'(void);	/* comments */
  465+    X        .endc
  466+    X        .mexit
  467+    X       .endc
  468+    X       .if idn,<name>,<INT2>
  469+    X        .if true, ...INT2
  470+    X     static void 'default'(void);	/* comments */
  471+    X        .endc
  472+    X        .mexit
  473+    X       .endc
  474+    X       .if idn,<name>,<INT3>
  475+    X        .if true, ...INT3
  476+    X     static void 'default'(void);	/* comments */
  477+    X        .endc
  478+    X        .mexit
  479+    X       .endc
  480+    X       .if idn,<name>,<INT4>
  481+    X        .if true, ...INT4
  482+    X     static void 'default'(void);	/* comments */
  483+    X        .endc
  484+    X        .mexit
  485+    X       .endc
  486+    X       .if idn,<name>,<INT5>
  487+    X        .if true, ...INT5
  488+    X     static void 'default'(void);	/* comments */
  489+    X        .endc
  490+    X        .mexit
  491+    X       .endc
  492+    X       .if idn,<name>,<INT6>
  493+    X        .if true, ...INT6
  494+    X     static void 'default'(void);	/* comments */
  495+    X        .endc
dispatch.c                               Atari Games Corp. macpp v9.12   "Oct 16 1997 13:26:41"


  496+    X        .mexit
  497+    X       .endc
  498+    X       .if idn,<name>,<INT7>
  499+    X        .if true, ...INT7
  500+    X     static void 'default'(void);	/* comments */
  501+    X        .endc
  502+    X        .mexit
  503+    X       .endc
  504+    X       .if true, PHX
  505+    X        .if idn,<name>,<XBUS>
  506+    X         .if true, ...XBUS0|...XBUS1|...XBUS2|...XBUS3
  507+    X     static void 'default'(void);
  508+    X         .endc
  509+    X         .mexit
  510+    X        .endc
  511+    X        .if idn,<name>,<XBUS0>
  512+    X         .if true, ...XBUS0
  513+    X     static void 'default'(void);
  514+    X         .endc
  515+    X         .mexit
  516+    X        .endc
  517+    X        .if idn,<name>,<XBUS1>
  518+    X         .if true, ...XBUS1
  519+    X     static void 'default'(void);
  520+    X         .endc
  521+    X         .mexit
  522+    X        .endc
  523+    X        .if idn,<name>,<XBUS2>
  524+    X         .if true, ...XBUS2
  525+    X     static void 'default'(void);
  526+    X         .endc
  527+    X         .mexit
  528+    X        .endc
  529+    X        .if idn,<name>,<XBUS3>
  530+    X         .if true, ...XBUS3
  531+    X     static void 'default'(void);
  532+    X         .endc
  533+    X         .mexit
  534+    X        .endc
  535+    X       .endc			; PHX
  536+    X       .if idn,<name>,<IOA>
  537+    X        .if true, ...IOA
  538+    X     static void 'default'(void);
  539+    X        .endc
  540+    X        .mexit
  541+    X       .endc
  542+    X     extern void 'default'(void);
  543+    X      .endc
  544+    X     .endm
  545+    X     	.include phx_vecs.mac		;Declare the non-extern vectors
  546+          ;
  547+    X      .if true, ((PROCESSOR&-16) == MIPS3000) || ((PROCESSOR&-16) == MIPS4000)
  548+    X     static void (*hwvinst(const struct irq_tab *, void (*)()))();
  549+    X      .endc
  550+          ;
  551+    X     .if df, PHOENIX_INTCTL_MASK
  552+    X     static void (*pvinst(const struct irq_tab *, void (*)()))();
dispatch.c                               Atari Games Corp. macpp v9.12   "Oct 16 1997 13:26:41"


  553+    X     .endc
  554+          ;
  555+    X     .if df, GALILEO_INTCTL_MASK
  556+    X     static void (*gvinst(const struct irq_tab *, void (*)()))();
  557+    X     .endc
  558+          ;
  559+    X     .if true, ...IOA
  560+    X     static void (*ioainst(const struct irq_tab *, void (*)()))();
  561+    X     .endc
  562+          ;
  563+    X     static const struct irq_tab irq_inits[] = {
  564+    X     	.macro VDF cond, name, softvec, intern, installer, notes, physical, default, comments
  565+    X     	.condit cond	
  566+    X      .if dif,<softvec>,<0>
  567+    X      { (void (**)())&softvec, installer, notes },	/* comments */
  568+    X      .iff
  569+    X      { 0, installer, notes },	/* comments */
  570+    X      .endc
  571+    X     	.endm
  572+    X     	.include phx_vecs.mac		;Build the irq_inits array
  573+    X      { 0, 0, 0} };
  574+          ;
  575+    X     .if true, ((PROCESSOR&-16) == MIPS3000) || ((PROCESSOR&-16) == MIPS4000)
  576+          
  577+    X     extern void (*ramv_tbl[])();
  578+          
  579+    X     static void (*hwvinst(const struct irq_tab *it, void (*new)()))() {
  580+    X         int indx;
  581+    X         void (*old_rtn)();
  582+          
  583+    X         indx = it->notes;
  584+    X         if (indx >= VN_MAX) return 0;
  585+    X         old_rtn = ramv_tbl[indx];
  586+    X         ramv_tbl[indx] = new;
  587+    X         return old_rtn;
  588+    X     }
  589+          
  590+    X      .if df, PHOENIX_INTCTL_MASK
  591+    X     static void (*pvinst(const struct irq_tab *it, void (*new)()))() {
  592+          
  593+    X         if (it->notes) {
  594+    X     	BLABF(("\ndispatch: Adding 0x%08lX to main INTCTL (0x%08lX)...", it->notes, *(VU32*)INTCTL_IE));
  595+    X     	*((VU32 *)(INTCTL_IE)) |= it->notes;
  596+    X         }
  597+    X         return 0;
  598+    X     }
  599+    X      .endc
  600+          
  601+    X      .if df, GALILEO_INTCTL_MASK
  602+    X     static void (*gvinst(const struct irq_tab *it, void (*new)()))() {
  603+          
  604+    X         if (it->notes) {
  605+    X     	BLABF(("\ndispatch: Adding 0x%08lX to Galileo INTCTL (0x%08lX)...", it->notes, \
  606+    X     			*(VU32*)GALILEO_CPU_I_ENA));
  607+    X     	*((VU32 *)(GALILEO_CPU_I_ENA)) |= it->notes;
  608+    X         }
  609+    X         return 0;
dispatch.c                               Atari Games Corp. macpp v9.12   "Oct 16 1997 13:26:41"


  610+    X     }
  611+    X      .endc
  612+          
  613+    X      .if true, ...IOA
  614+    X     static void (*ioainst(const struct irq_tab *it, void (*new)()))() {
  615+    X     extern void prc_wait_n_usecs( int );
  616+    X         if (it->notes)
  617+    X         {
  618+    X          BLABF(("\ndispatch: Adding 0x%04X to IOASIC INTCTL: (0x%04X)...", (int)it->notes, \
  619+    X     		*(VU32*)IO_MAIN_CTL&0xFFFF));
  620+    X          while ( ( *((VU32 *)IO_MAIN_CTL) & it->notes ) != it->notes )
  621+    X          {
  622+    X     #ifdef LED_OUT
  623+    X           *(VU32 *)LED_OUT = ~( 1 << B_LED_RED );
  624+    X     #endif
  625+    X           do
  626+    X           {
  627+    X            *((VU32 *)IO_MAIN_CTL) |= it->notes;
  628+    X            prc_wait_n_usecs( 1000 );
  629+    X           } while ( ( *((VU32 *)IO_MAIN_CTL) & it->notes ) != it->notes );
  630+    X           prc_wait_n_usecs( 1000 );
  631+    X     #ifdef LED_OUT
  632+    X           *(VU32 *)LED_OUT |= ( 1 << B_LED_RED );
  633+    X     #endif
  634+    X          }
  635+    X         }
  636+    X         return 0;
  637+    X     }
  638+    X      .endc
  639+    X     .endc
  640+          
  641+    X     void (*prc_set_vec (unsigned int vecnum, void (*routine)() ))()
  642+    X     {
  643+    X         void (*old_rtn)();
  644+    X         void (**softvec)();
  645+    X         const struct irq_tab *tbp;
  646+    X         int old_ipl;
  647+          
  648+    X         if ( vecnum >= N_INTVECS ) return 0;
  649+    X         tbp = irq_inits+vecnum;
  650+    X         softvec = tbp->softvec;
  651+    X         old_rtn = 0;
  652+    X         old_ipl = prc_set_ipl(INTS_OFF);
  653+    X         if ( tbp->installer ) old_rtn = tbp->installer(tbp, routine);
  654+    X         if ( softvec ) {
  655+    X     	if (!old_rtn) old_rtn = *softvec;
  656+    X     	*softvec = routine;
  657+    X         }
  658+    X         prc_set_ipl(old_ipl);
  659+    X         return old_rtn;
  660+    X     }
  661+          
  662+    X      .if true, PHX
  663+    X       .if true, ...XBUS0
  664+    X     static void xbus0_irq(void) {
  665+    X     	.macro VDF cond, name, softvec, intern, installer, notes, physical, default, comments
  666+    X     	.condit cond	
dispatch.c                               Atari Games Corp. macpp v9.12   "Oct 16 1997 13:26:41"


  667+    X       .iif idn,<name>,<XBUS0>,.mexit
  668+    X       .iif idn,<softvec>,<0>,.mexit
  669+    X       .if true, physical == XBUS0_LVL
  670+    X         if (softvec) softvec();
  671+    X       .endc
  672+    X     	.endm
  673+    X     	.include phx_vecs.mac		; pickup all vectors assigned to XBUS0_LVL
  674+    X         return;
  675+    X     }
  676+          
  677+    X       .endc		; ...XBUS0
  678+    X       .if true, ...XBUS1
  679+    X     static void xbus1_irq(void) {
  680+    X     	.macro VDF cond, name, softvec, intern, installer, notes, physical, default, comments
  681+    X     	.condit cond	
  682+    X       .iif idn,<name>,<XBUS1>,.mexit
  683+    X       .iif idn,<softvec>,<0>,.mexit
  684+    X       .if true, physical == XBUS1_LVL
  685+    X         if (softvec) softvec();
  686+    X       .endc
  687+    X     	.endm
  688+    X     	.include phx_vecs.mac		; pickup all vectors assigned to XBUS1_LVL
  689+    X         return;
  690+    X     }
  691+          
  692+    X       .endc		; ...XBUS1
  693+    X       .if true, ...XBUS2
  694+    X     static void xbus2_irq(void) {
  695+    X     	.macro VDF cond, name, softvec, intern, installer, notes, physical, default, comments
  696+    X     	.condit cond	
  697+    X       .iif idn,<name>,<XBUS2>,.mexit
  698+    X       .iif idn,<softvec>,<0>,.mexit
  699+    X       .if true, physical == XBUS2_LVL
  700+    X         if (softvec) softvec();
  701+    X       .endc
  702+    X     	.endm
  703+    X     	.include phx_vecs.mac		; pickup all vectors assigned to XBUS2_LVL
  704+    X         return;
  705+    X     }
  706+          
  707+    X       .endc		; ...XBUS2
  708+    X       .if true, ...XBUS3
  709+    X     static void xbus3_irq(void) {
  710+    X     	.macro VDF cond, name, softvec, intern, installer, notes, physical, default, comments
  711+    X     	.condit cond	
  712+    X       .iif idn,<name>,<XBUS3>,.mexit
  713+    X       .iif idn,<softvec>,<0>,.mexit
  714+    X       .if true, physical == XBUS3_LVL
  715+    X         if (softvec) softvec();
  716+    X       .endc
  717+    X     	.endm
  718+    X     	.include phx_vecs.mac		; pickup all vectors assigned to XBUS3_LVL
  719+    X         return;
  720+    X     }
  721+          
  722+    X       .endc		; ...XBUS3
  723+    X      .endc		; PHX
dispatch.c                               Atari Games Corp. macpp v9.12   "Oct 16 1997 13:26:41"


  724+    X      .if true, ...INT0
  725+    X     static void int0_irq(void) {
  726+    X     	.macro VDF cond, name, softvec, intern, installer, notes, physical, default, comments
  727+    X     	.condit cond	
  728+    X       .iif idn,<name>,<INT0>,.mexit
  729+    X       .iif idn,<softvec>,<0>,.mexit
  730+    X       .if true, physical == INT0_LVL
  731+    X         if (softvec) softvec();
  732+    X       .endc
  733+    X     	.endm
  734+    X     	.include phx_vecs.mac		; pickup all vectors assigned to IRQ 0
  735+    X         return;
  736+    X     }
  737+          
  738+    X      .endc		; ...INT0
  739+    X      .if true, ...INT1
  740+    X     static void int1_irq(void) {
  741+    X     	.macro VDF cond, name, softvec, intern, installer, notes, physical, default, comments
  742+    X     	.condit cond	
  743+    X       .iif idn,<name>,<INT1>,.mexit
  744+    X       .iif idn,<softvec>,<0>,.mexit
  745+    X       .if true, physical == INT1_LVL
  746+    X         if (softvec) softvec();
  747+    X       .endc
  748+    X     	.endm
  749+    X     	.include phx_vecs.mac		; pickup all vectors assigned to IRQ 1
  750+    X         return;
  751+    X     }
  752+          
  753+    X      .endc		; ...INT1
  754+    X      .if true, ...INT2
  755+    X     static void int2_irq(void) {
  756+    X     	.macro VDF cond, name, softvec, intern, installer, notes, physical, default, comments
  757+    X     	.condit cond	
  758+    X       .iif idn,<name>,<INT2>,.mexit
  759+    X       .iif idn,<softvec>,<0>,.mexit
  760+    X       .if true, physical == INT2_LVL
  761+    X         if (softvec) softvec();
  762+    X       .endc
  763+    X     	.endm
  764+    X     	.include phx_vecs.mac		; pickup all vectors assigned to IRQ 2
  765+    X         return;
  766+    X     }
  767+          
  768+    X      .endc		; ...INT2
  769+    X      .if true, ...INT3
  770+    X     static void int3_irq(void) {
  771+    X     	.macro VDF cond, name, softvec, intern, installer, notes, physical, default, comments
  772+    X     	.condit cond	
  773+    X       .iif idn,<name>,<INT3>,.mexit
  774+    X       .iif idn,<softvec>,<0>,.mexit
  775+    X       .if true, physical == INT3_LVL
  776+    X         if (softvec) softvec();
  777+    X       .endc
  778+    X     	.endm
  779+    X     	.include phx_vecs.mac		; pickup all vectors assigned to IRQ 3
  780+    X         return;
dispatch.c                               Atari Games Corp. macpp v9.12   "Oct 16 1997 13:26:41"


  781+    X     }
  782+          
  783+    X      .endc		; ...INT3
  784+    X      .if true, ...INT4
  785+    X     static void int4_irq(void) {
  786+    X     	.macro VDF cond, name, softvec, intern, installer, notes, physical, default, comments
  787+    X     	.condit cond	
  788+    X       .iif idn,<name>,<INT4>,.mexit
  789+    X       .iif idn,<softvec>,<0>,.mexit
  790+    X       .if true, physical == INT4_LVL
  791+    X         if (softvec) softvec();
  792+    X       .endc
  793+    X     	.endm
  794+    X     	.include phx_vecs.mac		; pickup all vectors assigned to IRQ 4
  795+    X         return;
  796+    X     }
  797+          
  798+    X      .endc		; ...INT4
  799+    X      .if true, ...INT5
  800+    X     static void int5_irq(void) {
  801+    X     	.macro VDF cond, name, softvec, intern, installer, notes, physical, default, comments
  802+    X     	.condit cond	
  803+    X       .iif idn,<name>,<INT5>,.mexit
  804+    X       .iif idn,<softvec>,<0>,.mexit
  805+    X       .if true, physical == INT5_LVL
  806+    X         if (softvec) softvec();
  807+    X       .endc
  808+    X     	.endm
  809+    X     	.include phx_vecs.mac		; pickup all vectors assigned to IRQ 5
  810+    X         return;
  811+    X     }
  812+          
  813+    X      .endc		; ...INT5
  814+    X      .if true, ...IOA && PHX
  815+    X     static void ioa_irq(void) {
  816+    X     	.macro VDF cond, name, softvec, intern, installer, notes, physical, default, comments
  817+    X     	.condit cond	
  818+    X       .iif idn,<name>,<IOA>,.mexit
  819+    X       .iif idn,<softvec>,<0>,.mexit
  820+    X       .if true, physical == IOASIC_LVL
  821+    X         if (softvec) softvec();
  822+    X       .endc
  823+    X     	.endm
  824+    X     	.include phx_vecs.mac		; pickup all vectors assigned to IRQ 5
  825+    X         return;
  826+    X     }
  827+          
  828+    X      .endc		; ...IOA
  829+    X      .if true, PHX
  830+    X       .if true, ...XBUS0|...XBUS1|...XBUS2|...XBUS3
  831+    X     static void xbus_irq(void) {
  832+    X         int which;
  833+    X         which = *(VU32 *)(XBUS_SLOT0+4);
  834+    X       .if true, ...XBUS0
  835+    X         if (!(which&1)) xbus0_irq();
  836+    X       .endc
  837+    X       .if true, ...XBUS1
dispatch.c                               Atari Games Corp. macpp v9.12   "Oct 16 1997 13:26:41"


  838+    X         if (!(which&2)) xbus1_irq();
  839+    X       .endc
  840+    X       .if true, ...XBUS2
  841+    X         if (!(which&4)) xbus2_irq();
  842+    X       .endc
  843+    X       .if true, ...XBUS3
  844+    X         if (!(which&8)) xbus3_irq();
  845+    X       .endc
  846+    X         return;
  847+    X     }
  848+    X       .endc
  849+    X      .endc		; PHX
  850+    X     void prc_init_vecs(void) {
  851+    X     	.macro VDF cond, name, softvec, intern, installer, notes, physical, default, comments
  852+    X     	.condit cond	
  853+    X     .if dif,<default>,<0>
  854+    X      .if true, PHX
  855+    X       .if idn,<name>,<XBUS0>
  856+    X        .iif true, ...XBUS0 == 0, .mexit
  857+    X       .endc
  858+    X       .if idn,<name>,<XBUS1>
  859+    X        .iif true, ...XBUS1 == 0, .mexit
  860+    X       .endc
  861+    X       .if idn,<name>,<XBUS2>
  862+    X        .iif true, ...XBUS2 == 0, .mexit
  863+    X       .endc
  864+    X       .if idn,<name>,<XBUS3>
  865+    X        .iif true, ...XBUS3 == 0, .mexit
  866+    X       .endc
  867+    X       .if idn,<name>,<XBUS>
  868+    X        .iif true, (...XBUS0|...XBUS1|...XBUS2|...XBUS3) == 0, .mexit
  869+    X       .endc
  870+    X      .endc	; PHX
  871+    X      .if idn,<name>,<INT0>
  872+    X       .iif true, ...INT0 == 0, .mexit
  873+    X      .endc
  874+    X      .if idn,<name>,<INT1>
  875+    X       .iif true, ...INT1 == 0, .mexit
  876+    X      .endc
  877+    X      .if idn,<name>,<INT2>
  878+    X       .iif true, ...INT2 == 0, .mexit
  879+    X      .endc
  880+    X      .if idn,<name>,<INT3>
  881+    X       .iif true, ...INT3 == 0, .mexit
  882+    X      .endc
  883+    X      .if idn,<name>,<INT4>
  884+    X       .iif true, ...INT4 == 0, .mexit
  885+    X      .endc
  886+    X      .if idn,<name>,<INT5>
  887+    X       .iif true, ...INT5 == 0, .mexit
  888+    X      .endc
  889+    X      .if idn,<name>,<IOA>
  890+    X       .iif true, ...IOA == 0, .mexit
  891+    X      .endc
  892+    X         prc_set_vec('name'_INTVEC, default);
  893+    X     .endc
  894+    X     	.endm
dispatch.c                               Atari Games Corp. macpp v9.12   "Oct 16 1997 13:26:41"


  895+    X     	.include phx_vecs.mac
  896+          
  897+    X     /* Map the Phoenix interrupts */
  898+          
  899+    X     .if df, INTCTL_MAPA_INIT
  900+    X         BLABF(("\ndispatch: Mapping the A interrupts: 0x%08lX...", INTCTL_MAPA_INIT));
  901+    X         *((VU32 *)(INTCTL_MAPA)) = INTCTL_MAPA_INIT;
  902+    X     .endc
  903+    X     .if df, INTCTL_MAPB_INIT
  904+    X         BLABF(("\ndispatch: Mapping the B interrupts: 0x%08lX...", INTCTL_MAPB_INIT));
  905+    X         *((VU32 *)(INTCTL_MAPB)) = INTCTL_MAPB_INIT;
  906+    X     .endc
  907+          
  908+    X     .if defined, ANNOUNCE_BOOT_ACTIONS
  909+    X      .if true, ANNOUNCE_BOOT_ACTIONS
  910+    X         {
  911+    X     	int jj;
  912+    X     	extern int prc_get_cause(void), prc_get_ipl(void);
  913+    X     	jj = prc_get_cause();
  914+    X     	if (jj&0xFF00) BLABF(("\ndispatch: CPU cause reg: %08lX, CPU SR reg: %08lX", jj, prc_get_ipl()));
  915+    X     	if (jj&0x0400) {
  916+    X       .if true, ...INT0
  917+    X     	.macro VDF cond, name, softvec, intern, installer, notes, physical, default, comments
  918+    X     	.condit cond	
  919+    X        .iif idn,<name>,<INT0>,.mexit
  920+    X        .iif idn,<softvec>,<0>,.mexit
  921+    X        .if true, physical == INT0_LVL
  922+    X     	    if (!softvec) BLAB("\ndispatch: Warning, IRQ 0 pending \"'comments'\"");
  923+    X        .endc
  924+    X     	.endm
  925+    X     	.include phx_vecs.mac		; pickup all vectors assigned to IRQ 0
  926+    X       .iff
  927+    X     	    BLAB("\ndispatch: Warning, IRQ 0 pending with no vector assigned");
  928+    X       .endc		; ...INT0
  929+    X     	}
  930+    X     	if (jj&0x0800) {
  931+    X       .if true, ...INT1
  932+    X     	.macro VDF cond, name, softvec, intern, installer, notes, physical, default, comments
  933+    X     	.condit cond	
  934+    X        .iif idn,<name>,<INT1>,.mexit
  935+    X        .iif idn,<softvec>,<0>,.mexit
  936+    X        .if true, physical == INT1_LVL
  937+    X     	    if (!softvec) BLAB("\ndispatch: Warning, IRQ 1 pending \"'comments'\"");
  938+    X        .endc
  939+    X     	.endm
  940+    X     	.include phx_vecs.mac		; pickup all vectors assigned to IRQ 1
  941+    X       .iff
  942+    X     	    BLAB("\ndispatch: Warning, IRQ 1 pending with no vector assigned");
  943+    X       .endc		; ...INT1
  944+    X     	}
  945+    X     	if (jj&0x1000) {
  946+    X       .if true, ...INT2
  947+    X     	.macro VDF cond, name, softvec, intern, installer, notes, physical, default, comments
  948+    X     	.condit cond	
  949+    X        .iif idn,<name>,<INT2>,.mexit
  950+    X        .iif idn,<softvec>,<0>,.mexit
  951+    X        .if true, physical == INT2_LVL
dispatch.c                               Atari Games Corp. macpp v9.12   "Oct 16 1997 13:26:41"


  952+    X     	    if (!softvec) BLAB("\ndispatch: Warning, IRQ 2 pending \"'comments'\"");
  953+    X        .endc
  954+    X     	.endm
  955+    X     	.include phx_vecs.mac		; pickup all vectors assigned to IRQ 2
  956+    X       .iff
  957+    X     	    BLAB("\ndispatch: Warning, IRQ 2 pending with no vector assigned");
  958+    X       .endc		; ...INT2
  959+    X     	}
  960+    X     	if (jj&0x2000) {
  961+    X       .if true, ...INT3
  962+    X     	.macro VDF cond, name, softvec, intern, installer, notes, physical, default, comments
  963+    X     	.condit cond	
  964+    X        .iif idn,<name>,<INT3>,.mexit
  965+    X        .iif idn,<softvec>,<0>,.mexit
  966+    X        .if true, physical == INT3_LVL
  967+    X     	    if (!softvec) BLAB("\ndispatch: Warning, IRQ 3 pending \"'comments'\"");
  968+    X        .endc
  969+    X     	.endm
  970+    X     	.include phx_vecs.mac		; pickup all vectors assigned to IRQ 3
  971+    X       .iff
  972+    X     	    BLAB("\ndispatch: Warning, IRQ 3 pending with no vector assigned");
  973+    X       .endc		; ...INT3
  974+    X     	}
  975+    X     	if (jj&0x4000) {
  976+    X       .if true, ...INT4
  977+    X     	.macro VDF cond, name, softvec, intern, installer, notes, physical, default, comments
  978+    X     	.condit cond	
  979+    X        .iif idn,<name>,<INT4>,.mexit
  980+    X        .iif idn,<softvec>,<0>,.mexit
  981+    X        .if true, physical == INT4_LVL
  982+    X     	    if (!softvec) BLAB("\ndispatch: Warning, IRQ 4 pending \"'comments'\"");
  983+    X        .endc
  984+    X     	.endm
  985+    X     	.include phx_vecs.mac		; pickup all vectors assigned to IRQ 4
  986+    X       .iff
  987+    X     	    BLAB("\ndispatch: Warning, IRQ 4 pending with no vector assigned");
  988+    X       .endc		; ...INT4
  989+    X     	}
  990+    X     	if (jj&0x8000) {
  991+    X       .if true, ...INT5
  992+    X     	.macro VDF cond, name, softvec, intern, installer, notes, physical, default, comments
  993+    X     	.condit cond	
  994+    X        .iif idn,<name>,<INT5>,.mexit
  995+    X        .iif idn,<softvec>,<0>,.mexit
  996+    X        .if true, physical == INT5_LVL
  997+    X     	    if (!softvec) BLAB("\ndispatch: Warning, IRQ 5 pending \"'comments'\"");
  998+    X        .endc
  999+    X     	.endm
 1000+    X     	.include phx_vecs.mac		; pickup all vectors assigned to IRQ 5
 1001+    X       .iff
 1002+    X     	    BLAB("\ndispatch: Warning, IRQ 5 pending with no vector assigned");
 1003+    X       .endc		; ...INT5
 1004+    X     	}
 1005+    X         }
 1006+    X      .endc		; true, ANNOUNCE_BOOT_ACTIONS
 1007+    X     .endc		; defined, ANNOUNCE_BOOT_ACTIONS
 1008+    X         return;
dispatch.c                               Atari Games Corp. macpp v9.12   "Oct 16 1997 13:26:41"


 1009+    X     }
 1010+   (4)    .endc		; _DISPATCH_MAC_ == 0
  971    (3)      .iff
  972     X     	    BLAB("\ndispatch: Warning, IRQ 3 pending with no vector assigned");
  973    (3)      .endc		; ...INT3
  974           	}
  975           	if (jj&0x4000) {
  976    (3)      .if true, ...INT4
  977           	.macro VDF cond, name, softvec, intern, installer, notes, physical, default, comments
  978           	.condit cond	
  979              .iif idn,<name>,<INT4>,.mexit
  980              .iif idn,<softvec>,<0>,.mexit
  981              .if true, physical == INT4_LVL
  982           	    if (!softvec) BLAB("\ndispatch: Warning, IRQ 4 pending \"'comments'\"");
  983              .endc
  984           	.endm
  985           	.include phx_vecs.mac		; pickup all vectors assigned to IRQ 4
    1+          ;/*		phx_vecs.mac
    2+          ; *
    3+          ; *		Copyright 1996 Atari Games Corporation
    4+          ; *	Unauthorized reproduction, adaptation, distribution, performance or 
    5+          ; *	display of this computer program or the associated audiovisual work
    6+          ; *	is strictly prohibited.
    7+          ; *
    8+          ; *	This file is processed by MACPP to produce dispatch.c and intvecs.h.
    9+          ; *
   10+          ; *	The definitions placed in intvecs.h declare virtual vector numbers
   11+          ; *	in the form of xxx_INTVEC and a cross reference table(s) so the
   12+          ; *	dispatcher can call the appropriate functions.
   13+          ; *
   14+          ; *	intvecs.h should be #include'd by any module that uses prc_set_vec().
   15+          ; */
   16+          ;
   17+          ; This file recursivley '.includes' itself to succesively build up the approprate
   18+          ; tables and functions in C and places the results in one of two files (the
   19+          ; first -out=file supplied on the MACPP command line is expected to be dispatch.c
   20+          ; and the second -out=file is expected to be intvecs.h and the third is expected to
   21+          ; be /dev/null). If you don't speak fluent MACPP, then you probably shouldn't be
   22+          ; changing anything in this file other than the VDF table listed below.
   23+          ;
   24+   (4)    .if not_defined, _DISPATCH_MAC_		;1 +++++
   25+    X     _DISPATCH_MAC_ == 0			;2 Don't move ...
   26+    X     OUTPUT_LANG == 5 ;LANG_NONE		;3 ... or change ... 
   27+    X     	.outfile 2			;4 ... anything on ...
   28+    X     	.include config.mac		;5 ... these ...
   29+    X     	.outfile 0			;6 ... nine  ...
   30+   (4)    .endc					;7 ... lines ...
   31+   (4)    .if true, (_DISPATCH_MAC_&1) != 0	;8
   32+   (5)     .if true, 0				;9 -----
   33+          
   34+    X     You are free to add or remove entries from this table according to your
   35+    X     requirements. There are 10 fields used on each line in this table. The
   36+    X     description of each field follows:
   37+          
   38+    X     Field 1 = macro call
   39+          
   40+    X     It must always be the keyword VDF (case is not significant).
dispatch.c                               Atari Games Corp. macpp v9.12   "Oct 16 1997 13:26:41"


   41+          
   42+    X     Field 2 = condition
   43+          
   44+    X     This is a dual operand field, so the two operands together must be enclosed in
   45+    X     <>'s. The first operand is one of T, F, D or N representing True, False,
   46+    X     Defined or Not_defined respectively. Case is significant, use uppercase only
   47+    X     please. For the conditions T or F the second operand must be an expression
   48+    X     which must resolve to non-$0 (True) or $0 (False) in order for the macro
   49+    X     to be processed (else it is ignored). The expression can contain no embedded
   50+    X     spaces. For the conditions D and N, the second operand must only be a symbol
   51+    X     which must be Defined or Not-defined respectively in order for the macro to be
   52+    X     processed. Some short cut expressions have been preprocessed to make using the
   53+    X     expressions a little more concise. These are:
   54+          
   55+    X     	PHX = not $0 if HOST_BOARD == PHOENIX
   56+    X     	PAD = not $0 if HOST_BOARD == PHOENIX_AD
   57+    X     	FLG = not $0 if HOST_BOARD == FLAGSTAFF
   58+    X     	SEA = not $0 if HOST_BOARD == SEATTLE
   59+    X     	VEG = not $0 if HOST_BOARD == VEGAS
   60+          
   61+    X     Field 3 = vector name
   62+          
   63+    X     The NAME field is the name of the virtual vector. An _INTVEC will be appended
   64+    X     to it in the C definitions in intvecs.h, but otherwise the name is unmolested.
   65+    X     Case is significant only if you want it to be. The R3K/R4K has an option where
   66+    X     a number of vectors are maintained in an array of pointers rather than each
   67+    X     one having its own name. The index into the array is same as the number
   68+    X     returned in the processor's CAUSE register for that particluar interrupt. This
   69+    X     procedure is done simply for performance reasons. The option is selected by
   70+    X     using a 0 for this field and using an installer function with the vector index
   71+    X     as the parameter to the installer.
   72+          
   73+    X     Field 4 = Vector pointer
   74+          
   75+    X     This field identifies the name of a variable in BSS that contains a pointer
   76+    X     to the function to call at interrupt (or will be set by the prc_set_vec()
   77+    X     function). This is the name of the "soft" or logical vector and is either
   78+    X     declared in dispatch.c or externally according to the INT/EXT field described
   79+    X     next.
   80+          
   81+    X     Field 5 = INTernal or EXTernal vector
   82+          
   83+    X     This field contains the keywords INT, EXT, VINT or VEXT identifying the vector
   84+    X     in field 4 as being defined INTernally, EXTernally, Volatile INTernally or
   85+    X     Volatile Externally to dispatch.c respectively.
   86+          
   87+    X     Field 6 = name of vector installer
   88+          
   89+    X     This field identifies the name of a function that prc_set_vec() will call to
   90+    X     actually install the vector or 0 if there is no special stuff that needs to
   91+    X     be performed during vector installation.
   92+          
   93+    X     Field 7 = Notes for the installer.
   94+          
   95+    X     The Notes field is a parameter that is passed to the installer if there is one.
   96+          
   97+    X     Field 8 = Physical vector attachment.
dispatch.c                               Atari Games Corp. macpp v9.12   "Oct 16 1997 13:26:41"


   98+          
   99+    X     A dispatch routine is constructed for each of the 4 XBUS interrupts and for each of
  100+    X     the 6 CPU interrupts.  This field instructs phx_vecs.mac into which of the XBUS or
  101+    X     INTx dispatchers a caller to this vector belongs.  If this vector is not associated
  102+    X     with an XBUS or an INTx interrupt, it needs to be -1.  Place the interrupt routines
  103+    X     in this table in the order in which you want them executed.
  104+          
  105+    X     Field 9 = Default function.
  106+          
  107+    X     Name of default routine to install in the vector, or 0 if none.  phx_vecs.mac builds
  108+    X     a function called prc_init_vecs(void) which, when called, will perform a string of
  109+    X     prc_set_vec()'s for all the vectors having this field non-zero.  After the vectors
  110+    X     have been loaded, prc_init_vecs(void) will map the phoenix and galileo interrupts as
  111+    X     specified in phoenix.mac.
  112+          
  113+    X     Field 10 = Comments.
  114+          
  115+    X     The Comments field is placed on selected lines in intvecs.h and/or dispatch.c
  116+    X     as simple 'C' comments.
  117+          
  118+   (5)     .endc				; Don't move this line
  119+          ;
  120+          ;   Condit	Name	   Vector   I/E	Installer   Notes      Phys	Default	Comments
  121+          ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  122+          VDF <T,1>	GAMEVB,	   gameint, EXT	0,          0,		-1,	0,	< post-wierdness Vblank >
  123+          VDF <T,1>	MS4,       ms4vec,  EXT	0,          0,		-1,	0,	< 4 Millisecond timer >
  124+          VDF <T,1>	PRC_DELAY, prc_delay_vec, EXT 0,    0,		-1,	sst_prc_delay, < prc_delay soft vector >
  125+          VDF <T,1>	PRC_SET_IPL, set_ipl_vec, INT 0,    0,		-1,	0,	< prc_set_ipl soft vector >
  126+          VDF <T,1>	SAVE,      savintp, EXT 0,          0,		-1,	0,	< context save soft vector >
  127+          VDF <T,1>	RESTORE,   restintp,EXT 0,          0,		-1,	0,	< context restore soft vector >
  128+          VDF <T,1>	SW0,	   0,	    INT hwvinst,    VN_IRQ0,    -1,	0,	< Software interrupt 0 >
  129+          VDF <T,1>	SW1,	   0,       INT hwvinst,    VN_IRQ1,    -1,	0,	< Software interrupt 0 >
  130+          VDF <T,1>	INT0,	   0,       INT hwvinst,    VN_IRQ2,    -1,	int0_irq, < Hardware interrupt 0 >
  131+          VDF <T,1>	INT1,	   0,	    INT hwvinst,    VN_IRQ3,    -1,	int1_irq, < Hardware interrupt 1 >
  132+          VDF <T,PHX>	INT2,	   0,	    INT hwvinst,    VN_IRQ4,    -1,	int2_irq, < Hardware interrupt 2 >
  133+          VDF <T,1>	INT3,	   0,       INT hwvinst,    VN_IRQ5,    -1,	int3_irq, < Hardware interrupt 3 >
  134+          VDF <T,1>	INT4,	   0,	    INT hwvinst,    VN_IRQ6,    -1,	int4_irq, < Hardware interrupt 4 >
  135+          VDF <T,1>	INT5,	   0,	    INT hwvinst,    VN_IRQ7,    -1,	int5_irq, < Hardware interrupt 5 >
  136+          VDF <T,1>	TLBMOD,	   0,	    INT hwvinst,    VN_TLBM,    -1,	0,	< TLB modification >
  137+          VDF <T,1>	TLBLOAD,   0,	    INT hwvinst,    VN_TLBL,    -1,	0,	< TLB miss on I or D fetch >
  138+          VDF <T,1>	TLBSTORE,  0,	    INT hwvinst,    VN_TLBS,    -1,	0,	< TLB miss on store >
  139+          VDF <T,1>	ADDRERRL,  0,	    INT hwvinst,    VN_ADDRL,   -1,	0,	< Address error on I or D fetch >
  140+          VDF <T,1>	ADDRERRS,  0,	    INT hwvinst,    VN_ADDRS,   -1,	0,	< Address error on store >
  141+          VDF <T,1>	BUSERRI,   0,	    INT hwvinst,    VN_BUSERRI, -1,	0,	< Bus error on I-fetch >
  142+          VDF <T,1>	BUSERRD,   0,	    INT hwvinst,    VN_BUSERRD, -1,	0,	< Bus error on D-fetch >
  143+          VDF <T,1>	SYSCALL,   0,       INT hwvinst,    VN_SYSCALL, -1,	0,	< SYSCALL instruction >
  144+          VDF <T,1>	BREAK,     0,       INT hwvinst,    VN_BREAK,   -1,	0,	< Breakpoint instruction >
  145+          VDF <T,1>	RESERV,    0,       INT hwvinst,    VN_RESERV,  -1,	0,	< Reserved instruction >
  146+          VDF <T,1>	COPROC,    0,       INT hwvinst,    VN_COPROC,  -1,	0,	< Coprocessor unusable >
  147+          VDF <T,1>	OVRFLOW,   0,       INT hwvinst,    VN_OVERFL,  -1,	0,	< Integer Arithmetic Overflow >
  148+          VDF <T,1>	TRAP,      0,       INT hwvinst,    VN_TRAPV,   -1,	0,	< TRAP exception >
  149+          VDF <T,1>	FLOAT,     0,       INT hwvinst,    VN_FPE,     -1,	0,	< FLoating point exception >
  150+          VDF <T,1>	TIMER,	   timervec, INT 0,	    0,          -1,	0,	< Soft Timer interrupt >
  151+          VDF <T,1>	TIMERPLL,  tpllvec, VEXT 0,	    0,		-1,	0,	<Adjust 1MS timer>
  152+          VDF <T,1>	GAMEFRAME, framevec,INT 0,	    0,		-1,	0,	< Frame complete >
  153+   (5)    .if true, PHX
  154+    X     VDF <D,NET_LVL>	NET,       netintp, INT 0,          0,		NET_LVL,0,	< network int soft vector >
dispatch.c                               Atari Games Corp. macpp v9.12   "Oct 16 1997 13:26:41"


  155+    X     VDF <D,XBUS>	XBUS,	   xbusintp, INT pvinst,    XBUS_NOTES,	XBUS_LVL,xbus_irq, < Any XBUS interrupt >
  156+    X     VDF <T,XS0>	XS0,       xs0intp, INT pvinst,	    XS0_NOTES,	XS0_LVL,0,	< Expansion Slot 0 interrupt >
  157+    X     VDF <T,XS1>	XS1,       xs1intp, INT pvinst,	    XS1_NOTES,	XS1_LVL,0,	< Expansion Slot 1 interrupt >
  158+    X     VDF <T,XS2>	XS2,       xs2intp, INT pvinst,	    XS2_NOTES,	XS2_LVL,0,	< Expansion Slot 2 interrupt >
  159+    X     VDF <T,XS3>	XS3,       xs3intp, INT pvinst,	    XS3_NOTES,	XS3_LVL,0,	< Expansion Slot 3 interrupt >
  160+    X     VDF <T,MIO>	MIO,       miointp, INT pvinst,	    MIO_NOTES,	MIO_LVL,0,	< Miscellaneous I/O interrupt >
  161+    X     VDF <T,CU1>	CU1,       cu1intp, INT pvinst,	    CU1_NOTES,	CU1_LVL,0,	< Combo UART 1 interrupt >
  162+    X     VDF <T,CU2>	CU2,       cu2intp, INT pvinst,	    CU2_NOTES,	CU2_LVL,0,	< Combo UART 2 interrupt >
  163+    X     VDF <T,CPP>	CPP,       cppintp, INT pvinst,	    CPP_NOTES,	CPP_LVL,0,	< Combo Parallel Port interrupt >
  164+    X     VDF <T,PCA>	PCA,       pcaintp, INT pvinst,	    PCA_NOTES,	PCA_LVL,0,	< PCI A interrupt >
  165+    X     VDF <T,PCB>	PCB,       pcbintp, INT pvinst,	    PCB_NOTES,	PCB_LVL,0,	< PCI B interrupt >
  166+    X     VDF <T,PCC>	PCC,       pccintp, INT pvinst,	    PCC_NOTES,	PCC_LVL,0,	< PCI C interrupt >
  167+    X     VDF <T,VSY>	VSY,       vsyintp, INT pvinst,	    VSY_NOTES,	VSY_LVL,0,	< PCI D (VSYNC) interrupt >
  168+    X     VDF <T,IDE>	IDE,	   ideintp, INT pvinst,	    IDE_NOTES,	IDE_LVL,0,	< IDE interrupt >
  169+    X     VDF <T,IOA>	IOA,	   ioaintp, INT pvinst,	    IOA_NOTES,	IOA_LVL,ioa_irq,< I/O Asic interrupt >
  170+    X     VDF <T,ADC>	ADC,	   adcintp, INT pvinst,	    ADC_NOTES,	ADC_LVL,0,	< A/D Converter interrupt >
  171+    X     VDF <D,SND_I>	CAGE,      cagevec, INT 0,          0,		CAGE_LVL,aud_irq, < CAGE interrupt >
  172+   (5)    .endc
  173+   (5)    .if true, PAD || FLG || SEA || VEG
  174+          ;VDF <T,1>	IOA,	   0,	    INT hwvinst,    VN_IRQ3,	-1,	0,	< I/O Asic interrupt >
  175+          VDF <T,1>	IDE,	   0,	    INT hwvinst,    VN_IRQ4,    -1,	0,	< IDE interrupt >
  176+          VDF <T,EXP>	EXP,       expintp, INT pvinst,	    EXP_NOTES,	EXP_LVL,0,	< Expansion Slot interrupt >
  177+   (6)     .if true, PAD || SEA
  178+          VDF <T,NSS>	NSS,	   nssintp, INT pvinst,	    NSS_NOTES,  NSS_LVL,0,	< NSS/Hi-Link interrupt>
  179+   (6)     .endc
  180+   (6)     .if true, FLG
  181+    X     VDF <T,ETH>	ETH,	   ethintp, INT pvinst,     ETH_NOTES,  ETH_LVL,0,	< ethernet interrupt >
  182+    X     VDF <D,SND_I>	CAGE,	   cagevec, INT ioainst,    CAGE_NOTES, CAGE_LVL,aud_irq, < CAGE interrupt >
  183+   (6)     .endc
  184+          VDF <T,WD1>	WD1,	   wd1intp, INT pvinst,	    WD1_NOTES,  WD1_LVL,0,	< Widget interrupt 1>
  185+          VDF <T,PCI>	PCI,       pciintp, INT pvinst,	    PCI_NOTES,	PCI_LVL,0,	< PCI interrupt >
  186+          VDF <T,ADC>	ADC,	   adcintp, INT pvinst,	    ADC_NOTES,	ADC_LVL,0,	< A/D Converter interrupt >
  187+          VDF <T,WD2>	WD2,	   wd2intp, INT pvinst,	    WD2_NOTES,  WD2_LVL,0,	< Widget interrupt 2>
  188+          VDF <T,DBG>	DBG,	   dbgintp, INT pvinst,	    DBG_NOTES,	DBG_LVL,0,	< Debug switch interrupt >
  189+          VDF <T,VSY>	VSY,	   vsyintp, INT pvinst,	    VSY_NOTES,	VSY_LVL,0,	< VSYNC interrupt >
  190+   (5)    .endc
  191+          VDF <T,GAL>	GAL,	   0,       INT gvinst,	    GAL_NOTES,  GAL_LVL,galileoint, < Any Galileo Error Interrupt >
  192+          VDF <T,MOE>	MOE,	   moeintp, INT gvinst,	    MOE_NOTES,	MOE_LVL,0,	< Galileo MemOut >
  193+          VDF <T,DOE>	DOE,	   doeintp, INT gvinst,	    DOE_NOTES,	DOE_LVL,0,	< Galileo DMAOut >
  194+          VDF <T,COE>	COE,	   coeintp, INT gvinst,	    COE_NOTES,	COE_LVL,0,	< Galileo CPUOut >
  195+          VDF <T,DM0>	DM0,	   dm0intp, INT gvinst,	    DM0_NOTES,	DM0_LVL,0,	< Galileo DMA0Comp >
  196+          VDF <T,DM1>	DM1,	   dm1intp, INT gvinst,	    DM1_NOTES,	DM1_LVL,0,	< Galileo DMA1Comp >
  197+          VDF <T,DM2>	DM2,	   dm2intp, INT gvinst,	    DM2_NOTES,	DM2_LVL,0,	< Galileo DMA2Comp >
  198+          VDF <T,DM3>	DM3,	   dm3intp, INT gvinst,	    DM3_NOTES,	DM3_LVL,0,	< Galileo DMA3Comp >
  199+          VDF <T,TM0>	TM0,	   tm0intp, INT gvinst,	    TM0_NOTES,	TM0_LVL,0,	< Galileo T0Exp >
  200+          VDF <T,TM1>	TM1,	   tm1intp, INT gvinst,	    TM1_NOTES,	TM1_LVL,0,	< Galileo T1Exp >
  201+          VDF <T,TM2>	TM2,	   tm2intp, INT gvinst,	    TM2_NOTES,	TM2_LVL,0,	< Galileo T2Exp >
  202+          VDF <T,TM3>	TM3,	   tm3intp, INT gvinst,	    TM3_NOTES,	TM3_LVL,cputimerint, < Galileo T3EXP timer interrupt >
  203+          VDF <T,MRE>	MRE,	   mreintp, INT gvinst,	    MRE_NOTES,	MRE_LVL,0,	< Galileo MasRdErr >
  204+          VDF <T,SWE>	SWE,	   sweintp, INT gvinst,	    SWE_NOTES,	SWE_LVL,0,	< Galileo SlvWrErr >
  205+          VDF <T,MWE>	MWE,	   mweintp, INT gvinst,	    MWE_NOTES,	MWE_LVL,0,	< Galileo MasWrErr >
  206+          VDF <T,SRE>	SRE,	   sreintp, INT gvinst,	    SRE_NOTES,	SRE_LVL,0,	< Galileo SlvRdErr >
  207+          VDF <T,AEP>	AEP,	   aepintp, INT gvinst,	    AEP_NOTES,	AEP_LVL,0,	< Galileo AddrErr >
  208+          VDF <T,MEP>	MEP,	   mepintp, INT gvinst,	    MEP_NOTES,	MEP_LVL,0,	< Galileo MemErr >
  209+          VDF <T,MAS>	MAS,	   masintp, INT gvinst,	    MAS_NOTES,	MAS_LVL,0,	< Galileo MasAbort >
  210+          VDF <T,TAR>	TAR,	   tarintp, INT gvinst,	    TAR_NOTES,	TAR_LVL,0,	< Galileo TarAbort >
  211+          VDF <T,RTY>	RTY,	   rtyintp, INT gvinst,	    RTY_NOTES,	RTY_LVL,0,	< Galileo RetryCtr >
dispatch.c                               Atari Games Corp. macpp v9.12   "Oct 16 1997 13:26:41"


  212+          VDF <T,PC0>	PC0,	   pc0intp, INT gvinst,	    PC0_NOTES,	PC0_LVL,0,	< Galileo PCI Interrupt >
  213+          VDF <T,PC1>	PC1,	   pc1intp, INT gvinst,	    PC1_NOTES,	PC1_LVL,0,	< Galileo PCI Interrupt >
  214+          VDF <T,PC2>	PC2,	   pc2intp, INT gvinst,	    PC2_NOTES,	PC2_LVL,0,	< Galileo PCI Interrupt >
  215+          VDF <T,PC3>	PC3,	   pc3intp, INT gvinst,	    PC3_NOTES,	PC3_LVL,0,	< Galileo PCI Interrupt >
  216+          VDF <D,UART_LVL> UART,	   uartintp,INT ioainst,    UART_NOTES,	UART_LVL,0,	< I/O ASIC UART interrupts >
  217+          VDF <D,SND_LVL>	SND,	   sndintp, INT ioainst,    SND_NOTES,	SND_LVL, 0,	< I/O ASIC Sound interrupts >
  218+          VDF <D,MC_LVL>	MC,	   mcintp,  INT ioainst,    MC_NOTES,	MC_LVL,	0,	< I/O ASIC Microcontroller interrupt >
  219+          ;
  220+   (4)    .endc			; (_DISPATCH_MAC_&1) != 0 *** DON'T MOVE THIS LINE EITHER ***
  221+          ;
  222+          ;+++++++ From here on, there are few user servicable parts inside. ++++
  223+          ;
  224+          ; This is sortof how it works:
  225+          ; The first pass through, _DISPATCH_MAC_ will be 0 (set above by the .if not_defined).
  226+          ; First the copyright boilerplate is inserted into both output files and the macro VDF
  227+          ; is defined to create externs. Some struct definitions and unique externs are depositied
  228+          ; into the .h file. Next _DISPATCH_MAC_ is set to 1 and this file is .included
  229+          ; again. This will cause MACPP to read the VDF table above and output the appropriate
  230+          ; information in the .h file but ignore the rest of the file. The VDF macro is redefined,
  231+          ; and the procedure is repeated causing the creation of different items according to what
  232+          ; is needed. Once the whole .h file is built, the procedure repeats for the building of the
  233+          ; .c file.
  234+          ;
  235+   (4)    .if true, _DISPATCH_MAC_ == 0		; First (main) pass
  236+    X      PHX == 0
  237+    X      PAD == 0
  238+    X      FLG == 0
  239+    X      SEA == 0
  240+    X      VEG == 0
  241+    X      .iif true, HOST_BOARD == PHOENIX, PHX == 1 ;set the appropriate ones true as desired
  242+    X      .iif true, HOST_BOARD == PHOENIX_AD, PAD == 1 ;set the appropriate ones true as desired
  243+    X      .iif true, HOST_BOARD == FLAGSTAFF, FLG == 1 ;set the appropriate ones true as desired
  244+    X      .iif true, HOST_BOARD == SEATTLE, SEA == 1 ;set the appropriate ones true as desired
  245+    X      .iif true, HOST_BOARD == VEGAS, VEG == 1 ;set the appropriate ones true as desired
  246+          ;
  247+    X     	.macro .condit flag,exp		; The .condit macro does an expression test ...
  248+    X     	.if identical,<flag>,<T>
  249+    X     		.iif false,exp,.mexit 10 ; ... and aborts higher level macros if false
  250+    X     		.mexit
  251+    X     	.endc
  252+    X     	.if identical,<flag>,<F>
  253+    X     		.iif true,exp,.mexit 10	; ... etc.
  254+    X     		.mexit
  255+    X     	.endc
  256+    X     	.if identical,<flag>,<D>
  257+    X     		.iif not_defined,exp,.mexit 10
  258+    X     		.mexit
  259+    X     	.endc
  260+    X     	.if identical,<flag>,<N>
  261+    X     		.iif defined,exp,.mexit 10
  262+    X     		.mexit
  263+    X     	.endc
  264+    X     	.endm
  265+          ;	
  266+    X     	.macro boilerplate file_name
  267+    X     /*		file_name
  268+    X      *
dispatch.c                               Atari Games Corp. macpp v9.12   "Oct 16 1997 13:26:41"


  269+    X      *		Copyright 1996 Atari Games Corporation
  270+    X      *	Unauthorized reproduction, adaptation, distribution, performance or 
  271+    X      *	display of this computer program or the associated audiovisual work
  272+    X      *	is strictly prohibited.
  273+    X      *
  274+    X      * ++++++ WARNING WARNING WARNING WARNING WARNING +++++
  275+    X      * This file is machine generated. Any changes you put in here will be lost
  276+    X      * the next time phx_vecs.mac is touched. You need to make your changes to
  277+    X      * phx_vecs.mac instead of this file.
  278+    X      */
  279+    X     	.endm
  280+    X     	boilerplate dispatch.c
  281+    X     	.outfile	1		;The externs go into the .h file
  282+    X     	boilerplate intvecs.h
  283+    X     #if !defined(_INTVECS_H_)
  284+    X     #define _INTVECS_H_
  285+          
  286+    X     struct irq_tab {
  287+    X     	void 	(**softvec)();
  288+    X     	void    (*(*installer)(const struct irq_tab *, void(*new)()))();
  289+    X     	int	notes;
  290+    X     };
  291+          ;
  292+    X     	.macro VDF cond, name, softvec, intern, installer, notes, physical, default, comments
  293+    X     	.condit cond	
  294+    X      .if dif,<softvec>,<0>
  295+    X       ...1 == 0
  296+    X       .iif idn,<intern>,<VINT>,...1 == 1
  297+    X       .iif idn,<intern>,<VEXT>,...1 == 1
  298+    X       .if true, ...1
  299+    X     extern	void (* volatile softvec)();	/* comments */
  300+    X       .iff
  301+    X     extern  void (*softvec)();	/* comments */
  302+    X       .endc
  303+    X      .endc
  304+    X     	.endm
  305+          ;
  306+    X     	_DISPATCH_MAC_ == 1		;next time we process the IRQ table
  307+    X     	.include phx_vecs.mac		;Make the externs
  308+          
  309+    X     enum vecs {
  310+    X     	.macro VDF cond, name, softvec, intern, installer, notes, physical, default, comments
  311+    X     	.condit cond	
  312+    X         name'_INTVEC,
  313+    X     	.endm
  314+    X     	.include phx_vecs.mac		;Make the enums
  315+    X         N_INTVECS
  316+    X     };
  317+          
  318+    X     void (*prc_set_vec (unsigned int vecnum, void (*routine)() ))();
  319+    X     void prc_init_vecs(void);		/* set the default vectors */
  320+          ;
  321+          ; Add a prototype for an as yet unused function
  322+    X     .if true, 0
  323+          
  324+    X     /*		prc_set_vecp(which, what)
  325+    X      *	Sets a special vector for the interrupt identified by <which>
dispatch.c                               Atari Games Corp. macpp v9.12   "Oct 16 1997 13:26:41"


  326+    X      *	to call the routine specified by <what>. <what> is
  327+    X      *	a struct that contains both a pointer to the code
  328+    X      *	to execute and an optional pointer to the private
  329+    X      *	variables for that routine. This is a change from the
  330+    X      *	behavior of prc_set_vec, and is intended to allow
  331+    X      *	multiple incarnations of a given device to share code.
  332+    X      */
  333+          
  334+    X     struct opaque;
  335+    X     extern struct VECP_vector {
  336+    X         void (*function)(struct opaque *);	/* Who you gonna call */
  337+    X         struct opaque *cookie;		/* a magic cookie to hand him */
  338+    X     } prc_set_vecp (
  339+    X         int __which,			/* one of xxx_INTVEC */
  340+    X         struct IRQ_vector __what		/* BY VALUE!!! */
  341+    X     );
  342+    X     .endc
  343+    X     #endif		/* _INTVECS_H_ */
  344+          ;
  345+          ; At this point, we have completed all processing of the .h file
  346+          ; so switch back to the .c file
  347+          ;
  348+    X     	.outfile	0		;switch back to dispatch.c
  349+          ;
  350+    X     #include <config.h>			/* begining of dispatch.c */
  351+    X     #include <os_proto.h>
  352+    X     #include <intvecs.h>
  353+          
  354+    X     #ifndef BLABF
  355+    X     # define BLABF(x)
  356+    X     #endif
  357+          
  358+    X     #ifndef BLAB
  359+    X     # define BLAB(x)
  360+    X     #endif
  361+          
  362+    X      .if true, 1
  363+    X     	.macro VDF cond, name, softvec, intern, installer, notes, physical, default, comments
  364+    X     	.condit cond	
  365+    X       .iif idn,<name>,<XBUS0>,.mexit
  366+    X       .iif idn,<name>,<XBUS1>,.mexit
  367+    X       .iif idn,<name>,<XBUS2>,.mexit
  368+    X       .iif idn,<name>,<XBUS3>,.mexit
  369+    X       .iif idn,<name>,<INT0>,.mexit
  370+    X       .iif idn,<name>,<INT1>,.mexit
  371+    X       .iif idn,<name>,<INT2>,.mexit
  372+    X       .iif idn,<name>,<INT3>,.mexit
  373+    X       .iif idn,<name>,<INT4>,.mexit
  374+    X       .iif idn,<name>,<INT5>,.mexit
  375+    X       .if true, PHX
  376+    X         .if true, physical == XBUS0_LVL
  377+    X     	  ...XBUS0 == ...XBUS0 + 1
  378+    X     	  .mexit
  379+    X         .endc
  380+    X         .if true, physical == XBUS1_LVL
  381+    X     	  ...XBUS1 == ...XBUS1 + 1
  382+    X     	  .mexit
dispatch.c                               Atari Games Corp. macpp v9.12   "Oct 16 1997 13:26:41"


  383+    X         .endc
  384+    X         .if true, physical == XBUS2_LVL
  385+    X     	  ...XBUS2 == ...XBUS2 + 1
  386+    X     	  .mexit
  387+    X         .endc
  388+    X         .if true, physical == XBUS3_LVL
  389+    X     	  ...XBUS3 == ...XBUS3 + 1
  390+    X     	  .mexit
  391+    X         .endc
  392+    X       .endc
  393+    X       .if true, physical == INT0_LVL
  394+    X         	...INT0 == ...INT0 + 1
  395+    X     	.mexit
  396+    X       .endc
  397+    X       .if true, physical == INT1_LVL
  398+    X         	...INT1 == ...INT1 + 1
  399+    X        .if true, PAD || FLG || SEA || VEG
  400+    X     	...IOA == ...IOA + 1
  401+    X         .if ndf, notes
  402+    X     #define notes IO_MAIN_GLOBAL_INT
  403+    X         .endc
  404+    X        .endc
  405+    X     	.mexit
  406+    X       .endc
  407+    X       .if true, physical == INT2_LVL
  408+    X         	...INT2 == ...INT2 + 1
  409+    X     	.mexit
  410+    X       .endc
  411+    X       .if true, physical == INT3_LVL
  412+    X         	...INT3 == ...INT3 + 1
  413+    X     	.mexit
  414+    X       .endc
  415+    X       .if true, physical == INT4_LVL
  416+    X         	...INT4 == ...INT4 + 1
  417+    X     	.mexit
  418+    X       .endc
  419+    X       .if true, physical == INT5_LVL
  420+    X         	...INT5 == ...INT5 + 1
  421+    X     	.mexit
  422+    X       .endc
  423+    X       .if true, physical == IOASIC_LVL
  424+    X         	...IOA == ...IOA + 1
  425+    X        .if ndf, notes
  426+    X     #define notes IO_MAIN_GLOBAL_INT
  427+    X        .endc
  428+    X     	.mexit
  429+    X       .endc
  430+    X     	.endm
  431+    X     ...XBUS0 == 0
  432+    X     ...XBUS1 == 0
  433+    X     ...XBUS2 == 0
  434+    X     ...XBUS3 == 0
  435+    X     ...INT0 == 0
  436+    X     ...INT1 == 0
  437+    X     ...INT2 == 0
  438+    X     ...INT3 == 0
  439+    X     ...INT4 == 0
dispatch.c                               Atari Games Corp. macpp v9.12   "Oct 16 1997 13:26:41"


  440+    X     ...INT5 == 0
  441+    X     ...IOA == 0
  442+    X     	.include phx_vecs.mac	; count vectors requiring dispatch
  443+    X      .endc
  444+          ; 
  445+    X     .macro VDF cond, name, softvec, intern, installer, notes, physical, default, comments
  446+    X      .condit cond	
  447+    X      .if dif,<softvec>,<0>
  448+    X       .if idn,<intern>,<INT>
  449+    X     void (*softvec)();	/* comments */
  450+    X       .endc
  451+    X       .if idn,<intern>,<VINT>
  452+    X     void (* volatile softvec)();	/* comments */
  453+    X       .endc
  454+    X      .endc
  455+    X      .if dif,<default>,<0>
  456+    X       .if idn,<name>,<INT0>
  457+    X        .if true, ...INT0
  458+    X     static void 'default'(void);	/* comments */
  459+    X        .endc
  460+    X        .mexit
  461+    X       .endc
  462+    X       .if idn,<name>,<INT1>
  463+    X        .if true, ...INT1
  464+    X     static void 'default'(void);	/* comments */
  465+    X        .endc
  466+    X        .mexit
  467+    X       .endc
  468+    X       .if idn,<name>,<INT2>
  469+    X        .if true, ...INT2
  470+    X     static void 'default'(void);	/* comments */
  471+    X        .endc
  472+    X        .mexit
  473+    X       .endc
  474+    X       .if idn,<name>,<INT3>
  475+    X        .if true, ...INT3
  476+    X     static void 'default'(void);	/* comments */
  477+    X        .endc
  478+    X        .mexit
  479+    X       .endc
  480+    X       .if idn,<name>,<INT4>
  481+    X        .if true, ...INT4
  482+    X     static void 'default'(void);	/* comments */
  483+    X        .endc
  484+    X        .mexit
  485+    X       .endc
  486+    X       .if idn,<name>,<INT5>
  487+    X        .if true, ...INT5
  488+    X     static void 'default'(void);	/* comments */
  489+    X        .endc
  490+    X        .mexit
  491+    X       .endc
  492+    X       .if idn,<name>,<INT6>
  493+    X        .if true, ...INT6
  494+    X     static void 'default'(void);	/* comments */
  495+    X        .endc
  496+    X        .mexit
dispatch.c                               Atari Games Corp. macpp v9.12   "Oct 16 1997 13:26:41"


  497+    X       .endc
  498+    X       .if idn,<name>,<INT7>
  499+    X        .if true, ...INT7
  500+    X     static void 'default'(void);	/* comments */
  501+    X        .endc
  502+    X        .mexit
  503+    X       .endc
  504+    X       .if true, PHX
  505+    X        .if idn,<name>,<XBUS>
  506+    X         .if true, ...XBUS0|...XBUS1|...XBUS2|...XBUS3
  507+    X     static void 'default'(void);
  508+    X         .endc
  509+    X         .mexit
  510+    X        .endc
  511+    X        .if idn,<name>,<XBUS0>
  512+    X         .if true, ...XBUS0
  513+    X     static void 'default'(void);
  514+    X         .endc
  515+    X         .mexit
  516+    X        .endc
  517+    X        .if idn,<name>,<XBUS1>
  518+    X         .if true, ...XBUS1
  519+    X     static void 'default'(void);
  520+    X         .endc
  521+    X         .mexit
  522+    X        .endc
  523+    X        .if idn,<name>,<XBUS2>
  524+    X         .if true, ...XBUS2
  525+    X     static void 'default'(void);
  526+    X         .endc
  527+    X         .mexit
  528+    X        .endc
  529+    X        .if idn,<name>,<XBUS3>
  530+    X         .if true, ...XBUS3
  531+    X     static void 'default'(void);
  532+    X         .endc
  533+    X         .mexit
  534+    X        .endc
  535+    X       .endc			; PHX
  536+    X       .if idn,<name>,<IOA>
  537+    X        .if true, ...IOA
  538+    X     static void 'default'(void);
  539+    X        .endc
  540+    X        .mexit
  541+    X       .endc
  542+    X     extern void 'default'(void);
  543+    X      .endc
  544+    X     .endm
  545+    X     	.include phx_vecs.mac		;Declare the non-extern vectors
  546+          ;
  547+    X      .if true, ((PROCESSOR&-16) == MIPS3000) || ((PROCESSOR&-16) == MIPS4000)
  548+    X     static void (*hwvinst(const struct irq_tab *, void (*)()))();
  549+    X      .endc
  550+          ;
  551+    X     .if df, PHOENIX_INTCTL_MASK
  552+    X     static void (*pvinst(const struct irq_tab *, void (*)()))();
  553+    X     .endc
dispatch.c                               Atari Games Corp. macpp v9.12   "Oct 16 1997 13:26:41"


  554+          ;
  555+    X     .if df, GALILEO_INTCTL_MASK
  556+    X     static void (*gvinst(const struct irq_tab *, void (*)()))();
  557+    X     .endc
  558+          ;
  559+    X     .if true, ...IOA
  560+    X     static void (*ioainst(const struct irq_tab *, void (*)()))();
  561+    X     .endc
  562+          ;
  563+    X     static const struct irq_tab irq_inits[] = {
  564+    X     	.macro VDF cond, name, softvec, intern, installer, notes, physical, default, comments
  565+    X     	.condit cond	
  566+    X      .if dif,<softvec>,<0>
  567+    X      { (void (**)())&softvec, installer, notes },	/* comments */
  568+    X      .iff
  569+    X      { 0, installer, notes },	/* comments */
  570+    X      .endc
  571+    X     	.endm
  572+    X     	.include phx_vecs.mac		;Build the irq_inits array
  573+    X      { 0, 0, 0} };
  574+          ;
  575+    X     .if true, ((PROCESSOR&-16) == MIPS3000) || ((PROCESSOR&-16) == MIPS4000)
  576+          
  577+    X     extern void (*ramv_tbl[])();
  578+          
  579+    X     static void (*hwvinst(const struct irq_tab *it, void (*new)()))() {
  580+    X         int indx;
  581+    X         void (*old_rtn)();
  582+          
  583+    X         indx = it->notes;
  584+    X         if (indx >= VN_MAX) return 0;
  585+    X         old_rtn = ramv_tbl[indx];
  586+    X         ramv_tbl[indx] = new;
  587+    X         return old_rtn;
  588+    X     }
  589+          
  590+    X      .if df, PHOENIX_INTCTL_MASK
  591+    X     static void (*pvinst(const struct irq_tab *it, void (*new)()))() {
  592+          
  593+    X         if (it->notes) {
  594+    X     	BLABF(("\ndispatch: Adding 0x%08lX to main INTCTL (0x%08lX)...", it->notes, *(VU32*)INTCTL_IE));
  595+    X     	*((VU32 *)(INTCTL_IE)) |= it->notes;
  596+    X         }
  597+    X         return 0;
  598+    X     }
  599+    X      .endc
  600+          
  601+    X      .if df, GALILEO_INTCTL_MASK
  602+    X     static void (*gvinst(const struct irq_tab *it, void (*new)()))() {
  603+          
  604+    X         if (it->notes) {
  605+    X     	BLABF(("\ndispatch: Adding 0x%08lX to Galileo INTCTL (0x%08lX)...", it->notes, \
  606+    X     			*(VU32*)GALILEO_CPU_I_ENA));
  607+    X     	*((VU32 *)(GALILEO_CPU_I_ENA)) |= it->notes;
  608+    X         }
  609+    X         return 0;
  610+    X     }
dispatch.c                               Atari Games Corp. macpp v9.12   "Oct 16 1997 13:26:41"


  611+    X      .endc
  612+          
  613+    X      .if true, ...IOA
  614+    X     static void (*ioainst(const struct irq_tab *it, void (*new)()))() {
  615+    X     extern void prc_wait_n_usecs( int );
  616+    X         if (it->notes)
  617+    X         {
  618+    X          BLABF(("\ndispatch: Adding 0x%04X to IOASIC INTCTL: (0x%04X)...", (int)it->notes, \
  619+    X     		*(VU32*)IO_MAIN_CTL&0xFFFF));
  620+    X          while ( ( *((VU32 *)IO_MAIN_CTL) & it->notes ) != it->notes )
  621+    X          {
  622+    X     #ifdef LED_OUT
  623+    X           *(VU32 *)LED_OUT = ~( 1 << B_LED_RED );
  624+    X     #endif
  625+    X           do
  626+    X           {
  627+    X            *((VU32 *)IO_MAIN_CTL) |= it->notes;
  628+    X            prc_wait_n_usecs( 1000 );
  629+    X           } while ( ( *((VU32 *)IO_MAIN_CTL) & it->notes ) != it->notes );
  630+    X           prc_wait_n_usecs( 1000 );
  631+    X     #ifdef LED_OUT
  632+    X           *(VU32 *)LED_OUT |= ( 1 << B_LED_RED );
  633+    X     #endif
  634+    X          }
  635+    X         }
  636+    X         return 0;
  637+    X     }
  638+    X      .endc
  639+    X     .endc
  640+          
  641+    X     void (*prc_set_vec (unsigned int vecnum, void (*routine)() ))()
  642+    X     {
  643+    X         void (*old_rtn)();
  644+    X         void (**softvec)();
  645+    X         const struct irq_tab *tbp;
  646+    X         int old_ipl;
  647+          
  648+    X         if ( vecnum >= N_INTVECS ) return 0;
  649+    X         tbp = irq_inits+vecnum;
  650+    X         softvec = tbp->softvec;
  651+    X         old_rtn = 0;
  652+    X         old_ipl = prc_set_ipl(INTS_OFF);
  653+    X         if ( tbp->installer ) old_rtn = tbp->installer(tbp, routine);
  654+    X         if ( softvec ) {
  655+    X     	if (!old_rtn) old_rtn = *softvec;
  656+    X     	*softvec = routine;
  657+    X         }
  658+    X         prc_set_ipl(old_ipl);
  659+    X         return old_rtn;
  660+    X     }
  661+          
  662+    X      .if true, PHX
  663+    X       .if true, ...XBUS0
  664+    X     static void xbus0_irq(void) {
  665+    X     	.macro VDF cond, name, softvec, intern, installer, notes, physical, default, comments
  666+    X     	.condit cond	
  667+    X       .iif idn,<name>,<XBUS0>,.mexit
dispatch.c                               Atari Games Corp. macpp v9.12   "Oct 16 1997 13:26:41"


  668+    X       .iif idn,<softvec>,<0>,.mexit
  669+    X       .if true, physical == XBUS0_LVL
  670+    X         if (softvec) softvec();
  671+    X       .endc
  672+    X     	.endm
  673+    X     	.include phx_vecs.mac		; pickup all vectors assigned to XBUS0_LVL
  674+    X         return;
  675+    X     }
  676+          
  677+    X       .endc		; ...XBUS0
  678+    X       .if true, ...XBUS1
  679+    X     static void xbus1_irq(void) {
  680+    X     	.macro VDF cond, name, softvec, intern, installer, notes, physical, default, comments
  681+    X     	.condit cond	
  682+    X       .iif idn,<name>,<XBUS1>,.mexit
  683+    X       .iif idn,<softvec>,<0>,.mexit
  684+    X       .if true, physical == XBUS1_LVL
  685+    X         if (softvec) softvec();
  686+    X       .endc
  687+    X     	.endm
  688+    X     	.include phx_vecs.mac		; pickup all vectors assigned to XBUS1_LVL
  689+    X         return;
  690+    X     }
  691+          
  692+    X       .endc		; ...XBUS1
  693+    X       .if true, ...XBUS2
  694+    X     static void xbus2_irq(void) {
  695+    X     	.macro VDF cond, name, softvec, intern, installer, notes, physical, default, comments
  696+    X     	.condit cond	
  697+    X       .iif idn,<name>,<XBUS2>,.mexit
  698+    X       .iif idn,<softvec>,<0>,.mexit
  699+    X       .if true, physical == XBUS2_LVL
  700+    X         if (softvec) softvec();
  701+    X       .endc
  702+    X     	.endm
  703+    X     	.include phx_vecs.mac		; pickup all vectors assigned to XBUS2_LVL
  704+    X         return;
  705+    X     }
  706+          
  707+    X       .endc		; ...XBUS2
  708+    X       .if true, ...XBUS3
  709+    X     static void xbus3_irq(void) {
  710+    X     	.macro VDF cond, name, softvec, intern, installer, notes, physical, default, comments
  711+    X     	.condit cond	
  712+    X       .iif idn,<name>,<XBUS3>,.mexit
  713+    X       .iif idn,<softvec>,<0>,.mexit
  714+    X       .if true, physical == XBUS3_LVL
  715+    X         if (softvec) softvec();
  716+    X       .endc
  717+    X     	.endm
  718+    X     	.include phx_vecs.mac		; pickup all vectors assigned to XBUS3_LVL
  719+    X         return;
  720+    X     }
  721+          
  722+    X       .endc		; ...XBUS3
  723+    X      .endc		; PHX
  724+    X      .if true, ...INT0
dispatch.c                               Atari Games Corp. macpp v9.12   "Oct 16 1997 13:26:41"


  725+    X     static void int0_irq(void) {
  726+    X     	.macro VDF cond, name, softvec, intern, installer, notes, physical, default, comments
  727+    X     	.condit cond	
  728+    X       .iif idn,<name>,<INT0>,.mexit
  729+    X       .iif idn,<softvec>,<0>,.mexit
  730+    X       .if true, physical == INT0_LVL
  731+    X         if (softvec) softvec();
  732+    X       .endc
  733+    X     	.endm
  734+    X     	.include phx_vecs.mac		; pickup all vectors assigned to IRQ 0
  735+    X         return;
  736+    X     }
  737+          
  738+    X      .endc		; ...INT0
  739+    X      .if true, ...INT1
  740+    X     static void int1_irq(void) {
  741+    X     	.macro VDF cond, name, softvec, intern, installer, notes, physical, default, comments
  742+    X     	.condit cond	
  743+    X       .iif idn,<name>,<INT1>,.mexit
  744+    X       .iif idn,<softvec>,<0>,.mexit
  745+    X       .if true, physical == INT1_LVL
  746+    X         if (softvec) softvec();
  747+    X       .endc
  748+    X     	.endm
  749+    X     	.include phx_vecs.mac		; pickup all vectors assigned to IRQ 1
  750+    X         return;
  751+    X     }
  752+          
  753+    X      .endc		; ...INT1
  754+    X      .if true, ...INT2
  755+    X     static void int2_irq(void) {
  756+    X     	.macro VDF cond, name, softvec, intern, installer, notes, physical, default, comments
  757+    X     	.condit cond	
  758+    X       .iif idn,<name>,<INT2>,.mexit
  759+    X       .iif idn,<softvec>,<0>,.mexit
  760+    X       .if true, physical == INT2_LVL
  761+    X         if (softvec) softvec();
  762+    X       .endc
  763+    X     	.endm
  764+    X     	.include phx_vecs.mac		; pickup all vectors assigned to IRQ 2
  765+    X         return;
  766+    X     }
  767+          
  768+    X      .endc		; ...INT2
  769+    X      .if true, ...INT3
  770+    X     static void int3_irq(void) {
  771+    X     	.macro VDF cond, name, softvec, intern, installer, notes, physical, default, comments
  772+    X     	.condit cond	
  773+    X       .iif idn,<name>,<INT3>,.mexit
  774+    X       .iif idn,<softvec>,<0>,.mexit
  775+    X       .if true, physical == INT3_LVL
  776+    X         if (softvec) softvec();
  777+    X       .endc
  778+    X     	.endm
  779+    X     	.include phx_vecs.mac		; pickup all vectors assigned to IRQ 3
  780+    X         return;
  781+    X     }
dispatch.c                               Atari Games Corp. macpp v9.12   "Oct 16 1997 13:26:41"


  782+          
  783+    X      .endc		; ...INT3
  784+    X      .if true, ...INT4
  785+    X     static void int4_irq(void) {
  786+    X     	.macro VDF cond, name, softvec, intern, installer, notes, physical, default, comments
  787+    X     	.condit cond	
  788+    X       .iif idn,<name>,<INT4>,.mexit
  789+    X       .iif idn,<softvec>,<0>,.mexit
  790+    X       .if true, physical == INT4_LVL
  791+    X         if (softvec) softvec();
  792+    X       .endc
  793+    X     	.endm
  794+    X     	.include phx_vecs.mac		; pickup all vectors assigned to IRQ 4
  795+    X         return;
  796+    X     }
  797+          
  798+    X      .endc		; ...INT4
  799+    X      .if true, ...INT5
  800+    X     static void int5_irq(void) {
  801+    X     	.macro VDF cond, name, softvec, intern, installer, notes, physical, default, comments
  802+    X     	.condit cond	
  803+    X       .iif idn,<name>,<INT5>,.mexit
  804+    X       .iif idn,<softvec>,<0>,.mexit
  805+    X       .if true, physical == INT5_LVL
  806+    X         if (softvec) softvec();
  807+    X       .endc
  808+    X     	.endm
  809+    X     	.include phx_vecs.mac		; pickup all vectors assigned to IRQ 5
  810+    X         return;
  811+    X     }
  812+          
  813+    X      .endc		; ...INT5
  814+    X      .if true, ...IOA && PHX
  815+    X     static void ioa_irq(void) {
  816+    X     	.macro VDF cond, name, softvec, intern, installer, notes, physical, default, comments
  817+    X     	.condit cond	
  818+    X       .iif idn,<name>,<IOA>,.mexit
  819+    X       .iif idn,<softvec>,<0>,.mexit
  820+    X       .if true, physical == IOASIC_LVL
  821+    X         if (softvec) softvec();
  822+    X       .endc
  823+    X     	.endm
  824+    X     	.include phx_vecs.mac		; pickup all vectors assigned to IRQ 5
  825+    X         return;
  826+    X     }
  827+          
  828+    X      .endc		; ...IOA
  829+    X      .if true, PHX
  830+    X       .if true, ...XBUS0|...XBUS1|...XBUS2|...XBUS3
  831+    X     static void xbus_irq(void) {
  832+    X         int which;
  833+    X         which = *(VU32 *)(XBUS_SLOT0+4);
  834+    X       .if true, ...XBUS0
  835+    X         if (!(which&1)) xbus0_irq();
  836+    X       .endc
  837+    X       .if true, ...XBUS1
  838+    X         if (!(which&2)) xbus1_irq();
dispatch.c                               Atari Games Corp. macpp v9.12   "Oct 16 1997 13:26:41"


  839+    X       .endc
  840+    X       .if true, ...XBUS2
  841+    X         if (!(which&4)) xbus2_irq();
  842+    X       .endc
  843+    X       .if true, ...XBUS3
  844+    X         if (!(which&8)) xbus3_irq();
  845+    X       .endc
  846+    X         return;
  847+    X     }
  848+    X       .endc
  849+    X      .endc		; PHX
  850+    X     void prc_init_vecs(void) {
  851+    X     	.macro VDF cond, name, softvec, intern, installer, notes, physical, default, comments
  852+    X     	.condit cond	
  853+    X     .if dif,<default>,<0>
  854+    X      .if true, PHX
  855+    X       .if idn,<name>,<XBUS0>
  856+    X        .iif true, ...XBUS0 == 0, .mexit
  857+    X       .endc
  858+    X       .if idn,<name>,<XBUS1>
  859+    X        .iif true, ...XBUS1 == 0, .mexit
  860+    X       .endc
  861+    X       .if idn,<name>,<XBUS2>
  862+    X        .iif true, ...XBUS2 == 0, .mexit
  863+    X       .endc
  864+    X       .if idn,<name>,<XBUS3>
  865+    X        .iif true, ...XBUS3 == 0, .mexit
  866+    X       .endc
  867+    X       .if idn,<name>,<XBUS>
  868+    X        .iif true, (...XBUS0|...XBUS1|...XBUS2|...XBUS3) == 0, .mexit
  869+    X       .endc
  870+    X      .endc	; PHX
  871+    X      .if idn,<name>,<INT0>
  872+    X       .iif true, ...INT0 == 0, .mexit
  873+    X      .endc
  874+    X      .if idn,<name>,<INT1>
  875+    X       .iif true, ...INT1 == 0, .mexit
  876+    X      .endc
  877+    X      .if idn,<name>,<INT2>
  878+    X       .iif true, ...INT2 == 0, .mexit
  879+    X      .endc
  880+    X      .if idn,<name>,<INT3>
  881+    X       .iif true, ...INT3 == 0, .mexit
  882+    X      .endc
  883+    X      .if idn,<name>,<INT4>
  884+    X       .iif true, ...INT4 == 0, .mexit
  885+    X      .endc
  886+    X      .if idn,<name>,<INT5>
  887+    X       .iif true, ...INT5 == 0, .mexit
  888+    X      .endc
  889+    X      .if idn,<name>,<IOA>
  890+    X       .iif true, ...IOA == 0, .mexit
  891+    X      .endc
  892+    X         prc_set_vec('name'_INTVEC, default);
  893+    X     .endc
  894+    X     	.endm
  895+    X     	.include phx_vecs.mac
dispatch.c                               Atari Games Corp. macpp v9.12   "Oct 16 1997 13:26:41"


  896+          
  897+    X     /* Map the Phoenix interrupts */
  898+          
  899+    X     .if df, INTCTL_MAPA_INIT
  900+    X         BLABF(("\ndispatch: Mapping the A interrupts: 0x%08lX...", INTCTL_MAPA_INIT));
  901+    X         *((VU32 *)(INTCTL_MAPA)) = INTCTL_MAPA_INIT;
  902+    X     .endc
  903+    X     .if df, INTCTL_MAPB_INIT
  904+    X         BLABF(("\ndispatch: Mapping the B interrupts: 0x%08lX...", INTCTL_MAPB_INIT));
  905+    X         *((VU32 *)(INTCTL_MAPB)) = INTCTL_MAPB_INIT;
  906+    X     .endc
  907+          
  908+    X     .if defined, ANNOUNCE_BOOT_ACTIONS
  909+    X      .if true, ANNOUNCE_BOOT_ACTIONS
  910+    X         {
  911+    X     	int jj;
  912+    X     	extern int prc_get_cause(void), prc_get_ipl(void);
  913+    X     	jj = prc_get_cause();
  914+    X     	if (jj&0xFF00) BLABF(("\ndispatch: CPU cause reg: %08lX, CPU SR reg: %08lX", jj, prc_get_ipl()));
  915+    X     	if (jj&0x0400) {
  916+    X       .if true, ...INT0
  917+    X     	.macro VDF cond, name, softvec, intern, installer, notes, physical, default, comments
  918+    X     	.condit cond	
  919+    X        .iif idn,<name>,<INT0>,.mexit
  920+    X        .iif idn,<softvec>,<0>,.mexit
  921+    X        .if true, physical == INT0_LVL
  922+    X     	    if (!softvec) BLAB("\ndispatch: Warning, IRQ 0 pending \"'comments'\"");
  923+    X        .endc
  924+    X     	.endm
  925+    X     	.include phx_vecs.mac		; pickup all vectors assigned to IRQ 0
  926+    X       .iff
  927+    X     	    BLAB("\ndispatch: Warning, IRQ 0 pending with no vector assigned");
  928+    X       .endc		; ...INT0
  929+    X     	}
  930+    X     	if (jj&0x0800) {
  931+    X       .if true, ...INT1
  932+    X     	.macro VDF cond, name, softvec, intern, installer, notes, physical, default, comments
  933+    X     	.condit cond	
  934+    X        .iif idn,<name>,<INT1>,.mexit
  935+    X        .iif idn,<softvec>,<0>,.mexit
  936+    X        .if true, physical == INT1_LVL
  937+    X     	    if (!softvec) BLAB("\ndispatch: Warning, IRQ 1 pending \"'comments'\"");
  938+    X        .endc
  939+    X     	.endm
  940+    X     	.include phx_vecs.mac		; pickup all vectors assigned to IRQ 1
  941+    X       .iff
  942+    X     	    BLAB("\ndispatch: Warning, IRQ 1 pending with no vector assigned");
  943+    X       .endc		; ...INT1
  944+    X     	}
  945+    X     	if (jj&0x1000) {
  946+    X       .if true, ...INT2
  947+    X     	.macro VDF cond, name, softvec, intern, installer, notes, physical, default, comments
  948+    X     	.condit cond	
  949+    X        .iif idn,<name>,<INT2>,.mexit
  950+    X        .iif idn,<softvec>,<0>,.mexit
  951+    X        .if true, physical == INT2_LVL
  952+    X     	    if (!softvec) BLAB("\ndispatch: Warning, IRQ 2 pending \"'comments'\"");
dispatch.c                               Atari Games Corp. macpp v9.12   "Oct 16 1997 13:26:41"


  953+    X        .endc
  954+    X     	.endm
  955+    X     	.include phx_vecs.mac		; pickup all vectors assigned to IRQ 2
  956+    X       .iff
  957+    X     	    BLAB("\ndispatch: Warning, IRQ 2 pending with no vector assigned");
  958+    X       .endc		; ...INT2
  959+    X     	}
  960+    X     	if (jj&0x2000) {
  961+    X       .if true, ...INT3
  962+    X     	.macro VDF cond, name, softvec, intern, installer, notes, physical, default, comments
  963+    X     	.condit cond	
  964+    X        .iif idn,<name>,<INT3>,.mexit
  965+    X        .iif idn,<softvec>,<0>,.mexit
  966+    X        .if true, physical == INT3_LVL
  967+    X     	    if (!softvec) BLAB("\ndispatch: Warning, IRQ 3 pending \"'comments'\"");
  968+    X        .endc
  969+    X     	.endm
  970+    X     	.include phx_vecs.mac		; pickup all vectors assigned to IRQ 3
  971+    X       .iff
  972+    X     	    BLAB("\ndispatch: Warning, IRQ 3 pending with no vector assigned");
  973+    X       .endc		; ...INT3
  974+    X     	}
  975+    X     	if (jj&0x4000) {
  976+    X       .if true, ...INT4
  977+    X     	.macro VDF cond, name, softvec, intern, installer, notes, physical, default, comments
  978+    X     	.condit cond	
  979+    X        .iif idn,<name>,<INT4>,.mexit
  980+    X        .iif idn,<softvec>,<0>,.mexit
  981+    X        .if true, physical == INT4_LVL
  982+    X     	    if (!softvec) BLAB("\ndispatch: Warning, IRQ 4 pending \"'comments'\"");
  983+    X        .endc
  984+    X     	.endm
  985+    X     	.include phx_vecs.mac		; pickup all vectors assigned to IRQ 4
  986+    X       .iff
  987+    X     	    BLAB("\ndispatch: Warning, IRQ 4 pending with no vector assigned");
  988+    X       .endc		; ...INT4
  989+    X     	}
  990+    X     	if (jj&0x8000) {
  991+    X       .if true, ...INT5
  992+    X     	.macro VDF cond, name, softvec, intern, installer, notes, physical, default, comments
  993+    X     	.condit cond	
  994+    X        .iif idn,<name>,<INT5>,.mexit
  995+    X        .iif idn,<softvec>,<0>,.mexit
  996+    X        .if true, physical == INT5_LVL
  997+    X     	    if (!softvec) BLAB("\ndispatch: Warning, IRQ 5 pending \"'comments'\"");
  998+    X        .endc
  999+    X     	.endm
 1000+    X     	.include phx_vecs.mac		; pickup all vectors assigned to IRQ 5
 1001+    X       .iff
 1002+    X     	    BLAB("\ndispatch: Warning, IRQ 5 pending with no vector assigned");
 1003+    X       .endc		; ...INT5
 1004+    X     	}
 1005+    X         }
 1006+    X      .endc		; true, ANNOUNCE_BOOT_ACTIONS
 1007+    X     .endc		; defined, ANNOUNCE_BOOT_ACTIONS
 1008+    X         return;
 1009+    X     }
dispatch.c                               Atari Games Corp. macpp v9.12   "Oct 16 1997 13:26:41"


 1010+   (4)    .endc		; _DISPATCH_MAC_ == 0
  986    (3)      .iff
  987     X     	    BLAB("\ndispatch: Warning, IRQ 4 pending with no vector assigned");
  988    (3)      .endc		; ...INT4
  989           	}
  990           	if (jj&0x8000) {
  991    (3)      .if true, ...INT5
  992           	.macro VDF cond, name, softvec, intern, installer, notes, physical, default, comments
  993           	.condit cond	
  994              .iif idn,<name>,<INT5>,.mexit
  995              .iif idn,<softvec>,<0>,.mexit
  996              .if true, physical == INT5_LVL
  997           	    if (!softvec) BLAB("\ndispatch: Warning, IRQ 5 pending \"'comments'\"");
  998              .endc
  999           	.endm
 1000           	.include phx_vecs.mac		; pickup all vectors assigned to IRQ 5
    1+          ;/*		phx_vecs.mac
    2+          ; *
    3+          ; *		Copyright 1996 Atari Games Corporation
    4+          ; *	Unauthorized reproduction, adaptation, distribution, performance or 
    5+          ; *	display of this computer program or the associated audiovisual work
    6+          ; *	is strictly prohibited.
    7+          ; *
    8+          ; *	This file is processed by MACPP to produce dispatch.c and intvecs.h.
    9+          ; *
   10+          ; *	The definitions placed in intvecs.h declare virtual vector numbers
   11+          ; *	in the form of xxx_INTVEC and a cross reference table(s) so the
   12+          ; *	dispatcher can call the appropriate functions.
   13+          ; *
   14+          ; *	intvecs.h should be #include'd by any module that uses prc_set_vec().
   15+          ; */
   16+          ;
   17+          ; This file recursivley '.includes' itself to succesively build up the approprate
   18+          ; tables and functions in C and places the results in one of two files (the
   19+          ; first -out=file supplied on the MACPP command line is expected to be dispatch.c
   20+          ; and the second -out=file is expected to be intvecs.h and the third is expected to
   21+          ; be /dev/null). If you don't speak fluent MACPP, then you probably shouldn't be
   22+          ; changing anything in this file other than the VDF table listed below.
   23+          ;
   24+   (4)    .if not_defined, _DISPATCH_MAC_		;1 +++++
   25+    X     _DISPATCH_MAC_ == 0			;2 Don't move ...
   26+    X     OUTPUT_LANG == 5 ;LANG_NONE		;3 ... or change ... 
   27+    X     	.outfile 2			;4 ... anything on ...
   28+    X     	.include config.mac		;5 ... these ...
   29+    X     	.outfile 0			;6 ... nine  ...
   30+   (4)    .endc					;7 ... lines ...
   31+   (4)    .if true, (_DISPATCH_MAC_&1) != 0	;8
   32+   (5)     .if true, 0				;9 -----
   33+          
   34+    X     You are free to add or remove entries from this table according to your
   35+    X     requirements. There are 10 fields used on each line in this table. The
   36+    X     description of each field follows:
   37+          
   38+    X     Field 1 = macro call
   39+          
   40+    X     It must always be the keyword VDF (case is not significant).
   41+          
dispatch.c                               Atari Games Corp. macpp v9.12   "Oct 16 1997 13:26:41"


   42+    X     Field 2 = condition
   43+          
   44+    X     This is a dual operand field, so the two operands together must be enclosed in
   45+    X     <>'s. The first operand is one of T, F, D or N representing True, False,
   46+    X     Defined or Not_defined respectively. Case is significant, use uppercase only
   47+    X     please. For the conditions T or F the second operand must be an expression
   48+    X     which must resolve to non-$0 (True) or $0 (False) in order for the macro
   49+    X     to be processed (else it is ignored). The expression can contain no embedded
   50+    X     spaces. For the conditions D and N, the second operand must only be a symbol
   51+    X     which must be Defined or Not-defined respectively in order for the macro to be
   52+    X     processed. Some short cut expressions have been preprocessed to make using the
   53+    X     expressions a little more concise. These are:
   54+          
   55+    X     	PHX = not $0 if HOST_BOARD == PHOENIX
   56+    X     	PAD = not $0 if HOST_BOARD == PHOENIX_AD
   57+    X     	FLG = not $0 if HOST_BOARD == FLAGSTAFF
   58+    X     	SEA = not $0 if HOST_BOARD == SEATTLE
   59+    X     	VEG = not $0 if HOST_BOARD == VEGAS
   60+          
   61+    X     Field 3 = vector name
   62+          
   63+    X     The NAME field is the name of the virtual vector. An _INTVEC will be appended
   64+    X     to it in the C definitions in intvecs.h, but otherwise the name is unmolested.
   65+    X     Case is significant only if you want it to be. The R3K/R4K has an option where
   66+    X     a number of vectors are maintained in an array of pointers rather than each
   67+    X     one having its own name. The index into the array is same as the number
   68+    X     returned in the processor's CAUSE register for that particluar interrupt. This
   69+    X     procedure is done simply for performance reasons. The option is selected by
   70+    X     using a 0 for this field and using an installer function with the vector index
   71+    X     as the parameter to the installer.
   72+          
   73+    X     Field 4 = Vector pointer
   74+          
   75+    X     This field identifies the name of a variable in BSS that contains a pointer
   76+    X     to the function to call at interrupt (or will be set by the prc_set_vec()
   77+    X     function). This is the name of the "soft" or logical vector and is either
   78+    X     declared in dispatch.c or externally according to the INT/EXT field described
   79+    X     next.
   80+          
   81+    X     Field 5 = INTernal or EXTernal vector
   82+          
   83+    X     This field contains the keywords INT, EXT, VINT or VEXT identifying the vector
   84+    X     in field 4 as being defined INTernally, EXTernally, Volatile INTernally or
   85+    X     Volatile Externally to dispatch.c respectively.
   86+          
   87+    X     Field 6 = name of vector installer
   88+          
   89+    X     This field identifies the name of a function that prc_set_vec() will call to
   90+    X     actually install the vector or 0 if there is no special stuff that needs to
   91+    X     be performed during vector installation.
   92+          
   93+    X     Field 7 = Notes for the installer.
   94+          
   95+    X     The Notes field is a parameter that is passed to the installer if there is one.
   96+          
   97+    X     Field 8 = Physical vector attachment.
   98+          
dispatch.c                               Atari Games Corp. macpp v9.12   "Oct 16 1997 13:26:41"


   99+    X     A dispatch routine is constructed for each of the 4 XBUS interrupts and for each of
  100+    X     the 6 CPU interrupts.  This field instructs phx_vecs.mac into which of the XBUS or
  101+    X     INTx dispatchers a caller to this vector belongs.  If this vector is not associated
  102+    X     with an XBUS or an INTx interrupt, it needs to be -1.  Place the interrupt routines
  103+    X     in this table in the order in which you want them executed.
  104+          
  105+    X     Field 9 = Default function.
  106+          
  107+    X     Name of default routine to install in the vector, or 0 if none.  phx_vecs.mac builds
  108+    X     a function called prc_init_vecs(void) which, when called, will perform a string of
  109+    X     prc_set_vec()'s for all the vectors having this field non-zero.  After the vectors
  110+    X     have been loaded, prc_init_vecs(void) will map the phoenix and galileo interrupts as
  111+    X     specified in phoenix.mac.
  112+          
  113+    X     Field 10 = Comments.
  114+          
  115+    X     The Comments field is placed on selected lines in intvecs.h and/or dispatch.c
  116+    X     as simple 'C' comments.
  117+          
  118+   (5)     .endc				; Don't move this line
  119+          ;
  120+          ;   Condit	Name	   Vector   I/E	Installer   Notes      Phys	Default	Comments
  121+          ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  122+          VDF <T,1>	GAMEVB,	   gameint, EXT	0,          0,		-1,	0,	< post-wierdness Vblank >
  123+          VDF <T,1>	MS4,       ms4vec,  EXT	0,          0,		-1,	0,	< 4 Millisecond timer >
  124+          VDF <T,1>	PRC_DELAY, prc_delay_vec, EXT 0,    0,		-1,	sst_prc_delay, < prc_delay soft vector >
  125+          VDF <T,1>	PRC_SET_IPL, set_ipl_vec, INT 0,    0,		-1,	0,	< prc_set_ipl soft vector >
  126+          VDF <T,1>	SAVE,      savintp, EXT 0,          0,		-1,	0,	< context save soft vector >
  127+          VDF <T,1>	RESTORE,   restintp,EXT 0,          0,		-1,	0,	< context restore soft vector >
  128+          VDF <T,1>	SW0,	   0,	    INT hwvinst,    VN_IRQ0,    -1,	0,	< Software interrupt 0 >
  129+          VDF <T,1>	SW1,	   0,       INT hwvinst,    VN_IRQ1,    -1,	0,	< Software interrupt 0 >
  130+          VDF <T,1>	INT0,	   0,       INT hwvinst,    VN_IRQ2,    -1,	int0_irq, < Hardware interrupt 0 >
  131+          VDF <T,1>	INT1,	   0,	    INT hwvinst,    VN_IRQ3,    -1,	int1_irq, < Hardware interrupt 1 >
  132+          VDF <T,PHX>	INT2,	   0,	    INT hwvinst,    VN_IRQ4,    -1,	int2_irq, < Hardware interrupt 2 >
  133+          VDF <T,1>	INT3,	   0,       INT hwvinst,    VN_IRQ5,    -1,	int3_irq, < Hardware interrupt 3 >
  134+          VDF <T,1>	INT4,	   0,	    INT hwvinst,    VN_IRQ6,    -1,	int4_irq, < Hardware interrupt 4 >
  135+          VDF <T,1>	INT5,	   0,	    INT hwvinst,    VN_IRQ7,    -1,	int5_irq, < Hardware interrupt 5 >
  136+          VDF <T,1>	TLBMOD,	   0,	    INT hwvinst,    VN_TLBM,    -1,	0,	< TLB modification >
  137+          VDF <T,1>	TLBLOAD,   0,	    INT hwvinst,    VN_TLBL,    -1,	0,	< TLB miss on I or D fetch >
  138+          VDF <T,1>	TLBSTORE,  0,	    INT hwvinst,    VN_TLBS,    -1,	0,	< TLB miss on store >
  139+          VDF <T,1>	ADDRERRL,  0,	    INT hwvinst,    VN_ADDRL,   -1,	0,	< Address error on I or D fetch >
  140+          VDF <T,1>	ADDRERRS,  0,	    INT hwvinst,    VN_ADDRS,   -1,	0,	< Address error on store >
  141+          VDF <T,1>	BUSERRI,   0,	    INT hwvinst,    VN_BUSERRI, -1,	0,	< Bus error on I-fetch >
  142+          VDF <T,1>	BUSERRD,   0,	    INT hwvinst,    VN_BUSERRD, -1,	0,	< Bus error on D-fetch >
  143+          VDF <T,1>	SYSCALL,   0,       INT hwvinst,    VN_SYSCALL, -1,	0,	< SYSCALL instruction >
  144+          VDF <T,1>	BREAK,     0,       INT hwvinst,    VN_BREAK,   -1,	0,	< Breakpoint instruction >
  145+          VDF <T,1>	RESERV,    0,       INT hwvinst,    VN_RESERV,  -1,	0,	< Reserved instruction >
  146+          VDF <T,1>	COPROC,    0,       INT hwvinst,    VN_COPROC,  -1,	0,	< Coprocessor unusable >
  147+          VDF <T,1>	OVRFLOW,   0,       INT hwvinst,    VN_OVERFL,  -1,	0,	< Integer Arithmetic Overflow >
  148+          VDF <T,1>	TRAP,      0,       INT hwvinst,    VN_TRAPV,   -1,	0,	< TRAP exception >
  149+          VDF <T,1>	FLOAT,     0,       INT hwvinst,    VN_FPE,     -1,	0,	< FLoating point exception >
  150+          VDF <T,1>	TIMER,	   timervec, INT 0,	    0,          -1,	0,	< Soft Timer interrupt >
  151+          VDF <T,1>	TIMERPLL,  tpllvec, VEXT 0,	    0,		-1,	0,	<Adjust 1MS timer>
  152+          VDF <T,1>	GAMEFRAME, framevec,INT 0,	    0,		-1,	0,	< Frame complete >
  153+   (5)    .if true, PHX
  154+    X     VDF <D,NET_LVL>	NET,       netintp, INT 0,          0,		NET_LVL,0,	< network int soft vector >
  155+    X     VDF <D,XBUS>	XBUS,	   xbusintp, INT pvinst,    XBUS_NOTES,	XBUS_LVL,xbus_irq, < Any XBUS interrupt >
dispatch.c                               Atari Games Corp. macpp v9.12   "Oct 16 1997 13:26:41"


  156+    X     VDF <T,XS0>	XS0,       xs0intp, INT pvinst,	    XS0_NOTES,	XS0_LVL,0,	< Expansion Slot 0 interrupt >
  157+    X     VDF <T,XS1>	XS1,       xs1intp, INT pvinst,	    XS1_NOTES,	XS1_LVL,0,	< Expansion Slot 1 interrupt >
  158+    X     VDF <T,XS2>	XS2,       xs2intp, INT pvinst,	    XS2_NOTES,	XS2_LVL,0,	< Expansion Slot 2 interrupt >
  159+    X     VDF <T,XS3>	XS3,       xs3intp, INT pvinst,	    XS3_NOTES,	XS3_LVL,0,	< Expansion Slot 3 interrupt >
  160+    X     VDF <T,MIO>	MIO,       miointp, INT pvinst,	    MIO_NOTES,	MIO_LVL,0,	< Miscellaneous I/O interrupt >
  161+    X     VDF <T,CU1>	CU1,       cu1intp, INT pvinst,	    CU1_NOTES,	CU1_LVL,0,	< Combo UART 1 interrupt >
  162+    X     VDF <T,CU2>	CU2,       cu2intp, INT pvinst,	    CU2_NOTES,	CU2_LVL,0,	< Combo UART 2 interrupt >
  163+    X     VDF <T,CPP>	CPP,       cppintp, INT pvinst,	    CPP_NOTES,	CPP_LVL,0,	< Combo Parallel Port interrupt >
  164+    X     VDF <T,PCA>	PCA,       pcaintp, INT pvinst,	    PCA_NOTES,	PCA_LVL,0,	< PCI A interrupt >
  165+    X     VDF <T,PCB>	PCB,       pcbintp, INT pvinst,	    PCB_NOTES,	PCB_LVL,0,	< PCI B interrupt >
  166+    X     VDF <T,PCC>	PCC,       pccintp, INT pvinst,	    PCC_NOTES,	PCC_LVL,0,	< PCI C interrupt >
  167+    X     VDF <T,VSY>	VSY,       vsyintp, INT pvinst,	    VSY_NOTES,	VSY_LVL,0,	< PCI D (VSYNC) interrupt >
  168+    X     VDF <T,IDE>	IDE,	   ideintp, INT pvinst,	    IDE_NOTES,	IDE_LVL,0,	< IDE interrupt >
  169+    X     VDF <T,IOA>	IOA,	   ioaintp, INT pvinst,	    IOA_NOTES,	IOA_LVL,ioa_irq,< I/O Asic interrupt >
  170+    X     VDF <T,ADC>	ADC,	   adcintp, INT pvinst,	    ADC_NOTES,	ADC_LVL,0,	< A/D Converter interrupt >
  171+    X     VDF <D,SND_I>	CAGE,      cagevec, INT 0,          0,		CAGE_LVL,aud_irq, < CAGE interrupt >
  172+   (5)    .endc
  173+   (5)    .if true, PAD || FLG || SEA || VEG
  174+          ;VDF <T,1>	IOA,	   0,	    INT hwvinst,    VN_IRQ3,	-1,	0,	< I/O Asic interrupt >
  175+          VDF <T,1>	IDE,	   0,	    INT hwvinst,    VN_IRQ4,    -1,	0,	< IDE interrupt >
  176+          VDF <T,EXP>	EXP,       expintp, INT pvinst,	    EXP_NOTES,	EXP_LVL,0,	< Expansion Slot interrupt >
  177+   (6)     .if true, PAD || SEA
  178+          VDF <T,NSS>	NSS,	   nssintp, INT pvinst,	    NSS_NOTES,  NSS_LVL,0,	< NSS/Hi-Link interrupt>
  179+   (6)     .endc
  180+   (6)     .if true, FLG
  181+    X     VDF <T,ETH>	ETH,	   ethintp, INT pvinst,     ETH_NOTES,  ETH_LVL,0,	< ethernet interrupt >
  182+    X     VDF <D,SND_I>	CAGE,	   cagevec, INT ioainst,    CAGE_NOTES, CAGE_LVL,aud_irq, < CAGE interrupt >
  183+   (6)     .endc
  184+          VDF <T,WD1>	WD1,	   wd1intp, INT pvinst,	    WD1_NOTES,  WD1_LVL,0,	< Widget interrupt 1>
  185+          VDF <T,PCI>	PCI,       pciintp, INT pvinst,	    PCI_NOTES,	PCI_LVL,0,	< PCI interrupt >
  186+          VDF <T,ADC>	ADC,	   adcintp, INT pvinst,	    ADC_NOTES,	ADC_LVL,0,	< A/D Converter interrupt >
  187+          VDF <T,WD2>	WD2,	   wd2intp, INT pvinst,	    WD2_NOTES,  WD2_LVL,0,	< Widget interrupt 2>
  188+          VDF <T,DBG>	DBG,	   dbgintp, INT pvinst,	    DBG_NOTES,	DBG_LVL,0,	< Debug switch interrupt >
  189+          VDF <T,VSY>	VSY,	   vsyintp, INT pvinst,	    VSY_NOTES,	VSY_LVL,0,	< VSYNC interrupt >
  190+   (5)    .endc
  191+          VDF <T,GAL>	GAL,	   0,       INT gvinst,	    GAL_NOTES,  GAL_LVL,galileoint, < Any Galileo Error Interrupt >
  192+          VDF <T,MOE>	MOE,	   moeintp, INT gvinst,	    MOE_NOTES,	MOE_LVL,0,	< Galileo MemOut >
  193+          VDF <T,DOE>	DOE,	   doeintp, INT gvinst,	    DOE_NOTES,	DOE_LVL,0,	< Galileo DMAOut >
  194+          VDF <T,COE>	COE,	   coeintp, INT gvinst,	    COE_NOTES,	COE_LVL,0,	< Galileo CPUOut >
  195+          VDF <T,DM0>	DM0,	   dm0intp, INT gvinst,	    DM0_NOTES,	DM0_LVL,0,	< Galileo DMA0Comp >
  196+          VDF <T,DM1>	DM1,	   dm1intp, INT gvinst,	    DM1_NOTES,	DM1_LVL,0,	< Galileo DMA1Comp >
  197+          VDF <T,DM2>	DM2,	   dm2intp, INT gvinst,	    DM2_NOTES,	DM2_LVL,0,	< Galileo DMA2Comp >
  198+          VDF <T,DM3>	DM3,	   dm3intp, INT gvinst,	    DM3_NOTES,	DM3_LVL,0,	< Galileo DMA3Comp >
  199+          VDF <T,TM0>	TM0,	   tm0intp, INT gvinst,	    TM0_NOTES,	TM0_LVL,0,	< Galileo T0Exp >
  200+          VDF <T,TM1>	TM1,	   tm1intp, INT gvinst,	    TM1_NOTES,	TM1_LVL,0,	< Galileo T1Exp >
  201+          VDF <T,TM2>	TM2,	   tm2intp, INT gvinst,	    TM2_NOTES,	TM2_LVL,0,	< Galileo T2Exp >
  202+          VDF <T,TM3>	TM3,	   tm3intp, INT gvinst,	    TM3_NOTES,	TM3_LVL,cputimerint, < Galileo T3EXP timer interrupt >
  203+          VDF <T,MRE>	MRE,	   mreintp, INT gvinst,	    MRE_NOTES,	MRE_LVL,0,	< Galileo MasRdErr >
  204+          VDF <T,SWE>	SWE,	   sweintp, INT gvinst,	    SWE_NOTES,	SWE_LVL,0,	< Galileo SlvWrErr >
  205+          VDF <T,MWE>	MWE,	   mweintp, INT gvinst,	    MWE_NOTES,	MWE_LVL,0,	< Galileo MasWrErr >
  206+          VDF <T,SRE>	SRE,	   sreintp, INT gvinst,	    SRE_NOTES,	SRE_LVL,0,	< Galileo SlvRdErr >
  207+          VDF <T,AEP>	AEP,	   aepintp, INT gvinst,	    AEP_NOTES,	AEP_LVL,0,	< Galileo AddrErr >
  208+          VDF <T,MEP>	MEP,	   mepintp, INT gvinst,	    MEP_NOTES,	MEP_LVL,0,	< Galileo MemErr >
  209+          VDF <T,MAS>	MAS,	   masintp, INT gvinst,	    MAS_NOTES,	MAS_LVL,0,	< Galileo MasAbort >
  210+          VDF <T,TAR>	TAR,	   tarintp, INT gvinst,	    TAR_NOTES,	TAR_LVL,0,	< Galileo TarAbort >
  211+          VDF <T,RTY>	RTY,	   rtyintp, INT gvinst,	    RTY_NOTES,	RTY_LVL,0,	< Galileo RetryCtr >
  212+          VDF <T,PC0>	PC0,	   pc0intp, INT gvinst,	    PC0_NOTES,	PC0_LVL,0,	< Galileo PCI Interrupt >
dispatch.c                               Atari Games Corp. macpp v9.12   "Oct 16 1997 13:26:41"


  213+          VDF <T,PC1>	PC1,	   pc1intp, INT gvinst,	    PC1_NOTES,	PC1_LVL,0,	< Galileo PCI Interrupt >
  214+          VDF <T,PC2>	PC2,	   pc2intp, INT gvinst,	    PC2_NOTES,	PC2_LVL,0,	< Galileo PCI Interrupt >
  215+          VDF <T,PC3>	PC3,	   pc3intp, INT gvinst,	    PC3_NOTES,	PC3_LVL,0,	< Galileo PCI Interrupt >
  216+          VDF <D,UART_LVL> UART,	   uartintp,INT ioainst,    UART_NOTES,	UART_LVL,0,	< I/O ASIC UART interrupts >
  217+          VDF <D,SND_LVL>	SND,	   sndintp, INT ioainst,    SND_NOTES,	SND_LVL, 0,	< I/O ASIC Sound interrupts >
  218+          VDF <D,MC_LVL>	MC,	   mcintp,  INT ioainst,    MC_NOTES,	MC_LVL,	0,	< I/O ASIC Microcontroller interrupt >
  219+          ;
  220+   (4)    .endc			; (_DISPATCH_MAC_&1) != 0 *** DON'T MOVE THIS LINE EITHER ***
  221+          ;
  222+          ;+++++++ From here on, there are few user servicable parts inside. ++++
  223+          ;
  224+          ; This is sortof how it works:
  225+          ; The first pass through, _DISPATCH_MAC_ will be 0 (set above by the .if not_defined).
  226+          ; First the copyright boilerplate is inserted into both output files and the macro VDF
  227+          ; is defined to create externs. Some struct definitions and unique externs are depositied
  228+          ; into the .h file. Next _DISPATCH_MAC_ is set to 1 and this file is .included
  229+          ; again. This will cause MACPP to read the VDF table above and output the appropriate
  230+          ; information in the .h file but ignore the rest of the file. The VDF macro is redefined,
  231+          ; and the procedure is repeated causing the creation of different items according to what
  232+          ; is needed. Once the whole .h file is built, the procedure repeats for the building of the
  233+          ; .c file.
  234+          ;
  235+   (4)    .if true, _DISPATCH_MAC_ == 0		; First (main) pass
  236+    X      PHX == 0
  237+    X      PAD == 0
  238+    X      FLG == 0
  239+    X      SEA == 0
  240+    X      VEG == 0
  241+    X      .iif true, HOST_BOARD == PHOENIX, PHX == 1 ;set the appropriate ones true as desired
  242+    X      .iif true, HOST_BOARD == PHOENIX_AD, PAD == 1 ;set the appropriate ones true as desired
  243+    X      .iif true, HOST_BOARD == FLAGSTAFF, FLG == 1 ;set the appropriate ones true as desired
  244+    X      .iif true, HOST_BOARD == SEATTLE, SEA == 1 ;set the appropriate ones true as desired
  245+    X      .iif true, HOST_BOARD == VEGAS, VEG == 1 ;set the appropriate ones true as desired
  246+          ;
  247+    X     	.macro .condit flag,exp		; The .condit macro does an expression test ...
  248+    X     	.if identical,<flag>,<T>
  249+    X     		.iif false,exp,.mexit 10 ; ... and aborts higher level macros if false
  250+    X     		.mexit
  251+    X     	.endc
  252+    X     	.if identical,<flag>,<F>
  253+    X     		.iif true,exp,.mexit 10	; ... etc.
  254+    X     		.mexit
  255+    X     	.endc
  256+    X     	.if identical,<flag>,<D>
  257+    X     		.iif not_defined,exp,.mexit 10
  258+    X     		.mexit
  259+    X     	.endc
  260+    X     	.if identical,<flag>,<N>
  261+    X     		.iif defined,exp,.mexit 10
  262+    X     		.mexit
  263+    X     	.endc
  264+    X     	.endm
  265+          ;	
  266+    X     	.macro boilerplate file_name
  267+    X     /*		file_name
  268+    X      *
  269+    X      *		Copyright 1996 Atari Games Corporation
dispatch.c                               Atari Games Corp. macpp v9.12   "Oct 16 1997 13:26:41"


  270+    X      *	Unauthorized reproduction, adaptation, distribution, performance or 
  271+    X      *	display of this computer program or the associated audiovisual work
  272+    X      *	is strictly prohibited.
  273+    X      *
  274+    X      * ++++++ WARNING WARNING WARNING WARNING WARNING +++++
  275+    X      * This file is machine generated. Any changes you put in here will be lost
  276+    X      * the next time phx_vecs.mac is touched. You need to make your changes to
  277+    X      * phx_vecs.mac instead of this file.
  278+    X      */
  279+    X     	.endm
  280+    X     	boilerplate dispatch.c
  281+    X     	.outfile	1		;The externs go into the .h file
  282+    X     	boilerplate intvecs.h
  283+    X     #if !defined(_INTVECS_H_)
  284+    X     #define _INTVECS_H_
  285+          
  286+    X     struct irq_tab {
  287+    X     	void 	(**softvec)();
  288+    X     	void    (*(*installer)(const struct irq_tab *, void(*new)()))();
  289+    X     	int	notes;
  290+    X     };
  291+          ;
  292+    X     	.macro VDF cond, name, softvec, intern, installer, notes, physical, default, comments
  293+    X     	.condit cond	
  294+    X      .if dif,<softvec>,<0>
  295+    X       ...1 == 0
  296+    X       .iif idn,<intern>,<VINT>,...1 == 1
  297+    X       .iif idn,<intern>,<VEXT>,...1 == 1
  298+    X       .if true, ...1
  299+    X     extern	void (* volatile softvec)();	/* comments */
  300+    X       .iff
  301+    X     extern  void (*softvec)();	/* comments */
  302+    X       .endc
  303+    X      .endc
  304+    X     	.endm
  305+          ;
  306+    X     	_DISPATCH_MAC_ == 1		;next time we process the IRQ table
  307+    X     	.include phx_vecs.mac		;Make the externs
  308+          
  309+    X     enum vecs {
  310+    X     	.macro VDF cond, name, softvec, intern, installer, notes, physical, default, comments
  311+    X     	.condit cond	
  312+    X         name'_INTVEC,
  313+    X     	.endm
  314+    X     	.include phx_vecs.mac		;Make the enums
  315+    X         N_INTVECS
  316+    X     };
  317+          
  318+    X     void (*prc_set_vec (unsigned int vecnum, void (*routine)() ))();
  319+    X     void prc_init_vecs(void);		/* set the default vectors */
  320+          ;
  321+          ; Add a prototype for an as yet unused function
  322+    X     .if true, 0
  323+          
  324+    X     /*		prc_set_vecp(which, what)
  325+    X      *	Sets a special vector for the interrupt identified by <which>
  326+    X      *	to call the routine specified by <what>. <what> is
dispatch.c                               Atari Games Corp. macpp v9.12   "Oct 16 1997 13:26:41"


  327+    X      *	a struct that contains both a pointer to the code
  328+    X      *	to execute and an optional pointer to the private
  329+    X      *	variables for that routine. This is a change from the
  330+    X      *	behavior of prc_set_vec, and is intended to allow
  331+    X      *	multiple incarnations of a given device to share code.
  332+    X      */
  333+          
  334+    X     struct opaque;
  335+    X     extern struct VECP_vector {
  336+    X         void (*function)(struct opaque *);	/* Who you gonna call */
  337+    X         struct opaque *cookie;		/* a magic cookie to hand him */
  338+    X     } prc_set_vecp (
  339+    X         int __which,			/* one of xxx_INTVEC */
  340+    X         struct IRQ_vector __what		/* BY VALUE!!! */
  341+    X     );
  342+    X     .endc
  343+    X     #endif		/* _INTVECS_H_ */
  344+          ;
  345+          ; At this point, we have completed all processing of the .h file
  346+          ; so switch back to the .c file
  347+          ;
  348+    X     	.outfile	0		;switch back to dispatch.c
  349+          ;
  350+    X     #include <config.h>			/* begining of dispatch.c */
  351+    X     #include <os_proto.h>
  352+    X     #include <intvecs.h>
  353+          
  354+    X     #ifndef BLABF
  355+    X     # define BLABF(x)
  356+    X     #endif
  357+          
  358+    X     #ifndef BLAB
  359+    X     # define BLAB(x)
  360+    X     #endif
  361+          
  362+    X      .if true, 1
  363+    X     	.macro VDF cond, name, softvec, intern, installer, notes, physical, default, comments
  364+    X     	.condit cond	
  365+    X       .iif idn,<name>,<XBUS0>,.mexit
  366+    X       .iif idn,<name>,<XBUS1>,.mexit
  367+    X       .iif idn,<name>,<XBUS2>,.mexit
  368+    X       .iif idn,<name>,<XBUS3>,.mexit
  369+    X       .iif idn,<name>,<INT0>,.mexit
  370+    X       .iif idn,<name>,<INT1>,.mexit
  371+    X       .iif idn,<name>,<INT2>,.mexit
  372+    X       .iif idn,<name>,<INT3>,.mexit
  373+    X       .iif idn,<name>,<INT4>,.mexit
  374+    X       .iif idn,<name>,<INT5>,.mexit
  375+    X       .if true, PHX
  376+    X         .if true, physical == XBUS0_LVL
  377+    X     	  ...XBUS0 == ...XBUS0 + 1
  378+    X     	  .mexit
  379+    X         .endc
  380+    X         .if true, physical == XBUS1_LVL
  381+    X     	  ...XBUS1 == ...XBUS1 + 1
  382+    X     	  .mexit
  383+    X         .endc
dispatch.c                               Atari Games Corp. macpp v9.12   "Oct 16 1997 13:26:41"


  384+    X         .if true, physical == XBUS2_LVL
  385+    X     	  ...XBUS2 == ...XBUS2 + 1
  386+    X     	  .mexit
  387+    X         .endc
  388+    X         .if true, physical == XBUS3_LVL
  389+    X     	  ...XBUS3 == ...XBUS3 + 1
  390+    X     	  .mexit
  391+    X         .endc
  392+    X       .endc
  393+    X       .if true, physical == INT0_LVL
  394+    X         	...INT0 == ...INT0 + 1
  395+    X     	.mexit
  396+    X       .endc
  397+    X       .if true, physical == INT1_LVL
  398+    X         	...INT1 == ...INT1 + 1
  399+    X        .if true, PAD || FLG || SEA || VEG
  400+    X     	...IOA == ...IOA + 1
  401+    X         .if ndf, notes
  402+    X     #define notes IO_MAIN_GLOBAL_INT
  403+    X         .endc
  404+    X        .endc
  405+    X     	.mexit
  406+    X       .endc
  407+    X       .if true, physical == INT2_LVL
  408+    X         	...INT2 == ...INT2 + 1
  409+    X     	.mexit
  410+    X       .endc
  411+    X       .if true, physical == INT3_LVL
  412+    X         	...INT3 == ...INT3 + 1
  413+    X     	.mexit
  414+    X       .endc
  415+    X       .if true, physical == INT4_LVL
  416+    X         	...INT4 == ...INT4 + 1
  417+    X     	.mexit
  418+    X       .endc
  419+    X       .if true, physical == INT5_LVL
  420+    X         	...INT5 == ...INT5 + 1
  421+    X     	.mexit
  422+    X       .endc
  423+    X       .if true, physical == IOASIC_LVL
  424+    X         	...IOA == ...IOA + 1
  425+    X        .if ndf, notes
  426+    X     #define notes IO_MAIN_GLOBAL_INT
  427+    X        .endc
  428+    X     	.mexit
  429+    X       .endc
  430+    X     	.endm
  431+    X     ...XBUS0 == 0
  432+    X     ...XBUS1 == 0
  433+    X     ...XBUS2 == 0
  434+    X     ...XBUS3 == 0
  435+    X     ...INT0 == 0
  436+    X     ...INT1 == 0
  437+    X     ...INT2 == 0
  438+    X     ...INT3 == 0
  439+    X     ...INT4 == 0
  440+    X     ...INT5 == 0
dispatch.c                               Atari Games Corp. macpp v9.12   "Oct 16 1997 13:26:41"


  441+    X     ...IOA == 0
  442+    X     	.include phx_vecs.mac	; count vectors requiring dispatch
  443+    X      .endc
  444+          ; 
  445+    X     .macro VDF cond, name, softvec, intern, installer, notes, physical, default, comments
  446+    X      .condit cond	
  447+    X      .if dif,<softvec>,<0>
  448+    X       .if idn,<intern>,<INT>
  449+    X     void (*softvec)();	/* comments */
  450+    X       .endc
  451+    X       .if idn,<intern>,<VINT>
  452+    X     void (* volatile softvec)();	/* comments */
  453+    X       .endc
  454+    X      .endc
  455+    X      .if dif,<default>,<0>
  456+    X       .if idn,<name>,<INT0>
  457+    X        .if true, ...INT0
  458+    X     static void 'default'(void);	/* comments */
  459+    X        .endc
  460+    X        .mexit
  461+    X       .endc
  462+    X       .if idn,<name>,<INT1>
  463+    X        .if true, ...INT1
  464+    X     static void 'default'(void);	/* comments */
  465+    X        .endc
  466+    X        .mexit
  467+    X       .endc
  468+    X       .if idn,<name>,<INT2>
  469+    X        .if true, ...INT2
  470+    X     static void 'default'(void);	/* comments */
  471+    X        .endc
  472+    X        .mexit
  473+    X       .endc
  474+    X       .if idn,<name>,<INT3>
  475+    X        .if true, ...INT3
  476+    X     static void 'default'(void);	/* comments */
  477+    X        .endc
  478+    X        .mexit
  479+    X       .endc
  480+    X       .if idn,<name>,<INT4>
  481+    X        .if true, ...INT4
  482+    X     static void 'default'(void);	/* comments */
  483+    X        .endc
  484+    X        .mexit
  485+    X       .endc
  486+    X       .if idn,<name>,<INT5>
  487+    X        .if true, ...INT5
  488+    X     static void 'default'(void);	/* comments */
  489+    X        .endc
  490+    X        .mexit
  491+    X       .endc
  492+    X       .if idn,<name>,<INT6>
  493+    X        .if true, ...INT6
  494+    X     static void 'default'(void);	/* comments */
  495+    X        .endc
  496+    X        .mexit
  497+    X       .endc
dispatch.c                               Atari Games Corp. macpp v9.12   "Oct 16 1997 13:26:41"


  498+    X       .if idn,<name>,<INT7>
  499+    X        .if true, ...INT7
  500+    X     static void 'default'(void);	/* comments */
  501+    X        .endc
  502+    X        .mexit
  503+    X       .endc
  504+    X       .if true, PHX
  505+    X        .if idn,<name>,<XBUS>
  506+    X         .if true, ...XBUS0|...XBUS1|...XBUS2|...XBUS3
  507+    X     static void 'default'(void);
  508+    X         .endc
  509+    X         .mexit
  510+    X        .endc
  511+    X        .if idn,<name>,<XBUS0>
  512+    X         .if true, ...XBUS0
  513+    X     static void 'default'(void);
  514+    X         .endc
  515+    X         .mexit
  516+    X        .endc
  517+    X        .if idn,<name>,<XBUS1>
  518+    X         .if true, ...XBUS1
  519+    X     static void 'default'(void);
  520+    X         .endc
  521+    X         .mexit
  522+    X        .endc
  523+    X        .if idn,<name>,<XBUS2>
  524+    X         .if true, ...XBUS2
  525+    X     static void 'default'(void);
  526+    X         .endc
  527+    X         .mexit
  528+    X        .endc
  529+    X        .if idn,<name>,<XBUS3>
  530+    X         .if true, ...XBUS3
  531+    X     static void 'default'(void);
  532+    X         .endc
  533+    X         .mexit
  534+    X        .endc
  535+    X       .endc			; PHX
  536+    X       .if idn,<name>,<IOA>
  537+    X        .if true, ...IOA
  538+    X     static void 'default'(void);
  539+    X        .endc
  540+    X        .mexit
  541+    X       .endc
  542+    X     extern void 'default'(void);
  543+    X      .endc
  544+    X     .endm
  545+    X     	.include phx_vecs.mac		;Declare the non-extern vectors
  546+          ;
  547+    X      .if true, ((PROCESSOR&-16) == MIPS3000) || ((PROCESSOR&-16) == MIPS4000)
  548+    X     static void (*hwvinst(const struct irq_tab *, void (*)()))();
  549+    X      .endc
  550+          ;
  551+    X     .if df, PHOENIX_INTCTL_MASK
  552+    X     static void (*pvinst(const struct irq_tab *, void (*)()))();
  553+    X     .endc
  554+          ;
dispatch.c                               Atari Games Corp. macpp v9.12   "Oct 16 1997 13:26:41"


  555+    X     .if df, GALILEO_INTCTL_MASK
  556+    X     static void (*gvinst(const struct irq_tab *, void (*)()))();
  557+    X     .endc
  558+          ;
  559+    X     .if true, ...IOA
  560+    X     static void (*ioainst(const struct irq_tab *, void (*)()))();
  561+    X     .endc
  562+          ;
  563+    X     static const struct irq_tab irq_inits[] = {
  564+    X     	.macro VDF cond, name, softvec, intern, installer, notes, physical, default, comments
  565+    X     	.condit cond	
  566+    X      .if dif,<softvec>,<0>
  567+    X      { (void (**)())&softvec, installer, notes },	/* comments */
  568+    X      .iff
  569+    X      { 0, installer, notes },	/* comments */
  570+    X      .endc
  571+    X     	.endm
  572+    X     	.include phx_vecs.mac		;Build the irq_inits array
  573+    X      { 0, 0, 0} };
  574+          ;
  575+    X     .if true, ((PROCESSOR&-16) == MIPS3000) || ((PROCESSOR&-16) == MIPS4000)
  576+          
  577+    X     extern void (*ramv_tbl[])();
  578+          
  579+    X     static void (*hwvinst(const struct irq_tab *it, void (*new)()))() {
  580+    X         int indx;
  581+    X         void (*old_rtn)();
  582+          
  583+    X         indx = it->notes;
  584+    X         if (indx >= VN_MAX) return 0;
  585+    X         old_rtn = ramv_tbl[indx];
  586+    X         ramv_tbl[indx] = new;
  587+    X         return old_rtn;
  588+    X     }
  589+          
  590+    X      .if df, PHOENIX_INTCTL_MASK
  591+    X     static void (*pvinst(const struct irq_tab *it, void (*new)()))() {
  592+          
  593+    X         if (it->notes) {
  594+    X     	BLABF(("\ndispatch: Adding 0x%08lX to main INTCTL (0x%08lX)...", it->notes, *(VU32*)INTCTL_IE));
  595+    X     	*((VU32 *)(INTCTL_IE)) |= it->notes;
  596+    X         }
  597+    X         return 0;
  598+    X     }
  599+    X      .endc
  600+          
  601+    X      .if df, GALILEO_INTCTL_MASK
  602+    X     static void (*gvinst(const struct irq_tab *it, void (*new)()))() {
  603+          
  604+    X         if (it->notes) {
  605+    X     	BLABF(("\ndispatch: Adding 0x%08lX to Galileo INTCTL (0x%08lX)...", it->notes, \
  606+    X     			*(VU32*)GALILEO_CPU_I_ENA));
  607+    X     	*((VU32 *)(GALILEO_CPU_I_ENA)) |= it->notes;
  608+    X         }
  609+    X         return 0;
  610+    X     }
  611+    X      .endc
dispatch.c                               Atari Games Corp. macpp v9.12   "Oct 16 1997 13:26:41"


  612+          
  613+    X      .if true, ...IOA
  614+    X     static void (*ioainst(const struct irq_tab *it, void (*new)()))() {
  615+    X     extern void prc_wait_n_usecs( int );
  616+    X         if (it->notes)
  617+    X         {
  618+    X          BLABF(("\ndispatch: Adding 0x%04X to IOASIC INTCTL: (0x%04X)...", (int)it->notes, \
  619+    X     		*(VU32*)IO_MAIN_CTL&0xFFFF));
  620+    X          while ( ( *((VU32 *)IO_MAIN_CTL) & it->notes ) != it->notes )
  621+    X          {
  622+    X     #ifdef LED_OUT
  623+    X           *(VU32 *)LED_OUT = ~( 1 << B_LED_RED );
  624+    X     #endif
  625+    X           do
  626+    X           {
  627+    X            *((VU32 *)IO_MAIN_CTL) |= it->notes;
  628+    X            prc_wait_n_usecs( 1000 );
  629+    X           } while ( ( *((VU32 *)IO_MAIN_CTL) & it->notes ) != it->notes );
  630+    X           prc_wait_n_usecs( 1000 );
  631+    X     #ifdef LED_OUT
  632+    X           *(VU32 *)LED_OUT |= ( 1 << B_LED_RED );
  633+    X     #endif
  634+    X          }
  635+    X         }
  636+    X         return 0;
  637+    X     }
  638+    X      .endc
  639+    X     .endc
  640+          
  641+    X     void (*prc_set_vec (unsigned int vecnum, void (*routine)() ))()
  642+    X     {
  643+    X         void (*old_rtn)();
  644+    X         void (**softvec)();
  645+    X         const struct irq_tab *tbp;
  646+    X         int old_ipl;
  647+          
  648+    X         if ( vecnum >= N_INTVECS ) return 0;
  649+    X         tbp = irq_inits+vecnum;
  650+    X         softvec = tbp->softvec;
  651+    X         old_rtn = 0;
  652+    X         old_ipl = prc_set_ipl(INTS_OFF);
  653+    X         if ( tbp->installer ) old_rtn = tbp->installer(tbp, routine);
  654+    X         if ( softvec ) {
  655+    X     	if (!old_rtn) old_rtn = *softvec;
  656+    X     	*softvec = routine;
  657+    X         }
  658+    X         prc_set_ipl(old_ipl);
  659+    X         return old_rtn;
  660+    X     }
  661+          
  662+    X      .if true, PHX
  663+    X       .if true, ...XBUS0
  664+    X     static void xbus0_irq(void) {
  665+    X     	.macro VDF cond, name, softvec, intern, installer, notes, physical, default, comments
  666+    X     	.condit cond	
  667+    X       .iif idn,<name>,<XBUS0>,.mexit
  668+    X       .iif idn,<softvec>,<0>,.mexit
dispatch.c                               Atari Games Corp. macpp v9.12   "Oct 16 1997 13:26:41"


  669+    X       .if true, physical == XBUS0_LVL
  670+    X         if (softvec) softvec();
  671+    X       .endc
  672+    X     	.endm
  673+    X     	.include phx_vecs.mac		; pickup all vectors assigned to XBUS0_LVL
  674+    X         return;
  675+    X     }
  676+          
  677+    X       .endc		; ...XBUS0
  678+    X       .if true, ...XBUS1
  679+    X     static void xbus1_irq(void) {
  680+    X     	.macro VDF cond, name, softvec, intern, installer, notes, physical, default, comments
  681+    X     	.condit cond	
  682+    X       .iif idn,<name>,<XBUS1>,.mexit
  683+    X       .iif idn,<softvec>,<0>,.mexit
  684+    X       .if true, physical == XBUS1_LVL
  685+    X         if (softvec) softvec();
  686+    X       .endc
  687+    X     	.endm
  688+    X     	.include phx_vecs.mac		; pickup all vectors assigned to XBUS1_LVL
  689+    X         return;
  690+    X     }
  691+          
  692+    X       .endc		; ...XBUS1
  693+    X       .if true, ...XBUS2
  694+    X     static void xbus2_irq(void) {
  695+    X     	.macro VDF cond, name, softvec, intern, installer, notes, physical, default, comments
  696+    X     	.condit cond	
  697+    X       .iif idn,<name>,<XBUS2>,.mexit
  698+    X       .iif idn,<softvec>,<0>,.mexit
  699+    X       .if true, physical == XBUS2_LVL
  700+    X         if (softvec) softvec();
  701+    X       .endc
  702+    X     	.endm
  703+    X     	.include phx_vecs.mac		; pickup all vectors assigned to XBUS2_LVL
  704+    X         return;
  705+    X     }
  706+          
  707+    X       .endc		; ...XBUS2
  708+    X       .if true, ...XBUS3
  709+    X     static void xbus3_irq(void) {
  710+    X     	.macro VDF cond, name, softvec, intern, installer, notes, physical, default, comments
  711+    X     	.condit cond	
  712+    X       .iif idn,<name>,<XBUS3>,.mexit
  713+    X       .iif idn,<softvec>,<0>,.mexit
  714+    X       .if true, physical == XBUS3_LVL
  715+    X         if (softvec) softvec();
  716+    X       .endc
  717+    X     	.endm
  718+    X     	.include phx_vecs.mac		; pickup all vectors assigned to XBUS3_LVL
  719+    X         return;
  720+    X     }
  721+          
  722+    X       .endc		; ...XBUS3
  723+    X      .endc		; PHX
  724+    X      .if true, ...INT0
  725+    X     static void int0_irq(void) {
dispatch.c                               Atari Games Corp. macpp v9.12   "Oct 16 1997 13:26:41"


  726+    X     	.macro VDF cond, name, softvec, intern, installer, notes, physical, default, comments
  727+    X     	.condit cond	
  728+    X       .iif idn,<name>,<INT0>,.mexit
  729+    X       .iif idn,<softvec>,<0>,.mexit
  730+    X       .if true, physical == INT0_LVL
  731+    X         if (softvec) softvec();
  732+    X       .endc
  733+    X     	.endm
  734+    X     	.include phx_vecs.mac		; pickup all vectors assigned to IRQ 0
  735+    X         return;
  736+    X     }
  737+          
  738+    X      .endc		; ...INT0
  739+    X      .if true, ...INT1
  740+    X     static void int1_irq(void) {
  741+    X     	.macro VDF cond, name, softvec, intern, installer, notes, physical, default, comments
  742+    X     	.condit cond	
  743+    X       .iif idn,<name>,<INT1>,.mexit
  744+    X       .iif idn,<softvec>,<0>,.mexit
  745+    X       .if true, physical == INT1_LVL
  746+    X         if (softvec) softvec();
  747+    X       .endc
  748+    X     	.endm
  749+    X     	.include phx_vecs.mac		; pickup all vectors assigned to IRQ 1
  750+    X         return;
  751+    X     }
  752+          
  753+    X      .endc		; ...INT1
  754+    X      .if true, ...INT2
  755+    X     static void int2_irq(void) {
  756+    X     	.macro VDF cond, name, softvec, intern, installer, notes, physical, default, comments
  757+    X     	.condit cond	
  758+    X       .iif idn,<name>,<INT2>,.mexit
  759+    X       .iif idn,<softvec>,<0>,.mexit
  760+    X       .if true, physical == INT2_LVL
  761+    X         if (softvec) softvec();
  762+    X       .endc
  763+    X     	.endm
  764+    X     	.include phx_vecs.mac		; pickup all vectors assigned to IRQ 2
  765+    X         return;
  766+    X     }
  767+          
  768+    X      .endc		; ...INT2
  769+    X      .if true, ...INT3
  770+    X     static void int3_irq(void) {
  771+    X     	.macro VDF cond, name, softvec, intern, installer, notes, physical, default, comments
  772+    X     	.condit cond	
  773+    X       .iif idn,<name>,<INT3>,.mexit
  774+    X       .iif idn,<softvec>,<0>,.mexit
  775+    X       .if true, physical == INT3_LVL
  776+    X         if (softvec) softvec();
  777+    X       .endc
  778+    X     	.endm
  779+    X     	.include phx_vecs.mac		; pickup all vectors assigned to IRQ 3
  780+    X         return;
  781+    X     }
  782+          
dispatch.c                               Atari Games Corp. macpp v9.12   "Oct 16 1997 13:26:41"


  783+    X      .endc		; ...INT3
  784+    X      .if true, ...INT4
  785+    X     static void int4_irq(void) {
  786+    X     	.macro VDF cond, name, softvec, intern, installer, notes, physical, default, comments
  787+    X     	.condit cond	
  788+    X       .iif idn,<name>,<INT4>,.mexit
  789+    X       .iif idn,<softvec>,<0>,.mexit
  790+    X       .if true, physical == INT4_LVL
  791+    X         if (softvec) softvec();
  792+    X       .endc
  793+    X     	.endm
  794+    X     	.include phx_vecs.mac		; pickup all vectors assigned to IRQ 4
  795+    X         return;
  796+    X     }
  797+          
  798+    X      .endc		; ...INT4
  799+    X      .if true, ...INT5
  800+    X     static void int5_irq(void) {
  801+    X     	.macro VDF cond, name, softvec, intern, installer, notes, physical, default, comments
  802+    X     	.condit cond	
  803+    X       .iif idn,<name>,<INT5>,.mexit
  804+    X       .iif idn,<softvec>,<0>,.mexit
  805+    X       .if true, physical == INT5_LVL
  806+    X         if (softvec) softvec();
  807+    X       .endc
  808+    X     	.endm
  809+    X     	.include phx_vecs.mac		; pickup all vectors assigned to IRQ 5
  810+    X         return;
  811+    X     }
  812+          
  813+    X      .endc		; ...INT5
  814+    X      .if true, ...IOA && PHX
  815+    X     static void ioa_irq(void) {
  816+    X     	.macro VDF cond, name, softvec, intern, installer, notes, physical, default, comments
  817+    X     	.condit cond	
  818+    X       .iif idn,<name>,<IOA>,.mexit
  819+    X       .iif idn,<softvec>,<0>,.mexit
  820+    X       .if true, physical == IOASIC_LVL
  821+    X         if (softvec) softvec();
  822+    X       .endc
  823+    X     	.endm
  824+    X     	.include phx_vecs.mac		; pickup all vectors assigned to IRQ 5
  825+    X         return;
  826+    X     }
  827+          
  828+    X      .endc		; ...IOA
  829+    X      .if true, PHX
  830+    X       .if true, ...XBUS0|...XBUS1|...XBUS2|...XBUS3
  831+    X     static void xbus_irq(void) {
  832+    X         int which;
  833+    X         which = *(VU32 *)(XBUS_SLOT0+4);
  834+    X       .if true, ...XBUS0
  835+    X         if (!(which&1)) xbus0_irq();
  836+    X       .endc
  837+    X       .if true, ...XBUS1
  838+    X         if (!(which&2)) xbus1_irq();
  839+    X       .endc
dispatch.c                               Atari Games Corp. macpp v9.12   "Oct 16 1997 13:26:41"


  840+    X       .if true, ...XBUS2
  841+    X         if (!(which&4)) xbus2_irq();
  842+    X       .endc
  843+    X       .if true, ...XBUS3
  844+    X         if (!(which&8)) xbus3_irq();
  845+    X       .endc
  846+    X         return;
  847+    X     }
  848+    X       .endc
  849+    X      .endc		; PHX
  850+    X     void prc_init_vecs(void) {
  851+    X     	.macro VDF cond, name, softvec, intern, installer, notes, physical, default, comments
  852+    X     	.condit cond	
  853+    X     .if dif,<default>,<0>
  854+    X      .if true, PHX
  855+    X       .if idn,<name>,<XBUS0>
  856+    X        .iif true, ...XBUS0 == 0, .mexit
  857+    X       .endc
  858+    X       .if idn,<name>,<XBUS1>
  859+    X        .iif true, ...XBUS1 == 0, .mexit
  860+    X       .endc
  861+    X       .if idn,<name>,<XBUS2>
  862+    X        .iif true, ...XBUS2 == 0, .mexit
  863+    X       .endc
  864+    X       .if idn,<name>,<XBUS3>
  865+    X        .iif true, ...XBUS3 == 0, .mexit
  866+    X       .endc
  867+    X       .if idn,<name>,<XBUS>
  868+    X        .iif true, (...XBUS0|...XBUS1|...XBUS2|...XBUS3) == 0, .mexit
  869+    X       .endc
  870+    X      .endc	; PHX
  871+    X      .if idn,<name>,<INT0>
  872+    X       .iif true, ...INT0 == 0, .mexit
  873+    X      .endc
  874+    X      .if idn,<name>,<INT1>
  875+    X       .iif true, ...INT1 == 0, .mexit
  876+    X      .endc
  877+    X      .if idn,<name>,<INT2>
  878+    X       .iif true, ...INT2 == 0, .mexit
  879+    X      .endc
  880+    X      .if idn,<name>,<INT3>
  881+    X       .iif true, ...INT3 == 0, .mexit
  882+    X      .endc
  883+    X      .if idn,<name>,<INT4>
  884+    X       .iif true, ...INT4 == 0, .mexit
  885+    X      .endc
  886+    X      .if idn,<name>,<INT5>
  887+    X       .iif true, ...INT5 == 0, .mexit
  888+    X      .endc
  889+    X      .if idn,<name>,<IOA>
  890+    X       .iif true, ...IOA == 0, .mexit
  891+    X      .endc
  892+    X         prc_set_vec('name'_INTVEC, default);
  893+    X     .endc
  894+    X     	.endm
  895+    X     	.include phx_vecs.mac
  896+          
dispatch.c                               Atari Games Corp. macpp v9.12   "Oct 16 1997 13:26:41"


  897+    X     /* Map the Phoenix interrupts */
  898+          
  899+    X     .if df, INTCTL_MAPA_INIT
  900+    X         BLABF(("\ndispatch: Mapping the A interrupts: 0x%08lX...", INTCTL_MAPA_INIT));
  901+    X         *((VU32 *)(INTCTL_MAPA)) = INTCTL_MAPA_INIT;
  902+    X     .endc
  903+    X     .if df, INTCTL_MAPB_INIT
  904+    X         BLABF(("\ndispatch: Mapping the B interrupts: 0x%08lX...", INTCTL_MAPB_INIT));
  905+    X         *((VU32 *)(INTCTL_MAPB)) = INTCTL_MAPB_INIT;
  906+    X     .endc
  907+          
  908+    X     .if defined, ANNOUNCE_BOOT_ACTIONS
  909+    X      .if true, ANNOUNCE_BOOT_ACTIONS
  910+    X         {
  911+    X     	int jj;
  912+    X     	extern int prc_get_cause(void), prc_get_ipl(void);
  913+    X     	jj = prc_get_cause();
  914+    X     	if (jj&0xFF00) BLABF(("\ndispatch: CPU cause reg: %08lX, CPU SR reg: %08lX", jj, prc_get_ipl()));
  915+    X     	if (jj&0x0400) {
  916+    X       .if true, ...INT0
  917+    X     	.macro VDF cond, name, softvec, intern, installer, notes, physical, default, comments
  918+    X     	.condit cond	
  919+    X        .iif idn,<name>,<INT0>,.mexit
  920+    X        .iif idn,<softvec>,<0>,.mexit
  921+    X        .if true, physical == INT0_LVL
  922+    X     	    if (!softvec) BLAB("\ndispatch: Warning, IRQ 0 pending \"'comments'\"");
  923+    X        .endc
  924+    X     	.endm
  925+    X     	.include phx_vecs.mac		; pickup all vectors assigned to IRQ 0
  926+    X       .iff
  927+    X     	    BLAB("\ndispatch: Warning, IRQ 0 pending with no vector assigned");
  928+    X       .endc		; ...INT0
  929+    X     	}
  930+    X     	if (jj&0x0800) {
  931+    X       .if true, ...INT1
  932+    X     	.macro VDF cond, name, softvec, intern, installer, notes, physical, default, comments
  933+    X     	.condit cond	
  934+    X        .iif idn,<name>,<INT1>,.mexit
  935+    X        .iif idn,<softvec>,<0>,.mexit
  936+    X        .if true, physical == INT1_LVL
  937+    X     	    if (!softvec) BLAB("\ndispatch: Warning, IRQ 1 pending \"'comments'\"");
  938+    X        .endc
  939+    X     	.endm
  940+    X     	.include phx_vecs.mac		; pickup all vectors assigned to IRQ 1
  941+    X       .iff
  942+    X     	    BLAB("\ndispatch: Warning, IRQ 1 pending with no vector assigned");
  943+    X       .endc		; ...INT1
  944+    X     	}
  945+    X     	if (jj&0x1000) {
  946+    X       .if true, ...INT2
  947+    X     	.macro VDF cond, name, softvec, intern, installer, notes, physical, default, comments
  948+    X     	.condit cond	
  949+    X        .iif idn,<name>,<INT2>,.mexit
  950+    X        .iif idn,<softvec>,<0>,.mexit
  951+    X        .if true, physical == INT2_LVL
  952+    X     	    if (!softvec) BLAB("\ndispatch: Warning, IRQ 2 pending \"'comments'\"");
  953+    X        .endc
dispatch.c                               Atari Games Corp. macpp v9.12   "Oct 16 1997 13:26:41"


  954+    X     	.endm
  955+    X     	.include phx_vecs.mac		; pickup all vectors assigned to IRQ 2
  956+    X       .iff
  957+    X     	    BLAB("\ndispatch: Warning, IRQ 2 pending with no vector assigned");
  958+    X       .endc		; ...INT2
  959+    X     	}
  960+    X     	if (jj&0x2000) {
  961+    X       .if true, ...INT3
  962+    X     	.macro VDF cond, name, softvec, intern, installer, notes, physical, default, comments
  963+    X     	.condit cond	
  964+    X        .iif idn,<name>,<INT3>,.mexit
  965+    X        .iif idn,<softvec>,<0>,.mexit
  966+    X        .if true, physical == INT3_LVL
  967+    X     	    if (!softvec) BLAB("\ndispatch: Warning, IRQ 3 pending \"'comments'\"");
  968+    X        .endc
  969+    X     	.endm
  970+    X     	.include phx_vecs.mac		; pickup all vectors assigned to IRQ 3
  971+    X       .iff
  972+    X     	    BLAB("\ndispatch: Warning, IRQ 3 pending with no vector assigned");
  973+    X       .endc		; ...INT3
  974+    X     	}
  975+    X     	if (jj&0x4000) {
  976+    X       .if true, ...INT4
  977+    X     	.macro VDF cond, name, softvec, intern, installer, notes, physical, default, comments
  978+    X     	.condit cond	
  979+    X        .iif idn,<name>,<INT4>,.mexit
  980+    X        .iif idn,<softvec>,<0>,.mexit
  981+    X        .if true, physical == INT4_LVL
  982+    X     	    if (!softvec) BLAB("\ndispatch: Warning, IRQ 4 pending \"'comments'\"");
  983+    X        .endc
  984+    X     	.endm
  985+    X     	.include phx_vecs.mac		; pickup all vectors assigned to IRQ 4
  986+    X       .iff
  987+    X     	    BLAB("\ndispatch: Warning, IRQ 4 pending with no vector assigned");
  988+    X       .endc		; ...INT4
  989+    X     	}
  990+    X     	if (jj&0x8000) {
  991+    X       .if true, ...INT5
  992+    X     	.macro VDF cond, name, softvec, intern, installer, notes, physical, default, comments
  993+    X     	.condit cond	
  994+    X        .iif idn,<name>,<INT5>,.mexit
  995+    X        .iif idn,<softvec>,<0>,.mexit
  996+    X        .if true, physical == INT5_LVL
  997+    X     	    if (!softvec) BLAB("\ndispatch: Warning, IRQ 5 pending \"'comments'\"");
  998+    X        .endc
  999+    X     	.endm
 1000+    X     	.include phx_vecs.mac		; pickup all vectors assigned to IRQ 5
 1001+    X       .iff
 1002+    X     	    BLAB("\ndispatch: Warning, IRQ 5 pending with no vector assigned");
 1003+    X       .endc		; ...INT5
 1004+    X     	}
 1005+    X         }
 1006+    X      .endc		; true, ANNOUNCE_BOOT_ACTIONS
 1007+    X     .endc		; defined, ANNOUNCE_BOOT_ACTIONS
 1008+    X         return;
 1009+    X     }
 1010+   (4)    .endc		; _DISPATCH_MAC_ == 0
dispatch.c                               Atari Games Corp. macpp v9.12   "Oct 16 1997 13:26:41"


 1001    (3)      .iff
 1002     X     	    BLAB("\ndispatch: Warning, IRQ 5 pending with no vector assigned");
 1003    (3)      .endc		; ...INT5
 1004           	}
 1005               }
 1006    (2)     .endc		; true, ANNOUNCE_BOOT_ACTIONS
 1007    (1)    .endc		; defined, ANNOUNCE_BOOT_ACTIONS
 1008               return;
 1009           }
 1010    (0)    .endc		; _DISPATCH_MAC_ == 0
